// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateHomeRegionControlInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHomeRegionControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHomeRegionControlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHomeRegionControlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHomeRegionControlOutputError>
}

extension CreateHomeRegionControlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHomeRegionControlInput(dryRun: \(Swift.String(describing: dryRun)), homeRegion: \(Swift.String(describing: homeRegion)), target: \(Swift.String(describing: target)))"}
}

extension CreateHomeRegionControlInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case homeRegion = "HomeRegion"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct CreateHomeRegionControlInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHomeRegionControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHomeRegionControlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHomeRegionControlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHomeRegionControlOutputError>
}

public struct CreateHomeRegionControlInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHomeRegionControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHomeRegionControlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHomeRegionControlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHomeRegionControlOutputError>
}

public struct CreateHomeRegionControlInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHomeRegionControlInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateHomeRegionControlInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateHomeRegionControlInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHomeRegionControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHomeRegionControlOutputError>
}

public struct CreateHomeRegionControlInput: Swift.Equatable {
    /// Optional Boolean flag to indicate whether any effect should take place. It tests whether
    ///       the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The name of the home region of the calling account.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// The account for which this command sets up a home region control. The Target
    ///       is always of type ACCOUNT.
    /// This member is required.
    public var target: MigrationHubConfigClientTypes.Target?

    public init (
        dryRun: Swift.Bool = false,
        homeRegion: Swift.String? = nil,
        target: MigrationHubConfigClientTypes.Target? = nil
    )
    {
        self.dryRun = dryRun
        self.homeRegion = homeRegion
        self.target = target
    }
}

struct CreateHomeRegionControlInputBody: Swift.Equatable {
    public let homeRegion: Swift.String?
    public let target: MigrationHubConfigClientTypes.Target?
    public let dryRun: Swift.Bool
}

extension CreateHomeRegionControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case homeRegion = "HomeRegion"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(MigrationHubConfigClientTypes.Target.self, forKey: .target)
        target = targetDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateHomeRegionControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHomeRegionControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHomeRegionControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHomeRegionControlOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHomeRegionControlOutputResponse(homeRegionControl: \(Swift.String(describing: homeRegionControl)))"}
}

extension CreateHomeRegionControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHomeRegionControlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.homeRegionControl = output.homeRegionControl
        } else {
            self.homeRegionControl = nil
        }
    }
}

public struct CreateHomeRegionControlOutputResponse: Swift.Equatable {
    /// This object is the HomeRegionControl object that's returned by a successful
    ///       call to CreateHomeRegionControl.
    public var homeRegionControl: MigrationHubConfigClientTypes.HomeRegionControl?

    public init (
        homeRegionControl: MigrationHubConfigClientTypes.HomeRegionControl? = nil
    )
    {
        self.homeRegionControl = homeRegionControl
    }
}

struct CreateHomeRegionControlOutputResponseBody: Swift.Equatable {
    public let homeRegionControl: MigrationHubConfigClientTypes.HomeRegionControl?
}

extension CreateHomeRegionControlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegionControl = "HomeRegionControl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionControlDecoded = try containerValues.decodeIfPresent(MigrationHubConfigClientTypes.HomeRegionControl.self, forKey: .homeRegionControl)
        homeRegionControl = homeRegionControlDecoded
    }
}

public struct DescribeHomeRegionControlsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHomeRegionControlsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHomeRegionControlsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHomeRegionControlsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHomeRegionControlsOutputError>
}

extension DescribeHomeRegionControlsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHomeRegionControlsInput(controlId: \(Swift.String(describing: controlId)), homeRegion: \(Swift.String(describing: homeRegion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), target: \(Swift.String(describing: target)))"}
}

extension DescribeHomeRegionControlsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlId = "ControlId"
        case homeRegion = "HomeRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlId = controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct DescribeHomeRegionControlsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHomeRegionControlsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHomeRegionControlsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHomeRegionControlsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHomeRegionControlsOutputError>
}

public struct DescribeHomeRegionControlsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHomeRegionControlsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHomeRegionControlsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHomeRegionControlsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHomeRegionControlsOutputError>
}

public struct DescribeHomeRegionControlsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHomeRegionControlsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeHomeRegionControlsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeHomeRegionControlsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHomeRegionControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHomeRegionControlsOutputError>
}

public struct DescribeHomeRegionControlsInput: Swift.Equatable {
    /// The ControlID is a unique identifier string of your
    ///         HomeRegionControl object.
    public var controlId: Swift.String?
    /// The name of the home region you'd like to view.
    public var homeRegion: Swift.String?
    /// The maximum number of filtering results to display per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, more results are available.
    ///       To retrieve the next page of results, make the call again using the returned token in
    ///         NextToken.
    public var nextToken: Swift.String?
    /// The target parameter specifies the identifier to which the home region is applied, which
    ///       is always of type ACCOUNT. It applies the home region to the current
    ///         ACCOUNT.
    public var target: MigrationHubConfigClientTypes.Target?

    public init (
        controlId: Swift.String? = nil,
        homeRegion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        target: MigrationHubConfigClientTypes.Target? = nil
    )
    {
        self.controlId = controlId
        self.homeRegion = homeRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.target = target
    }
}

struct DescribeHomeRegionControlsInputBody: Swift.Equatable {
    public let controlId: Swift.String?
    public let homeRegion: Swift.String?
    public let target: MigrationHubConfigClientTypes.Target?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeHomeRegionControlsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlId = "ControlId"
        case homeRegion = "HomeRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(MigrationHubConfigClientTypes.Target.self, forKey: .target)
        target = targetDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeHomeRegionControlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHomeRegionControlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHomeRegionControlsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHomeRegionControlsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHomeRegionControlsOutputResponse(homeRegionControls: \(Swift.String(describing: homeRegionControls)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeHomeRegionControlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHomeRegionControlsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.homeRegionControls = output.homeRegionControls
            self.nextToken = output.nextToken
        } else {
            self.homeRegionControls = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeHomeRegionControlsOutputResponse: Swift.Equatable {
    /// An array that contains your HomeRegionControl objects.
    public var homeRegionControls: [MigrationHubConfigClientTypes.HomeRegionControl]?
    /// If a NextToken was returned by a previous call, more results are available.
    ///       To retrieve the next page of results, make the call again using the returned token in
    ///         NextToken.
    public var nextToken: Swift.String?

    public init (
        homeRegionControls: [MigrationHubConfigClientTypes.HomeRegionControl]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.homeRegionControls = homeRegionControls
        self.nextToken = nextToken
    }
}

struct DescribeHomeRegionControlsOutputResponseBody: Swift.Equatable {
    public let homeRegionControls: [MigrationHubConfigClientTypes.HomeRegionControl]?
    public let nextToken: Swift.String?
}

extension DescribeHomeRegionControlsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegionControls = "HomeRegionControls"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionControlsContainer = try containerValues.decodeIfPresent([MigrationHubConfigClientTypes.HomeRegionControl?].self, forKey: .homeRegionControls)
        var homeRegionControlsDecoded0:[MigrationHubConfigClientTypes.HomeRegionControl]? = nil
        if let homeRegionControlsContainer = homeRegionControlsContainer {
            homeRegionControlsDecoded0 = [MigrationHubConfigClientTypes.HomeRegionControl]()
            for structure0 in homeRegionControlsContainer {
                if let structure0 = structure0 {
                    homeRegionControlsDecoded0?.append(structure0)
                }
            }
        }
        homeRegionControls = homeRegionControlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DryRunOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DryRunOperation(message: \(Swift.String(describing: message)))"}
}

extension DryRunOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DryRunOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised to indicate that authorization of an action was successful, when the
///         DryRun flag is set to true.
public struct DryRunOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DryRunOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DryRunOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetHomeRegionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHomeRegionInput()"}
}

extension GetHomeRegionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetHomeRegionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHomeRegionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHomeRegionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHomeRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHomeRegionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHomeRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHomeRegionOutputError>
}

public struct GetHomeRegionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHomeRegionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHomeRegionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHomeRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHomeRegionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHomeRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHomeRegionOutputError>
}

public struct GetHomeRegionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHomeRegionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetHomeRegionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHomeRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetHomeRegionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetHomeRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHomeRegionOutputError>
}

public struct GetHomeRegionInput: Swift.Equatable {

    public init() {}
}

struct GetHomeRegionInputBody: Swift.Equatable {
}

extension GetHomeRegionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetHomeRegionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHomeRegionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHomeRegionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHomeRegionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHomeRegionOutputResponse(homeRegion: \(Swift.String(describing: homeRegion)))"}
}

extension GetHomeRegionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetHomeRegionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.homeRegion = output.homeRegion
        } else {
            self.homeRegion = nil
        }
    }
}

public struct GetHomeRegionOutputResponse: Swift.Equatable {
    /// The name of the home region of the calling account.
    public var homeRegion: Swift.String?

    public init (
        homeRegion: Swift.String? = nil
    )
    {
        self.homeRegion = homeRegion
    }
}

struct GetHomeRegionOutputResponseBody: Swift.Equatable {
    public let homeRegion: Swift.String?
}

extension GetHomeRegionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension MigrationHubConfigClientTypes.HomeRegionControl: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlId = "ControlId"
        case homeRegion = "HomeRegion"
        case requestedTime = "RequestedTime"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlId = controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let requestedTime = requestedTime {
            try encodeContainer.encode(requestedTime.timeIntervalSince1970, forKey: .requestedTime)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(MigrationHubConfigClientTypes.Target.self, forKey: .target)
        target = targetDecoded
        let requestedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestedTime)
        requestedTime = requestedTimeDecoded
    }
}

extension MigrationHubConfigClientTypes.HomeRegionControl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HomeRegionControl(controlId: \(Swift.String(describing: controlId)), homeRegion: \(Swift.String(describing: homeRegion)), requestedTime: \(Swift.String(describing: requestedTime)), target: \(Swift.String(describing: target)))"}
}

extension MigrationHubConfigClientTypes {
    /// A home region control is an object that specifies the home region for an account, with
    ///       some additional information. It contains a target (always of type ACCOUNT), an
    ///       ID, and a time at which the home region was set.
    public struct HomeRegionControl: Swift.Equatable {
        /// A unique identifier that's generated for each home region control. It's always a string
        ///       that begins with "hrc-" followed by 12 lowercase letters and numbers.
        public var controlId: Swift.String?
        /// The AWS Region that's been set as home region. For example, "us-west-2" or "eu-central-1"
        ///       are valid home regions.
        public var homeRegion: Swift.String?
        /// A timestamp representing the time when the customer called
        ///         CreateHomeregionControl and set the home region for the account.
        public var requestedTime: ClientRuntime.Date?
        /// The target parameter specifies the identifier to which the home region is applied, which
        ///       is always an ACCOUNT. It applies the home region to the current
        ///         ACCOUNT.
        public var target: MigrationHubConfigClientTypes.Target?

        public init (
            controlId: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            requestedTime: ClientRuntime.Date? = nil,
            target: MigrationHubConfigClientTypes.Target? = nil
        )
        {
            self.controlId = controlId
            self.homeRegion = homeRegion
            self.requestedTime = requestedTime
            self.target = target
        }
    }

}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(message: \(Swift.String(describing: message)))"}
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when an internal, configuration, or dependency error is
///       encountered.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInputException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when the provided input violates a policy constraint or is entered in the
///       wrong format or data type.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when a request fails due to temporary unavailability of the
///       service.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubConfigClientTypes.Target: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MigrationHubConfigClientTypes.TargetType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension MigrationHubConfigClientTypes.Target: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Target(id: \(Swift.String(describing: id)), type: \(Swift.String(describing: type)))"}
}

extension MigrationHubConfigClientTypes {
    /// The target parameter specifies the identifier to which the home region is applied, which
    ///       is always an ACCOUNT. It applies the home region to the current
    ///         ACCOUNT.
    public struct Target: Swift.Equatable {
        /// The TargetID is a 12-character identifier of the ACCOUNT for
        ///       which the control was created. (This must be the current account.)
        public var id: Swift.String?
        /// The target type is always an ACCOUNT.
        /// This member is required.
        public var type: MigrationHubConfigClientTypes.TargetType?

        public init (
            id: Swift.String? = nil,
            type: MigrationHubConfigClientTypes.TargetType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension MigrationHubConfigClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .account,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds the caller should wait before retrying.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
