// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension MediaTailorClient {
    /// Configures Amazon CloudWatch log settings for a playback configuration.
    func configureLogsForPlaybackConfiguration(input: ConfigureLogsForPlaybackConfigurationInput) async throws -> ConfigureLogsForPlaybackConfigurationOutputResponse
    {
        typealias configureLogsForPlaybackConfigurationContinuation = CheckedContinuation<ConfigureLogsForPlaybackConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: configureLogsForPlaybackConfigurationContinuation) in
            configureLogsForPlaybackConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a channel.
    func createChannel(input: CreateChannelInput) async throws -> CreateChannelOutputResponse
    {
        typealias createChannelContinuation = CheckedContinuation<CreateChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createChannelContinuation) in
            createChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new prefetch schedule for the specified playback configuration.
    func createPrefetchSchedule(input: CreatePrefetchScheduleInput) async throws -> CreatePrefetchScheduleOutputResponse
    {
        typealias createPrefetchScheduleContinuation = CheckedContinuation<CreatePrefetchScheduleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPrefetchScheduleContinuation) in
            createPrefetchSchedule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a program.
    func createProgram(input: CreateProgramInput) async throws -> CreateProgramOutputResponse
    {
        typealias createProgramContinuation = CheckedContinuation<CreateProgramOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createProgramContinuation) in
            createProgram(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a source location on a specific channel.
    func createSourceLocation(input: CreateSourceLocationInput) async throws -> CreateSourceLocationOutputResponse
    {
        typealias createSourceLocationContinuation = CheckedContinuation<CreateSourceLocationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSourceLocationContinuation) in
            createSourceLocation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates name for a specific VOD source in a source location.
    func createVodSource(input: CreateVodSourceInput) async throws -> CreateVodSourceOutputResponse
    {
        typealias createVodSourceContinuation = CheckedContinuation<CreateVodSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createVodSourceContinuation) in
            createVodSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a channel. You must stop the channel before it can be deleted.
    func deleteChannel(input: DeleteChannelInput) async throws -> DeleteChannelOutputResponse
    {
        typealias deleteChannelContinuation = CheckedContinuation<DeleteChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteChannelContinuation) in
            deleteChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a channel's IAM policy.
    func deleteChannelPolicy(input: DeleteChannelPolicyInput) async throws -> DeleteChannelPolicyOutputResponse
    {
        typealias deleteChannelPolicyContinuation = CheckedContinuation<DeleteChannelPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteChannelPolicyContinuation) in
            deleteChannelPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the playback configuration for the specified name.
    func deletePlaybackConfiguration(input: DeletePlaybackConfigurationInput) async throws -> DeletePlaybackConfigurationOutputResponse
    {
        typealias deletePlaybackConfigurationContinuation = CheckedContinuation<DeletePlaybackConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePlaybackConfigurationContinuation) in
            deletePlaybackConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a prefetch schedule for a specific playback configuration. If you call DeletePrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code.
    func deletePrefetchSchedule(input: DeletePrefetchScheduleInput) async throws -> DeletePrefetchScheduleOutputResponse
    {
        typealias deletePrefetchScheduleContinuation = CheckedContinuation<DeletePrefetchScheduleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePrefetchScheduleContinuation) in
            deletePrefetchSchedule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specific program on a specific channel.
    func deleteProgram(input: DeleteProgramInput) async throws -> DeleteProgramOutputResponse
    {
        typealias deleteProgramContinuation = CheckedContinuation<DeleteProgramOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteProgramContinuation) in
            deleteProgram(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a source location on a specific channel.
    func deleteSourceLocation(input: DeleteSourceLocationInput) async throws -> DeleteSourceLocationOutputResponse
    {
        typealias deleteSourceLocationContinuation = CheckedContinuation<DeleteSourceLocationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSourceLocationContinuation) in
            deleteSourceLocation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specific VOD source in a specific source location.
    func deleteVodSource(input: DeleteVodSourceInput) async throws -> DeleteVodSourceOutputResponse
    {
        typealias deleteVodSourceContinuation = CheckedContinuation<DeleteVodSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteVodSourceContinuation) in
            deleteVodSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the properties of a specific channel.
    func describeChannel(input: DescribeChannelInput) async throws -> DescribeChannelOutputResponse
    {
        typealias describeChannelContinuation = CheckedContinuation<DescribeChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeChannelContinuation) in
            describeChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the properties of the requested program.
    func describeProgram(input: DescribeProgramInput) async throws -> DescribeProgramOutputResponse
    {
        typealias describeProgramContinuation = CheckedContinuation<DescribeProgramOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeProgramContinuation) in
            describeProgram(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the properties of the requested source location.
    func describeSourceLocation(input: DescribeSourceLocationInput) async throws -> DescribeSourceLocationOutputResponse
    {
        typealias describeSourceLocationContinuation = CheckedContinuation<DescribeSourceLocationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSourceLocationContinuation) in
            describeSourceLocation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Provides details about a specific VOD source in a specific source location.
    func describeVodSource(input: DescribeVodSourceInput) async throws -> DescribeVodSourceOutputResponse
    {
        typealias describeVodSourceContinuation = CheckedContinuation<DescribeVodSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeVodSourceContinuation) in
            describeVodSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about a channel's IAM policy.
    func getChannelPolicy(input: GetChannelPolicyInput) async throws -> GetChannelPolicyOutputResponse
    {
        typealias getChannelPolicyContinuation = CheckedContinuation<GetChannelPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getChannelPolicyContinuation) in
            getChannelPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves information about your channel's schedule.
    func getChannelSchedule(input: GetChannelScheduleInput) async throws -> GetChannelScheduleOutputResponse
    {
        typealias getChannelScheduleContinuation = CheckedContinuation<GetChannelScheduleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getChannelScheduleContinuation) in
            getChannelSchedule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the playback configuration for the specified name.
    func getPlaybackConfiguration(input: GetPlaybackConfigurationInput) async throws -> GetPlaybackConfigurationOutputResponse
    {
        typealias getPlaybackConfigurationContinuation = CheckedContinuation<GetPlaybackConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPlaybackConfigurationContinuation) in
            getPlaybackConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns information about the prefetch schedule for a specific playback configuration. If you call GetPrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code.
    func getPrefetchSchedule(input: GetPrefetchScheduleInput) async throws -> GetPrefetchScheduleOutputResponse
    {
        typealias getPrefetchScheduleContinuation = CheckedContinuation<GetPrefetchScheduleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPrefetchScheduleContinuation) in
            getPrefetchSchedule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of alerts for the given resource.
    func listAlerts(input: ListAlertsInput) async throws -> ListAlertsOutputResponse
    {
        typealias listAlertsContinuation = CheckedContinuation<ListAlertsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listAlertsContinuation) in
            listAlerts(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of channels that are associated with this account.
    func listChannels(input: ListChannelsInput) async throws -> ListChannelsOutputResponse
    {
        typealias listChannelsContinuation = CheckedContinuation<ListChannelsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listChannelsContinuation) in
            listChannels(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of the playback configurations defined in AWS Elemental MediaTailor. You can specify a maximum number of configurations to return at a time. The default maximum is 50. Results are returned in pagefuls. If MediaTailor has more configurations than the specified maximum, it provides parameters in the response that you can use to retrieve the next pageful.
    func listPlaybackConfigurations(input: ListPlaybackConfigurationsInput) async throws -> ListPlaybackConfigurationsOutputResponse
    {
        typealias listPlaybackConfigurationsContinuation = CheckedContinuation<ListPlaybackConfigurationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listPlaybackConfigurationsContinuation) in
            listPlaybackConfigurations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new prefetch schedule.
    func listPrefetchSchedules(input: ListPrefetchSchedulesInput) async throws -> ListPrefetchSchedulesOutputResponse
    {
        typealias listPrefetchSchedulesContinuation = CheckedContinuation<ListPrefetchSchedulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listPrefetchSchedulesContinuation) in
            listPrefetchSchedules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of source locations.
    func listSourceLocations(input: ListSourceLocationsInput) async throws -> ListSourceLocationsOutputResponse
    {
        typealias listSourceLocationsContinuation = CheckedContinuation<ListSourceLocationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSourceLocationsContinuation) in
            listSourceLocations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of the tags assigned to the specified playback configuration resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists all the VOD sources in a source location.
    func listVodSources(input: ListVodSourcesInput) async throws -> ListVodSourcesOutputResponse
    {
        typealias listVodSourcesContinuation = CheckedContinuation<ListVodSourcesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listVodSourcesContinuation) in
            listVodSources(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an IAM policy for the channel.
    func putChannelPolicy(input: PutChannelPolicyInput) async throws -> PutChannelPolicyOutputResponse
    {
        typealias putChannelPolicyContinuation = CheckedContinuation<PutChannelPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putChannelPolicyContinuation) in
            putChannelPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds a new playback configuration to AWS Elemental MediaTailor.
    func putPlaybackConfiguration(input: PutPlaybackConfigurationInput) async throws -> PutPlaybackConfigurationOutputResponse
    {
        typealias putPlaybackConfigurationContinuation = CheckedContinuation<PutPlaybackConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putPlaybackConfigurationContinuation) in
            putPlaybackConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a specific channel.
    func startChannel(input: StartChannelInput) async throws -> StartChannelOutputResponse
    {
        typealias startChannelContinuation = CheckedContinuation<StartChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startChannelContinuation) in
            startChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops a specific channel.
    func stopChannel(input: StopChannelInput) async throws -> StopChannelOutputResponse
    {
        typealias stopChannelContinuation = CheckedContinuation<StopChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopChannelContinuation) in
            stopChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds tags to the specified playback configuration resource. You can specify one or more tags to add.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes tags from the specified playback configuration resource. You can specify one or more tags to remove.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing channel.
    func updateChannel(input: UpdateChannelInput) async throws -> UpdateChannelOutputResponse
    {
        typealias updateChannelContinuation = CheckedContinuation<UpdateChannelOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateChannelContinuation) in
            updateChannel(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a source location on a specific channel.
    func updateSourceLocation(input: UpdateSourceLocationInput) async throws -> UpdateSourceLocationOutputResponse
    {
        typealias updateSourceLocationContinuation = CheckedContinuation<UpdateSourceLocationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateSourceLocationContinuation) in
            updateSourceLocation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a specific VOD source in a specific source location.
    func updateVodSource(input: UpdateVodSourceInput) async throws -> UpdateVodSourceOutputResponse
    {
        typealias updateVodSourceContinuation = CheckedContinuation<UpdateVodSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateVodSourceContinuation) in
            updateVodSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
