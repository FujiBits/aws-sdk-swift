// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaTailorClientTypes.AccessConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case secretsManagerAccessTokenConfiguration = "SecretsManagerAccessTokenConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessType = accessType {
            try encodeContainer.encode(accessType.rawValue, forKey: .accessType)
        }
        if let secretsManagerAccessTokenConfiguration = secretsManagerAccessTokenConfiguration {
            try encodeContainer.encode(secretsManagerAccessTokenConfiguration, forKey: .secretsManagerAccessTokenConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessType.self, forKey: .accessType)
        accessType = accessTypeDecoded
        let secretsManagerAccessTokenConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration.self, forKey: .secretsManagerAccessTokenConfiguration)
        secretsManagerAccessTokenConfiguration = secretsManagerAccessTokenConfigurationDecoded
    }
}

extension MediaTailorClientTypes.AccessConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessConfiguration(accessType: \(Swift.String(describing: accessType)), secretsManagerAccessTokenConfiguration: \(Swift.String(describing: secretsManagerAccessTokenConfiguration)))"}
}

extension MediaTailorClientTypes {
    /// Access configuration parameters.
    public struct AccessConfiguration: Swift.Equatable {
        /// The type of authentication used to access content from HttpConfiguration::BaseUrl on your source location. Accepted value: S3_SIGV4. S3_SIGV4 - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name. Before you can use S3_SIGV4, you must meet these requirements: • You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide. • The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations. • The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.
        public var accessType: MediaTailorClientTypes.AccessType?
        /// AWS Secrets Manager access token configuration parameters.
        public var secretsManagerAccessTokenConfiguration: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration?

        public init (
            accessType: MediaTailorClientTypes.AccessType? = nil,
            secretsManagerAccessTokenConfiguration: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration? = nil
        )
        {
            self.accessType = accessType
            self.secretsManagerAccessTokenConfiguration = secretsManagerAccessTokenConfiguration
        }
    }

}

extension MediaTailorClientTypes {
    public enum AccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3Sigv4
        case secretsManagerAccessToken
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessType] {
            return [
                .s3Sigv4,
                .secretsManagerAccessToken,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3Sigv4: return "S3_SIGV4"
            case .secretsManagerAccessToken: return "SECRETS_MANAGER_ACCESS_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessType(rawValue: rawValue) ?? AccessType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.AdBreak: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageType = "MessageType"
        case offsetMillis = "OffsetMillis"
        case slate = "Slate"
        case spliceInsertMessage = "SpliceInsertMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let offsetMillis = offsetMillis {
            try encodeContainer.encode(offsetMillis, forKey: .offsetMillis)
        }
        if let slate = slate {
            try encodeContainer.encode(slate, forKey: .slate)
        }
        if let spliceInsertMessage = spliceInsertMessage {
            try encodeContainer.encode(spliceInsertMessage, forKey: .spliceInsertMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let offsetMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offsetMillis)
        offsetMillis = offsetMillisDecoded
        let slateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .slate)
        slate = slateDecoded
        let spliceInsertMessageDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SpliceInsertMessage.self, forKey: .spliceInsertMessage)
        spliceInsertMessage = spliceInsertMessageDecoded
    }
}

extension MediaTailorClientTypes.AdBreak: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdBreak(messageType: \(Swift.String(describing: messageType)), offsetMillis: \(Swift.String(describing: offsetMillis)), slate: \(Swift.String(describing: slate)), spliceInsertMessage: \(Swift.String(describing: spliceInsertMessage)))"}
}

extension MediaTailorClientTypes {
    /// Ad break configuration parameters.
    public struct AdBreak: Swift.Equatable {
        /// The SCTE-35 ad insertion type. Accepted value: SPLICE_INSERT.
        public var messageType: MediaTailorClientTypes.MessageType?
        /// How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.
        public var offsetMillis: Swift.Int?
        /// Ad break slate configuration.
        public var slate: MediaTailorClientTypes.SlateSource?
        /// This defines the SCTE-35 splice_insert() message inserted around the ad. For information about using splice_insert(), see the SCTE-35 specficiaiton, section 9.7.3.1.
        public var spliceInsertMessage: MediaTailorClientTypes.SpliceInsertMessage?

        public init (
            messageType: MediaTailorClientTypes.MessageType? = nil,
            offsetMillis: Swift.Int? = nil,
            slate: MediaTailorClientTypes.SlateSource? = nil,
            spliceInsertMessage: MediaTailorClientTypes.SpliceInsertMessage? = nil
        )
        {
            self.messageType = messageType
            self.offsetMillis = offsetMillis
            self.slate = slate
            self.spliceInsertMessage = spliceInsertMessage
        }
    }

}

extension MediaTailorClientTypes.AdMarkerPassthrough: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension MediaTailorClientTypes.AdMarkerPassthrough: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdMarkerPassthrough(enabled: \(Swift.String(describing: enabled)))"}
}

extension MediaTailorClientTypes {
    /// For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
    public struct AdMarkerPassthrough: Swift.Equatable {
        /// Enables ad marker passthrough for your configuration.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension MediaTailorClientTypes.Alert: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertCode = "AlertCode"
        case alertMessage = "AlertMessage"
        case lastModifiedTime = "LastModifiedTime"
        case relatedResourceArns = "RelatedResourceArns"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertCode = alertCode {
            try encodeContainer.encode(alertCode, forKey: .alertCode)
        }
        if let alertMessage = alertMessage {
            try encodeContainer.encode(alertMessage, forKey: .alertMessage)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let relatedResourceArns = relatedResourceArns {
            var relatedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedResourceArns)
            for __listof__string0 in relatedResourceArns {
                try relatedResourceArnsContainer.encode(__listof__string0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertCode)
        alertCode = alertCodeDecoded
        let alertMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertMessage)
        alertMessage = alertMessageDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let relatedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedResourceArns)
        var relatedResourceArnsDecoded0:[Swift.String]? = nil
        if let relatedResourceArnsContainer = relatedResourceArnsContainer {
            relatedResourceArnsDecoded0 = [Swift.String]()
            for string0 in relatedResourceArnsContainer {
                if let string0 = string0 {
                    relatedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        relatedResourceArns = relatedResourceArnsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension MediaTailorClientTypes.Alert: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Alert(alertCode: \(Swift.String(describing: alertCode)), alertMessage: \(Swift.String(describing: alertMessage)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), relatedResourceArns: \(Swift.String(describing: relatedResourceArns)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension MediaTailorClientTypes {
    /// Alert configuration parameters.
    public struct Alert: Swift.Equatable {
        /// The code for the alert. For example, NOT_PROCESSED.
        /// This member is required.
        public var alertCode: Swift.String?
        /// If an alert is generated for a resource, an explanation of the reason for the alert.
        /// This member is required.
        public var alertMessage: Swift.String?
        /// The timestamp when the alert was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The Amazon Resource Names (ARNs) related to this alert.
        /// This member is required.
        public var relatedResourceArns: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init (
            alertCode: Swift.String? = nil,
            alertMessage: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            relatedResourceArns: [Swift.String]? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.alertCode = alertCode
            self.alertMessage = alertMessage
            self.lastModifiedTime = lastModifiedTime
            self.relatedResourceArns = relatedResourceArns
            self.resourceArn = resourceArn
        }
    }

}

extension MediaTailorClientTypes.AvailSuppression: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MediaTailorClientTypes.AvailSuppression: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailSuppression(mode: \(Swift.String(describing: mode)), value: \(Swift.String(describing: value)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression.
    public struct AvailSuppression: Swift.Equatable {
        /// Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to BEHIND_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.
        public var mode: MediaTailorClientTypes.Mode?
        /// A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.
        public var value: Swift.String?

        public init (
            mode: MediaTailorClientTypes.Mode? = nil,
            value: Swift.String? = nil
        )
        {
            self.mode = mode
            self.value = value
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalid request parameters.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaTailorClientTypes.Bumper: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUrl = "EndUrl"
        case startUrl = "StartUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endUrl = endUrl {
            try encodeContainer.encode(endUrl, forKey: .endUrl)
        }
        if let startUrl = startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endUrl)
        endUrl = endUrlDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
    }
}

extension MediaTailorClientTypes.Bumper: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Bumper(endUrl: \(Swift.String(describing: endUrl)), startUrl: \(Swift.String(describing: startUrl)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers.
    public struct Bumper: Swift.Equatable {
        /// The URL for the end bumper asset.
        public var endUrl: Swift.String?
        /// The URL for the start bumper asset.
        public var startUrl: Swift.String?

        public init (
            endUrl: Swift.String? = nil,
            startUrl: Swift.String? = nil
        )
        {
            self.endUrl = endUrl
            self.startUrl = startUrl
        }
    }

}

extension MediaTailorClientTypes.CdnConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adSegmentUrlPrefix = "AdSegmentUrlPrefix"
        case contentSegmentUrlPrefix = "ContentSegmentUrlPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adSegmentUrlPrefix = adSegmentUrlPrefix {
            try encodeContainer.encode(adSegmentUrlPrefix, forKey: .adSegmentUrlPrefix)
        }
        if let contentSegmentUrlPrefix = contentSegmentUrlPrefix {
            try encodeContainer.encode(contentSegmentUrlPrefix, forKey: .contentSegmentUrlPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adSegmentUrlPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adSegmentUrlPrefix)
        adSegmentUrlPrefix = adSegmentUrlPrefixDecoded
        let contentSegmentUrlPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentSegmentUrlPrefix)
        contentSegmentUrlPrefix = contentSegmentUrlPrefixDecoded
    }
}

extension MediaTailorClientTypes.CdnConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CdnConfiguration(adSegmentUrlPrefix: \(Swift.String(describing: adSegmentUrlPrefix)), contentSegmentUrlPrefix: \(Swift.String(describing: contentSegmentUrlPrefix)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public struct CdnConfiguration: Swift.Equatable {
        /// A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.&amp;lt;region&gt;.amazonaws.com. Then specify the rule's name in this AdSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.
        public var adSegmentUrlPrefix: Swift.String?
        /// A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this ContentSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.
        public var contentSegmentUrlPrefix: Swift.String?

        public init (
            adSegmentUrlPrefix: Swift.String? = nil,
            contentSegmentUrlPrefix: Swift.String? = nil
        )
        {
            self.adSegmentUrlPrefix = adSegmentUrlPrefix
            self.contentSegmentUrlPrefix = contentSegmentUrlPrefix
        }
    }

}

extension MediaTailorClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelState = channelState {
            try encodeContainer.encode(channelState, forKey: .channelState)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let fillerSlate = fillerSlate {
            try encodeContainer.encode(fillerSlate, forKey: .fillerSlate)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for responseoutputs0 in outputs {
                try outputsContainer.encode(responseoutputs0)
            }
        }
        if let playbackMode = playbackMode {
            try encodeContainer.encode(playbackMode, forKey: .playbackMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaTailorClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(arn: \(Swift.String(describing: arn)), channelName: \(Swift.String(describing: channelName)), channelState: \(Swift.String(describing: channelState)), creationTime: \(Swift.String(describing: creationTime)), fillerSlate: \(Swift.String(describing: fillerSlate)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputs: \(Swift.String(describing: outputs)), playbackMode: \(Swift.String(describing: playbackMode)), tags: \(Swift.String(describing: tags)))"}
}

extension MediaTailorClientTypes {
    /// The configuration parameters for a channel.
    public struct Channel: Swift.Equatable {
        /// The ARN of the channel.
        /// This member is required.
        public var arn: Swift.String?
        /// The name of the channel.
        /// This member is required.
        public var channelName: Swift.String?
        /// Returns the state whether the channel is running or not.
        /// This member is required.
        public var channelState: Swift.String?
        /// The timestamp of when the channel was created.
        public var creationTime: ClientRuntime.Date?
        /// Contains information about the slate used to fill gaps between programs in the schedule. You must configure FillerSlate if your channel uses an LINEAR PlaybackMode.
        public var fillerSlate: MediaTailorClientTypes.SlateSource?
        /// The timestamp of when the channel was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The channel's output properties.
        /// This member is required.
        public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
        /// The type of playback mode for this channel. LINEAR - Programs play back-to-back only once. LOOP - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.
        /// This member is required.
        public var playbackMode: Swift.String?
        /// The tags to assign to the channel.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelState: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
            playbackMode: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.channelName = channelName
            self.channelState = channelState
            self.creationTime = creationTime
            self.fillerSlate = fillerSlate
            self.lastModifiedTime = lastModifiedTime
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
        }
    }

}

extension MediaTailorClientTypes {
    public enum ChannelState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelState] {
            return [
                .running,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelState(rawValue: rawValue) ?? ChannelState.sdkUnknown(rawValue)
        }
    }
}

public struct ConfigureLogsForPlaybackConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsForPlaybackConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureLogsForPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureLogsForPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsForPlaybackConfigurationOutputError>
}

extension ConfigureLogsForPlaybackConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureLogsForPlaybackConfigurationInput(percentEnabled: \(Swift.String(describing: percentEnabled)), playbackConfigurationName: \(Swift.String(describing: playbackConfigurationName)))"}
}

extension ConfigureLogsForPlaybackConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
        case playbackConfigurationName = "PlaybackConfigurationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentEnabled = percentEnabled {
            try encodeContainer.encode(percentEnabled, forKey: .percentEnabled)
        }
        if let playbackConfigurationName = playbackConfigurationName {
            try encodeContainer.encode(playbackConfigurationName, forKey: .playbackConfigurationName)
        }
    }
}

public struct ConfigureLogsForPlaybackConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsForPlaybackConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureLogsForPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureLogsForPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsForPlaybackConfigurationOutputError>
}

public struct ConfigureLogsForPlaybackConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsForPlaybackConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureLogsForPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureLogsForPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsForPlaybackConfigurationOutputError>
}

public struct ConfigureLogsForPlaybackConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsForPlaybackConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ConfigureLogsForPlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ConfigureLogsForPlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsForPlaybackConfigurationOutputError>
}

public struct ConfigureLogsForPlaybackConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsForPlaybackConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ConfigureLogsForPlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/configureLogs/playbackConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ConfigureLogsForPlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsForPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsForPlaybackConfigurationOutputError>
}

/// Configures Amazon CloudWatch log settings for a playback configuration.
public struct ConfigureLogsForPlaybackConfigurationInput: Swift.Equatable {
    /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode. Valid values: 0 - 100
    /// This member is required.
    public var percentEnabled: Swift.Int?
    /// The name of the playback configuration.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?

    public init (
        percentEnabled: Swift.Int? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.percentEnabled = percentEnabled
        self.playbackConfigurationName = playbackConfigurationName
    }
}

struct ConfigureLogsForPlaybackConfigurationInputBody: Swift.Equatable {
    public let percentEnabled: Swift.Int?
    public let playbackConfigurationName: Swift.String?
}

extension ConfigureLogsForPlaybackConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
        case playbackConfigurationName = "PlaybackConfigurationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentEnabledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentEnabled)
        percentEnabled = percentEnabledDecoded
        let playbackConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationName)
        playbackConfigurationName = playbackConfigurationNameDecoded
    }
}

extension ConfigureLogsForPlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureLogsForPlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfigureLogsForPlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureLogsForPlaybackConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureLogsForPlaybackConfigurationOutputResponse(percentEnabled: \(Swift.String(describing: percentEnabled)), playbackConfigurationName: \(Swift.String(describing: playbackConfigurationName)))"}
}

extension ConfigureLogsForPlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfigureLogsForPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.percentEnabled = output.percentEnabled
            self.playbackConfigurationName = output.playbackConfigurationName
        } else {
            self.percentEnabled = nil
            self.playbackConfigurationName = nil
        }
    }
}

public struct ConfigureLogsForPlaybackConfigurationOutputResponse: Swift.Equatable {
    /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.
    public var percentEnabled: Swift.Int?
    /// The name of the playback configuration.
    public var playbackConfigurationName: Swift.String?

    public init (
        percentEnabled: Swift.Int? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.percentEnabled = percentEnabled
        self.playbackConfigurationName = playbackConfigurationName
    }
}

struct ConfigureLogsForPlaybackConfigurationOutputResponseBody: Swift.Equatable {
    public let percentEnabled: Swift.Int?
    public let playbackConfigurationName: Swift.String?
}

extension ConfigureLogsForPlaybackConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
        case playbackConfigurationName = "PlaybackConfigurationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentEnabledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentEnabled)
        percentEnabled = percentEnabledDecoded
        let playbackConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationName)
        playbackConfigurationName = playbackConfigurationNameDecoded
    }
}

public struct CreateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(channelName: \(Swift.String(describing: channelName)), fillerSlate: \(Swift.String(describing: fillerSlate)), outputs: \(Swift.String(describing: outputs)), playbackMode: \(Swift.String(describing: playbackMode)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fillerSlate = "FillerSlate"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fillerSlate = fillerSlate {
            try encodeContainer.encode(fillerSlate, forKey: .fillerSlate)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for requestoutputs0 in outputs {
                try outputsContainer.encode(requestoutputs0)
            }
        }
        if let playbackMode = playbackMode {
            try encodeContainer.encode(playbackMode.rawValue, forKey: .playbackMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?
    /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses a LINEAR PlaybackMode.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The channel's output properties.
    /// This member is required.
    public var outputs: [MediaTailorClientTypes.RequestOutputItem]?
    /// The type of playback mode to use for this channel. LINEAR - The programs in the schedule play once back-to-back in the schedule. LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.
    /// This member is required.
    public var playbackMode: MediaTailorClientTypes.PlaybackMode?
    /// The tags to assign to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        channelName: Swift.String? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        outputs: [MediaTailorClientTypes.RequestOutputItem]? = nil,
        playbackMode: MediaTailorClientTypes.PlaybackMode? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelName = channelName
        self.fillerSlate = fillerSlate
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    public let fillerSlate: MediaTailorClientTypes.SlateSource?
    public let outputs: [MediaTailorClientTypes.RequestOutputItem]?
    public let playbackMode: MediaTailorClientTypes.PlaybackMode?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fillerSlate = "FillerSlate"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.RequestOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.RequestOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.RequestOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PlaybackMode.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelOutputResponse(arn: \(Swift.String(describing: arn)), channelName: \(Swift.String(describing: channelName)), channelState: \(Swift.String(describing: channelState)), creationTime: \(Swift.String(describing: creationTime)), fillerSlate: \(Swift.String(describing: fillerSlate)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputs: \(Swift.String(describing: outputs)), playbackMode: \(Swift.String(describing: playbackMode)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.fillerSlate = output.fillerSlate
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.fillerSlate = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var arn: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?
    /// Indicates whether the channel is in a running state or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: ClientRuntime.Date?
    /// Contains information about the slate used to fill gaps between programs in the schedule.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp of when the channel was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The channel's output properties.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The channel's playback mode.
    public var playbackMode: Swift.String?
    /// The tags assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let channelName: Swift.String?
    public let channelState: MediaTailorClientTypes.ChannelState?
    public let creationTime: ClientRuntime.Date?
    public let fillerSlate: MediaTailorClientTypes.SlateSource?
    public let lastModifiedTime: ClientRuntime.Date?
    public let outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    public let playbackMode: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateProgramInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgramInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProgramInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProgramInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgramOutputError>
}

extension CreateProgramInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProgramInput(adBreaks: \(Swift.String(describing: adBreaks)), channelName: \(Swift.String(describing: channelName)), programName: \(Swift.String(describing: programName)), scheduleConfiguration: \(Swift.String(describing: scheduleConfiguration)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension CreateProgramInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adBreaks = adBreaks {
            var adBreaksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adBreaks)
            for __listofadbreak0 in adBreaks {
                try adBreaksContainer.encode(__listofadbreak0)
            }
        }
        if let scheduleConfiguration = scheduleConfiguration {
            try encodeContainer.encode(scheduleConfiguration, forKey: .scheduleConfiguration)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }
}

public struct CreateProgramInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgramInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProgramInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProgramInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgramOutputError>
}

public struct CreateProgramInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgramInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProgramInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProgramInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgramOutputError>
}

public struct CreateProgramInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgramInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateProgramInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProgramInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgramOutputError>
}

public struct CreateProgramInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgramInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateProgramInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        guard let programName = input.programName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("programName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProgramInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgramOutputError>
}

public struct CreateProgramInput: Swift.Equatable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?
    /// The identifier for the program you are working on.
    /// This member is required.
    public var programName: Swift.String?
    /// The schedule configuration settings.
    /// This member is required.
    public var scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration?
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.channelName = channelName
        self.programName = programName
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct CreateProgramInputBody: Swift.Equatable {
    public let adBreaks: [MediaTailorClientTypes.AdBreak]?
    public let scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration?
    public let sourceLocationName: Swift.String?
    public let vodSourceName: Swift.String?
}

extension CreateProgramInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[MediaTailorClientTypes.AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [MediaTailorClientTypes.AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension CreateProgramOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProgramOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProgramOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProgramOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProgramOutputResponse(adBreaks: \(Swift.String(describing: adBreaks)), arn: \(Swift.String(describing: arn)), channelName: \(Swift.String(describing: channelName)), creationTime: \(Swift.String(describing: creationTime)), programName: \(Swift.String(describing: programName)), scheduledStartTime: \(Swift.String(describing: scheduledStartTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension CreateProgramOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProgramOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adBreaks = output.adBreaks
            self.arn = output.arn
            self.channelName = output.channelName
            self.creationTime = output.creationTime
            self.programName = output.programName
            self.scheduledStartTime = output.scheduledStartTime
            self.sourceLocationName = output.sourceLocationName
            self.vodSourceName = output.vodSourceName
        } else {
            self.adBreaks = nil
            self.arn = nil
            self.channelName = nil
            self.creationTime = nil
            self.programName = nil
            self.scheduledStartTime = nil
            self.sourceLocationName = nil
            self.vodSourceName = nil
        }
    }
}

public struct CreateProgramOutputResponse: Swift.Equatable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The ARN of the program.
    public var arn: Swift.String?
    /// The name of the channel that the program belongs to.
    public var channelName: Swift.String?
    /// The timestamp of when the program was created.
    public var creationTime: ClientRuntime.Date?
    /// The name of the program.
    public var programName: Swift.String?
    /// The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.
    public var scheduledStartTime: ClientRuntime.Date?
    /// The source location name.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init (
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        programName: Swift.String? = nil,
        scheduledStartTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.channelName = channelName
        self.creationTime = creationTime
        self.programName = programName
        self.scheduledStartTime = scheduledStartTime
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct CreateProgramOutputResponseBody: Swift.Equatable {
    public let adBreaks: [MediaTailorClientTypes.AdBreak]?
    public let arn: Swift.String?
    public let channelName: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let programName: Swift.String?
    public let scheduledStartTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let vodSourceName: Swift.String?
}

extension CreateProgramOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case arn = "Arn"
        case channelName = "ChannelName"
        case creationTime = "CreationTime"
        case programName = "ProgramName"
        case scheduledStartTime = "ScheduledStartTime"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[MediaTailorClientTypes.AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [MediaTailorClientTypes.AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .programName)
        programName = programNameDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

public struct CreateSourceLocationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSourceLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSourceLocationOutputError>
}

extension CreateSourceLocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSourceLocationInput(accessConfiguration: \(Swift.String(describing: accessConfiguration)), defaultSegmentDeliveryConfiguration: \(Swift.String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(Swift.String(describing: httpConfiguration)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSourceLocationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSourceLocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSourceLocationOutputError>
}

public struct CreateSourceLocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSourceLocationOutputError>
}

public struct CreateSourceLocationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSourceLocationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSourceLocationOutputError>
}

public struct CreateSourceLocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSourceLocationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSourceLocationOutputError>
}

public struct CreateSourceLocationInput: Swift.Equatable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The optional configuration for the server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The source's HTTP package configurations.
    /// This member is required.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the source location.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateSourceLocationInputBody: Swift.Equatable {
    public let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    public let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateSourceLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSourceLocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSourceLocationOutputResponse(accessConfiguration: \(Swift.String(describing: accessConfiguration)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(Swift.String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(Swift.String(describing: httpConfiguration)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct CreateSourceLocationOutputResponse: Swift.Equatable {
    /// The access configuration for the source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The ARN of the source location.
    public var arn: Swift.String?
    /// The timestamp that indicates when the source location was created.
    public var creationTime: ClientRuntime.Date?
    /// The default segment delivery configuration settings.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP package configuration settings for the source location.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The timestamp that indicates when the source location was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the source location.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateSourceLocationOutputResponseBody: Swift.Equatable {
    public let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    public let lastModifiedTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateSourceLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateVodSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVodSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVodSourceOutputError>
}

extension CreateVodSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVodSourceInput(httpPackageConfigurations: \(Swift.String(describing: httpPackageConfigurations)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension CreateVodSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfigurations0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfigurations0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateVodSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVodSourceOutputError>
}

public struct CreateVodSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVodSourceOutputError>
}

public struct CreateVodSourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVodSourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVodSourceOutputError>
}

public struct CreateVodSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVodSourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        guard let vodSourceName = input.vodSourceName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("vodSourceName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVodSourceOutputError>
}

public struct CreateVodSourceInput: Swift.Equatable {
    /// An array of HTTP package configuration parameters for this VOD source.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the VOD source.
    public var tags: [Swift.String:Swift.String]?
    /// The identifier for the VOD source you are working on.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct CreateVodSourceInputBody: Swift.Equatable {
    public let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateVodSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVodSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVodSourceOutputResponse(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), httpPackageConfigurations: \(Swift.String(describing: httpPackageConfigurations)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension CreateVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct CreateVodSourceOutputResponse: Swift.Equatable {
    /// The ARN of the VOD source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the VOD source was created.
    public var creationTime: ClientRuntime.Date?
    /// The HTTP package configurations.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The ARN for the VOD source.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location associated with the VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the VOD source.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the VOD source.
    public var vodSourceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct CreateVodSourceOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    public let lastModifiedTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let vodSourceName: Swift.String?
}

extension CreateVodSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.DashConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestEndpointPrefix = "ManifestEndpointPrefix"
        case mpdLocation = "MpdLocation"
        case originManifestType = "OriginManifestType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestEndpointPrefix = manifestEndpointPrefix {
            try encodeContainer.encode(manifestEndpointPrefix, forKey: .manifestEndpointPrefix)
        }
        if let mpdLocation = mpdLocation {
            try encodeContainer.encode(mpdLocation, forKey: .mpdLocation)
        }
        if let originManifestType = originManifestType {
            try encodeContainer.encode(originManifestType.rawValue, forKey: .originManifestType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestEndpointPrefix)
        manifestEndpointPrefix = manifestEndpointPrefixDecoded
        let mpdLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mpdLocation)
        mpdLocation = mpdLocationDecoded
        let originManifestTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.OriginManifestType.self, forKey: .originManifestType)
        originManifestType = originManifestTypeDecoded
    }
}

extension MediaTailorClientTypes.DashConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DashConfiguration(manifestEndpointPrefix: \(Swift.String(describing: manifestEndpointPrefix)), mpdLocation: \(Swift.String(describing: mpdLocation)), originManifestType: \(Swift.String(describing: originManifestType)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for DASH content.
    public struct DashConfiguration: Swift.Equatable {
        /// The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.
        public var manifestEndpointPrefix: Swift.String?
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public var mpdLocation: Swift.String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public var originManifestType: MediaTailorClientTypes.OriginManifestType?

        public init (
            manifestEndpointPrefix: Swift.String? = nil,
            mpdLocation: Swift.String? = nil,
            originManifestType: MediaTailorClientTypes.OriginManifestType? = nil
        )
        {
            self.manifestEndpointPrefix = manifestEndpointPrefix
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }
    }

}

extension MediaTailorClientTypes.DashConfigurationForPut: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mpdLocation = "MpdLocation"
        case originManifestType = "OriginManifestType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mpdLocation = mpdLocation {
            try encodeContainer.encode(mpdLocation, forKey: .mpdLocation)
        }
        if let originManifestType = originManifestType {
            try encodeContainer.encode(originManifestType.rawValue, forKey: .originManifestType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mpdLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mpdLocation)
        mpdLocation = mpdLocationDecoded
        let originManifestTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.OriginManifestType.self, forKey: .originManifestType)
        originManifestType = originManifestTypeDecoded
    }
}

extension MediaTailorClientTypes.DashConfigurationForPut: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DashConfigurationForPut(mpdLocation: \(Swift.String(describing: mpdLocation)), originManifestType: \(Swift.String(describing: originManifestType)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for DASH PUT operations.
    public struct DashConfigurationForPut: Swift.Equatable {
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public var mpdLocation: Swift.String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public var originManifestType: MediaTailorClientTypes.OriginManifestType?

        public init (
            mpdLocation: Swift.String? = nil,
            originManifestType: MediaTailorClientTypes.OriginManifestType? = nil
        )
        {
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }
    }

}

extension MediaTailorClientTypes.DashPlaylistSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case minBufferTimeSeconds = "MinBufferTimeSeconds"
        case minUpdatePeriodSeconds = "MinUpdatePeriodSeconds"
        case suggestedPresentationDelaySeconds = "SuggestedPresentationDelaySeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestWindowSeconds = manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let minBufferTimeSeconds = minBufferTimeSeconds {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if let minUpdatePeriodSeconds = minUpdatePeriodSeconds {
            try encodeContainer.encode(minUpdatePeriodSeconds, forKey: .minUpdatePeriodSeconds)
        }
        if let suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds {
            try encodeContainer.encode(suggestedPresentationDelaySeconds, forKey: .suggestedPresentationDelaySeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let minUpdatePeriodSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUpdatePeriodSeconds)
        minUpdatePeriodSeconds = minUpdatePeriodSecondsDecoded
        let suggestedPresentationDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .suggestedPresentationDelaySeconds)
        suggestedPresentationDelaySeconds = suggestedPresentationDelaySecondsDecoded
    }
}

extension MediaTailorClientTypes.DashPlaylistSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DashPlaylistSettings(manifestWindowSeconds: \(Swift.String(describing: manifestWindowSeconds)), minBufferTimeSeconds: \(Swift.String(describing: minBufferTimeSeconds)), minUpdatePeriodSeconds: \(Swift.String(describing: minUpdatePeriodSeconds)), suggestedPresentationDelaySeconds: \(Swift.String(describing: suggestedPresentationDelaySeconds)))"}
}

extension MediaTailorClientTypes {
    /// Dash manifest configuration parameters.
    public struct DashPlaylistSettings: Swift.Equatable {
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public var manifestWindowSeconds: Swift.Int?
        /// Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var minBufferTimeSeconds: Swift.Int?
        /// Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var minUpdatePeriodSeconds: Swift.Int?
        /// Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var suggestedPresentationDelaySeconds: Swift.Int?

        public init (
            manifestWindowSeconds: Swift.Int? = nil,
            minBufferTimeSeconds: Swift.Int? = nil,
            minUpdatePeriodSeconds: Swift.Int? = nil,
            suggestedPresentationDelaySeconds: Swift.Int? = nil
        )
        {
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
        }
    }

}

extension MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseUrl = "BaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseUrl = baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
    }
}

extension MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultSegmentDeliveryConfiguration(baseUrl: \(Swift.String(describing: baseUrl)))"}
}

extension MediaTailorClientTypes {
    /// The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.
    public struct DefaultSegmentDeliveryConfiguration: Swift.Equatable {
        /// The hostname of the server that will be used to serve segments. This string must include the protocol, such as https://.
        public var baseUrl: Swift.String?

        public init (
            baseUrl: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
        }
    }

}

extension DeleteChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelInput(channelName: \(Swift.String(describing: channelName)))"}
}

extension DeleteChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelPolicyInput(channelName: \(Swift.String(describing: channelName)))"}
}

extension DeleteChannelPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelPolicyOutputError>
}

public struct DeleteChannelPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelPolicyOutputError>
}

public struct DeleteChannelPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelPolicyOutputError>
}

public struct DeleteChannelPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelPolicyOutputError>
}

public struct DeleteChannelPolicyInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelPolicyInputBody: Swift.Equatable {
}

extension DeleteChannelPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelPolicyOutputResponse()"}
}

extension DeleteChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlaybackConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlaybackConfigurationInput(name: \(Swift.String(describing: name)))"}
}

extension DeletePlaybackConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePlaybackConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackConfigurationOutputError>
}

public struct DeletePlaybackConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackConfigurationOutputError>
}

public struct DeletePlaybackConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackConfigurationOutputError>
}

public struct DeletePlaybackConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/playbackConfiguration/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackConfigurationOutputError>
}

public struct DeletePlaybackConfigurationInput: Swift.Equatable {
    /// The identifier for the playback configuration.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeletePlaybackConfigurationInputBody: Swift.Equatable {
}

extension DeletePlaybackConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaybackConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlaybackConfigurationOutputResponse()"}
}

extension DeletePlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaybackConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePlaybackConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeletePlaybackConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProgramInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProgramInput(channelName: \(Swift.String(describing: channelName)), programName: \(Swift.String(describing: programName)))"}
}

extension DeleteProgramInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProgramInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgramInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProgramInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProgramInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgramOutputError>
}

public struct DeleteProgramInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgramInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProgramInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProgramInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgramOutputError>
}

public struct DeleteProgramInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgramInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteProgramInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProgramInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgramOutputError>
}

public struct DeleteProgramInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgramInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteProgramInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        guard let programName = input.programName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("programName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProgramInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgramOutputError>
}

public struct DeleteProgramInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?
    /// The identifier for the program you are working on.
    /// This member is required.
    public var programName: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

struct DeleteProgramInputBody: Swift.Equatable {
}

extension DeleteProgramInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProgramOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProgramOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProgramOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProgramOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProgramOutputResponse()"}
}

extension DeleteProgramOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProgramOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProgramOutputResponseBody: Swift.Equatable {
}

extension DeleteProgramOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSourceLocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSourceLocationInput(sourceLocationName: \(Swift.String(describing: sourceLocationName)))"}
}

extension DeleteSourceLocationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSourceLocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSourceLocationOutputError>
}

public struct DeleteSourceLocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSourceLocationOutputError>
}

public struct DeleteSourceLocationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSourceLocationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSourceLocationOutputError>
}

public struct DeleteSourceLocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSourceLocationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSourceLocationOutputError>
}

public struct DeleteSourceLocationInput: Swift.Equatable {
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

struct DeleteSourceLocationInputBody: Swift.Equatable {
}

extension DeleteSourceLocationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceLocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSourceLocationOutputResponse()"}
}

extension DeleteSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSourceLocationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSourceLocationOutputResponseBody: Swift.Equatable {
}

extension DeleteSourceLocationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVodSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVodSourceInput(sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension DeleteVodSourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVodSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVodSourceOutputError>
}

public struct DeleteVodSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVodSourceOutputError>
}

public struct DeleteVodSourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVodSourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVodSourceOutputError>
}

public struct DeleteVodSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVodSourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        guard let vodSourceName = input.vodSourceName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("vodSourceName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVodSourceOutputError>
}

public struct DeleteVodSourceInput: Swift.Equatable {
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The identifier for the VOD source you are working on.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DeleteVodSourceInputBody: Swift.Equatable {
}

extension DeleteVodSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVodSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVodSourceOutputResponse()"}
}

extension DeleteVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVodSourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVodSourceOutputResponseBody: Swift.Equatable {
}

extension DeleteVodSourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelInput(channelName: \(Swift.String(describing: channelName)))"}
}

extension DescribeChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelOutputResponse(arn: \(Swift.String(describing: arn)), channelName: \(Swift.String(describing: channelName)), channelState: \(Swift.String(describing: channelState)), creationTime: \(Swift.String(describing: creationTime)), fillerSlate: \(Swift.String(describing: fillerSlate)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputs: \(Swift.String(describing: outputs)), playbackMode: \(Swift.String(describing: playbackMode)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.fillerSlate = output.fillerSlate
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.fillerSlate = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var arn: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?
    /// Indicates whether the channel is in a running state or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: ClientRuntime.Date?
    /// Contains information about the slate used to fill gaps between programs in the schedule.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp of when the channel was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The channel's output properties.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The channel's playback mode.
    public var playbackMode: Swift.String?
    /// The tags assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let channelName: Swift.String?
    public let channelState: MediaTailorClientTypes.ChannelState?
    public let creationTime: ClientRuntime.Date?
    public let fillerSlate: MediaTailorClientTypes.SlateSource?
    public let lastModifiedTime: ClientRuntime.Date?
    public let outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    public let playbackMode: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeProgramInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProgramInput(channelName: \(Swift.String(describing: channelName)), programName: \(Swift.String(describing: programName)))"}
}

extension DescribeProgramInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeProgramInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProgramInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProgramInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProgramInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProgramOutputError>
}

public struct DescribeProgramInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProgramInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProgramInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProgramInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProgramOutputError>
}

public struct DescribeProgramInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProgramInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeProgramInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProgramInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProgramOutputError>
}

public struct DescribeProgramInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProgramInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeProgramInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProgramOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        guard let programName = input.programName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("programName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProgramInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProgramOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProgramOutputError>
}

public struct DescribeProgramInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?
    /// The identifier for the program you are working on.
    /// This member is required.
    public var programName: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

struct DescribeProgramInputBody: Swift.Equatable {
}

extension DescribeProgramInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProgramOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProgramOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProgramOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProgramOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProgramOutputResponse(adBreaks: \(Swift.String(describing: adBreaks)), arn: \(Swift.String(describing: arn)), channelName: \(Swift.String(describing: channelName)), creationTime: \(Swift.String(describing: creationTime)), programName: \(Swift.String(describing: programName)), scheduledStartTime: \(Swift.String(describing: scheduledStartTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension DescribeProgramOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProgramOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adBreaks = output.adBreaks
            self.arn = output.arn
            self.channelName = output.channelName
            self.creationTime = output.creationTime
            self.programName = output.programName
            self.scheduledStartTime = output.scheduledStartTime
            self.sourceLocationName = output.sourceLocationName
            self.vodSourceName = output.vodSourceName
        } else {
            self.adBreaks = nil
            self.arn = nil
            self.channelName = nil
            self.creationTime = nil
            self.programName = nil
            self.scheduledStartTime = nil
            self.sourceLocationName = nil
            self.vodSourceName = nil
        }
    }
}

public struct DescribeProgramOutputResponse: Swift.Equatable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The ARN of the program.
    public var arn: Swift.String?
    /// The name of the channel that the program belongs to.
    public var channelName: Swift.String?
    /// The timestamp of when the program was created.
    public var creationTime: ClientRuntime.Date?
    /// The name of the program.
    public var programName: Swift.String?
    /// The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.
    public var scheduledStartTime: ClientRuntime.Date?
    /// The source location name.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init (
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        programName: Swift.String? = nil,
        scheduledStartTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.channelName = channelName
        self.creationTime = creationTime
        self.programName = programName
        self.scheduledStartTime = scheduledStartTime
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DescribeProgramOutputResponseBody: Swift.Equatable {
    public let adBreaks: [MediaTailorClientTypes.AdBreak]?
    public let arn: Swift.String?
    public let channelName: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let programName: Swift.String?
    public let scheduledStartTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let vodSourceName: Swift.String?
}

extension DescribeProgramOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case arn = "Arn"
        case channelName = "ChannelName"
        case creationTime = "CreationTime"
        case programName = "ProgramName"
        case scheduledStartTime = "ScheduledStartTime"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[MediaTailorClientTypes.AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [MediaTailorClientTypes.AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .programName)
        programName = programNameDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension DescribeSourceLocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSourceLocationInput(sourceLocationName: \(Swift.String(describing: sourceLocationName)))"}
}

extension DescribeSourceLocationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeSourceLocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceLocationOutputError>
}

public struct DescribeSourceLocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceLocationOutputError>
}

public struct DescribeSourceLocationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceLocationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceLocationOutputError>
}

public struct DescribeSourceLocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceLocationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceLocationOutputError>
}

public struct DescribeSourceLocationInput: Swift.Equatable {
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

struct DescribeSourceLocationInputBody: Swift.Equatable {
}

extension DescribeSourceLocationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceLocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSourceLocationOutputResponse(accessConfiguration: \(Swift.String(describing: accessConfiguration)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(Swift.String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(Swift.String(describing: httpConfiguration)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct DescribeSourceLocationOutputResponse: Swift.Equatable {
    /// The access configuration for the source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The ARN of the source location.
    public var arn: Swift.String?
    /// The timestamp that indicates when the source location was created.
    public var creationTime: ClientRuntime.Date?
    /// The default segment delivery configuration settings.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP package configuration settings for the source location.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The timestamp that indicates when the source location was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the source location.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct DescribeSourceLocationOutputResponseBody: Swift.Equatable {
    public let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    public let lastModifiedTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeSourceLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeVodSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVodSourceInput(sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension DescribeVodSourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeVodSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVodSourceOutputError>
}

public struct DescribeVodSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVodSourceOutputError>
}

public struct DescribeVodSourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVodSourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVodSourceOutputError>
}

public struct DescribeVodSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVodSourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        guard let vodSourceName = input.vodSourceName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("vodSourceName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVodSourceOutputError>
}

public struct DescribeVodSourceInput: Swift.Equatable {
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The identifier for the VOD source you are working on.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DescribeVodSourceInputBody: Swift.Equatable {
}

extension DescribeVodSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVodSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVodSourceOutputResponse(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), httpPackageConfigurations: \(Swift.String(describing: httpPackageConfigurations)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension DescribeVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct DescribeVodSourceOutputResponse: Swift.Equatable {
    /// The ARN of the VOD source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the VOD source was created.
    public var creationTime: ClientRuntime.Date?
    /// The HTTP package configurations.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The ARN for the VOD source.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location associated with the VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the VOD source.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the VOD source.
    public var vodSourceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct DescribeVodSourceOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    public let lastModifiedTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let vodSourceName: Swift.String?
}

extension DescribeVodSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension GetChannelPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelPolicyInput(channelName: \(Swift.String(describing: channelName)))"}
}

extension GetChannelPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetChannelPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelPolicyOutputError>
}

public struct GetChannelPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelPolicyOutputError>
}

public struct GetChannelPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetChannelPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelPolicyOutputError>
}

public struct GetChannelPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetChannelPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelPolicyOutputError>
}

public struct GetChannelPolicyInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct GetChannelPolicyInputBody: Swift.Equatable {
}

extension GetChannelPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension GetChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetChannelPolicyOutputResponse: Swift.Equatable {
    /// The IAM policy for the channel.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetChannelPolicyOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
}

extension GetChannelPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetChannelScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelScheduleInput(channelName: \(Swift.String(describing: channelName)), durationMinutes: \(Swift.String(describing: durationMinutes)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetChannelScheduleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetChannelScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelScheduleOutputError>
}

public struct GetChannelScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let durationMinutes = input.operationInput.durationMinutes {
            let durationMinutesQueryItem = ClientRuntime.URLQueryItem(name: "durationMinutes".urlPercentEncoding(), value: Swift.String(durationMinutes).urlPercentEncoding())
            input.builder.withQueryItem(durationMinutesQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelScheduleOutputError>
}

public struct GetChannelScheduleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelScheduleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetChannelScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelScheduleOutputError>
}

public struct GetChannelScheduleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelScheduleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetChannelScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/schedule"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelScheduleOutputError>
}

public struct GetChannelScheduleInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?
    /// The schedule duration in minutes. The maximum duration is 4320 minutes (three days).
    public var durationMinutes: Swift.String?
    /// Upper bound on number of records to return. The maximum number of results is 100.
    public var maxResults: Swift.Int?
    /// Pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        durationMinutes: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.durationMinutes = durationMinutes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetChannelScheduleInputBody: Swift.Equatable {
}

extension GetChannelScheduleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelScheduleOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelScheduleOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetChannelScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetChannelScheduleOutputResponse: Swift.Equatable {
    /// An array of schedule entries for the channel.
    public var items: [MediaTailorClientTypes.ScheduleEntry]?
    /// Pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.ScheduleEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetChannelScheduleOutputResponseBody: Swift.Equatable {
    public let items: [MediaTailorClientTypes.ScheduleEntry]?
    public let nextToken: Swift.String?
}

extension GetChannelScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ScheduleEntry?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.ScheduleEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.ScheduleEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetPlaybackConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaybackConfigurationInput(name: \(Swift.String(describing: name)))"}
}

extension GetPlaybackConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPlaybackConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackConfigurationOutputError>
}

public struct GetPlaybackConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackConfigurationOutputError>
}

public struct GetPlaybackConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackConfigurationOutputError>
}

public struct GetPlaybackConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/playbackConfiguration/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackConfigurationOutputError>
}

public struct GetPlaybackConfigurationInput: Swift.Equatable {
    /// The identifier for the playback configuration.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetPlaybackConfigurationInputBody: Swift.Equatable {
}

extension GetPlaybackConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlaybackConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaybackConfigurationOutputResponse(adDecisionServerUrl: \(Swift.String(describing: adDecisionServerUrl)), availSuppression: \(Swift.String(describing: availSuppression)), bumper: \(Swift.String(describing: bumper)), cdnConfiguration: \(Swift.String(describing: cdnConfiguration)), configurationAliases: \(Swift.String(describing: configurationAliases)), dashConfiguration: \(Swift.String(describing: dashConfiguration)), hlsConfiguration: \(Swift.String(describing: hlsConfiguration)), livePreRollConfiguration: \(Swift.String(describing: livePreRollConfiguration)), logConfiguration: \(Swift.String(describing: logConfiguration)), manifestProcessingRules: \(Swift.String(describing: manifestProcessingRules)), name: \(Swift.String(describing: name)), personalizationThresholdSeconds: \(Swift.String(describing: personalizationThresholdSeconds)), playbackConfigurationArn: \(Swift.String(describing: playbackConfigurationArn)), playbackEndpointPrefix: \(Swift.String(describing: playbackEndpointPrefix)), sessionInitializationEndpointPrefix: \(Swift.String(describing: sessionInitializationEndpointPrefix)), slateAdUrl: \(Swift.String(describing: slateAdUrl)), tags: \(Swift.String(describing: tags)), transcodeProfileName: \(Swift.String(describing: transcodeProfileName)), videoContentSourceUrl: \(Swift.String(describing: videoContentSourceUrl)))"}
}

extension GetPlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adDecisionServerUrl = output.adDecisionServerUrl
            self.availSuppression = output.availSuppression
            self.bumper = output.bumper
            self.cdnConfiguration = output.cdnConfiguration
            self.configurationAliases = output.configurationAliases
            self.dashConfiguration = output.dashConfiguration
            self.hlsConfiguration = output.hlsConfiguration
            self.livePreRollConfiguration = output.livePreRollConfiguration
            self.logConfiguration = output.logConfiguration
            self.manifestProcessingRules = output.manifestProcessingRules
            self.name = output.name
            self.personalizationThresholdSeconds = output.personalizationThresholdSeconds
            self.playbackConfigurationArn = output.playbackConfigurationArn
            self.playbackEndpointPrefix = output.playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = output.sessionInitializationEndpointPrefix
            self.slateAdUrl = output.slateAdUrl
            self.tags = output.tags
            self.transcodeProfileName = output.transcodeProfileName
            self.videoContentSourceUrl = output.videoContentSourceUrl
        } else {
            self.adDecisionServerUrl = nil
            self.availSuppression = nil
            self.bumper = nil
            self.cdnConfiguration = nil
            self.configurationAliases = nil
            self.dashConfiguration = nil
            self.hlsConfiguration = nil
            self.livePreRollConfiguration = nil
            self.logConfiguration = nil
            self.manifestProcessingRules = nil
            self.name = nil
            self.personalizationThresholdSeconds = nil
            self.playbackConfigurationArn = nil
            self.playbackEndpointPrefix = nil
            self.sessionInitializationEndpointPrefix = nil
            self.slateAdUrl = nil
            self.tags = nil
            self.transcodeProfileName = nil
            self.videoContentSourceUrl = nil
        }
    }
}

public struct GetPlaybackConfigurationOutputResponse: Swift.Equatable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression.
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers.
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables.
    public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    /// The configuration for HLS content.
    public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The Amazon CloudWatch log settings for a playback configuration.
    public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor.
    public var personalizationThresholdSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) for the playback configuration.
    public var playbackConfigurationArn: Swift.String?
    /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.
    public var playbackEndpointPrefix: Swift.String?
    /// The URL that the player uses to initialize a session that uses client-side reporting.
    public var sessionInitializationEndpointPrefix: Swift.String?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags assigned to the playback configuration.
    public var tags: [Swift.String:Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init (
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
        hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        playbackConfigurationArn: Swift.String? = nil,
        playbackEndpointPrefix: Swift.String? = nil,
        sessionInitializationEndpointPrefix: Swift.String? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.logConfiguration = logConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct GetPlaybackConfigurationOutputResponseBody: Swift.Equatable {
    public let adDecisionServerUrl: Swift.String?
    public let availSuppression: MediaTailorClientTypes.AvailSuppression?
    public let bumper: MediaTailorClientTypes.Bumper?
    public let cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    public let configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    public let dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    public let hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    public let livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    public let logConfiguration: MediaTailorClientTypes.LogConfiguration?
    public let manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    public let name: Swift.String?
    public let personalizationThresholdSeconds: Swift.Int?
    public let playbackConfigurationArn: Swift.String?
    public let playbackEndpointPrefix: Swift.String?
    public let sessionInitializationEndpointPrefix: Swift.String?
    public let slateAdUrl: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let transcodeProfileName: Swift.String?
    public let videoContentSourceUrl: Swift.String?
}

extension GetPlaybackConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case logConfiguration = "LogConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension MediaTailorClientTypes.HlsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestEndpointPrefix = "ManifestEndpointPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestEndpointPrefix = manifestEndpointPrefix {
            try encodeContainer.encode(manifestEndpointPrefix, forKey: .manifestEndpointPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestEndpointPrefix)
        manifestEndpointPrefix = manifestEndpointPrefixDecoded
    }
}

extension MediaTailorClientTypes.HlsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsConfiguration(manifestEndpointPrefix: \(Swift.String(describing: manifestEndpointPrefix)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for HLS content.
    public struct HlsConfiguration: Swift.Equatable {
        /// The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.
        public var manifestEndpointPrefix: Swift.String?

        public init (
            manifestEndpointPrefix: Swift.String? = nil
        )
        {
            self.manifestEndpointPrefix = manifestEndpointPrefix
        }
    }

}

extension MediaTailorClientTypes.HlsPlaylistSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestWindowSeconds = "ManifestWindowSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestWindowSeconds = manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
    }
}

extension MediaTailorClientTypes.HlsPlaylistSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsPlaylistSettings(manifestWindowSeconds: \(Swift.String(describing: manifestWindowSeconds)))"}
}

extension MediaTailorClientTypes {
    /// HLS playlist configuration parameters.
    public struct HlsPlaylistSettings: Swift.Equatable {
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public var manifestWindowSeconds: Swift.Int?

        public init (
            manifestWindowSeconds: Swift.Int? = nil
        )
        {
            self.manifestWindowSeconds = manifestWindowSeconds
        }
    }

}

extension MediaTailorClientTypes.HttpConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseUrl = "BaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseUrl = baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
    }
}

extension MediaTailorClientTypes.HttpConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpConfiguration(baseUrl: \(Swift.String(describing: baseUrl)))"}
}

extension MediaTailorClientTypes {
    /// The HTTP configuration for the source location.
    public struct HttpConfiguration: Swift.Equatable {
        /// The base URL for the source location host server. This string must include the protocol, such as https://.
        /// This member is required.
        public var baseUrl: Swift.String?

        public init (
            baseUrl: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
        }
    }

}

extension MediaTailorClientTypes.HttpPackageConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case sourceGroup = "SourceGroup"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let sourceGroup = sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension MediaTailorClientTypes.HttpPackageConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpPackageConfiguration(path: \(Swift.String(describing: path)), sourceGroup: \(Swift.String(describing: sourceGroup)), type: \(Swift.String(describing: type)))"}
}

extension MediaTailorClientTypes {
    /// The HTTP package configuration properties for the requested VOD source.
    public struct HttpPackageConfiguration: Swift.Equatable {
        /// The relative path to the URL for this VOD source. This is combined with SourceLocation::HttpConfiguration::BaseUrl to form a valid URL.
        /// This member is required.
        public var path: Swift.String?
        /// The name of the source group. This has to match one of the Channel::Outputs::SourceGroup.
        /// This member is required.
        public var sourceGroup: Swift.String?
        /// The streaming protocol for this package configuration. Supported values are HLS and DASH.
        /// This member is required.
        public var type: MediaTailorClientTypes.ModelType?

        public init (
            path: Swift.String? = nil,
            sourceGroup: Swift.String? = nil,
            type: MediaTailorClientTypes.ModelType? = nil
        )
        {
            self.path = path
            self.sourceGroup = sourceGroup
            self.type = type
        }
    }

}

extension ListAlertsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlertsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListAlertsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAlertsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlertsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlertsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlertsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlertsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlertsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlertsOutputError>
}

public struct ListAlertsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlertsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlertsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlertsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlertsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlertsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlertsOutputError>
}

public struct ListAlertsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlertsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAlertsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlertsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAlertsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlertsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlertsOutputError>
}

public struct ListAlertsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlertsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAlertsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlertsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/alerts"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAlertsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlertsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlertsOutputError>
}

public struct ListAlertsInput: Swift.Equatable {
    /// Upper bound on number of records to return. The maximum number of results is 100.
    public var maxResults: Swift.Int?
    /// Pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListAlertsInputBody: Swift.Equatable {
}

extension ListAlertsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAlertsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlertsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlertsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlertsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlertsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlertsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAlertsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlertsOutputResponse: Swift.Equatable {
    /// An array of alerts that are associated with this resource.
    public var items: [MediaTailorClientTypes.Alert]?
    /// Pagination token from the list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.Alert]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAlertsOutputResponseBody: Swift.Equatable {
    public let items: [MediaTailorClientTypes.Alert]?
    public let nextToken: Swift.String?
}

extension ListAlertsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.Alert?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.Alert]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.Alert]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Swift.Equatable {
    /// Upper bound on number of records to return. The maximum number of results is 100.
    public var maxResults: Swift.Int?
    /// Pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// An array of channels that are associated with this account.
    public var items: [MediaTailorClientTypes.Channel]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    public let items: [MediaTailorClientTypes.Channel]?
    public let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.Channel?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.Channel]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.Channel]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlaybackConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlaybackConfigurationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPlaybackConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPlaybackConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaybackConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaybackConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackConfigurationsOutputError>
}

public struct ListPlaybackConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaybackConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaybackConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackConfigurationsOutputError>
}

public struct ListPlaybackConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPlaybackConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPlaybackConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackConfigurationsOutputError>
}

public struct ListPlaybackConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPlaybackConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/playbackConfigurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPlaybackConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackConfigurationsOutputError>
}

public struct ListPlaybackConfigurationsInput: Swift.Equatable {
    /// Maximum number of records to return.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaybackConfigurationsInputBody: Swift.Equatable {
}

extension ListPlaybackConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPlaybackConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaybackConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlaybackConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaybackConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlaybackConfigurationsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPlaybackConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPlaybackConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaybackConfigurationsOutputResponse: Swift.Equatable {
    /// Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.
    public var items: [MediaTailorClientTypes.PlaybackConfiguration]?
    /// Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.PlaybackConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListPlaybackConfigurationsOutputResponseBody: Swift.Equatable {
    public let items: [MediaTailorClientTypes.PlaybackConfiguration]?
    public let nextToken: Swift.String?
}

extension ListPlaybackConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.PlaybackConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.PlaybackConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.PlaybackConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSourceLocationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSourceLocationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSourceLocationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSourceLocationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSourceLocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSourceLocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSourceLocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSourceLocationsOutputError>
}

public struct ListSourceLocationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSourceLocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSourceLocationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSourceLocationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSourceLocationsOutputError>
}

public struct ListSourceLocationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSourceLocationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSourceLocationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSourceLocationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSourceLocationsOutputError>
}

public struct ListSourceLocationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSourceLocationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSourceLocationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sourceLocations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSourceLocationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSourceLocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSourceLocationsOutputError>
}

public struct ListSourceLocationsInput: Swift.Equatable {
    /// Upper bound on number of records to return. The maximum number of results is 100.
    public var maxResults: Swift.Int?
    /// Pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSourceLocationsInputBody: Swift.Equatable {
}

extension ListSourceLocationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSourceLocationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceLocationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSourceLocationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceLocationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSourceLocationsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSourceLocationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSourceLocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceLocationsOutputResponse: Swift.Equatable {
    /// An array of source locations.
    public var items: [MediaTailorClientTypes.SourceLocation]?
    /// Pagination token from the list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.SourceLocation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceLocationsOutputResponseBody: Swift.Equatable {
    public let items: [MediaTailorClientTypes.SourceLocation]?
    public let nextToken: Swift.String?
}

extension ListSourceLocationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SourceLocation?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.SourceLocation]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.SourceLocation]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A comma-separated list of tag key:value pairs.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVodSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVodSourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sourceLocationName: \(Swift.String(describing: sourceLocationName)))"}
}

extension ListVodSourcesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListVodSourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVodSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVodSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVodSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVodSourcesOutputError>
}

public struct ListVodSourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVodSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVodSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVodSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVodSourcesOutputError>
}

public struct ListVodSourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVodSourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListVodSourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVodSourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVodSourcesOutputError>
}

public struct ListVodSourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVodSourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListVodSourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVodSourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVodSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVodSourcesOutputError>
}

public struct ListVodSourcesInput: Swift.Equatable {
    /// Upper bound on number of records to return. The maximum number of results is 100.
    public var maxResults: Swift.Int?
    /// Pagination token from the GET list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceLocationName = sourceLocationName
    }
}

struct ListVodSourcesInputBody: Swift.Equatable {
}

extension ListVodSourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVodSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVodSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVodSourcesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVodSourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVodSourcesOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListVodSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVodSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListVodSourcesOutputResponse: Swift.Equatable {
    /// Lists the VOD sources.
    public var items: [MediaTailorClientTypes.VodSource]?
    /// Pagination token from the list request. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.VodSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListVodSourcesOutputResponseBody: Swift.Equatable {
    public let items: [MediaTailorClientTypes.VodSource]?
    public let nextToken: Swift.String?
}

extension ListVodSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.VodSource?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.VodSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.VodSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MediaTailorClientTypes.LivePreRollConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case maxDurationSeconds = "MaxDurationSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let maxDurationSeconds = maxDurationSeconds {
            try encodeContainer.encode(maxDurationSeconds, forKey: .maxDurationSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let maxDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDurationSeconds)
        maxDurationSeconds = maxDurationSecondsDecoded
    }
}

extension MediaTailorClientTypes.LivePreRollConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LivePreRollConfiguration(adDecisionServerUrl: \(Swift.String(describing: adDecisionServerUrl)), maxDurationSeconds: \(Swift.String(describing: maxDurationSeconds)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for pre-roll ad insertion.
    public struct LivePreRollConfiguration: Swift.Equatable {
        /// The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
        public var adDecisionServerUrl: Swift.String?
        /// The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.
        public var maxDurationSeconds: Swift.Int?

        public init (
            adDecisionServerUrl: Swift.String? = nil,
            maxDurationSeconds: Swift.Int? = nil
        )
        {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.maxDurationSeconds = maxDurationSeconds
        }
    }

}

extension MediaTailorClientTypes.LogConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentEnabled = percentEnabled {
            try encodeContainer.encode(percentEnabled, forKey: .percentEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentEnabledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentEnabled)
        percentEnabled = percentEnabledDecoded
    }
}

extension MediaTailorClientTypes.LogConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LogConfiguration(percentEnabled: \(Swift.String(describing: percentEnabled)))"}
}

extension MediaTailorClientTypes {
    /// Returns Amazon CloudWatch log settings for a playback configuration.
    public struct LogConfiguration: Swift.Equatable {
        /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode. Valid values: 0 - 100
        /// This member is required.
        public var percentEnabled: Swift.Int?

        public init (
            percentEnabled: Swift.Int? = nil
        )
        {
            self.percentEnabled = percentEnabled
        }
    }

}

extension MediaTailorClientTypes.ManifestProcessingRules: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkerPassthrough = "AdMarkerPassthrough"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkerPassthrough = adMarkerPassthrough {
            try encodeContainer.encode(adMarkerPassthrough, forKey: .adMarkerPassthrough)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkerPassthroughDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AdMarkerPassthrough.self, forKey: .adMarkerPassthrough)
        adMarkerPassthrough = adMarkerPassthroughDecoded
    }
}

extension MediaTailorClientTypes.ManifestProcessingRules: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManifestProcessingRules(adMarkerPassthrough: \(Swift.String(describing: adMarkerPassthrough)))"}
}

extension MediaTailorClientTypes {
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public struct ManifestProcessingRules: Swift.Equatable {
        /// For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
        public var adMarkerPassthrough: MediaTailorClientTypes.AdMarkerPassthrough?

        public init (
            adMarkerPassthrough: MediaTailorClientTypes.AdMarkerPassthrough? = nil
        )
        {
            self.adMarkerPassthrough = adMarkerPassthrough
        }
    }

}

extension MediaTailorClientTypes {
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case spliceInsert
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .spliceInsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .spliceInsert: return "SPLICE_INSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case behindLiveEdge
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .behindLiveEdge,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .behindLiveEdge: return "BEHIND_LIVE_EDGE"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes {
    public enum OriginManifestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiPeriod
        case singlePeriod
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginManifestType] {
            return [
                .multiPeriod,
                .singlePeriod,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiPeriod: return "MULTI_PERIOD"
            case .singlePeriod: return "SINGLE_PERIOD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginManifestType(rawValue: rawValue) ?? OriginManifestType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.PlaybackConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case logConfiguration = "LogConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let availSuppression = availSuppression {
            try encodeContainer.encode(availSuppression, forKey: .availSuppression)
        }
        if let bumper = bumper {
            try encodeContainer.encode(bumper, forKey: .bumper)
        }
        if let cdnConfiguration = cdnConfiguration {
            try encodeContainer.encode(cdnConfiguration, forKey: .cdnConfiguration)
        }
        if let configurationAliases = configurationAliases {
            var configurationAliasesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurationAliases)
            for (dictKey0, configurationaliasesresponse0) in configurationAliases {
                try configurationAliasesContainer.encode(configurationaliasesresponse0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dashConfiguration = dashConfiguration {
            try encodeContainer.encode(dashConfiguration, forKey: .dashConfiguration)
        }
        if let hlsConfiguration = hlsConfiguration {
            try encodeContainer.encode(hlsConfiguration, forKey: .hlsConfiguration)
        }
        if let livePreRollConfiguration = livePreRollConfiguration {
            try encodeContainer.encode(livePreRollConfiguration, forKey: .livePreRollConfiguration)
        }
        if let logConfiguration = logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let manifestProcessingRules = manifestProcessingRules {
            try encodeContainer.encode(manifestProcessingRules, forKey: .manifestProcessingRules)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let personalizationThresholdSeconds = personalizationThresholdSeconds {
            try encodeContainer.encode(personalizationThresholdSeconds, forKey: .personalizationThresholdSeconds)
        }
        if let playbackConfigurationArn = playbackConfigurationArn {
            try encodeContainer.encode(playbackConfigurationArn, forKey: .playbackConfigurationArn)
        }
        if let playbackEndpointPrefix = playbackEndpointPrefix {
            try encodeContainer.encode(playbackEndpointPrefix, forKey: .playbackEndpointPrefix)
        }
        if let sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix {
            try encodeContainer.encode(sessionInitializationEndpointPrefix, forKey: .sessionInitializationEndpointPrefix)
        }
        if let slateAdUrl = slateAdUrl {
            try encodeContainer.encode(slateAdUrl, forKey: .slateAdUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let transcodeProfileName = transcodeProfileName {
            try encodeContainer.encode(transcodeProfileName, forKey: .transcodeProfileName)
        }
        if let videoContentSourceUrl = videoContentSourceUrl {
            try encodeContainer.encode(videoContentSourceUrl, forKey: .videoContentSourceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension MediaTailorClientTypes.PlaybackConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaybackConfiguration(adDecisionServerUrl: \(Swift.String(describing: adDecisionServerUrl)), availSuppression: \(Swift.String(describing: availSuppression)), bumper: \(Swift.String(describing: bumper)), cdnConfiguration: \(Swift.String(describing: cdnConfiguration)), configurationAliases: \(Swift.String(describing: configurationAliases)), dashConfiguration: \(Swift.String(describing: dashConfiguration)), hlsConfiguration: \(Swift.String(describing: hlsConfiguration)), livePreRollConfiguration: \(Swift.String(describing: livePreRollConfiguration)), logConfiguration: \(Swift.String(describing: logConfiguration)), manifestProcessingRules: \(Swift.String(describing: manifestProcessingRules)), name: \(Swift.String(describing: name)), personalizationThresholdSeconds: \(Swift.String(describing: personalizationThresholdSeconds)), playbackConfigurationArn: \(Swift.String(describing: playbackConfigurationArn)), playbackEndpointPrefix: \(Swift.String(describing: playbackEndpointPrefix)), sessionInitializationEndpointPrefix: \(Swift.String(describing: sessionInitializationEndpointPrefix)), slateAdUrl: \(Swift.String(describing: slateAdUrl)), tags: \(Swift.String(describing: tags)), transcodeProfileName: \(Swift.String(describing: transcodeProfileName)), videoContentSourceUrl: \(Swift.String(describing: videoContentSourceUrl)))"}
}

extension MediaTailorClientTypes {
    /// Creates a playback configuration. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with configurations in AWS Elemental MediaTailor.
    public struct PlaybackConfiguration: Swift.Equatable {
        /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
        public var adDecisionServerUrl: Swift.String?
        /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression.
        public var availSuppression: MediaTailorClientTypes.AvailSuppression?
        /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers.
        public var bumper: MediaTailorClientTypes.Bumper?
        /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
        public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
        /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables.
        public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
        /// The configuration for a DASH source.
        public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
        /// The configuration for HLS content.
        public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
        /// The configuration for pre-roll ad insertion.
        public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
        /// The Amazon CloudWatch log settings for a playback configuration.
        public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
        /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
        public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
        /// The identifier for the playback configuration.
        public var name: Swift.String?
        /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor.
        public var personalizationThresholdSeconds: Swift.Int?
        /// The Amazon Resource Name (ARN) for the playback configuration.
        public var playbackConfigurationArn: Swift.String?
        /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.
        public var playbackEndpointPrefix: Swift.String?
        /// The URL that the player uses to initialize a session that uses client-side reporting.
        public var sessionInitializationEndpointPrefix: Swift.String?
        /// The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
        public var slateAdUrl: Swift.String?
        /// The tags to assign to the playback configuration.
        public var tags: [Swift.String:Swift.String]?
        /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
        public var transcodeProfileName: Swift.String?
        /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
        public var videoContentSourceUrl: Swift.String?

        public init (
            adDecisionServerUrl: Swift.String? = nil,
            availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
            bumper: MediaTailorClientTypes.Bumper? = nil,
            cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
            configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
            dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
            hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
            livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
            logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
            manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
            name: Swift.String? = nil,
            personalizationThresholdSeconds: Swift.Int? = nil,
            playbackConfigurationArn: Swift.String? = nil,
            playbackEndpointPrefix: Swift.String? = nil,
            sessionInitializationEndpointPrefix: Swift.String? = nil,
            slateAdUrl: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            transcodeProfileName: Swift.String? = nil,
            videoContentSourceUrl: Swift.String? = nil
        )
        {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.availSuppression = availSuppression
            self.bumper = bumper
            self.cdnConfiguration = cdnConfiguration
            self.configurationAliases = configurationAliases
            self.dashConfiguration = dashConfiguration
            self.hlsConfiguration = hlsConfiguration
            self.livePreRollConfiguration = livePreRollConfiguration
            self.logConfiguration = logConfiguration
            self.manifestProcessingRules = manifestProcessingRules
            self.name = name
            self.personalizationThresholdSeconds = personalizationThresholdSeconds
            self.playbackConfigurationArn = playbackConfigurationArn
            self.playbackEndpointPrefix = playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
            self.slateAdUrl = slateAdUrl
            self.tags = tags
            self.transcodeProfileName = transcodeProfileName
            self.videoContentSourceUrl = videoContentSourceUrl
        }
    }

}

extension MediaTailorClientTypes {
    public enum PlaybackMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linear
        case loop
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaybackMode] {
            return [
                .linear,
                .loop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case .loop: return "LOOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlaybackMode(rawValue: rawValue) ?? PlaybackMode.sdkUnknown(rawValue)
        }
    }
}

public struct PutChannelPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutChannelPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutChannelPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutChannelPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutChannelPolicyOutputError>
}

extension PutChannelPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutChannelPolicyInput(channelName: \(Swift.String(describing: channelName)), policy: \(Swift.String(describing: policy)))"}
}

extension PutChannelPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutChannelPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutChannelPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutChannelPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutChannelPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutChannelPolicyOutputError>
}

public struct PutChannelPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutChannelPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutChannelPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutChannelPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutChannelPolicyOutputError>
}

public struct PutChannelPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutChannelPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutChannelPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutChannelPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutChannelPolicyOutputError>
}

public struct PutChannelPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutChannelPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutChannelPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutChannelPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutChannelPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutChannelPolicyOutputError>
}

public struct PutChannelPolicyInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?
    /// Adds an IAM role that determines the permissions of your channel.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.policy = policy
    }
}

struct PutChannelPolicyInputBody: Swift.Equatable {
    public let policy: Swift.String?
}

extension PutChannelPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutChannelPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutChannelPolicyOutputResponse()"}
}

extension PutChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutChannelPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutChannelPolicyOutputResponseBody: Swift.Equatable {
}

extension PutChannelPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutPlaybackConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPlaybackConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPlaybackConfigurationOutputError>
}

extension PutPlaybackConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPlaybackConfigurationInput(adDecisionServerUrl: \(Swift.String(describing: adDecisionServerUrl)), availSuppression: \(Swift.String(describing: availSuppression)), bumper: \(Swift.String(describing: bumper)), cdnConfiguration: \(Swift.String(describing: cdnConfiguration)), configurationAliases: \(Swift.String(describing: configurationAliases)), dashConfiguration: \(Swift.String(describing: dashConfiguration)), livePreRollConfiguration: \(Swift.String(describing: livePreRollConfiguration)), manifestProcessingRules: \(Swift.String(describing: manifestProcessingRules)), name: \(Swift.String(describing: name)), personalizationThresholdSeconds: \(Swift.String(describing: personalizationThresholdSeconds)), slateAdUrl: \(Swift.String(describing: slateAdUrl)), tags: \(Swift.String(describing: tags)), transcodeProfileName: \(Swift.String(describing: transcodeProfileName)), videoContentSourceUrl: \(Swift.String(describing: videoContentSourceUrl)))"}
}

extension PutPlaybackConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let availSuppression = availSuppression {
            try encodeContainer.encode(availSuppression, forKey: .availSuppression)
        }
        if let bumper = bumper {
            try encodeContainer.encode(bumper, forKey: .bumper)
        }
        if let cdnConfiguration = cdnConfiguration {
            try encodeContainer.encode(cdnConfiguration, forKey: .cdnConfiguration)
        }
        if let configurationAliases = configurationAliases {
            var configurationAliasesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurationAliases)
            for (dictKey0, configurationaliasesrequest0) in configurationAliases {
                try configurationAliasesContainer.encode(configurationaliasesrequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dashConfiguration = dashConfiguration {
            try encodeContainer.encode(dashConfiguration, forKey: .dashConfiguration)
        }
        if let livePreRollConfiguration = livePreRollConfiguration {
            try encodeContainer.encode(livePreRollConfiguration, forKey: .livePreRollConfiguration)
        }
        if let manifestProcessingRules = manifestProcessingRules {
            try encodeContainer.encode(manifestProcessingRules, forKey: .manifestProcessingRules)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let personalizationThresholdSeconds = personalizationThresholdSeconds {
            try encodeContainer.encode(personalizationThresholdSeconds, forKey: .personalizationThresholdSeconds)
        }
        if let slateAdUrl = slateAdUrl {
            try encodeContainer.encode(slateAdUrl, forKey: .slateAdUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let transcodeProfileName = transcodeProfileName {
            try encodeContainer.encode(transcodeProfileName, forKey: .transcodeProfileName)
        }
        if let videoContentSourceUrl = videoContentSourceUrl {
            try encodeContainer.encode(videoContentSourceUrl, forKey: .videoContentSourceUrl)
        }
    }
}

public struct PutPlaybackConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPlaybackConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPlaybackConfigurationOutputError>
}

public struct PutPlaybackConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPlaybackConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPlaybackConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPlaybackConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPlaybackConfigurationOutputError>
}

public struct PutPlaybackConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPlaybackConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutPlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutPlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPlaybackConfigurationOutputError>
}

public struct PutPlaybackConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPlaybackConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutPlaybackConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/playbackConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutPlaybackConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutPlaybackConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPlaybackConfigurationOutputError>
}

public struct PutPlaybackConfigurationInput: Swift.Equatable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression.
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers.
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables.
    public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor.
    public var personalizationThresholdSeconds: Swift.Int?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags to assign to the playback configuration.
    public var tags: [Swift.String:Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init (
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct PutPlaybackConfigurationInputBody: Swift.Equatable {
    public let adDecisionServerUrl: Swift.String?
    public let availSuppression: MediaTailorClientTypes.AvailSuppression?
    public let bumper: MediaTailorClientTypes.Bumper?
    public let cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    public let configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    public let dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut?
    public let livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    public let manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    public let name: Swift.String?
    public let personalizationThresholdSeconds: Swift.Int?
    public let slateAdUrl: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let transcodeProfileName: Swift.String?
    public let videoContentSourceUrl: Swift.String?
}

extension PutPlaybackConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfigurationForPut.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension PutPlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPlaybackConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPlaybackConfigurationOutputResponse(adDecisionServerUrl: \(Swift.String(describing: adDecisionServerUrl)), availSuppression: \(Swift.String(describing: availSuppression)), bumper: \(Swift.String(describing: bumper)), cdnConfiguration: \(Swift.String(describing: cdnConfiguration)), configurationAliases: \(Swift.String(describing: configurationAliases)), dashConfiguration: \(Swift.String(describing: dashConfiguration)), hlsConfiguration: \(Swift.String(describing: hlsConfiguration)), livePreRollConfiguration: \(Swift.String(describing: livePreRollConfiguration)), logConfiguration: \(Swift.String(describing: logConfiguration)), manifestProcessingRules: \(Swift.String(describing: manifestProcessingRules)), name: \(Swift.String(describing: name)), personalizationThresholdSeconds: \(Swift.String(describing: personalizationThresholdSeconds)), playbackConfigurationArn: \(Swift.String(describing: playbackConfigurationArn)), playbackEndpointPrefix: \(Swift.String(describing: playbackEndpointPrefix)), sessionInitializationEndpointPrefix: \(Swift.String(describing: sessionInitializationEndpointPrefix)), slateAdUrl: \(Swift.String(describing: slateAdUrl)), tags: \(Swift.String(describing: tags)), transcodeProfileName: \(Swift.String(describing: transcodeProfileName)), videoContentSourceUrl: \(Swift.String(describing: videoContentSourceUrl)))"}
}

extension PutPlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adDecisionServerUrl = output.adDecisionServerUrl
            self.availSuppression = output.availSuppression
            self.bumper = output.bumper
            self.cdnConfiguration = output.cdnConfiguration
            self.configurationAliases = output.configurationAliases
            self.dashConfiguration = output.dashConfiguration
            self.hlsConfiguration = output.hlsConfiguration
            self.livePreRollConfiguration = output.livePreRollConfiguration
            self.logConfiguration = output.logConfiguration
            self.manifestProcessingRules = output.manifestProcessingRules
            self.name = output.name
            self.personalizationThresholdSeconds = output.personalizationThresholdSeconds
            self.playbackConfigurationArn = output.playbackConfigurationArn
            self.playbackEndpointPrefix = output.playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = output.sessionInitializationEndpointPrefix
            self.slateAdUrl = output.slateAdUrl
            self.tags = output.tags
            self.transcodeProfileName = output.transcodeProfileName
            self.videoContentSourceUrl = output.videoContentSourceUrl
        } else {
            self.adDecisionServerUrl = nil
            self.availSuppression = nil
            self.bumper = nil
            self.cdnConfiguration = nil
            self.configurationAliases = nil
            self.dashConfiguration = nil
            self.hlsConfiguration = nil
            self.livePreRollConfiguration = nil
            self.logConfiguration = nil
            self.manifestProcessingRules = nil
            self.name = nil
            self.personalizationThresholdSeconds = nil
            self.playbackConfigurationArn = nil
            self.playbackEndpointPrefix = nil
            self.sessionInitializationEndpointPrefix = nil
            self.slateAdUrl = nil
            self.tags = nil
            self.transcodeProfileName = nil
            self.videoContentSourceUrl = nil
        }
    }
}

public struct PutPlaybackConfigurationOutputResponse: Swift.Equatable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression.
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers.
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html">Domain Variables.
    public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    /// The configuration for HLS content.
    public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The Amazon CloudWatch log settings for a playback configuration.
    public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor.
    public var personalizationThresholdSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) for the playback configuration.
    public var playbackConfigurationArn: Swift.String?
    /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.
    public var playbackEndpointPrefix: Swift.String?
    /// The URL that the player uses to initialize a session that uses client-side reporting.
    public var sessionInitializationEndpointPrefix: Swift.String?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags assigned to the playback configuration.
    public var tags: [Swift.String:Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init (
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
        hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        playbackConfigurationArn: Swift.String? = nil,
        playbackEndpointPrefix: Swift.String? = nil,
        sessionInitializationEndpointPrefix: Swift.String? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.logConfiguration = logConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct PutPlaybackConfigurationOutputResponseBody: Swift.Equatable {
    public let adDecisionServerUrl: Swift.String?
    public let availSuppression: MediaTailorClientTypes.AvailSuppression?
    public let bumper: MediaTailorClientTypes.Bumper?
    public let cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    public let configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    public let dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    public let hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    public let livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    public let logConfiguration: MediaTailorClientTypes.LogConfiguration?
    public let manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    public let name: Swift.String?
    public let personalizationThresholdSeconds: Swift.Int?
    public let playbackConfigurationArn: Swift.String?
    public let playbackEndpointPrefix: Swift.String?
    public let sessionInitializationEndpointPrefix: Swift.String?
    public let slateAdUrl: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let transcodeProfileName: Swift.String?
    public let videoContentSourceUrl: Swift.String?
}

extension PutPlaybackConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case logConfiguration = "LogConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension MediaTailorClientTypes {
    public enum RelativePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterProgram
        case beforeProgram
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativePosition] {
            return [
                .afterProgram,
                .beforeProgram,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterProgram: return "AFTER_PROGRAM"
            case .beforeProgram: return "BEFORE_PROGRAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelativePosition(rawValue: rawValue) ?? RelativePosition.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.RequestOutputItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashPlaylistSettings = "DashPlaylistSettings"
        case hlsPlaylistSettings = "HlsPlaylistSettings"
        case manifestName = "ManifestName"
        case sourceGroup = "SourceGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashPlaylistSettings = dashPlaylistSettings {
            try encodeContainer.encode(dashPlaylistSettings, forKey: .dashPlaylistSettings)
        }
        if let hlsPlaylistSettings = hlsPlaylistSettings {
            try encodeContainer.encode(hlsPlaylistSettings, forKey: .hlsPlaylistSettings)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let sourceGroup = sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashPlaylistSettings.self, forKey: .dashPlaylistSettings)
        dashPlaylistSettings = dashPlaylistSettingsDecoded
        let hlsPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsPlaylistSettings.self, forKey: .hlsPlaylistSettings)
        hlsPlaylistSettings = hlsPlaylistSettingsDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
    }
}

extension MediaTailorClientTypes.RequestOutputItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestOutputItem(dashPlaylistSettings: \(Swift.String(describing: dashPlaylistSettings)), hlsPlaylistSettings: \(Swift.String(describing: hlsPlaylistSettings)), manifestName: \(Swift.String(describing: manifestName)), sourceGroup: \(Swift.String(describing: sourceGroup)))"}
}

extension MediaTailorClientTypes {
    /// The output configuration for this channel.
    public struct RequestOutputItem: Swift.Equatable {
        /// DASH manifest configuration parameters.
        public var dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings?
        /// HLS playlist configuration parameters.
        public var hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings?
        /// The name of the manifest for the channel. The name appears in the PlaybackUrl.
        /// This member is required.
        public var manifestName: Swift.String?
        /// A string used to match which HttpPackageConfiguration is used for each VodSource.
        /// This member is required.
        public var sourceGroup: Swift.String?

        public init (
            dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings? = nil,
            hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings? = nil,
            manifestName: Swift.String? = nil,
            sourceGroup: Swift.String? = nil
        )
        {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.sourceGroup = sourceGroup
        }
    }

}

extension MediaTailorClientTypes.ResponseOutputItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashPlaylistSettings = "DashPlaylistSettings"
        case hlsPlaylistSettings = "HlsPlaylistSettings"
        case manifestName = "ManifestName"
        case playbackUrl = "PlaybackUrl"
        case sourceGroup = "SourceGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashPlaylistSettings = dashPlaylistSettings {
            try encodeContainer.encode(dashPlaylistSettings, forKey: .dashPlaylistSettings)
        }
        if let hlsPlaylistSettings = hlsPlaylistSettings {
            try encodeContainer.encode(hlsPlaylistSettings, forKey: .hlsPlaylistSettings)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playbackUrl = playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let sourceGroup = sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashPlaylistSettings.self, forKey: .dashPlaylistSettings)
        dashPlaylistSettings = dashPlaylistSettingsDecoded
        let hlsPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsPlaylistSettings.self, forKey: .hlsPlaylistSettings)
        hlsPlaylistSettings = hlsPlaylistSettingsDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
    }
}

extension MediaTailorClientTypes.ResponseOutputItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponseOutputItem(dashPlaylistSettings: \(Swift.String(describing: dashPlaylistSettings)), hlsPlaylistSettings: \(Swift.String(describing: hlsPlaylistSettings)), manifestName: \(Swift.String(describing: manifestName)), playbackUrl: \(Swift.String(describing: playbackUrl)), sourceGroup: \(Swift.String(describing: sourceGroup)))"}
}

extension MediaTailorClientTypes {
    /// This response includes only the "property" : "type" property.
    public struct ResponseOutputItem: Swift.Equatable {
        /// DASH manifest configuration settings.
        public var dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings?
        /// HLS manifest configuration settings.
        public var hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings?
        /// The name of the manifest for the channel that will appear in the channel output's playback URL.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The URL used for playback by content players.
        /// This member is required.
        public var playbackUrl: Swift.String?
        /// A string used to associate a package configuration source group with a channel output.
        /// This member is required.
        public var sourceGroup: Swift.String?

        public init (
            dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings? = nil,
            hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings? = nil,
            manifestName: Swift.String? = nil,
            playbackUrl: Swift.String? = nil,
            sourceGroup: Swift.String? = nil
        )
        {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.playbackUrl = playbackUrl
            self.sourceGroup = sourceGroup
        }
    }

}

extension MediaTailorClientTypes.ScheduleAdBreak: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateDurationSeconds = "ApproximateDurationSeconds"
        case approximateStartTime = "ApproximateStartTime"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateDurationSeconds = approximateDurationSeconds {
            try encodeContainer.encode(approximateDurationSeconds, forKey: .approximateDurationSeconds)
        }
        if let approximateStartTime = approximateStartTime {
            try encodeContainer.encode(approximateStartTime.timeIntervalSince1970, forKey: .approximateStartTime)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateDurationSeconds)
        approximateDurationSeconds = approximateDurationSecondsDecoded
        let approximateStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approximateStartTime)
        approximateStartTime = approximateStartTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.ScheduleAdBreak: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleAdBreak(approximateDurationSeconds: \(Swift.String(describing: approximateDurationSeconds)), approximateStartTime: \(Swift.String(describing: approximateStartTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension MediaTailorClientTypes {
    /// The schedule's ad break properties.
    public struct ScheduleAdBreak: Swift.Equatable {
        /// The approximate duration of the ad break, in seconds.
        public var approximateDurationSeconds: Swift.Int?
        /// The approximate time that the ad will start playing.
        public var approximateStartTime: ClientRuntime.Date?
        /// The name of the source location containing the VOD source used for the ad break.
        public var sourceLocationName: Swift.String?
        /// The name of the VOD source used for the ad break.
        public var vodSourceName: Swift.String?

        public init (
            approximateDurationSeconds: Swift.Int? = nil,
            approximateStartTime: ClientRuntime.Date? = nil,
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }

}

extension MediaTailorClientTypes.ScheduleConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transition = "Transition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transition = transition {
            try encodeContainer.encode(transition, forKey: .transition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Transition.self, forKey: .transition)
        transition = transitionDecoded
    }
}

extension MediaTailorClientTypes.ScheduleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleConfiguration(transition: \(Swift.String(describing: transition)))"}
}

extension MediaTailorClientTypes {
    /// Schedule configuration parameters. A channel must be stopped before changes can be made to the schedule.
    public struct ScheduleConfiguration: Swift.Equatable {
        /// Program transition configurations.
        /// This member is required.
        public var transition: MediaTailorClientTypes.Transition?

        public init (
            transition: MediaTailorClientTypes.Transition? = nil
        )
        {
            self.transition = transition
        }
    }

}

extension MediaTailorClientTypes.ScheduleEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateDurationSeconds = "ApproximateDurationSeconds"
        case approximateStartTime = "ApproximateStartTime"
        case arn = "Arn"
        case channelName = "ChannelName"
        case programName = "ProgramName"
        case scheduleAdBreaks = "ScheduleAdBreaks"
        case scheduleEntryType = "ScheduleEntryType"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateDurationSeconds = approximateDurationSeconds {
            try encodeContainer.encode(approximateDurationSeconds, forKey: .approximateDurationSeconds)
        }
        if let approximateStartTime = approximateStartTime {
            try encodeContainer.encode(approximateStartTime.timeIntervalSince1970, forKey: .approximateStartTime)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let programName = programName {
            try encodeContainer.encode(programName, forKey: .programName)
        }
        if let scheduleAdBreaks = scheduleAdBreaks {
            var scheduleAdBreaksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scheduleAdBreaks)
            for __listofscheduleadbreak0 in scheduleAdBreaks {
                try scheduleAdBreaksContainer.encode(__listofscheduleadbreak0)
            }
        }
        if let scheduleEntryType = scheduleEntryType {
            try encodeContainer.encode(scheduleEntryType.rawValue, forKey: .scheduleEntryType)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateDurationSeconds)
        approximateDurationSeconds = approximateDurationSecondsDecoded
        let approximateStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approximateStartTime)
        approximateStartTime = approximateStartTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .programName)
        programName = programNameDecoded
        let scheduleAdBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ScheduleAdBreak?].self, forKey: .scheduleAdBreaks)
        var scheduleAdBreaksDecoded0:[MediaTailorClientTypes.ScheduleAdBreak]? = nil
        if let scheduleAdBreaksContainer = scheduleAdBreaksContainer {
            scheduleAdBreaksDecoded0 = [MediaTailorClientTypes.ScheduleAdBreak]()
            for structure0 in scheduleAdBreaksContainer {
                if let structure0 = structure0 {
                    scheduleAdBreaksDecoded0?.append(structure0)
                }
            }
        }
        scheduleAdBreaks = scheduleAdBreaksDecoded0
        let scheduleEntryTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ScheduleEntryType.self, forKey: .scheduleEntryType)
        scheduleEntryType = scheduleEntryTypeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.ScheduleEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleEntry(approximateDurationSeconds: \(Swift.String(describing: approximateDurationSeconds)), approximateStartTime: \(Swift.String(describing: approximateStartTime)), arn: \(Swift.String(describing: arn)), channelName: \(Swift.String(describing: channelName)), programName: \(Swift.String(describing: programName)), scheduleAdBreaks: \(Swift.String(describing: scheduleAdBreaks)), scheduleEntryType: \(Swift.String(describing: scheduleEntryType)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension MediaTailorClientTypes {
    /// The properties for a schedule.
    public struct ScheduleEntry: Swift.Equatable {
        /// The approximate duration of this program, in seconds.
        public var approximateDurationSeconds: Swift.Int?
        /// The approximate time that the program will start playing.
        public var approximateStartTime: ClientRuntime.Date?
        /// The ARN of the program.
        /// This member is required.
        public var arn: Swift.String?
        /// The name of the channel that uses this schedule.
        /// This member is required.
        public var channelName: Swift.String?
        /// The name of the program.
        /// This member is required.
        public var programName: Swift.String?
        /// The schedule's ad break properties.
        public var scheduleAdBreaks: [MediaTailorClientTypes.ScheduleAdBreak]?
        /// The type of schedule entry. Valid values: PROGRAM or FILLER_SLATE.
        public var scheduleEntryType: MediaTailorClientTypes.ScheduleEntryType?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The name of the VOD source.
        /// This member is required.
        public var vodSourceName: Swift.String?

        public init (
            approximateDurationSeconds: Swift.Int? = nil,
            approximateStartTime: ClientRuntime.Date? = nil,
            arn: Swift.String? = nil,
            channelName: Swift.String? = nil,
            programName: Swift.String? = nil,
            scheduleAdBreaks: [MediaTailorClientTypes.ScheduleAdBreak]? = nil,
            scheduleEntryType: MediaTailorClientTypes.ScheduleEntryType? = nil,
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.arn = arn
            self.channelName = channelName
            self.programName = programName
            self.scheduleAdBreaks = scheduleAdBreaks
            self.scheduleEntryType = scheduleEntryType
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }

}

extension MediaTailorClientTypes {
    public enum ScheduleEntryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fillerSlate
        case program
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleEntryType] {
            return [
                .fillerSlate,
                .program,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fillerSlate: return "FILLER_SLATE"
            case .program: return "PROGRAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleEntryType(rawValue: rawValue) ?? ScheduleEntryType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerName = "HeaderName"
        case secretArn = "SecretArn"
        case secretStringKey = "SecretStringKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerName = headerName {
            try encodeContainer.encode(headerName, forKey: .headerName)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let secretStringKey = secretStringKey {
            try encodeContainer.encode(secretStringKey, forKey: .secretStringKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let secretStringKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretStringKey)
        secretStringKey = secretStringKeyDecoded
    }
}

extension MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecretsManagerAccessTokenConfiguration(headerName: \(Swift.String(describing: headerName)), secretArn: \(Swift.String(describing: secretArn)), secretStringKey: \(Swift.String(describing: secretStringKey)))"}
}

extension MediaTailorClientTypes {
    /// AWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html">Working with AWS Secrets Manager access token authentication.
    public struct SecretsManagerAccessTokenConfiguration: Swift.Equatable {
        /// The name of the HTTP header used to supply the access token in requests to the source location.
        public var headerName: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.
        public var secretArn: Swift.String?
        /// The AWS Secrets Manager <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html">SecretString key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.
        public var secretStringKey: Swift.String?

        public init (
            headerName: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            secretStringKey: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.secretArn = secretArn
            self.secretStringKey = secretStringKey
        }
    }

}

extension MediaTailorClientTypes.SlateSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.SlateSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlateSource(sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension MediaTailorClientTypes {
    /// Slate VOD source configuration.
    public struct SlateSource: Swift.Equatable {
        /// The name of the source location where the slate VOD source is stored.
        public var sourceLocationName: Swift.String?
        /// The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.
        public var vodSourceName: Swift.String?

        public init (
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }

}

extension MediaTailorClientTypes.SourceLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaTailorClientTypes.SourceLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceLocation(accessConfiguration: \(Swift.String(describing: accessConfiguration)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(Swift.String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(Swift.String(describing: httpConfiguration)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)))"}
}

extension MediaTailorClientTypes {
    /// This response includes only the "type" : "object" property.
    public struct SourceLocation: Swift.Equatable {
        /// The access configuration for the source location.
        public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
        /// The ARN of the SourceLocation.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the source location was created.
        public var creationTime: ClientRuntime.Date?
        /// The default segment delivery configuration.
        public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
        /// The HTTP configuration for the source location.
        /// This member is required.
        public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
        /// The timestamp that indicates when the source location was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the source location.
        public var tags: [Swift.String:Swift.String]?

        public init (
            accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
            httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessConfiguration = accessConfiguration
            self.arn = arn
            self.creationTime = creationTime
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }
    }

}

extension MediaTailorClientTypes.SpliceInsertMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availNum = "AvailNum"
        case availsExpected = "AvailsExpected"
        case spliceEventId = "SpliceEventId"
        case uniqueProgramId = "UniqueProgramId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availNum = availNum {
            try encodeContainer.encode(availNum, forKey: .availNum)
        }
        if let availsExpected = availsExpected {
            try encodeContainer.encode(availsExpected, forKey: .availsExpected)
        }
        if let spliceEventId = spliceEventId {
            try encodeContainer.encode(spliceEventId, forKey: .spliceEventId)
        }
        if let uniqueProgramId = uniqueProgramId {
            try encodeContainer.encode(uniqueProgramId, forKey: .uniqueProgramId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availNumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availNum)
        availNum = availNumDecoded
        let availsExpectedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availsExpected)
        availsExpected = availsExpectedDecoded
        let spliceEventIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spliceEventId)
        spliceEventId = spliceEventIdDecoded
        let uniqueProgramIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uniqueProgramId)
        uniqueProgramId = uniqueProgramIdDecoded
    }
}

extension MediaTailorClientTypes.SpliceInsertMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpliceInsertMessage(availNum: \(Swift.String(describing: availNum)), availsExpected: \(Swift.String(describing: availsExpected)), spliceEventId: \(Swift.String(describing: spliceEventId)), uniqueProgramId: \(Swift.String(describing: uniqueProgramId)))"}
}

extension MediaTailorClientTypes {
    /// Splice insert message configuration.
    public struct SpliceInsertMessage: Swift.Equatable {
        /// This is written to splice_insert.avail_num, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var availNum: Swift.Int?
        /// This is written to splice_insert.avails_expected, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var availsExpected: Swift.Int?
        /// This is written to splice_insert.splice_event_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 1.
        public var spliceEventId: Swift.Int?
        /// This is written to splice_insert.unique_program_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var uniqueProgramId: Swift.Int?

        public init (
            availNum: Swift.Int? = nil,
            availsExpected: Swift.Int? = nil,
            spliceEventId: Swift.Int? = nil,
            uniqueProgramId: Swift.Int? = nil
        )
        {
            self.availNum = availNum
            self.availsExpected = availsExpected
            self.spliceEventId = spliceEventId
            self.uniqueProgramId = uniqueProgramId
        }
    }

}

extension StartChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartChannelInput(channelName: \(Swift.String(describing: channelName)))"}
}

extension StartChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StartChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChannelOutputError>
}

public struct StartChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChannelOutputError>
}

public struct StartChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChannelOutputError>
}

public struct StartChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/start"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartChannelOutputError>
}

public struct StartChannelInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct StartChannelInputBody: Swift.Equatable {
}

extension StartChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartChannelOutputResponse()"}
}

extension StartChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartChannelOutputResponseBody: Swift.Equatable {
}

extension StartChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopChannelInput(channelName: \(Swift.String(describing: channelName)))"}
}

extension StopChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopChannelOutputError>
}

public struct StopChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopChannelOutputError>
}

public struct StopChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopChannelOutputError>
}

public struct StopChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())/stop"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopChannelOutputError>
}

public struct StopChannelInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct StopChannelInputBody: Swift.Equatable {
}

extension StopChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StopChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopChannelOutputResponse()"}
}

extension StopChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopChannelOutputResponseBody: Swift.Equatable {
}

extension StopChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A comma-separated list of tag key:value pairs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MediaTailorClientTypes.Transition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relativePosition = "RelativePosition"
        case relativeProgram = "RelativeProgram"
        case scheduledStartTimeMillis = "ScheduledStartTimeMillis"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relativePosition = relativePosition {
            try encodeContainer.encode(relativePosition.rawValue, forKey: .relativePosition)
        }
        if let relativeProgram = relativeProgram {
            try encodeContainer.encode(relativeProgram, forKey: .relativeProgram)
        }
        if let scheduledStartTimeMillis = scheduledStartTimeMillis {
            try encodeContainer.encode(scheduledStartTimeMillis, forKey: .scheduledStartTimeMillis)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relativePositionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.RelativePosition.self, forKey: .relativePosition)
        relativePosition = relativePositionDecoded
        let relativeProgramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativeProgram)
        relativeProgram = relativeProgramDecoded
        let scheduledStartTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scheduledStartTimeMillis)
        scheduledStartTimeMillis = scheduledStartTimeMillisDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension MediaTailorClientTypes.Transition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Transition(relativePosition: \(Swift.String(describing: relativePosition)), relativeProgram: \(Swift.String(describing: relativeProgram)), scheduledStartTimeMillis: \(Swift.String(describing: scheduledStartTimeMillis)), type: \(Swift.String(describing: type)))"}
}

extension MediaTailorClientTypes {
    /// Program transition configuration.
    public struct Transition: Swift.Equatable {
        /// The position where this program will be inserted relative to the RelativePosition.
        /// This member is required.
        public var relativePosition: MediaTailorClientTypes.RelativePosition?
        /// The name of the program that this program will be inserted next to, as defined by RelativePosition.
        public var relativeProgram: Swift.String?
        /// The date and time that the program is scheduled to start, in epoch milliseconds.
        public var scheduledStartTimeMillis: Swift.Int?
        /// Defines when the program plays in the schedule. You can set the value to ABSOLUTE or RELATIVE. ABSOLUTE - The program plays at a specific wall clock time. This setting can only be used for channels using the LINEAR PlaybackMode. Note the following considerations when using ABSOLUTE transitions: If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary. If there are gaps in playback, MediaTailor plays the FillerSlate you configured for your linear channel. RELATIVE - The program is inserted into the schedule either before or after a program that you specify via RelativePosition.
        /// This member is required.
        public var type: Swift.String?

        public init (
            relativePosition: MediaTailorClientTypes.RelativePosition? = nil,
            relativeProgram: Swift.String? = nil,
            scheduledStartTimeMillis: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.relativePosition = relativePosition
            self.relativeProgram = relativeProgram
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
            self.type = type
        }
    }

}

extension MediaTailorClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dash
        case hls
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .dash,
                .hls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dash: return "DASH"
            case .hls: return "HLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the playback configuration. You can get this from the response to any playback configuration request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A comma-separated list of the tag keys to remove from the playback configuration.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelName: \(Swift.String(describing: channelName)), outputs: \(Swift.String(describing: outputs)))"}
}

extension UpdateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "Outputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for requestoutputs0 in outputs {
                try outputsContainer.encode(requestoutputs0)
            }
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelName = input.channelName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channel/\(channelName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The identifier for the channel you are working on.
    /// This member is required.
    public var channelName: Swift.String?
    /// The channel's output properties.
    /// This member is required.
    public var outputs: [MediaTailorClientTypes.RequestOutputItem]?

    public init (
        channelName: Swift.String? = nil,
        outputs: [MediaTailorClientTypes.RequestOutputItem]? = nil
    )
    {
        self.channelName = channelName
        self.outputs = outputs
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    public let outputs: [MediaTailorClientTypes.RequestOutputItem]?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "Outputs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.RequestOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.RequestOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.RequestOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelOutputResponse(arn: \(Swift.String(describing: arn)), channelName: \(Swift.String(describing: channelName)), channelState: \(Swift.String(describing: channelState)), creationTime: \(Swift.String(describing: creationTime)), fillerSlate: \(Swift.String(describing: fillerSlate)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputs: \(Swift.String(describing: outputs)), playbackMode: \(Swift.String(describing: playbackMode)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.fillerSlate = output.fillerSlate
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.fillerSlate = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var arn: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?
    /// Indicates whether the channel is in a running state or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: ClientRuntime.Date?
    /// Contains information about the slate used to fill gaps between programs in the schedule.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp of when the channel was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The channel's output properties.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The channel's playback mode.
    public var playbackMode: Swift.String?
    /// The tags assigned to the channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let channelName: Swift.String?
    public let channelState: MediaTailorClientTypes.ChannelState?
    public let creationTime: ClientRuntime.Date?
    public let fillerSlate: MediaTailorClientTypes.SlateSource?
    public let lastModifiedTime: ClientRuntime.Date?
    public let outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    public let playbackMode: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateSourceLocationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSourceLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSourceLocationOutputError>
}

extension UpdateSourceLocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSourceLocationInput(accessConfiguration: \(Swift.String(describing: accessConfiguration)), defaultSegmentDeliveryConfiguration: \(Swift.String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(Swift.String(describing: httpConfiguration)), sourceLocationName: \(Swift.String(describing: sourceLocationName)))"}
}

extension UpdateSourceLocationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
    }
}

public struct UpdateSourceLocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSourceLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSourceLocationOutputError>
}

public struct UpdateSourceLocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSourceLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSourceLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSourceLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSourceLocationOutputError>
}

public struct UpdateSourceLocationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSourceLocationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSourceLocationOutputError>
}

public struct UpdateSourceLocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSourceLocationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSourceLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSourceLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSourceLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSourceLocationOutputError>
}

public struct UpdateSourceLocationInput: Swift.Equatable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The optional configuration for the host server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP configuration for the source location.
    /// This member is required.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.sourceLocationName = sourceLocationName
    }
}

struct UpdateSourceLocationInputBody: Swift.Equatable {
    public let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    public let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
}

extension UpdateSourceLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
    }
}

extension UpdateSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSourceLocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSourceLocationOutputResponse(accessConfiguration: \(Swift.String(describing: accessConfiguration)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultSegmentDeliveryConfiguration: \(Swift.String(describing: defaultSegmentDeliveryConfiguration)), httpConfiguration: \(Swift.String(describing: httpConfiguration)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct UpdateSourceLocationOutputResponse: Swift.Equatable {
    /// The access configuration for the source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The ARN of the source location.
    public var arn: Swift.String?
    /// The timestamp that indicates when the source location was created.
    public var creationTime: ClientRuntime.Date?
    /// The default segment delivery configuration settings.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP package configuration settings for the source location.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The timestamp that indicates when the source location was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the source location.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct UpdateSourceLocationOutputResponseBody: Swift.Equatable {
    public let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    public let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    public let lastModifiedTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension UpdateSourceLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateVodSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVodSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVodSourceOutputError>
}

extension UpdateVodSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVodSourceInput(httpPackageConfigurations: \(Swift.String(describing: httpPackageConfigurations)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension UpdateVodSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfigurations0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfigurations0)
            }
        }
    }
}

public struct UpdateVodSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVodSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVodSourceOutputError>
}

public struct UpdateVodSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVodSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVodSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVodSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVodSourceOutputError>
}

public struct UpdateVodSourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVodSourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVodSourceOutputError>
}

public struct UpdateVodSourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVodSourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateVodSourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sourceLocationName = input.sourceLocationName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sourceLocationName is nil and needs a value for the path of this operation"))))
        }
        guard let vodSourceName = input.vodSourceName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("vodSourceName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVodSourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVodSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVodSourceOutputError>
}

public struct UpdateVodSourceInput: Swift.Equatable {
    /// An array of HTTP package configurations for the VOD source on this account.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The identifier for the source location you are working on.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The identifier for the VOD source you are working on.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct UpdateVodSourceInputBody: Swift.Equatable {
    public let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
}

extension UpdateVodSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
    }
}

extension UpdateVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVodSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVodSourceOutputResponse(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), httpPackageConfigurations: \(Swift.String(describing: httpPackageConfigurations)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension UpdateVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct UpdateVodSourceOutputResponse: Swift.Equatable {
    /// The ARN of the VOD source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the VOD source was created.
    public var creationTime: ClientRuntime.Date?
    /// The HTTP package configurations.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The ARN for the VOD source.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location associated with the VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the VOD source.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the VOD source.
    public var vodSourceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct UpdateVodSourceOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    public let lastModifiedTime: ClientRuntime.Date?
    public let sourceLocationName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let vodSourceName: Swift.String?
}

extension UpdateVodSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.VodSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfigurations0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfigurations0)
            }
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let sourceLocationName = sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vodSourceName = vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.VodSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VodSource(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), httpPackageConfigurations: \(Swift.String(describing: httpPackageConfigurations)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), sourceLocationName: \(Swift.String(describing: sourceLocationName)), tags: \(Swift.String(describing: tags)), vodSourceName: \(Swift.String(describing: vodSourceName)))"}
}

extension MediaTailorClientTypes {
    /// VOD source configuration parameters.
    public struct VodSource: Swift.Equatable {
        /// The ARN for the VOD source.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the VOD source was created.
        public var creationTime: ClientRuntime.Date?
        /// The HTTP package configurations for the VOD source.
        /// This member is required.
        public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
        /// The timestamp that indicates when the VOD source was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the source location that the VOD source is associated with.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the VOD source.
        public var tags: [Swift.String:Swift.String]?
        /// The name of the VOD source.
        /// This member is required.
        public var vodSourceName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }
    }

}
