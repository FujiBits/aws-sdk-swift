// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes.Answer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceAnswers = "ChoiceAnswers"
        case choices = "Choices"
        case helpfulResourceDisplayText = "HelpfulResourceDisplayText"
        case helpfulResourceUrl = "HelpfulResourceUrl"
        case improvementPlanUrl = "ImprovementPlanUrl"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case pillarId = "PillarId"
        case questionDescription = "QuestionDescription"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case reason = "Reason"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceAnswers = choiceAnswers {
            var choiceAnswersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswers)
            for choiceanswers0 in choiceAnswers {
                try choiceAnswersContainer.encode(choiceanswers0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choices0 in choices {
                try choicesContainer.encode(choices0)
            }
        }
        if let helpfulResourceDisplayText = helpfulResourceDisplayText {
            try encodeContainer.encode(helpfulResourceDisplayText, forKey: .helpfulResourceDisplayText)
        }
        if let helpfulResourceUrl = helpfulResourceUrl {
            try encodeContainer.encode(helpfulResourceUrl, forKey: .helpfulResourceUrl)
        }
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionDescription = questionDescription {
            try encodeContainer.encode(questionDescription, forKey: .questionDescription)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let questionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionDescription)
        questionDescription = questionDescriptionDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let helpfulResourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceUrl)
        helpfulResourceUrl = helpfulResourceUrlDecoded
        let helpfulResourceDisplayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceDisplayText)
        helpfulResourceDisplayText = helpfulResourceDisplayTextDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswersContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswer?].self, forKey: .choiceAnswers)
        var choiceAnswersDecoded0:[WellArchitectedClientTypes.ChoiceAnswer]? = nil
        if let choiceAnswersContainer = choiceAnswersContainer {
            choiceAnswersDecoded0 = [WellArchitectedClientTypes.ChoiceAnswer]()
            for structure0 in choiceAnswersContainer {
                if let structure0 = structure0 {
                    choiceAnswersDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswers = choiceAnswersDecoded0
        let isApplicableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes.Answer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Answer(choiceAnswers: \(Swift.String(describing: choiceAnswers)), choices: \(Swift.String(describing: choices)), helpfulResourceDisplayText: \(Swift.String(describing: helpfulResourceDisplayText)), helpfulResourceUrl: \(Swift.String(describing: helpfulResourceUrl)), improvementPlanUrl: \(Swift.String(describing: improvementPlanUrl)), isApplicable: \(Swift.String(describing: isApplicable)), notes: \(Swift.String(describing: notes)), pillarId: \(Swift.String(describing: pillarId)), questionDescription: \(Swift.String(describing: questionDescription)), questionId: \(Swift.String(describing: questionId)), questionTitle: \(Swift.String(describing: questionTitle)), reason: \(Swift.String(describing: reason)), risk: \(Swift.String(describing: risk)), selectedChoices: \(Swift.String(describing: selectedChoices)))"}
}

extension WellArchitectedClientTypes {
    /// An answer of the question.
    public struct Answer: Swift.Equatable {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// The helpful resource text to be displayed.
        public var helpfulResourceDisplayText: Swift.String?
        /// The helpful resource URL for a question.
        public var helpfulResourceUrl: Swift.String?
        /// The improvement plan URL for a question. This value is only available if the question has been answered.
        public var improvementPlanUrl: Swift.String?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why the question is not applicable to your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init (
            choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            helpfulResourceDisplayText: Swift.String? = nil,
            helpfulResourceUrl: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil,
            isApplicable: Swift.Bool = false,
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswers = choiceAnswers
            self.choices = choices
            self.helpfulResourceDisplayText = helpfulResourceDisplayText
            self.helpfulResourceUrl = helpfulResourceUrl
            self.improvementPlanUrl = improvementPlanUrl
            self.isApplicable = isApplicable
            self.notes = notes
            self.pillarId = pillarId
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }

}

extension WellArchitectedClientTypes {
    public enum AnswerReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [AnswerReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnswerReason(rawValue: rawValue) ?? AnswerReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.AnswerSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceAnswerSummaries = "ChoiceAnswerSummaries"
        case choices = "Choices"
        case isApplicable = "IsApplicable"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case reason = "Reason"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceAnswerSummaries = choiceAnswerSummaries {
            var choiceAnswerSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswerSummaries)
            for choiceanswersummaries0 in choiceAnswerSummaries {
                try choiceAnswerSummariesContainer.encode(choiceanswersummaries0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choices0 in choices {
                try choicesContainer.encode(choices0)
            }
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswerSummary?].self, forKey: .choiceAnswerSummaries)
        var choiceAnswerSummariesDecoded0:[WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil
        if let choiceAnswerSummariesContainer = choiceAnswerSummariesContainer {
            choiceAnswerSummariesDecoded0 = [WellArchitectedClientTypes.ChoiceAnswerSummary]()
            for structure0 in choiceAnswerSummariesContainer {
                if let structure0 = structure0 {
                    choiceAnswerSummariesDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswerSummaries = choiceAnswerSummariesDecoded0
        let isApplicableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes.AnswerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnswerSummary(choiceAnswerSummaries: \(Swift.String(describing: choiceAnswerSummaries)), choices: \(Swift.String(describing: choices)), isApplicable: \(Swift.String(describing: isApplicable)), pillarId: \(Swift.String(describing: pillarId)), questionId: \(Swift.String(describing: questionId)), questionTitle: \(Swift.String(describing: questionTitle)), reason: \(Swift.String(describing: reason)), risk: \(Swift.String(describing: risk)), selectedChoices: \(Swift.String(describing: selectedChoices)))"}
}

extension WellArchitectedClientTypes {
    /// An answer summary of a lens review in a workload.
    public struct AnswerSummary: Swift.Equatable {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init (
            choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            isApplicable: Swift.Bool = false,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswerSummaries = choiceAnswerSummaries
            self.choices = choices
            self.isApplicable = isApplicable
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }

}

public struct AssociateLensesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLensesOutputError>
}

extension AssociateLensesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateLensesInput(lensAliases: \(Swift.String(describing: lensAliases)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension AssociateLensesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensaliases0 in lensAliases {
                try lensAliasesContainer.encode(lensaliases0)
            }
        }
    }
}

public struct AssociateLensesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLensesOutputError>
}

public struct AssociateLensesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLensesOutputError>
}

public struct AssociateLensesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLensesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateLensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateLensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLensesOutputError>
}

public struct AssociateLensesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateLensesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateLensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/associateLenses"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateLensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateLensesOutputError>
}

/// Input to associate lens reviews.
public struct AssociateLensesInput: Swift.Equatable {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct AssociateLensesInputBody: Swift.Equatable {
    public let lensAliases: [Swift.String]?
}

extension AssociateLensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[Swift.String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [Swift.String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension AssociateLensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLensesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateLensesOutputResponse()"}
}

extension AssociateLensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateLensesOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateLensesOutputResponseBody: Swift.Equatable {
}

extension AssociateLensesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WellArchitectedClientTypes.Choice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case description = "Description"
        case helpfulResource = "HelpfulResource"
        case improvementPlan = "ImprovementPlan"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let helpfulResource = helpfulResource {
            try encodeContainer.encode(helpfulResource, forKey: .helpfulResource)
        }
        if let improvementPlan = improvementPlan {
            try encodeContainer.encode(improvementPlan, forKey: .improvementPlan)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let helpfulResourceDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceContent.self, forKey: .helpfulResource)
        helpfulResource = helpfulResourceDecoded
        let improvementPlanDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceContent.self, forKey: .improvementPlan)
        improvementPlan = improvementPlanDecoded
    }
}

extension WellArchitectedClientTypes.Choice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Choice(choiceId: \(Swift.String(describing: choiceId)), description: \(Swift.String(describing: description)), helpfulResource: \(Swift.String(describing: helpfulResource)), improvementPlan: \(Swift.String(describing: improvementPlan)), title: \(Swift.String(describing: title)))"}
}

extension WellArchitectedClientTypes {
    /// A choice available to answer question.
    public struct Choice: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The description of a choice.
        public var description: Swift.String?
        /// The choice level helpful resource.
        public var helpfulResource: WellArchitectedClientTypes.ChoiceContent?
        /// The choice level improvement plan.
        public var improvementPlan: WellArchitectedClientTypes.ChoiceContent?
        /// The title of a choice.
        public var title: Swift.String?

        public init (
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            helpfulResource: WellArchitectedClientTypes.ChoiceContent? = nil,
            improvementPlan: WellArchitectedClientTypes.ChoiceContent? = nil,
            title: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.description = description
            self.helpfulResource = helpfulResource
            self.improvementPlan = improvementPlan
            self.title = title
        }
    }

}

extension WellArchitectedClientTypes.ChoiceAnswer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case notes = "Notes"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension WellArchitectedClientTypes.ChoiceAnswer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChoiceAnswer(choiceId: \(Swift.String(describing: choiceId)), notes: \(Swift.String(describing: notes)), reason: \(Swift.String(describing: reason)), status: \(Swift.String(describing: status)))"}
}

extension WellArchitectedClientTypes {
    /// A choice that has been answered on a question in your workload.
    public struct ChoiceAnswer: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init (
            choiceId: Swift.String? = nil,
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.ChoiceAnswerSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes.ChoiceAnswerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChoiceAnswerSummary(choiceId: \(Swift.String(describing: choiceId)), reason: \(Swift.String(describing: reason)), status: \(Swift.String(describing: status)))"}
}

extension WellArchitectedClientTypes {
    /// A choice summary that has been answered on a question in your workload.
    public struct ChoiceAnswerSummary: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init (
            choiceId: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.reason = reason
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.ChoiceContent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayText = "DisplayText"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayText = displayText {
            try encodeContainer.encode(displayText, forKey: .displayText)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayText)
        displayText = displayTextDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension WellArchitectedClientTypes.ChoiceContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChoiceContent(displayText: \(Swift.String(describing: displayText)), url: \(Swift.String(describing: url)))"}
}

extension WellArchitectedClientTypes {
    /// The choice content.
    public struct ChoiceContent: Swift.Equatable {
        /// The display text for the choice content.
        public var displayText: Swift.String?
        /// The URL for the choice content.
        public var url: Swift.String?

        public init (
            displayText: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.displayText = displayText
            self.url = url
        }
    }

}

extension WellArchitectedClientTypes.ChoiceImprovementPlan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case displayText = "DisplayText"
        case improvementPlanUrl = "ImprovementPlanUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let displayText = displayText {
            try encodeContainer.encode(displayText, forKey: .displayText)
        }
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let displayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayText)
        displayText = displayTextDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
    }
}

extension WellArchitectedClientTypes.ChoiceImprovementPlan: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChoiceImprovementPlan(choiceId: \(Swift.String(describing: choiceId)), displayText: \(Swift.String(describing: displayText)), improvementPlanUrl: \(Swift.String(describing: improvementPlanUrl)))"}
}

extension WellArchitectedClientTypes {
    /// The choice level improvement plan.
    public struct ChoiceImprovementPlan: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The display text for the improvement plan.
        public var displayText: Swift.String?
        /// The improvement plan URL for a question. This value is only available if the question has been answered.
        public var improvementPlanUrl: Swift.String?

        public init (
            choiceId: Swift.String? = nil,
            displayText: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.displayText = displayText
            self.improvementPlanUrl = improvementPlanUrl
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ChoiceReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChoiceReason(rawValue: rawValue) ?? ChoiceReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum ChoiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notApplicable
        case selected
        case unselected
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceStatus] {
            return [
                .notApplicable,
                .selected,
                .unselected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notApplicable: return "NOT_APPLICABLE"
            case .selected: return "SELECTED"
            case .unselected: return "UNSELECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChoiceStatus(rawValue: rawValue) ?? ChoiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ChoiceUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notes = "Notes"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension WellArchitectedClientTypes.ChoiceUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChoiceUpdate(notes: \(Swift.String(describing: notes)), reason: \(Swift.String(describing: reason)), status: \(Swift.String(describing: status)))"}
}

extension WellArchitectedClientTypes {
    /// A list of choices to be updated.
    public struct ChoiceUpdate: Swift.Equatable {
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        /// This member is required.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init (
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateLensShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLensShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLensShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensShareOutputError>
}

extension CreateLensShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLensShareInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), lensAlias: \(Swift.String(describing: lensAlias)), sharedWith: \(Swift.String(describing: sharedWith)))"}
}

extension CreateLensShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

public struct CreateLensShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLensShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLensShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensShareOutputError>
}

public struct CreateLensShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLensShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLensShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensShareOutputError>
}

public struct CreateLensShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLensShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLensShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensShareOutputError>
}

public struct CreateLensShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLensShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())/shares"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLensShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensShareOutputError>
}

public struct CreateLensShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The Amazon Web Services account ID or IAM role with which the workload is shared.
    /// This member is required.
    public var sharedWith: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        sharedWith: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.sharedWith = sharedWith
    }
}

struct CreateLensShareInputBody: Swift.Equatable {
    public let sharedWith: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension CreateLensShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateLensShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLensShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLensShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLensShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLensShareOutputResponse(shareId: \(Swift.String(describing: shareId)))"}
}

extension CreateLensShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLensShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
        } else {
            self.shareId = nil
        }
    }
}

public struct CreateLensShareOutputResponse: Swift.Equatable {
    /// The ID associated with the workload share.
    public var shareId: Swift.String?

    public init (
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

struct CreateLensShareOutputResponseBody: Swift.Equatable {
    public let shareId: Swift.String?
}

extension CreateLensShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

public struct CreateLensVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLensVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLensVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensVersionOutputError>
}

extension CreateLensVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLensVersionInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), isMajorVersion: \(Swift.String(describing: isMajorVersion)), lensAlias: \(Swift.String(describing: lensAlias)), lensVersion: \(Swift.String(describing: lensVersion)))"}
}

extension CreateLensVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case isMajorVersion = "IsMajorVersion"
        case lensVersion = "LensVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if isMajorVersion != false {
            try encodeContainer.encode(isMajorVersion, forKey: .isMajorVersion)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
    }
}

public struct CreateLensVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLensVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLensVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensVersionOutputError>
}

public struct CreateLensVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLensVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLensVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensVersionOutputError>
}

public struct CreateLensVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLensVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLensVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensVersionOutputError>
}

public struct CreateLensVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLensVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLensVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())/versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLensVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLensVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLensVersionOutputError>
}

public struct CreateLensVersionInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Set to true if this new major lens version.
    public var isMajorVersion: Swift.Bool
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The version of the lens being created.
    /// This member is required.
    public var lensVersion: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        isMajorVersion: Swift.Bool = false,
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.isMajorVersion = isMajorVersion
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct CreateLensVersionInputBody: Swift.Equatable {
    public let lensVersion: Swift.String?
    public let isMajorVersion: Swift.Bool
    public let clientRequestToken: Swift.String?
}

extension CreateLensVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case isMajorVersion = "IsMajorVersion"
        case lensVersion = "LensVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let isMajorVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isMajorVersion)
        isMajorVersion = isMajorVersionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateLensVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLensVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLensVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLensVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLensVersionOutputResponse(lensArn: \(Swift.String(describing: lensArn)), lensVersion: \(Swift.String(describing: lensVersion)))"}
}

extension CreateLensVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLensVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensArn = output.lensArn
            self.lensVersion = output.lensVersion
        } else {
            self.lensArn = nil
            self.lensVersion = nil
        }
    }
}

public struct CreateLensVersionOutputResponse: Swift.Equatable {
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The version of the lens.
    public var lensVersion: Swift.String?

    public init (
        lensArn: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensArn = lensArn
        self.lensVersion = lensVersion
    }
}

struct CreateLensVersionOutputResponseBody: Swift.Equatable {
    public let lensArn: Swift.String?
    public let lensVersion: Swift.String?
}

extension CreateLensVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case lensVersion = "LensVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
    }
}

public struct CreateMilestoneInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMilestoneInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMilestoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMilestoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMilestoneOutputError>
}

extension CreateMilestoneInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMilestoneInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), milestoneName: \(Swift.String(describing: milestoneName)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension CreateMilestoneInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

public struct CreateMilestoneInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMilestoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMilestoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMilestoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMilestoneOutputError>
}

public struct CreateMilestoneInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMilestoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMilestoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMilestoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMilestoneOutputError>
}

public struct CreateMilestoneInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMilestoneInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMilestoneInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMilestoneInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMilestoneOutputError>
}

public struct CreateMilestoneInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMilestoneInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMilestoneInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/milestones"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMilestoneInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMilestoneOutputError>
}

/// Input for milestone creation.
public struct CreateMilestoneInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct CreateMilestoneInputBody: Swift.Equatable {
    public let milestoneName: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension CreateMilestoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateMilestoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMilestoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMilestoneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMilestoneOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMilestoneOutputResponse(milestoneNumber: \(Swift.String(describing: milestoneNumber)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension CreateMilestoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMilestoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a create milestone call.
public struct CreateMilestoneOutputResponse: Swift.Equatable {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct CreateMilestoneOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneNumber: Swift.Int
}

extension CreateMilestoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
    }
}

public struct CreateWorkloadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadOutputError>
}

extension CreateWorkloadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkloadInput(accountIds: \(Swift.String(describing: accountIds)), architecturalDesign: \(Swift.String(describing: architecturalDesign)), awsRegions: \(Swift.String(describing: awsRegions)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), industry: \(Swift.String(describing: industry)), industryType: \(Swift.String(describing: industryType)), lenses: \(Swift.String(describing: lenses)), nonAwsRegions: \(Swift.String(describing: nonAwsRegions)), notes: \(Swift.String(describing: notes)), pillarPriorities: \(Swift.String(describing: pillarPriorities)), reviewOwner: \(Swift.String(describing: reviewOwner)), tags: \(Swift.String(describing: tags)), workloadName: \(Swift.String(describing: workloadName)))"}
}

extension CreateWorkloadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

public struct CreateWorkloadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadOutputError>
}

public struct CreateWorkloadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadOutputError>
}

public struct CreateWorkloadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadOutputError>
}

public struct CreateWorkloadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/workloads"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadOutputError>
}

/// Input for workload creation.
public struct CreateWorkloadInput: Swift.Equatable {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description for the workload.
    /// This member is required.
    public var description: Swift.String?
    /// The environment for the workload.
    /// This member is required.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lenses: [Swift.String]?
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    /// This member is required.
    public var reviewOwner: Swift.String?
    /// The tags to be associated with the workload.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    /// This member is required.
    public var workloadName: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        lenses: [Swift.String]? = nil,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.environment = environment
        self.industry = industry
        self.industryType = industryType
        self.lenses = lenses
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.tags = tags
        self.workloadName = workloadName
    }
}

struct CreateWorkloadInputBody: Swift.Equatable {
    public let workloadName: Swift.String?
    public let description: Swift.String?
    public let environment: WellArchitectedClientTypes.WorkloadEnvironment?
    public let accountIds: [Swift.String]?
    public let awsRegions: [Swift.String]?
    public let nonAwsRegions: [Swift.String]?
    public let pillarPriorities: [Swift.String]?
    public let architecturalDesign: Swift.String?
    public let reviewOwner: Swift.String?
    public let industryType: Swift.String?
    public let industry: Swift.String?
    public let lenses: [Swift.String]?
    public let notes: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkloadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkloadOutputResponse(workloadArn: \(Swift.String(describing: workloadArn)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension CreateWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workloadArn = output.workloadArn
            self.workloadId = output.workloadId
        } else {
            self.workloadArn = nil
            self.workloadId = nil
        }
    }
}

/// Output of a create workload call.
public struct CreateWorkloadOutputResponse: Swift.Equatable {
    /// The ARN for the workload.
    public var workloadArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        workloadArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
        self.workloadId = workloadId
    }
}

struct CreateWorkloadOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let workloadArn: Swift.String?
}

extension CreateWorkloadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
    }
}

public struct CreateWorkloadShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadShareOutputError>
}

extension CreateWorkloadShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkloadShareInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), permissionType: \(Swift.String(describing: permissionType)), sharedWith: \(Swift.String(describing: sharedWith)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension CreateWorkloadShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

public struct CreateWorkloadShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadShareOutputError>
}

public struct CreateWorkloadShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadShareOutputError>
}

public struct CreateWorkloadShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateWorkloadShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorkloadShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadShareOutputError>
}

public struct CreateWorkloadShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkloadShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateWorkloadShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/shares"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorkloadShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkloadShareOutputError>
}

/// Input for Create Workload Share
public struct CreateWorkloadShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Permission granted on a workload share.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The Amazon Web Services account ID or IAM role with which the workload is shared.
    /// This member is required.
    public var sharedWith: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        sharedWith: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.permissionType = permissionType
        self.sharedWith = sharedWith
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareInputBody: Swift.Equatable {
    public let sharedWith: Swift.String?
    public let permissionType: WellArchitectedClientTypes.PermissionType?
    public let clientRequestToken: Swift.String?
}

extension CreateWorkloadShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWorkloadShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkloadShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkloadShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkloadShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkloadShareOutputResponse(shareId: \(Swift.String(describing: shareId)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension CreateWorkloadShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkloadShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
            self.workloadId = output.workloadId
        } else {
            self.shareId = nil
            self.workloadId = nil
        }
    }
}

/// Input for Create Workload Share
public struct CreateWorkloadShareOutputResponse: Swift.Equatable {
    /// The ID associated with the workload share.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let shareId: Swift.String?
}

extension CreateWorkloadShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

extension DeleteLensInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLensInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), lensAlias: \(Swift.String(describing: lensAlias)), lensStatus: \(Swift.String(describing: lensStatus)))"}
}

extension DeleteLensInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLensInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensOutputError>
}

public struct DeleteLensInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientRequestToken = input.operationInput.clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            input.builder.withQueryItem(clientRequestTokenQueryItem)
        }
        if let lensStatus = input.operationInput.lensStatus {
            let lensStatusQueryItem = ClientRuntime.URLQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(lensStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensOutputError>
}

public struct DeleteLensInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensOutputError>
}

public struct DeleteLensInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensOutputError>
}

public struct DeleteLensInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The status of the lens to be deleted.
    /// This member is required.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.lensStatus = lensStatus
    }
}

struct DeleteLensInputBody: Swift.Equatable {
}

extension DeleteLensInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLensOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLensOutputResponse()"}
}

extension DeleteLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLensOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLensOutputResponseBody: Swift.Equatable {
}

extension DeleteLensOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLensShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLensShareInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), lensAlias: \(Swift.String(describing: lensAlias)), shareId: \(Swift.String(describing: shareId)))"}
}

extension DeleteLensShareInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLensShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLensShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLensShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensShareOutputError>
}

public struct DeleteLensShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLensShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientRequestToken = input.operationInput.clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            input.builder.withQueryItem(clientRequestTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLensShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensShareOutputError>
}

public struct DeleteLensShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLensShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLensShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensShareOutputError>
}

public struct DeleteLensShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLensShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLensShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        guard let shareId = input.shareId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("shareId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLensShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLensShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLensShareOutputError>
}

public struct DeleteLensShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ID associated with the workload share.
    /// This member is required.
    public var shareId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.shareId = shareId
    }
}

struct DeleteLensShareInputBody: Swift.Equatable {
}

extension DeleteLensShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLensShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLensShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLensShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLensShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLensShareOutputResponse()"}
}

extension DeleteLensShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLensShareOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLensShareOutputResponseBody: Swift.Equatable {
}

extension DeleteLensShareOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkloadInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension DeleteWorkloadInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteWorkloadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadOutputError>
}

public struct DeleteWorkloadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientRequestToken = input.operationInput.clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            input.builder.withQueryItem(clientRequestTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadOutputError>
}

public struct DeleteWorkloadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadOutputError>
}

public struct DeleteWorkloadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadOutputError>
}

/// Input for workload deletion.
public struct DeleteWorkloadInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadInputBody: Swift.Equatable {
}

extension DeleteWorkloadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkloadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkloadOutputResponse()"}
}

extension DeleteWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkloadOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWorkloadOutputResponseBody: Swift.Equatable {
}

extension DeleteWorkloadOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkloadShareInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), shareId: \(Swift.String(describing: shareId)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension DeleteWorkloadShareInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteWorkloadShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadShareOutputError>
}

public struct DeleteWorkloadShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientRequestToken = input.operationInput.clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            input.builder.withQueryItem(clientRequestTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadShareOutputError>
}

public struct DeleteWorkloadShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteWorkloadShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWorkloadShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadShareOutputError>
}

public struct DeleteWorkloadShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkloadShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteWorkloadShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let shareId = input.shareId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("shareId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWorkloadShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkloadShareOutputError>
}

/// Input for Delete Workload Share
public struct DeleteWorkloadShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID associated with the workload share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadShareInputBody: Swift.Equatable {
}

extension DeleteWorkloadShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkloadShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkloadShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkloadShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkloadShareOutputResponse()"}
}

extension DeleteWorkloadShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkloadShareOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWorkloadShareOutputResponseBody: Swift.Equatable {
}

extension DeleteWorkloadShareOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WellArchitectedClientTypes {
    public enum DifferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case new
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [DifferenceStatus] {
            return [
                .deleted,
                .new,
                .updated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .new: return "NEW"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DifferenceStatus(rawValue: rawValue) ?? DifferenceStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DisassociateLensesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLensesOutputError>
}

extension DisassociateLensesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateLensesInput(lensAliases: \(Swift.String(describing: lensAliases)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension DisassociateLensesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensaliases0 in lensAliases {
                try lensAliasesContainer.encode(lensaliases0)
            }
        }
    }
}

public struct DisassociateLensesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLensesOutputError>
}

public struct DisassociateLensesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLensesOutputError>
}

public struct DisassociateLensesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLensesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateLensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateLensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLensesOutputError>
}

public struct DisassociateLensesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateLensesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateLensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/disassociateLenses"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateLensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateLensesOutputError>
}

/// Input to disassociate lens reviews.
public struct DisassociateLensesInput: Swift.Equatable {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct DisassociateLensesInputBody: Swift.Equatable {
    public let lensAliases: [Swift.String]?
}

extension DisassociateLensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[Swift.String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [Swift.String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension DisassociateLensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLensesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateLensesOutputResponse()"}
}

extension DisassociateLensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateLensesOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateLensesOutputResponseBody: Swift.Equatable {
}

extension DisassociateLensesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportLensInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportLensInput(lensAlias: \(Swift.String(describing: lensAlias)), lensVersion: \(Swift.String(describing: lensVersion)))"}
}

extension ExportLensInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ExportLensInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportLensInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportLensOutputError>
}

public struct ExportLensInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportLensInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let lensVersion = input.operationInput.lensVersion {
            let lensVersionQueryItem = ClientRuntime.URLQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            input.builder.withQueryItem(lensVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportLensOutputError>
}

public struct ExportLensInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportLensInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ExportLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExportLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportLensOutputError>
}

public struct ExportLensInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportLensInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ExportLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())/export"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExportLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportLensOutputError>
}

public struct ExportLensInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be exported.
    public var lensVersion: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct ExportLensInputBody: Swift.Equatable {
}

extension ExportLensInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportLensOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportLensOutputResponse(lensJSON: \(Swift.String(describing: lensJSON)))"}
}

extension ExportLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportLensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensJSON = output.lensJSON
        } else {
            self.lensJSON = nil
        }
    }
}

public struct ExportLensOutputResponse: Swift.Equatable {
    /// The JSON for the lens.
    public var lensJSON: Swift.String?

    public init (
        lensJSON: Swift.String? = nil
    )
    {
        self.lensJSON = lensJSON
    }
}

struct ExportLensOutputResponseBody: Swift.Equatable {
    public let lensJSON: Swift.String?
}

extension ExportLensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensJSON = "LensJSON"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensJSON)
        lensJSON = lensJSONDecoded
    }
}

extension GetAnswerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAnswerInput(lensAlias: \(Swift.String(describing: lensAlias)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), questionId: \(Swift.String(describing: questionId)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetAnswerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAnswerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnswerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAnswerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAnswerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnswerOutputError>
}

public struct GetAnswerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnswerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAnswerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(input.operationInput.milestoneNumber).urlPercentEncoding())
            input.builder.withQueryItem(milestoneNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAnswerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnswerOutputError>
}

public struct GetAnswerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnswerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAnswerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAnswerInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnswerOutputError>
}

public struct GetAnswerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAnswerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAnswerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        guard let questionId = input.questionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("questionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAnswerInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAnswerOutputError>
}

/// Input to get answer.
public struct GetAnswerInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

struct GetAnswerInputBody: Swift.Equatable {
}

extension GetAnswerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnswerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnswerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnswerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnswerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAnswerOutputResponse(answer: \(Swift.String(describing: answer)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetAnswerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnswerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a get answer call.
public struct GetAnswerOutputResponse: Swift.Equatable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetAnswerOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneNumber: Swift.Int
    public let lensAlias: Swift.String?
    public let lensArn: Swift.String?
    public let answer: WellArchitectedClientTypes.Answer?
}

extension GetAnswerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

extension GetLensInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensInput(lensAlias: \(Swift.String(describing: lensAlias)), lensVersion: \(Swift.String(describing: lensVersion)))"}
}

extension GetLensInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLensInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensOutputError>
}

public struct GetLensInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let lensVersion = input.operationInput.lensVersion {
            let lensVersionQueryItem = ClientRuntime.URLQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            input.builder.withQueryItem(lensVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensOutputError>
}

public struct GetLensInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensOutputError>
}

public struct GetLensInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensOutputError>
}

public struct GetLensInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be retrieved.
    public var lensVersion: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct GetLensInputBody: Swift.Equatable {
}

extension GetLensInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensOutputResponse(lens: \(Swift.String(describing: lens)))"}
}

extension GetLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lens = output.lens
        } else {
            self.lens = nil
        }
    }
}

public struct GetLensOutputResponse: Swift.Equatable {
    /// A lens return object.
    public var lens: WellArchitectedClientTypes.Lens?

    public init (
        lens: WellArchitectedClientTypes.Lens? = nil
    )
    {
        self.lens = lens
    }
}

struct GetLensOutputResponseBody: Swift.Equatable {
    public let lens: WellArchitectedClientTypes.Lens?
}

extension GetLensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lens = "Lens"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Lens.self, forKey: .lens)
        lens = lensDecoded
    }
}

extension GetLensReviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensReviewInput(lensAlias: \(Swift.String(describing: lensAlias)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetLensReviewInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLensReviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewOutputError>
}

public struct GetLensReviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(input.operationInput.milestoneNumber).urlPercentEncoding())
            input.builder.withQueryItem(milestoneNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewOutputError>
}

public struct GetLensReviewInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLensReviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensReviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewOutputError>
}

public struct GetLensReviewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLensReviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensReviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewOutputError>
}

/// Input to get lens review.
public struct GetLensReviewInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewInputBody: Swift.Equatable {
}

extension GetLensReviewInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensReviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensReviewOutputResponse(lensReview: \(Swift.String(describing: lensReview)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetLensReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a get lens review call.
public struct GetLensReviewOutputResponse: Swift.Equatable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneNumber: Swift.Int
    public let lensReview: WellArchitectedClientTypes.LensReview?
}

extension GetLensReviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

extension GetLensReviewReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensReviewReportInput(lensAlias: \(Swift.String(describing: lensAlias)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetLensReviewReportInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLensReviewReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensReviewReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensReviewReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewReportOutputError>
}

public struct GetLensReviewReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensReviewReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(input.operationInput.milestoneNumber).urlPercentEncoding())
            input.builder.withQueryItem(milestoneNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensReviewReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewReportOutputError>
}

public struct GetLensReviewReportInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewReportInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLensReviewReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensReviewReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewReportOutputError>
}

public struct GetLensReviewReportInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensReviewReportInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLensReviewReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/report"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensReviewReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensReviewReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensReviewReportOutputError>
}

/// Input to get lens review report.
public struct GetLensReviewReportInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportInputBody: Swift.Equatable {
}

extension GetLensReviewReportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensReviewReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensReviewReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensReviewReportOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensReviewReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensReviewReportOutputResponse(lensReviewReport: \(Swift.String(describing: lensReviewReport)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetLensReviewReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensReviewReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReviewReport = output.lensReviewReport
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReviewReport = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a get lens review report call.
public struct GetLensReviewReportOutputResponse: Swift.Equatable {
    /// A report of a lens review.
    public var lensReviewReport: WellArchitectedClientTypes.LensReviewReport?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReviewReport: WellArchitectedClientTypes.LensReviewReport? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewReport = lensReviewReport
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneNumber: Swift.Int
    public let lensReviewReport: WellArchitectedClientTypes.LensReviewReport?
}

extension GetLensReviewReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReviewReport = "LensReviewReport"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewReportDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReviewReport.self, forKey: .lensReviewReport)
        lensReviewReport = lensReviewReportDecoded
    }
}

extension GetLensVersionDifferenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensVersionDifferenceInput(baseLensVersion: \(Swift.String(describing: baseLensVersion)), lensAlias: \(Swift.String(describing: lensAlias)), targetLensVersion: \(Swift.String(describing: targetLensVersion)))"}
}

extension GetLensVersionDifferenceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLensVersionDifferenceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensVersionDifferenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensVersionDifferenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensVersionDifferenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensVersionDifferenceOutputError>
}

public struct GetLensVersionDifferenceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensVersionDifferenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLensVersionDifferenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let baseLensVersion = input.operationInput.baseLensVersion {
            let baseLensVersionQueryItem = ClientRuntime.URLQueryItem(name: "BaseLensVersion".urlPercentEncoding(), value: Swift.String(baseLensVersion).urlPercentEncoding())
            input.builder.withQueryItem(baseLensVersionQueryItem)
        }
        if let targetLensVersion = input.operationInput.targetLensVersion {
            let targetLensVersionQueryItem = ClientRuntime.URLQueryItem(name: "TargetLensVersion".urlPercentEncoding(), value: Swift.String(targetLensVersion).urlPercentEncoding())
            input.builder.withQueryItem(targetLensVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLensVersionDifferenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensVersionDifferenceOutputError>
}

public struct GetLensVersionDifferenceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensVersionDifferenceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLensVersionDifferenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensVersionDifferenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensVersionDifferenceOutputError>
}

public struct GetLensVersionDifferenceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLensVersionDifferenceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLensVersionDifferenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())/versionDifference"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLensVersionDifferenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLensVersionDifferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLensVersionDifferenceOutputError>
}

public struct GetLensVersionDifferenceInput: Swift.Equatable {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to target a difference for.
    public var targetLensVersion: Swift.String?

    public init (
        baseLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.lensAlias = lensAlias
        self.targetLensVersion = targetLensVersion
    }
}

struct GetLensVersionDifferenceInputBody: Swift.Equatable {
}

extension GetLensVersionDifferenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensVersionDifferenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensVersionDifferenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensVersionDifferenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensVersionDifferenceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLensVersionDifferenceOutputResponse(baseLensVersion: \(Swift.String(describing: baseLensVersion)), latestLensVersion: \(Swift.String(describing: latestLensVersion)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), targetLensVersion: \(Swift.String(describing: targetLensVersion)), versionDifferences: \(Swift.String(describing: versionDifferences)))"}
}

extension GetLensVersionDifferenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensVersionDifferenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseLensVersion = output.baseLensVersion
            self.latestLensVersion = output.latestLensVersion
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.targetLensVersion = output.targetLensVersion
            self.versionDifferences = output.versionDifferences
        } else {
            self.baseLensVersion = nil
            self.latestLensVersion = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.targetLensVersion = nil
            self.versionDifferences = nil
        }
    }
}

public struct GetLensVersionDifferenceOutputResponse: Swift.Equatable {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The latest version of the lens.
    public var latestLensVersion: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The target lens version for the lens.
    public var targetLensVersion: Swift.String?
    /// The differences between the base and latest versions of the lens.
    public var versionDifferences: WellArchitectedClientTypes.VersionDifferences?

    public init (
        baseLensVersion: Swift.String? = nil,
        latestLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil,
        versionDifferences: WellArchitectedClientTypes.VersionDifferences? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.latestLensVersion = latestLensVersion
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.targetLensVersion = targetLensVersion
        self.versionDifferences = versionDifferences
    }
}

struct GetLensVersionDifferenceOutputResponseBody: Swift.Equatable {
    public let lensAlias: Swift.String?
    public let lensArn: Swift.String?
    public let baseLensVersion: Swift.String?
    public let targetLensVersion: Swift.String?
    public let latestLensVersion: Swift.String?
    public let versionDifferences: WellArchitectedClientTypes.VersionDifferences?
}

extension GetLensVersionDifferenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseLensVersion = "BaseLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case targetLensVersion = "TargetLensVersion"
        case versionDifferences = "VersionDifferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let baseLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseLensVersion)
        baseLensVersion = baseLensVersionDecoded
        let targetLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLensVersion)
        targetLensVersion = targetLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
        let versionDifferencesDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.VersionDifferences.self, forKey: .versionDifferences)
        versionDifferences = versionDifferencesDecoded
    }
}

extension GetMilestoneInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMilestoneInput(milestoneNumber: \(Swift.String(describing: milestoneNumber)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetMilestoneInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMilestoneInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMilestoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMilestoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMilestoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMilestoneOutputError>
}

public struct GetMilestoneInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMilestoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMilestoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMilestoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMilestoneOutputError>
}

public struct GetMilestoneInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMilestoneInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMilestoneInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMilestoneInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMilestoneOutputError>
}

public struct GetMilestoneInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMilestoneInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMilestoneInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMilestoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        let milestoneNumber = input.milestoneNumber
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/milestones/\(milestoneNumber)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMilestoneInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMilestoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMilestoneOutputError>
}

/// Input to get a milestone.
public struct GetMilestoneInput: Swift.Equatable {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    /// This member is required.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetMilestoneInputBody: Swift.Equatable {
}

extension GetMilestoneInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMilestoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMilestoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMilestoneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMilestoneOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMilestoneOutputResponse(milestone: \(Swift.String(describing: milestone)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetMilestoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMilestoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.milestone = output.milestone
            self.workloadId = output.workloadId
        } else {
            self.milestone = nil
            self.workloadId = nil
        }
    }
}

/// Output of a get milestone call.
public struct GetMilestoneOutputResponse: Swift.Equatable {
    /// A milestone return object.
    public var milestone: WellArchitectedClientTypes.Milestone?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        milestone: WellArchitectedClientTypes.Milestone? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestone = milestone
        self.workloadId = workloadId
    }
}

struct GetMilestoneOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestone: WellArchitectedClientTypes.Milestone?
}

extension GetMilestoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestone = "Milestone"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Milestone.self, forKey: .milestone)
        milestone = milestoneDecoded
    }
}

extension GetWorkloadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadInput(workloadId: \(Swift.String(describing: workloadId)))"}
}

extension GetWorkloadInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWorkloadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkloadOutputError>
}

public struct GetWorkloadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkloadOutputError>
}

public struct GetWorkloadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkloadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkloadOutputError>
}

public struct GetWorkloadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkloadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkloadOutputError>
}

/// Input to get a workload.
public struct GetWorkloadInput: Swift.Equatable {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        workloadId: Swift.String? = nil
    )
    {
        self.workloadId = workloadId
    }
}

struct GetWorkloadInputBody: Swift.Equatable {
}

extension GetWorkloadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkloadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkloadOutputResponse(workload: \(Swift.String(describing: workload)))"}
}

extension GetWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// Output of a get workload call.
public struct GetWorkloadOutputResponse: Swift.Equatable {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init (
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct GetWorkloadOutputResponseBody: Swift.Equatable {
    public let workload: WellArchitectedClientTypes.Workload?
}

extension GetWorkloadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workload = "Workload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

public struct ImportLensInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportLensInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportLensOutputError>
}

extension ImportLensInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportLensInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), jSONString: \(Swift.String(describing: jSONString)), lensAlias: \(Swift.String(describing: lensAlias)), tags: \(Swift.String(describing: tags)))"}
}

extension ImportLensInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case jSONString = "JSONString"
        case lensAlias = "LensAlias"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let jSONString = jSONString {
            try encodeContainer.encode(jSONString, forKey: .jSONString)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ImportLensInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportLensInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportLensOutputError>
}

public struct ImportLensInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportLensInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportLensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportLensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportLensOutputError>
}

public struct ImportLensInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportLensInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ImportLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportLensOutputError>
}

public struct ImportLensInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportLensInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ImportLensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportLensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/importLens"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportLensInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportLensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportLensOutputError>
}

public struct ImportLensInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The JSON representation of a lens.
    /// This member is required.
    public var jSONString: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// Tags to associate to a lens.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        jSONString: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.jSONString = jSONString
        self.lensAlias = lensAlias
        self.tags = tags
    }
}

struct ImportLensInputBody: Swift.Equatable {
    public let lensAlias: Swift.String?
    public let jSONString: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension ImportLensInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case jSONString = "JSONString"
        case lensAlias = "LensAlias"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let jSONStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jSONString)
        jSONString = jSONStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportLensOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportLensOutputResponse(lensArn: \(Swift.String(describing: lensArn)), status: \(Swift.String(describing: status)))"}
}

extension ImportLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportLensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensArn = output.lensArn
            self.status = output.status
        } else {
            self.lensArn = nil
            self.status = nil
        }
    }
}

public struct ImportLensOutputResponse: Swift.Equatable {
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The status of the imported lens.
    public var status: WellArchitectedClientTypes.ImportLensStatus?

    public init (
        lensArn: Swift.String? = nil,
        status: WellArchitectedClientTypes.ImportLensStatus? = nil
    )
    {
        self.lensArn = lensArn
        self.status = status
    }
}

struct ImportLensOutputResponseBody: Swift.Equatable {
    public let lensArn: Swift.String?
    public let status: WellArchitectedClientTypes.ImportLensStatus?
}

extension ImportLensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ImportLensStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WellArchitectedClientTypes {
    public enum ImportLensStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case error
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportLensStatus] {
            return [
                .complete,
                .error,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportLensStatus(rawValue: rawValue) ?? ImportLensStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ImprovementSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementPlanUrl = "ImprovementPlanUrl"
        case improvementPlans = "ImprovementPlans"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case risk = "Risk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if let improvementPlans = improvementPlans {
            var improvementPlansContainer = encodeContainer.nestedUnkeyedContainer(forKey: .improvementPlans)
            for choiceimprovementplans0 in improvementPlans {
                try improvementPlansContainer.encode(choiceimprovementplans0)
            }
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let improvementPlansContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceImprovementPlan?].self, forKey: .improvementPlans)
        var improvementPlansDecoded0:[WellArchitectedClientTypes.ChoiceImprovementPlan]? = nil
        if let improvementPlansContainer = improvementPlansContainer {
            improvementPlansDecoded0 = [WellArchitectedClientTypes.ChoiceImprovementPlan]()
            for structure0 in improvementPlansContainer {
                if let structure0 = structure0 {
                    improvementPlansDecoded0?.append(structure0)
                }
            }
        }
        improvementPlans = improvementPlansDecoded0
    }
}

extension WellArchitectedClientTypes.ImprovementSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImprovementSummary(improvementPlanUrl: \(Swift.String(describing: improvementPlanUrl)), improvementPlans: \(Swift.String(describing: improvementPlans)), pillarId: \(Swift.String(describing: pillarId)), questionId: \(Swift.String(describing: questionId)), questionTitle: \(Swift.String(describing: questionTitle)), risk: \(Swift.String(describing: risk)))"}
}

extension WellArchitectedClientTypes {
    /// An improvement summary of a lens review in a workload.
    public struct ImprovementSummary: Swift.Equatable {
        /// The improvement plan URL for a question. This value is only available if the question has been answered.
        public var improvementPlanUrl: Swift.String?
        /// The improvement plan details.
        public var improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?

        public init (
            improvementPlanUrl: Swift.String? = nil,
            improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil
        )
        {
            self.improvementPlanUrl = improvementPlanUrl
            self.improvementPlans = improvementPlans
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.risk = risk
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a problem with the Well-Architected Tool API service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes.Lens: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lensArn = "LensArn"
        case lensVersion = "LensVersion"
        case name = "Name"
        case owner = "Owner"
        case shareInvitationId = "ShareInvitationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
    }
}

extension WellArchitectedClientTypes.Lens: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Lens(description: \(Swift.String(describing: description)), lensArn: \(Swift.String(describing: lensArn)), lensVersion: \(Swift.String(describing: lensVersion)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), shareInvitationId: \(Swift.String(describing: shareInvitationId)))"}
}

extension WellArchitectedClientTypes {
    /// A lens return object.
    public struct Lens: Swift.Equatable {
        /// The description of the lens.
        public var description: Swift.String?
        /// The ARN of a lens.
        public var lensArn: Swift.String?
        /// The version of a lens.
        public var lensVersion: Swift.String?
        /// The full name of the lens.
        public var name: Swift.String?
        /// The Amazon Web Services account ID that owns the lens.
        public var owner: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?

        public init (
            description: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil
        )
        {
            self.description = description
            self.lensArn = lensArn
            self.lensVersion = lensVersion
            self.name = name
            self.owner = owner
            self.shareInvitationId = shareInvitationId
        }
    }

}

extension WellArchitectedClientTypes.LensReview: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case nextToken = "NextToken"
        case notes = "Notes"
        case pillarReviewSummaries = "PillarReviewSummaries"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarReviewSummaries = pillarReviewSummaries {
            var pillarReviewSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarReviewSummaries)
            for pillarreviewsummaries0 in pillarReviewSummaries {
                try pillarReviewSummariesContainer.encode(pillarreviewsummaries0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let pillarReviewSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.PillarReviewSummary?].self, forKey: .pillarReviewSummaries)
        var pillarReviewSummariesDecoded0:[WellArchitectedClientTypes.PillarReviewSummary]? = nil
        if let pillarReviewSummariesContainer = pillarReviewSummariesContainer {
            pillarReviewSummariesDecoded0 = [WellArchitectedClientTypes.PillarReviewSummary]()
            for structure0 in pillarReviewSummariesContainer {
                if let structure0 = structure0 {
                    pillarReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        pillarReviewSummaries = pillarReviewSummariesDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WellArchitectedClientTypes.LensReview: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LensReview(lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), lensName: \(Swift.String(describing: lensName)), lensStatus: \(Swift.String(describing: lensStatus)), lensVersion: \(Swift.String(describing: lensVersion)), nextToken: \(Swift.String(describing: nextToken)), notes: \(Swift.String(describing: notes)), pillarReviewSummaries: \(Swift.String(describing: pillarReviewSummaries)), riskCounts: \(Swift.String(describing: riskCounts)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension WellArchitectedClientTypes {
    /// A lens review of a question.
    public struct LensReview: Swift.Equatable {
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// The token to use to retrieve the next set of results.
        public var nextToken: Swift.String?
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// List of pillar review summaries of lens review in a workload.
        public var pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init (
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            nextToken: Swift.String? = nil,
            notes: Swift.String? = nil,
            pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.nextToken = nextToken
            self.notes = notes
            self.pillarReviewSummaries = pillarReviewSummaries
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.LensReviewReport: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base64String = "Base64String"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base64String = base64String {
            try encodeContainer.encode(base64String, forKey: .base64String)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let base64StringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .base64String)
        base64String = base64StringDecoded
    }
}

extension WellArchitectedClientTypes.LensReviewReport: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LensReviewReport(base64String: \(Swift.String(describing: base64String)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)))"}
}

extension WellArchitectedClientTypes {
    /// A report of a lens review.
    public struct LensReviewReport: Swift.Equatable {
        /// The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file.
        public var base64String: Swift.String?
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?

        public init (
            base64String: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil
        )
        {
            self.base64String = base64String
            self.lensAlias = lensAlias
            self.lensArn = lensArn
        }
    }

}

extension WellArchitectedClientTypes.LensReviewSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
    }
}

extension WellArchitectedClientTypes.LensReviewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LensReviewSummary(lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), lensName: \(Swift.String(describing: lensName)), lensStatus: \(Swift.String(describing: lensStatus)), lensVersion: \(Swift.String(describing: lensVersion)), riskCounts: \(Swift.String(describing: riskCounts)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension WellArchitectedClientTypes {
    /// A lens review summary of a workload.
    public struct LensReviewSummary: Swift.Equatable {
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init (
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.LensShareSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WellArchitectedClientTypes.LensShareSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LensShareSummary(shareId: \(Swift.String(describing: shareId)), sharedWith: \(Swift.String(describing: sharedWith)), status: \(Swift.String(describing: status)))"}
}

extension WellArchitectedClientTypes {
    /// A lens share summary return object.
    public struct LensShareSummary: Swift.Equatable {
        /// The ID associated with the workload share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The status of a workload share.
        public var status: WellArchitectedClientTypes.ShareStatus?

        public init (
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes {
    public enum LensStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case current
        case deleted
        case deprecated
        case notCurrent
        case unshared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatus] {
            return [
                .current,
                .deleted,
                .deprecated,
                .notCurrent,
                .unshared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .notCurrent: return "NOT_CURRENT"
            case .unshared: return "UNSHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensStatus(rawValue: rawValue) ?? LensStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum LensStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatusType] {
            return [
                .all,
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensStatusType(rawValue: rawValue) ?? LensStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.LensSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensType = "LensType"
        case lensVersion = "LensVersion"
        case owner = "Owner"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensType = lensType {
            try encodeContainer.encode(lensType.rawValue, forKey: .lensType)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensType.self, forKey: .lensType)
        lensType = lensTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
    }
}

extension WellArchitectedClientTypes.LensSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LensSummary(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), lensName: \(Swift.String(describing: lensName)), lensStatus: \(Swift.String(describing: lensStatus)), lensType: \(Swift.String(describing: lensType)), lensVersion: \(Swift.String(describing: lensVersion)), owner: \(Swift.String(describing: owner)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension WellArchitectedClientTypes {
    /// A lens summary of a lens.
    public struct LensSummary: Swift.Equatable {
        /// The date and time recorded.
        public var createdAt: ClientRuntime.Date?
        /// The description of the lens.
        public var description: Swift.String?
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN of the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The type of the lens.
        public var lensType: WellArchitectedClientTypes.LensType?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensType: WellArchitectedClientTypes.LensType? = nil,
            lensVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensType = lensType
            self.lensVersion = lensVersion
            self.owner = owner
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes {
    public enum LensType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOfficial
        case customSelf
        case customShared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensType] {
            return [
                .awsOfficial,
                .customSelf,
                .customShared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOfficial: return "AWS_OFFICIAL"
            case .customSelf: return "CUSTOM_SELF"
            case .customShared: return "CUSTOM_SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensType(rawValue: rawValue) ?? LensType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.LensUpgradeSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentLensVersion = "CurrentLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLensVersion = currentLensVersion {
            try encodeContainer.encode(currentLensVersion, forKey: .currentLensVersion)
        }
        if let latestLensVersion = latestLensVersion {
            try encodeContainer.encode(latestLensVersion, forKey: .latestLensVersion)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let currentLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentLensVersion)
        currentLensVersion = currentLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
    }
}

extension WellArchitectedClientTypes.LensUpgradeSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LensUpgradeSummary(currentLensVersion: \(Swift.String(describing: currentLensVersion)), latestLensVersion: \(Swift.String(describing: latestLensVersion)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), workloadId: \(Swift.String(describing: workloadId)), workloadName: \(Swift.String(describing: workloadName)))"}
}

extension WellArchitectedClientTypes {
    /// Lens upgrade summary return object.
    public struct LensUpgradeSummary: Swift.Equatable {
        /// The current version of the lens.
        public var currentLensVersion: Swift.String?
        /// The latest version of the lens.
        public var latestLensVersion: Swift.String?
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            currentLensVersion: Swift.String? = nil,
            latestLensVersion: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.currentLensVersion = currentLensVersion
            self.latestLensVersion = latestLensVersion
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension ListAnswersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAnswersInput(lensAlias: \(Swift.String(describing: lensAlias)), maxResults: \(Swift.String(describing: maxResults)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), nextToken: \(Swift.String(describing: nextToken)), pillarId: \(Swift.String(describing: pillarId)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListAnswersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAnswersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnswersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAnswersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnswersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAnswersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnswersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnswersOutputError>
}

public struct ListAnswersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnswersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAnswersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnswersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pillarId = input.operationInput.pillarId {
            let pillarIdQueryItem = ClientRuntime.URLQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            input.builder.withQueryItem(pillarIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if input.operationInput.milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(input.operationInput.milestoneNumber).urlPercentEncoding())
            input.builder.withQueryItem(milestoneNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAnswersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnswersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnswersOutputError>
}

public struct ListAnswersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnswersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAnswersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnswersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAnswersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnswersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnswersOutputError>
}

public struct ListAnswersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAnswersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAnswersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAnswersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAnswersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAnswersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAnswersOutputError>
}

/// Input to list answers.
public struct ListAnswersInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.workloadId = workloadId
    }
}

struct ListAnswersInputBody: Swift.Equatable {
}

extension ListAnswersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAnswersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnswersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnswersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnswersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAnswersOutputResponse(answerSummaries: \(Swift.String(describing: answerSummaries)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListAnswersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnswersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.answerSummaries = output.answerSummaries
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.answerSummaries = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list answers call.
public struct ListAnswersOutputResponse: Swift.Equatable {
    /// List of answer summaries of lens review in a workload.
    public var answerSummaries: [WellArchitectedClientTypes.AnswerSummary]?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        answerSummaries: [WellArchitectedClientTypes.AnswerSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answerSummaries = answerSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListAnswersOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneNumber: Swift.Int
    public let lensAlias: Swift.String?
    public let lensArn: Swift.String?
    public let answerSummaries: [WellArchitectedClientTypes.AnswerSummary]?
    public let nextToken: Swift.String?
}

extension ListAnswersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerSummaries = "AnswerSummaries"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.AnswerSummary?].self, forKey: .answerSummaries)
        var answerSummariesDecoded0:[WellArchitectedClientTypes.AnswerSummary]? = nil
        if let answerSummariesContainer = answerSummariesContainer {
            answerSummariesDecoded0 = [WellArchitectedClientTypes.AnswerSummary]()
            for structure0 in answerSummariesContainer {
                if let structure0 = structure0 {
                    answerSummariesDecoded0?.append(structure0)
                }
            }
        }
        answerSummaries = answerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensReviewImprovementsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensReviewImprovementsInput(lensAlias: \(Swift.String(describing: lensAlias)), maxResults: \(Swift.String(describing: maxResults)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), nextToken: \(Swift.String(describing: nextToken)), pillarId: \(Swift.String(describing: pillarId)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListLensReviewImprovementsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLensReviewImprovementsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewImprovementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensReviewImprovementsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensReviewImprovementsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewImprovementsOutputError>
}

public struct ListLensReviewImprovementsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewImprovementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensReviewImprovementsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pillarId = input.operationInput.pillarId {
            let pillarIdQueryItem = ClientRuntime.URLQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            input.builder.withQueryItem(pillarIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if input.operationInput.milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(input.operationInput.milestoneNumber).urlPercentEncoding())
            input.builder.withQueryItem(milestoneNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensReviewImprovementsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewImprovementsOutputError>
}

public struct ListLensReviewImprovementsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewImprovementsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLensReviewImprovementsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensReviewImprovementsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewImprovementsOutputError>
}

public struct ListLensReviewImprovementsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewImprovementsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLensReviewImprovementsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/improvements"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensReviewImprovementsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewImprovementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewImprovementsOutputError>
}

/// Input to list lens review improvements.
public struct ListLensReviewImprovementsInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsInputBody: Swift.Equatable {
}

extension ListLensReviewImprovementsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensReviewImprovementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensReviewImprovementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensReviewImprovementsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensReviewImprovementsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensReviewImprovementsOutputResponse(improvementSummaries: \(Swift.String(describing: improvementSummaries)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListLensReviewImprovementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensReviewImprovementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.improvementSummaries = output.improvementSummaries
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.improvementSummaries = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list lens review improvements call.
public struct ListLensReviewImprovementsOutputResponse: Swift.Equatable {
    /// List of improvement summaries of lens review in a workload.
    public var improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.improvementSummaries = improvementSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneNumber: Swift.Int
    public let lensAlias: Swift.String?
    public let lensArn: Swift.String?
    public let improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]?
    public let nextToken: Swift.String?
}

extension ListLensReviewImprovementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementSummaries = "ImprovementSummaries"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let improvementSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ImprovementSummary?].self, forKey: .improvementSummaries)
        var improvementSummariesDecoded0:[WellArchitectedClientTypes.ImprovementSummary]? = nil
        if let improvementSummariesContainer = improvementSummariesContainer {
            improvementSummariesDecoded0 = [WellArchitectedClientTypes.ImprovementSummary]()
            for structure0 in improvementSummariesContainer {
                if let structure0 = structure0 {
                    improvementSummariesDecoded0?.append(structure0)
                }
            }
        }
        improvementSummaries = improvementSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensReviewsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensReviewsInput(maxResults: \(Swift.String(describing: maxResults)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListLensReviewsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLensReviewsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensReviewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensReviewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewsOutputError>
}

public struct ListLensReviewsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensReviewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if input.operationInput.milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(input.operationInput.milestoneNumber).urlPercentEncoding())
            input.builder.withQueryItem(milestoneNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensReviewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewsOutputError>
}

public struct ListLensReviewsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLensReviewsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensReviewsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewsOutputError>
}

public struct ListLensReviewsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensReviewsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLensReviewsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensReviewsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensReviewsOutputError>
}

/// Input to list lens reviews.
public struct ListLensReviewsInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsInputBody: Swift.Equatable {
}

extension ListLensReviewsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensReviewsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensReviewsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensReviewsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensReviewsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensReviewsOutputResponse(lensReviewSummaries: \(Swift.String(describing: lensReviewSummaries)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListLensReviewsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensReviewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReviewSummaries = output.lensReviewSummaries
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.lensReviewSummaries = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list lens reviews call.
public struct ListLensReviewsOutputResponse: Swift.Equatable {
    /// List of lens summaries of lens reviews of a workload.
    public var lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]? = nil,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewSummaries = lensReviewSummaries
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneNumber: Swift.Int
    public let lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]?
    public let nextToken: Swift.String?
}

extension ListLensReviewsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReviewSummaries = "LensReviewSummaries"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensReviewSummary?].self, forKey: .lensReviewSummaries)
        var lensReviewSummariesDecoded0:[WellArchitectedClientTypes.LensReviewSummary]? = nil
        if let lensReviewSummariesContainer = lensReviewSummariesContainer {
            lensReviewSummariesDecoded0 = [WellArchitectedClientTypes.LensReviewSummary]()
            for structure0 in lensReviewSummariesContainer {
                if let structure0 = structure0 {
                    lensReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensReviewSummaries = lensReviewSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensSharesInput(lensAlias: \(Swift.String(describing: lensAlias)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sharedWithPrefix: \(Swift.String(describing: sharedWithPrefix)))"}
}

extension ListLensSharesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLensSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensSharesOutputError>
}

public struct ListLensSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sharedWithPrefix = input.operationInput.sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.URLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            input.builder.withQueryItem(sharedWithPrefixQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensSharesOutputError>
}

public struct ListLensSharesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensSharesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLensSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensSharesOutputError>
}

public struct ListLensSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensSharesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLensSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/lenses/\(lensAlias.urlPercentEncoding())/shares"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensSharesOutputError>
}

public struct ListLensSharesInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID or IAM role with which the lens is shared.
    public var sharedWithPrefix: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
    }
}

struct ListLensSharesInputBody: Swift.Equatable {
}

extension ListLensSharesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensSharesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensSharesOutputResponse(lensShareSummaries: \(Swift.String(describing: lensShareSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLensSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensShareSummaries = output.lensShareSummaries
            self.nextToken = output.nextToken
        } else {
            self.lensShareSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListLensSharesOutputResponse: Swift.Equatable {
    /// A list of lens share summaries.
    public var lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensShareSummaries = lensShareSummaries
        self.nextToken = nextToken
    }
}

struct ListLensSharesOutputResponseBody: Swift.Equatable {
    public let lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]?
    public let nextToken: Swift.String?
}

extension ListLensSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensShareSummaries = "LensShareSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensShareSummary?].self, forKey: .lensShareSummaries)
        var lensShareSummariesDecoded0:[WellArchitectedClientTypes.LensShareSummary]? = nil
        if let lensShareSummariesContainer = lensShareSummariesContainer {
            lensShareSummariesDecoded0 = [WellArchitectedClientTypes.LensShareSummary]()
            for structure0 in lensShareSummariesContainer {
                if let structure0 = structure0 {
                    lensShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensShareSummaries = lensShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensesInput(lensName: \(Swift.String(describing: lensName)), lensStatus: \(Swift.String(describing: lensStatus)), lensType: \(Swift.String(describing: lensType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLensesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLensesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensesOutputError>
}

public struct ListLensesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let lensName = input.operationInput.lensName {
            let lensNameQueryItem = ClientRuntime.URLQueryItem(name: "LensName".urlPercentEncoding(), value: Swift.String(lensName).urlPercentEncoding())
            input.builder.withQueryItem(lensNameQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let lensType = input.operationInput.lensType {
            let lensTypeQueryItem = ClientRuntime.URLQueryItem(name: "LensType".urlPercentEncoding(), value: Swift.String(lensType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(lensTypeQueryItem)
        }
        if let lensStatus = input.operationInput.lensStatus {
            let lensStatusQueryItem = ClientRuntime.URLQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(lensStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensesOutputError>
}

public struct ListLensesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensesOutputError>
}

public struct ListLensesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLensesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/lenses"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLensesOutputError>
}

/// Input to list lenses.
public struct ListLensesInput: Swift.Equatable {
    /// The full name of the lens.
    public var lensName: Swift.String?
    /// The status of lenses to be returned.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?
    /// The type of lenses to be returned.
    public var lensType: WellArchitectedClientTypes.LensType?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        lensName: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil,
        lensType: WellArchitectedClientTypes.LensType? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.lensName = lensName
        self.lensStatus = lensStatus
        self.lensType = lensType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLensesInputBody: Swift.Equatable {
}

extension ListLensesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLensesOutputResponse(lensSummaries: \(Swift.String(describing: lensSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensSummaries = output.lensSummaries
            self.nextToken = output.nextToken
        } else {
            self.lensSummaries = nil
            self.nextToken = nil
        }
    }
}

/// Output of a list lenses call.
public struct ListLensesOutputResponse: Swift.Equatable {
    /// List of lens summaries of available lenses.
    public var lensSummaries: [WellArchitectedClientTypes.LensSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        lensSummaries: [WellArchitectedClientTypes.LensSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensSummaries = lensSummaries
        self.nextToken = nextToken
    }
}

struct ListLensesOutputResponseBody: Swift.Equatable {
    public let lensSummaries: [WellArchitectedClientTypes.LensSummary]?
    public let nextToken: Swift.String?
}

extension ListLensesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensSummaries = "LensSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensSummary?].self, forKey: .lensSummaries)
        var lensSummariesDecoded0:[WellArchitectedClientTypes.LensSummary]? = nil
        if let lensSummariesContainer = lensSummariesContainer {
            lensSummariesDecoded0 = [WellArchitectedClientTypes.LensSummary]()
            for structure0 in lensSummariesContainer {
                if let structure0 = structure0 {
                    lensSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensSummaries = lensSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMilestonesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMilestonesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMilestonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMilestonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMilestonesOutputError>
}

extension ListMilestonesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMilestonesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListMilestonesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMilestonesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMilestonesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMilestonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMilestonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMilestonesOutputError>
}

public struct ListMilestonesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMilestonesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMilestonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMilestonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMilestonesOutputError>
}

public struct ListMilestonesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMilestonesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMilestonesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMilestonesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMilestonesOutputError>
}

public struct ListMilestonesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMilestonesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMilestonesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMilestonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/milestonesSummaries"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMilestonesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMilestonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMilestonesOutputError>
}

/// Input to list all milestones for a workload.
public struct ListMilestonesInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListMilestonesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMilestonesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMilestonesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMilestonesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMilestonesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMilestonesOutputResponse(milestoneSummaries: \(Swift.String(describing: milestoneSummaries)), nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListMilestonesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMilestonesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.milestoneSummaries = output.milestoneSummaries
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.milestoneSummaries = nil
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list milestones call.
public struct ListMilestonesOutputResponse: Swift.Equatable {
    /// A list of milestone summaries.
    public var milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneSummaries = milestoneSummaries
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]?
    public let nextToken: Swift.String?
}

extension ListMilestonesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneSummaries = "MilestoneSummaries"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.MilestoneSummary?].self, forKey: .milestoneSummaries)
        var milestoneSummariesDecoded0:[WellArchitectedClientTypes.MilestoneSummary]? = nil
        if let milestoneSummariesContainer = milestoneSummariesContainer {
            milestoneSummariesDecoded0 = [WellArchitectedClientTypes.MilestoneSummary]()
            for structure0 in milestoneSummariesContainer {
                if let structure0 = structure0 {
                    milestoneSummariesDecoded0?.append(structure0)
                }
            }
        }
        milestoneSummaries = milestoneSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNotificationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNotificationsOutputError>
}

extension ListNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNotificationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }
}

public struct ListNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNotificationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNotificationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/notifications"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListNotificationsInputBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNotificationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), notificationSummaries: \(Swift.String(describing: notificationSummaries)))"}
}

extension ListNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notificationSummaries = output.notificationSummaries
        } else {
            self.nextToken = nil
            self.notificationSummaries = nil
        }
    }
}

public struct ListNotificationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of lens notification summaries in a workload.
    public var notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationSummaries = notificationSummaries
    }
}

struct ListNotificationsOutputResponseBody: Swift.Equatable {
    public let notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]?
    public let nextToken: Swift.String?
}

extension ListNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notificationSummaries = "NotificationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.NotificationSummary?].self, forKey: .notificationSummaries)
        var notificationSummariesDecoded0:[WellArchitectedClientTypes.NotificationSummary]? = nil
        if let notificationSummariesContainer = notificationSummariesContainer {
            notificationSummariesDecoded0 = [WellArchitectedClientTypes.NotificationSummary]()
            for structure0 in notificationSummariesContainer {
                if let structure0 = structure0 {
                    notificationSummariesDecoded0?.append(structure0)
                }
            }
        }
        notificationSummaries = notificationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListShareInvitationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListShareInvitationsInput(lensNamePrefix: \(Swift.String(describing: lensNamePrefix)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), shareResourceType: \(Swift.String(describing: shareResourceType)), workloadNamePrefix: \(Swift.String(describing: workloadNamePrefix)))"}
}

extension ListShareInvitationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListShareInvitationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListShareInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListShareInvitationsOutputError>
}

public struct ListShareInvitationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListShareInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let lensNamePrefix = input.operationInput.lensNamePrefix {
            let lensNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "LensNamePrefix".urlPercentEncoding(), value: Swift.String(lensNamePrefix).urlPercentEncoding())
            input.builder.withQueryItem(lensNamePrefixQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let shareResourceType = input.operationInput.shareResourceType {
            let shareResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "ShareResourceType".urlPercentEncoding(), value: Swift.String(shareResourceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(shareResourceTypeQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let workloadNamePrefix = input.operationInput.workloadNamePrefix {
            let workloadNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "WorkloadNamePrefix".urlPercentEncoding(), value: Swift.String(workloadNamePrefix).urlPercentEncoding())
            input.builder.withQueryItem(workloadNamePrefixQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListShareInvitationsOutputError>
}

public struct ListShareInvitationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListShareInvitationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListShareInvitationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListShareInvitationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListShareInvitationsOutputError>
}

public struct ListShareInvitationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListShareInvitationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListShareInvitationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/shareInvitations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListShareInvitationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListShareInvitationsOutputError>
}

/// Input for List Share Invitations
public struct ListShareInvitationsInput: Swift.Equatable {
    /// An optional string added to the beginning of each lens name returned in the results.
    public var lensNamePrefix: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of share invitations to be returned.
    public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init (
        lensNamePrefix: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.lensNamePrefix = lensNamePrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shareResourceType = shareResourceType
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListShareInvitationsInputBody: Swift.Equatable {
}

extension ListShareInvitationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListShareInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListShareInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListShareInvitationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListShareInvitationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListShareInvitationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), shareInvitationSummaries: \(Swift.String(describing: shareInvitationSummaries)))"}
}

extension ListShareInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.shareInvitationSummaries = output.shareInvitationSummaries
        } else {
            self.nextToken = nil
            self.shareInvitationSummaries = nil
        }
    }
}

/// Input for List Share Invitations
public struct ListShareInvitationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of share invitation summaries in a workload.
    public var shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.shareInvitationSummaries = shareInvitationSummaries
    }
}

struct ListShareInvitationsOutputResponseBody: Swift.Equatable {
    public let shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]?
    public let nextToken: Swift.String?
}

extension ListShareInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case shareInvitationSummaries = "ShareInvitationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ShareInvitationSummary?].self, forKey: .shareInvitationSummaries)
        var shareInvitationSummariesDecoded0:[WellArchitectedClientTypes.ShareInvitationSummary]? = nil
        if let shareInvitationSummariesContainer = shareInvitationSummariesContainer {
            shareInvitationSummariesDecoded0 = [WellArchitectedClientTypes.ShareInvitationSummary]()
            for structure0 in shareInvitationSummariesContainer {
                if let structure0 = structure0 {
                    shareInvitationSummariesDecoded0?.append(structure0)
                }
            }
        }
        shareInvitationSummaries = shareInvitationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(workloadArn: \(Swift.String(describing: workloadArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadArn = input.workloadArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(workloadArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init (
        workloadArn: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWorkloadSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkloadSharesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sharedWithPrefix: \(Swift.String(describing: sharedWithPrefix)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension ListWorkloadSharesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListWorkloadSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkloadSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkloadSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadSharesOutputError>
}

public struct ListWorkloadSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkloadSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sharedWithPrefix = input.operationInput.sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.URLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            input.builder.withQueryItem(sharedWithPrefixQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkloadSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadSharesOutputError>
}

public struct ListWorkloadSharesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadSharesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListWorkloadSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorkloadSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadSharesOutputError>
}

public struct ListWorkloadSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadSharesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListWorkloadSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/shares"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorkloadSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadSharesOutputError>
}

/// Input for List Workload Share
public struct ListWorkloadSharesInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID or IAM role with which the workload is shared.
    public var sharedWithPrefix: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.workloadId = workloadId
    }
}

struct ListWorkloadSharesInputBody: Swift.Equatable {
}

extension ListWorkloadSharesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkloadSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkloadSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkloadSharesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkloadSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkloadSharesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), workloadId: \(Swift.String(describing: workloadId)), workloadShareSummaries: \(Swift.String(describing: workloadShareSummaries)))"}
}

extension ListWorkloadSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkloadSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
            self.workloadShareSummaries = output.workloadShareSummaries
        } else {
            self.nextToken = nil
            self.workloadId = nil
            self.workloadShareSummaries = nil
        }
    }
}

/// Input for List Workload Share
public struct ListWorkloadSharesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A list of workload share summaries.
    public var workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadId = workloadId
        self.workloadShareSummaries = workloadShareSummaries
    }
}

struct ListWorkloadSharesOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]?
    public let nextToken: Swift.String?
}

extension ListWorkloadSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
        case workloadShareSummaries = "WorkloadShareSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadShareSummary?].self, forKey: .workloadShareSummaries)
        var workloadShareSummariesDecoded0:[WellArchitectedClientTypes.WorkloadShareSummary]? = nil
        if let workloadShareSummariesContainer = workloadShareSummariesContainer {
            workloadShareSummariesDecoded0 = [WellArchitectedClientTypes.WorkloadShareSummary]()
            for structure0 in workloadShareSummariesContainer {
                if let structure0 = structure0 {
                    workloadShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadShareSummaries = workloadShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorkloadsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkloadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkloadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadsOutputError>
}

extension ListWorkloadsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkloadsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), workloadNamePrefix: \(Swift.String(describing: workloadNamePrefix)))"}
}

extension ListWorkloadsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadNamePrefix = workloadNamePrefix {
            try encodeContainer.encode(workloadNamePrefix, forKey: .workloadNamePrefix)
        }
    }
}

public struct ListWorkloadsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkloadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkloadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadsOutputError>
}

public struct ListWorkloadsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkloadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkloadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadsOutputError>
}

public struct ListWorkloadsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListWorkloadsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorkloadsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadsOutputError>
}

public struct ListWorkloadsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkloadsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListWorkloadsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/workloadsSummaries"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorkloadsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkloadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkloadsOutputError>
}

/// Input to list all workloads.
public struct ListWorkloadsInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListWorkloadsInputBody: Swift.Equatable {
    public let workloadNamePrefix: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListWorkloadsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadNamePrefix)
        workloadNamePrefix = workloadNamePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkloadsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkloadsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkloadsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkloadsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkloadsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), workloadSummaries: \(Swift.String(describing: workloadSummaries)))"}
}

extension ListWorkloadsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkloadsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadSummaries = output.workloadSummaries
        } else {
            self.nextToken = nil
            self.workloadSummaries = nil
        }
    }
}

/// Output of a list workloads call.
public struct ListWorkloadsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of workload summaries.
    public var workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadSummaries = workloadSummaries
    }
}

struct ListWorkloadsOutputResponseBody: Swift.Equatable {
    public let workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]?
    public let nextToken: Swift.String?
}

extension ListWorkloadsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workloadSummaries = "WorkloadSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadSummary?].self, forKey: .workloadSummaries)
        var workloadSummariesDecoded0:[WellArchitectedClientTypes.WorkloadSummary]? = nil
        if let workloadSummariesContainer = workloadSummariesContainer {
            workloadSummariesDecoded0 = [WellArchitectedClientTypes.WorkloadSummary]()
            for structure0 in workloadSummariesContainer {
                if let structure0 = structure0 {
                    workloadSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadSummaries = workloadSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WellArchitectedClientTypes.Milestone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workload = "Workload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if milestoneNumber != 0 {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = recordedAt {
            try encodeContainer.encode(recordedAt.timeIntervalSince1970, forKey: .recordedAt)
        }
        if let workload = workload {
            try encodeContainer.encode(workload, forKey: .workload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

extension WellArchitectedClientTypes.Milestone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Milestone(milestoneName: \(Swift.String(describing: milestoneName)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), recordedAt: \(Swift.String(describing: recordedAt)), workload: \(Swift.String(describing: workload)))"}
}

extension WellArchitectedClientTypes {
    /// A milestone return object.
    public struct Milestone: Swift.Equatable {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int
        /// The date and time recorded.
        public var recordedAt: ClientRuntime.Date?
        /// A workload return object.
        public var workload: WellArchitectedClientTypes.Workload?

        public init (
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int = 0,
            recordedAt: ClientRuntime.Date? = nil,
            workload: WellArchitectedClientTypes.Workload? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workload = workload
        }
    }

}

extension WellArchitectedClientTypes.MilestoneSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workloadSummary = "WorkloadSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if milestoneNumber != 0 {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = recordedAt {
            try encodeContainer.encode(recordedAt.timeIntervalSince1970, forKey: .recordedAt)
        }
        if let workloadSummary = workloadSummary {
            try encodeContainer.encode(workloadSummary, forKey: .workloadSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadSummaryDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadSummary.self, forKey: .workloadSummary)
        workloadSummary = workloadSummaryDecoded
    }
}

extension WellArchitectedClientTypes.MilestoneSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MilestoneSummary(milestoneName: \(Swift.String(describing: milestoneName)), milestoneNumber: \(Swift.String(describing: milestoneNumber)), recordedAt: \(Swift.String(describing: recordedAt)), workloadSummary: \(Swift.String(describing: workloadSummary)))"}
}

extension WellArchitectedClientTypes {
    /// A milestone summary return object.
    public struct MilestoneSummary: Swift.Equatable {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int
        /// The date and time recorded.
        public var recordedAt: ClientRuntime.Date?
        /// A workload summary return object.
        public var workloadSummary: WellArchitectedClientTypes.WorkloadSummary?

        public init (
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int = 0,
            recordedAt: ClientRuntime.Date? = nil,
            workloadSummary: WellArchitectedClientTypes.WorkloadSummary? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workloadSummary = workloadSummary
        }
    }

}

extension WellArchitectedClientTypes.NotificationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensUpgradeSummary = "LensUpgradeSummary"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensUpgradeSummary = lensUpgradeSummary {
            try encodeContainer.encode(lensUpgradeSummary, forKey: .lensUpgradeSummary)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.NotificationType.self, forKey: .type)
        type = typeDecoded
        let lensUpgradeSummaryDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensUpgradeSummary.self, forKey: .lensUpgradeSummary)
        lensUpgradeSummary = lensUpgradeSummaryDecoded
    }
}

extension WellArchitectedClientTypes.NotificationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationSummary(lensUpgradeSummary: \(Swift.String(describing: lensUpgradeSummary)), type: \(Swift.String(describing: type)))"}
}

extension WellArchitectedClientTypes {
    /// A notification summary return object.
    public struct NotificationSummary: Swift.Equatable {
        /// Summary of lens upgrade.
        public var lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary?
        /// The type of notification.
        public var type: WellArchitectedClientTypes.NotificationType?

        public init (
            lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary? = nil,
            type: WellArchitectedClientTypes.NotificationType? = nil
        )
        {
            self.lensUpgradeSummary = lensUpgradeSummary
            self.type = type
        }
    }

}

extension WellArchitectedClientTypes {
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lensVersionDeprecated
        case lensVersionUpgraded
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .lensVersionDeprecated,
                .lensVersionUpgraded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lensVersionDeprecated: return "LENS_VERSION_DEPRECATED"
            case .lensVersionUpgraded: return "LENS_VERSION_UPGRADED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// Permission granted on a workload share.
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contributor
        case readonly
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .contributor,
                .readonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .readonly: return "READONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.PillarDifference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differenceStatus = "DifferenceStatus"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case questionDifferences = "QuestionDifferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let questionDifferences = questionDifferences {
            var questionDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .questionDifferences)
            for questiondifferences0 in questionDifferences {
                try questionDifferencesContainer.encode(questiondifferences0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
        let questionDifferencesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.QuestionDifference?].self, forKey: .questionDifferences)
        var questionDifferencesDecoded0:[WellArchitectedClientTypes.QuestionDifference]? = nil
        if let questionDifferencesContainer = questionDifferencesContainer {
            questionDifferencesDecoded0 = [WellArchitectedClientTypes.QuestionDifference]()
            for structure0 in questionDifferencesContainer {
                if let structure0 = structure0 {
                    questionDifferencesDecoded0?.append(structure0)
                }
            }
        }
        questionDifferences = questionDifferencesDecoded0
    }
}

extension WellArchitectedClientTypes.PillarDifference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PillarDifference(differenceStatus: \(Swift.String(describing: differenceStatus)), pillarId: \(Swift.String(describing: pillarId)), pillarName: \(Swift.String(describing: pillarName)), questionDifferences: \(Swift.String(describing: questionDifferences)))"}
}

extension WellArchitectedClientTypes {
    /// A pillar difference return object.
    public struct PillarDifference: Swift.Equatable {
        /// Indicates the type of change to the pillar.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// List of question differences.
        public var questionDifferences: [WellArchitectedClientTypes.QuestionDifference]?

        public init (
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            questionDifferences: [WellArchitectedClientTypes.QuestionDifference]? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.questionDifferences = questionDifferences
        }
    }

}

extension WellArchitectedClientTypes.PillarReviewSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notes = "Notes"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case riskCounts = "RiskCounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
    }
}

extension WellArchitectedClientTypes.PillarReviewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PillarReviewSummary(notes: \(Swift.String(describing: notes)), pillarId: \(Swift.String(describing: pillarId)), pillarName: \(Swift.String(describing: pillarName)), riskCounts: \(Swift.String(describing: riskCounts)))"}
}

extension WellArchitectedClientTypes {
    /// A pillar review summary of a lens review.
    public struct PillarReviewSummary: Swift.Equatable {
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?

        public init (
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.notes = notes
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.riskCounts = riskCounts
        }
    }

}

extension WellArchitectedClientTypes.QuestionDifference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differenceStatus = "DifferenceStatus"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
    }
}

extension WellArchitectedClientTypes.QuestionDifference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuestionDifference(differenceStatus: \(Swift.String(describing: differenceStatus)), questionId: \(Swift.String(describing: questionId)), questionTitle: \(Swift.String(describing: questionTitle)))"}
}

extension WellArchitectedClientTypes {
    /// A question difference return object.
    public struct QuestionDifference: Swift.Equatable {
        /// Indicates the type of change to the question.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?

        public init (
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.questionId = questionId
            self.questionTitle = questionTitle
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The risk for a given workload, lens review, pillar, or question.
    public enum Risk: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case medium
        case `none`
        case notApplicable
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [Risk] {
            return [
                .high,
                .medium,
                .none,
                .notApplicable,
                .unanswered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case .notApplicable: return "NOT_APPLICABLE"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Risk(rawValue: rawValue) ?? Risk.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user has reached their resource quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating quota.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    public var resourceType: Swift.String?
    /// Service Quotas requirement to identify originating service.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension WellArchitectedClientTypes.ShareInvitation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case shareInvitationId = "ShareInvitationId"
        case shareResourceType = "ShareResourceType"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let shareResourceType = shareResourceType {
            try encodeContainer.encode(shareResourceType.rawValue, forKey: .shareResourceType)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let shareResourceTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareResourceType.self, forKey: .shareResourceType)
        shareResourceType = shareResourceTypeDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
    }
}

extension WellArchitectedClientTypes.ShareInvitation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareInvitation(lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), shareInvitationId: \(Swift.String(describing: shareInvitationId)), shareResourceType: \(Swift.String(describing: shareResourceType)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension WellArchitectedClientTypes {
    /// The share invitation.
    public struct ShareInvitation: Swift.Equatable {
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?

        public init (
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            workloadId: Swift.String? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.workloadId = workloadId
        }
    }

}

extension WellArchitectedClientTypes {
    /// Share invitation action taken by contributor.
    public enum ShareInvitationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case reject
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareInvitationAction] {
            return [
                .accept,
                .reject,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .reject: return "REJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareInvitationAction(rawValue: rawValue) ?? ShareInvitationAction.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ShareInvitationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case lensName = "LensName"
        case permissionType = "PermissionType"
        case shareInvitationId = "ShareInvitationId"
        case shareResourceType = "ShareResourceType"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let shareResourceType = shareResourceType {
            try encodeContainer.encode(shareResourceType.rawValue, forKey: .shareResourceType)
        }
        if let sharedBy = sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let shareResourceTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareResourceType.self, forKey: .shareResourceType)
        shareResourceType = shareResourceTypeDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
    }
}

extension WellArchitectedClientTypes.ShareInvitationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareInvitationSummary(lensArn: \(Swift.String(describing: lensArn)), lensName: \(Swift.String(describing: lensName)), permissionType: \(Swift.String(describing: permissionType)), shareInvitationId: \(Swift.String(describing: shareInvitationId)), shareResourceType: \(Swift.String(describing: shareResourceType)), sharedBy: \(Swift.String(describing: sharedBy)), sharedWith: \(Swift.String(describing: sharedWith)), workloadId: \(Swift.String(describing: workloadId)), workloadName: \(Swift.String(describing: workloadName)))"}
}

extension WellArchitectedClientTypes {
    /// A share invitation summary return object.
    public struct ShareInvitationSummary: Swift.Equatable {
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// Permission granted on a workload share.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.lensArn = lensArn
            self.lensName = lensName
            self.permissionType = permissionType
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ShareResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lens
        case workload
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareResourceType] {
            return [
                .lens,
                .workload,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lens: return "LENS"
            case .workload: return "WORKLOAD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareResourceType(rawValue: rawValue) ?? ShareResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// The status of a workload share.
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case expired
        case pending
        case rejected
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .accepted,
                .expired,
                .pending,
                .rejected,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(tags: \(Swift.String(describing: tags)), workloadArn: \(Swift.String(describing: workloadArn)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadArn = input.workloadArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(workloadArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init (
        tags: [Swift.String:Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tags = tags
        self.workloadArn = workloadArn
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating quota.
    public var quotaCode: Swift.String?
    /// Service Quotas requirement to identify originating service.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(tagKeys: \(Swift.String(describing: tagKeys)), workloadArn: \(Swift.String(describing: workloadArn)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadArn = input.workloadArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(workloadArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init (
        tagKeys: [Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.workloadArn = workloadArn
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAnswerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAnswerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAnswerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAnswerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAnswerOutputError>
}

extension UpdateAnswerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAnswerInput(choiceUpdates: \(Swift.String(describing: choiceUpdates)), isApplicable: \(Swift.String(describing: isApplicable)), lensAlias: \(Swift.String(describing: lensAlias)), notes: \(Swift.String(describing: notes)), questionId: \(Swift.String(describing: questionId)), reason: \(Swift.String(describing: reason)), selectedChoices: \(Swift.String(describing: selectedChoices)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension UpdateAnswerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceUpdates = choiceUpdates {
            var choiceUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .choiceUpdates)
            for (dictKey0, choiceupdates0) in choiceUpdates {
                try choiceUpdatesContainer.encode(choiceupdates0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }
}

public struct UpdateAnswerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAnswerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAnswerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAnswerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAnswerOutputError>
}

public struct UpdateAnswerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAnswerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAnswerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAnswerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAnswerOutputError>
}

public struct UpdateAnswerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAnswerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAnswerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAnswerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAnswerOutputError>
}

public struct UpdateAnswerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAnswerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAnswerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        guard let questionId = input.questionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("questionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAnswerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAnswerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAnswerOutputError>
}

/// Input to update answer.
public struct UpdateAnswerInput: Swift.Equatable {
    /// A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.
    public var choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    /// Defines whether this question is applicable to a lens review.
    public var isApplicable: Swift.Bool
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload.
    public var notes: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The reason why a question is not applicable to your workload.
    public var reason: WellArchitectedClientTypes.AnswerReason?
    /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
    public var selectedChoices: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil,
        isApplicable: Swift.Bool = false,
        lensAlias: Swift.String? = nil,
        notes: Swift.String? = nil,
        questionId: Swift.String? = nil,
        reason: WellArchitectedClientTypes.AnswerReason? = nil,
        selectedChoices: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceUpdates = choiceUpdates
        self.isApplicable = isApplicable
        self.lensAlias = lensAlias
        self.notes = notes
        self.questionId = questionId
        self.reason = reason
        self.selectedChoices = selectedChoices
        self.workloadId = workloadId
    }
}

struct UpdateAnswerInputBody: Swift.Equatable {
    public let selectedChoices: [Swift.String]?
    public let choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    public let notes: Swift.String?
    public let isApplicable: Swift.Bool
    public let reason: WellArchitectedClientTypes.AnswerReason?
}

extension UpdateAnswerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: WellArchitectedClientTypes.ChoiceUpdate?].self, forKey: .choiceUpdates)
        var choiceUpdatesDecoded0: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil
        if let choiceUpdatesContainer = choiceUpdatesContainer {
            choiceUpdatesDecoded0 = [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]()
            for (key0, choiceupdate0) in choiceUpdatesContainer {
                if let choiceupdate0 = choiceupdate0 {
                    choiceUpdatesDecoded0?[key0] = choiceupdate0
                }
            }
        }
        choiceUpdates = choiceUpdatesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let isApplicableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension UpdateAnswerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnswerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnswerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnswerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAnswerOutputResponse(answer: \(Swift.String(describing: answer)), lensAlias: \(Swift.String(describing: lensAlias)), lensArn: \(Swift.String(describing: lensArn)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension UpdateAnswerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAnswerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.workloadId = nil
        }
    }
}

/// Output of a update answer call.
public struct UpdateAnswerOutputResponse: Swift.Equatable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.workloadId = workloadId
    }
}

struct UpdateAnswerOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let lensAlias: Swift.String?
    public let lensArn: Swift.String?
    public let answer: WellArchitectedClientTypes.Answer?
}

extension UpdateAnswerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

public struct UpdateLensReviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLensReviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLensReviewOutputError>
}

extension UpdateLensReviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLensReviewInput(lensAlias: \(Swift.String(describing: lensAlias)), lensNotes: \(Swift.String(describing: lensNotes)), pillarNotes: \(Swift.String(describing: pillarNotes)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension UpdateLensReviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensNotes = lensNotes {
            try encodeContainer.encode(lensNotes, forKey: .lensNotes)
        }
        if let pillarNotes = pillarNotes {
            var pillarNotesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .pillarNotes)
            for (dictKey0, pillarnotes0) in pillarNotes {
                try pillarNotesContainer.encode(pillarnotes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateLensReviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLensReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLensReviewOutputError>
}

public struct UpdateLensReviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLensReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLensReviewOutputError>
}

public struct UpdateLensReviewInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLensReviewInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLensReviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLensReviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLensReviewOutputError>
}

public struct UpdateLensReviewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLensReviewInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLensReviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLensReviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLensReviewOutputError>
}

/// Input for update lens review.
public struct UpdateLensReviewInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload.
    public var lensNotes: Swift.String?
    /// List of pillar notes of a lens review in a workload.
    public var pillarNotes: [Swift.String:Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        lensNotes: Swift.String? = nil,
        pillarNotes: [Swift.String:Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensNotes = lensNotes
        self.pillarNotes = pillarNotes
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewInputBody: Swift.Equatable {
    public let lensNotes: Swift.String?
    public let pillarNotes: [Swift.String:Swift.String]?
}

extension UpdateLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensNotes)
        lensNotes = lensNotesDecoded
        let pillarNotesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pillarNotes)
        var pillarNotesDecoded0: [Swift.String:Swift.String]? = nil
        if let pillarNotesContainer = pillarNotesContainer {
            pillarNotesDecoded0 = [Swift.String:Swift.String]()
            for (key0, notes0) in pillarNotesContainer {
                if let notes0 = notes0 {
                    pillarNotesDecoded0?[key0] = notes0
                }
            }
        }
        pillarNotes = pillarNotesDecoded0
    }
}

extension UpdateLensReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLensReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLensReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLensReviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLensReviewOutputResponse(lensReview: \(Swift.String(describing: lensReview)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension UpdateLensReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLensReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.workloadId = nil
        }
    }
}

/// Output of a update lens review call.
public struct UpdateLensReviewOutputResponse: Swift.Equatable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let lensReview: WellArchitectedClientTypes.LensReview?
}

extension UpdateLensReviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

public struct UpdateShareInvitationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShareInvitationOutputError>
}

extension UpdateShareInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateShareInvitationInput(shareInvitationAction: \(Swift.String(describing: shareInvitationAction)), shareInvitationId: \(Swift.String(describing: shareInvitationId)))"}
}

extension UpdateShareInvitationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareInvitationAction = shareInvitationAction {
            try encodeContainer.encode(shareInvitationAction.rawValue, forKey: .shareInvitationAction)
        }
    }
}

public struct UpdateShareInvitationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShareInvitationOutputError>
}

public struct UpdateShareInvitationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShareInvitationOutputError>
}

public struct UpdateShareInvitationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShareInvitationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateShareInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateShareInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShareInvitationOutputError>
}

public struct UpdateShareInvitationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShareInvitationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateShareInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let shareInvitationId = input.shareInvitationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("shareInvitationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/shareInvitations/\(shareInvitationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateShareInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShareInvitationOutputError>
}

/// Input for Update Share Invitation
public struct UpdateShareInvitationInput: Swift.Equatable {
    /// Share invitation action taken by contributor.
    /// This member is required.
    public var shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction?
    /// The ID assigned to the share invitation.
    /// This member is required.
    public var shareInvitationId: Swift.String?

    public init (
        shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction? = nil,
        shareInvitationId: Swift.String? = nil
    )
    {
        self.shareInvitationAction = shareInvitationAction
        self.shareInvitationId = shareInvitationId
    }
}

struct UpdateShareInvitationInputBody: Swift.Equatable {
    public let shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction?
}

extension UpdateShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationActionDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareInvitationAction.self, forKey: .shareInvitationAction)
        shareInvitationAction = shareInvitationActionDecoded
    }
}

extension UpdateShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateShareInvitationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateShareInvitationOutputResponse(shareInvitation: \(Swift.String(describing: shareInvitation)))"}
}

extension UpdateShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shareInvitation = output.shareInvitation
        } else {
            self.shareInvitation = nil
        }
    }
}

public struct UpdateShareInvitationOutputResponse: Swift.Equatable {
    /// The updated workload share invitation.
    public var shareInvitation: WellArchitectedClientTypes.ShareInvitation?

    public init (
        shareInvitation: WellArchitectedClientTypes.ShareInvitation? = nil
    )
    {
        self.shareInvitation = shareInvitation
    }
}

struct UpdateShareInvitationOutputResponseBody: Swift.Equatable {
    public let shareInvitation: WellArchitectedClientTypes.ShareInvitation?
}

extension UpdateShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitation = "ShareInvitation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareInvitation.self, forKey: .shareInvitation)
        shareInvitation = shareInvitationDecoded
    }
}

public struct UpdateWorkloadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadOutputError>
}

extension UpdateWorkloadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkloadInput(accountIds: \(Swift.String(describing: accountIds)), architecturalDesign: \(Swift.String(describing: architecturalDesign)), awsRegions: \(Swift.String(describing: awsRegions)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), improvementStatus: \(Swift.String(describing: improvementStatus)), industry: \(Swift.String(describing: industry)), industryType: \(Swift.String(describing: industryType)), isReviewOwnerUpdateAcknowledged: \(Swift.String(describing: isReviewOwnerUpdateAcknowledged)), nonAwsRegions: \(Swift.String(describing: nonAwsRegions)), notes: \(Swift.String(describing: notes)), pillarPriorities: \(Swift.String(describing: pillarPriorities)), reviewOwner: \(Swift.String(describing: reviewOwner)), workloadId: \(Swift.String(describing: workloadId)), workloadName: \(Swift.String(describing: workloadName)))"}
}

extension UpdateWorkloadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if isReviewOwnerUpdateAcknowledged != false {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

public struct UpdateWorkloadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadOutputError>
}

public struct UpdateWorkloadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkloadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkloadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadOutputError>
}

public struct UpdateWorkloadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadOutputError>
}

public struct UpdateWorkloadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateWorkloadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWorkloadInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadOutputError>
}

/// Input to update a workload.
public struct UpdateWorkloadInput: Swift.Equatable {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// The description for the workload.
    public var description: Swift.String?
    /// The environment for the workload.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The improvement status for a workload.
    public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
    public var isReviewOwnerUpdateAcknowledged: Swift.Bool
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    public var reviewOwner: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    public var workloadName: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        isReviewOwnerUpdateAcknowledged: Swift.Bool = false,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.description = description
        self.environment = environment
        self.improvementStatus = improvementStatus
        self.industry = industry
        self.industryType = industryType
        self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

struct UpdateWorkloadInputBody: Swift.Equatable {
    public let workloadName: Swift.String?
    public let description: Swift.String?
    public let environment: WellArchitectedClientTypes.WorkloadEnvironment?
    public let accountIds: [Swift.String]?
    public let awsRegions: [Swift.String]?
    public let nonAwsRegions: [Swift.String]?
    public let pillarPriorities: [Swift.String]?
    public let architecturalDesign: Swift.String?
    public let reviewOwner: Swift.String?
    public let isReviewOwnerUpdateAcknowledged: Swift.Bool
    public let industryType: Swift.String?
    public let industry: Swift.String?
    public let notes: Swift.String?
    public let improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
}

extension UpdateWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
    }
}

extension UpdateWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkloadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkloadOutputResponse(workload: \(Swift.String(describing: workload)))"}
}

extension UpdateWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// Output of an update workload call.
public struct UpdateWorkloadOutputResponse: Swift.Equatable {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init (
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct UpdateWorkloadOutputResponseBody: Swift.Equatable {
    public let workload: WellArchitectedClientTypes.Workload?
}

extension UpdateWorkloadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workload = "Workload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

public struct UpdateWorkloadShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadShareOutputError>
}

extension UpdateWorkloadShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkloadShareInput(permissionType: \(Swift.String(describing: permissionType)), shareId: \(Swift.String(describing: shareId)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension UpdateWorkloadShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
    }
}

public struct UpdateWorkloadShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadShareOutputError>
}

public struct UpdateWorkloadShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkloadShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkloadShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadShareOutputError>
}

public struct UpdateWorkloadShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateWorkloadShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWorkloadShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadShareOutputError>
}

public struct UpdateWorkloadShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkloadShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateWorkloadShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let shareId = input.shareId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("shareId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWorkloadShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkloadShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkloadShareOutputError>
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareInput: Swift.Equatable {
    /// Permission granted on a workload share.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The ID associated with the workload share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.permissionType = permissionType
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct UpdateWorkloadShareInputBody: Swift.Equatable {
    public let permissionType: WellArchitectedClientTypes.PermissionType?
}

extension UpdateWorkloadShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
    }
}

extension UpdateWorkloadShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkloadShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkloadShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkloadShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkloadShareOutputResponse(workloadId: \(Swift.String(describing: workloadId)), workloadShare: \(Swift.String(describing: workloadShare)))"}
}

extension UpdateWorkloadShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorkloadShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workloadId = output.workloadId
            self.workloadShare = output.workloadShare
        } else {
            self.workloadId = nil
            self.workloadShare = nil
        }
    }
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareOutputResponse: Swift.Equatable {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A workload share return object.
    public var workloadShare: WellArchitectedClientTypes.WorkloadShare?

    public init (
        workloadId: Swift.String? = nil,
        workloadShare: WellArchitectedClientTypes.WorkloadShare? = nil
    )
    {
        self.workloadId = workloadId
        self.workloadShare = workloadShare
    }
}

struct UpdateWorkloadShareOutputResponseBody: Swift.Equatable {
    public let workloadId: Swift.String?
    public let workloadShare: WellArchitectedClientTypes.WorkloadShare?
}

extension UpdateWorkloadShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadId = "WorkloadId"
        case workloadShare = "WorkloadShare"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadShare.self, forKey: .workloadShare)
        workloadShare = workloadShareDecoded
    }
}

public struct UpgradeLensReviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeLensReviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradeLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradeLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeLensReviewOutputError>
}

extension UpgradeLensReviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradeLensReviewInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), lensAlias: \(Swift.String(describing: lensAlias)), milestoneName: \(Swift.String(describing: milestoneName)), workloadId: \(Swift.String(describing: workloadId)))"}
}

extension UpgradeLensReviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

public struct UpgradeLensReviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeLensReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradeLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradeLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeLensReviewOutputError>
}

public struct UpgradeLensReviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeLensReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradeLensReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradeLensReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeLensReviewOutputError>
}

public struct UpgradeLensReviewInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeLensReviewInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpgradeLensReviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpgradeLensReviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeLensReviewOutputError>
}

public struct UpgradeLensReviewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeLensReviewInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpgradeLensReviewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workloadId = input.workloadId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workloadId is nil and needs a value for the path of this operation"))))
        }
        guard let lensAlias = input.lensAlias else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("lensAlias is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/upgrade"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpgradeLensReviewInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeLensReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeLensReviewOutputError>
}

public struct UpgradeLensReviewInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct UpgradeLensReviewInputBody: Swift.Equatable {
    public let milestoneName: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension UpgradeLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpgradeLensReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradeLensReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradeLensReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradeLensReviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradeLensReviewOutputResponse()"}
}

extension UpgradeLensReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpgradeLensReviewOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpgradeLensReviewOutputResponseBody: Swift.Equatable {
}

extension UpgradeLensReviewOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fields: \(Swift.String(describing: fields)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user input is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable.
    public var fields: [WellArchitectedClientTypes.ValidationExceptionField]?
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// The reason why the request failed validation.
    public var reason: WellArchitectedClientTypes.ValidationExceptionReason?

    public init (
        fields: [WellArchitectedClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WellArchitectedClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: WellArchitectedClientTypes.ValidationExceptionReason?
    public let fields: [WellArchitectedClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[WellArchitectedClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [WellArchitectedClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension WellArchitectedClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension WellArchitectedClientTypes {
    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Description of the error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name for which validation failed.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WellArchitectedClientTypes {
    /// The reason why the request failed validation.
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.VersionDifferences: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pillarDifferences = "PillarDifferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pillarDifferences = pillarDifferences {
            var pillarDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarDifferences)
            for pillardifferences0 in pillarDifferences {
                try pillarDifferencesContainer.encode(pillardifferences0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarDifferencesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.PillarDifference?].self, forKey: .pillarDifferences)
        var pillarDifferencesDecoded0:[WellArchitectedClientTypes.PillarDifference]? = nil
        if let pillarDifferencesContainer = pillarDifferencesContainer {
            pillarDifferencesDecoded0 = [WellArchitectedClientTypes.PillarDifference]()
            for structure0 in pillarDifferencesContainer {
                if let structure0 = structure0 {
                    pillarDifferencesDecoded0?.append(structure0)
                }
            }
        }
        pillarDifferences = pillarDifferencesDecoded0
    }
}

extension WellArchitectedClientTypes.VersionDifferences: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VersionDifferences(pillarDifferences: \(Swift.String(describing: pillarDifferences)))"}
}

extension WellArchitectedClientTypes {
    /// The differences between the base and latest versions of the lens.
    public struct VersionDifferences: Swift.Equatable {
        /// The differences between the base and latest versions of the lens.
        public var pillarDifferences: [WellArchitectedClientTypes.PillarDifference]?

        public init (
            pillarDifferences: [WellArchitectedClientTypes.PillarDifference]? = nil
        )
        {
            self.pillarDifferences = pillarDifferences
        }
    }

}

extension WellArchitectedClientTypes.Workload: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case owner = "Owner"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case reviewRestrictionDate = "ReviewRestrictionDate"
        case riskCounts = "RiskCounts"
        case shareInvitationId = "ShareInvitationId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if isReviewOwnerUpdateAcknowledged != false {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let reviewRestrictionDate = reviewRestrictionDate {
            try encodeContainer.encode(reviewRestrictionDate.timeIntervalSince1970, forKey: .reviewRestrictionDate)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let workloadArn = workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let reviewRestrictionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .reviewRestrictionDate)
        reviewRestrictionDate = reviewRestrictionDateDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WellArchitectedClientTypes.Workload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Workload(accountIds: \(Swift.String(describing: accountIds)), architecturalDesign: \(Swift.String(describing: architecturalDesign)), awsRegions: \(Swift.String(describing: awsRegions)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), improvementStatus: \(Swift.String(describing: improvementStatus)), industry: \(Swift.String(describing: industry)), industryType: \(Swift.String(describing: industryType)), isReviewOwnerUpdateAcknowledged: \(Swift.String(describing: isReviewOwnerUpdateAcknowledged)), lenses: \(Swift.String(describing: lenses)), nonAwsRegions: \(Swift.String(describing: nonAwsRegions)), notes: \(Swift.String(describing: notes)), owner: \(Swift.String(describing: owner)), pillarPriorities: \(Swift.String(describing: pillarPriorities)), reviewOwner: \(Swift.String(describing: reviewOwner)), reviewRestrictionDate: \(Swift.String(describing: reviewRestrictionDate)), riskCounts: \(Swift.String(describing: riskCounts)), shareInvitationId: \(Swift.String(describing: shareInvitationId)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), workloadArn: \(Swift.String(describing: workloadArn)), workloadId: \(Swift.String(describing: workloadId)), workloadName: \(Swift.String(describing: workloadName)))"}
}

extension WellArchitectedClientTypes {
    /// A workload return object.
    public struct Workload: Swift.Equatable {
        /// The list of Amazon Web Services account IDs associated with the workload.
        public var accountIds: [Swift.String]?
        /// The URL of the architectural design for the workload.
        public var architecturalDesign: Swift.String?
        /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
        public var awsRegions: [Swift.String]?
        /// The description for the workload.
        public var description: Swift.String?
        /// The environment for the workload.
        public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The industry for the workload.
        public var industry: Swift.String?
        /// The industry type for the workload. If specified, must be one of the following:
        ///
        /// * Agriculture
        ///
        /// * Automobile
        ///
        /// * Defense
        ///
        /// * Design and Engineering
        ///
        /// * Digital Advertising
        ///
        /// * Education
        ///
        /// * Environmental Protection
        ///
        /// * Financial Services
        ///
        /// * Gaming
        ///
        /// * General Public Services
        ///
        /// * Healthcare
        ///
        /// * Hospitality
        ///
        /// * InfoTech
        ///
        /// * Justice and Public Safety
        ///
        /// * Life Sciences
        ///
        /// * Manufacturing
        ///
        /// * Media & Entertainment
        ///
        /// * Mining & Resources
        ///
        /// * Oil & Gas
        ///
        /// * Power & Utilities
        ///
        /// * Professional Services
        ///
        /// * Real Estate & Construction
        ///
        /// * Retail & Wholesale
        ///
        /// * Social Protection
        ///
        /// * Telecommunications
        ///
        /// * Travel, Transportation & Logistics
        ///
        /// * Other
        public var industryType: Swift.String?
        /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
        public var isReviewOwnerUpdateAcknowledged: Swift.Bool
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias].
        public var lenses: [Swift.String]?
        /// The list of non-Amazon Web Services Regions associated with the workload.
        public var nonAwsRegions: [Swift.String]?
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
        public var pillarPriorities: [Swift.String]?
        /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
        public var reviewOwner: Swift.String?
        /// The date and time recorded.
        public var reviewRestrictionDate: ClientRuntime.Date?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags associated with the workload.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            accountIds: [Swift.String]? = nil,
            architecturalDesign: Swift.String? = nil,
            awsRegions: [Swift.String]? = nil,
            description: Swift.String? = nil,
            environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            industry: Swift.String? = nil,
            industryType: Swift.String? = nil,
            isReviewOwnerUpdateAcknowledged: Swift.Bool = false,
            lenses: [Swift.String]? = nil,
            nonAwsRegions: [Swift.String]? = nil,
            notes: Swift.String? = nil,
            owner: Swift.String? = nil,
            pillarPriorities: [Swift.String]? = nil,
            reviewOwner: Swift.String? = nil,
            reviewRestrictionDate: ClientRuntime.Date? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.accountIds = accountIds
            self.architecturalDesign = architecturalDesign
            self.awsRegions = awsRegions
            self.description = description
            self.environment = environment
            self.improvementStatus = improvementStatus
            self.industry = industry
            self.industryType = industryType
            self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
            self.lenses = lenses
            self.nonAwsRegions = nonAwsRegions
            self.notes = notes
            self.owner = owner
            self.pillarPriorities = pillarPriorities
            self.reviewOwner = reviewOwner
            self.reviewRestrictionDate = reviewRestrictionDate
            self.riskCounts = riskCounts
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes {
    /// The environment for the workload.
    public enum WorkloadEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preproduction
        case production
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEnvironment] {
            return [
                .preproduction,
                .production,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preproduction: return "PREPRODUCTION"
            case .production: return "PRODUCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadEnvironment(rawValue: rawValue) ?? WorkloadEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// The improvement status for a workload.
    public enum WorkloadImprovementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case notApplicable
        case notStarted
        case riskAcknowledged
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadImprovementStatus] {
            return [
                .complete,
                .inProgress,
                .notApplicable,
                .notStarted,
                .riskAcknowledged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inProgress: return "IN_PROGRESS"
            case .notApplicable: return "NOT_APPLICABLE"
            case .notStarted: return "NOT_STARTED"
            case .riskAcknowledged: return "RISK_ACKNOWLEDGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadImprovementStatus(rawValue: rawValue) ?? WorkloadImprovementStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.WorkloadShare: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case status = "Status"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedBy = sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
    }
}

extension WellArchitectedClientTypes.WorkloadShare: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkloadShare(permissionType: \(Swift.String(describing: permissionType)), shareId: \(Swift.String(describing: shareId)), sharedBy: \(Swift.String(describing: sharedBy)), sharedWith: \(Swift.String(describing: sharedWith)), status: \(Swift.String(describing: status)), workloadId: \(Swift.String(describing: workloadId)), workloadName: \(Swift.String(describing: workloadName)))"}
}

extension WellArchitectedClientTypes {
    /// A workload share return object.
    public struct WorkloadShare: Swift.Equatable {
        /// Permission granted on a workload share.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the workload share.
        public var shareId: Swift.String?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The status of a workload share.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.status = status
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes.WorkloadShareSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WellArchitectedClientTypes.WorkloadShareSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkloadShareSummary(permissionType: \(Swift.String(describing: permissionType)), shareId: \(Swift.String(describing: shareId)), sharedWith: \(Swift.String(describing: sharedWith)), status: \(Swift.String(describing: status)))"}
}

extension WellArchitectedClientTypes {
    /// A workload share summary return object.
    public struct WorkloadShareSummary: Swift.Equatable {
        /// Permission granted on a workload share.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the workload share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The status of a workload share.
        public var status: WellArchitectedClientTypes.ShareStatus?

        public init (
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.WorkloadSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementStatus = "ImprovementStatus"
        case lenses = "Lenses"
        case owner = "Owner"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let workloadArn = workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
    }
}

extension WellArchitectedClientTypes.WorkloadSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkloadSummary(improvementStatus: \(Swift.String(describing: improvementStatus)), lenses: \(Swift.String(describing: lenses)), owner: \(Swift.String(describing: owner)), riskCounts: \(Swift.String(describing: riskCounts)), updatedAt: \(Swift.String(describing: updatedAt)), workloadArn: \(Swift.String(describing: workloadArn)), workloadId: \(Swift.String(describing: workloadId)), workloadName: \(Swift.String(describing: workloadName)))"}
}

extension WellArchitectedClientTypes {
    /// A workload summary return object.
    public struct WorkloadSummary: Swift.Equatable {
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias].
        public var lenses: [Swift.String]?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            lenses: [Swift.String]? = nil,
            owner: Swift.String? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.improvementStatus = improvementStatus
            self.lenses = lenses
            self.owner = owner
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}
