// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension WellArchitectedClient {
    /// Associate a lens to a workload. Up to 10 lenses can be associated with a workload in a single API operation. A maximum of 20 lenses can be associated with a workload. Disclaimer By accessing and/or applying custom lenses created by another Amazon Web Services user or account, you acknowledge that custom lenses created by other users and shared with you are Third Party Content as defined in the Amazon Web Services Customer Agreement.
    func associateLenses(input: AssociateLensesInput) async throws -> AssociateLensesOutputResponse
    {
        typealias associateLensesContinuation = CheckedContinuation<AssociateLensesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateLensesContinuation) in
            associateLenses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a lens share. The owner of a lens can share it with other Amazon Web Services accounts and IAM users in the same Amazon Web Services Region. Shared access to a lens is not removed until the lens invitation is deleted. Disclaimer By sharing your custom lenses with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your custom lenses available to those other accounts. Those other accounts may continue to access and use your shared custom lenses even if you delete the custom lenses from your own Amazon Web Services account or terminate your Amazon Web Services account.
    func createLensShare(input: CreateLensShareInput) async throws -> CreateLensShareOutputResponse
    {
        typealias createLensShareContinuation = CheckedContinuation<CreateLensShareOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLensShareContinuation) in
            createLensShare(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a new lens version. A lens can have up to 100 versions. After a lens has been imported, create a new lens version to publish it. The owner of a lens can share the lens with other Amazon Web Services accounts and IAM users in the same Amazon Web Services Region. Only the owner of a lens can delete it.
    func createLensVersion(input: CreateLensVersionInput) async throws -> CreateLensVersionOutputResponse
    {
        typealias createLensVersionContinuation = CheckedContinuation<CreateLensVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLensVersionContinuation) in
            createLensVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a milestone for an existing workload.
    func createMilestone(input: CreateMilestoneInput) async throws -> CreateMilestoneOutputResponse
    {
        typealias createMilestoneContinuation = CheckedContinuation<CreateMilestoneOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createMilestoneContinuation) in
            createMilestone(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a new workload. The owner of a workload can share the workload with other Amazon Web Services accounts and IAM users in the same Amazon Web Services Region. Only the owner of a workload can delete it. For more information, see [Defining a Workload](https://docs.aws.amazon.com/wellarchitected/latest/userguide/define-workload.html) in the Well-Architected Tool User Guide.
    func createWorkload(input: CreateWorkloadInput) async throws -> CreateWorkloadOutputResponse
    {
        typealias createWorkloadContinuation = CheckedContinuation<CreateWorkloadOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorkloadContinuation) in
            createWorkload(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a workload share. The owner of a workload can share it with other Amazon Web Services accounts and IAM users in the same Amazon Web Services Region. Shared access to a workload is not removed until the workload invitation is deleted. For more information, see [Sharing a Workload](https://docs.aws.amazon.com/wellarchitected/latest/userguide/workloads-sharing.html) in the Well-Architected Tool User Guide.
    func createWorkloadShare(input: CreateWorkloadShareInput) async throws -> CreateWorkloadShareOutputResponse
    {
        typealias createWorkloadShareContinuation = CheckedContinuation<CreateWorkloadShareOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createWorkloadShareContinuation) in
            createWorkloadShare(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete an existing lens. Only the owner of a lens can delete it. After the lens is deleted, Amazon Web Services accounts and IAM users that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads. Disclaimer By sharing your custom lenses with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your custom lenses available to those other accounts. Those other accounts may continue to access and use your shared custom lenses even if you delete the custom lenses from your own Amazon Web Services account or terminate your Amazon Web Services account.
    func deleteLens(input: DeleteLensInput) async throws -> DeleteLensOutputResponse
    {
        typealias deleteLensContinuation = CheckedContinuation<DeleteLensOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLensContinuation) in
            deleteLens(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a lens share. After the lens share is deleted, Amazon Web Services accounts and IAM users that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads. Disclaimer By sharing your custom lenses with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your custom lenses available to those other accounts. Those other accounts may continue to access and use your shared custom lenses even if you delete the custom lenses from your own Amazon Web Services account or terminate your Amazon Web Services account.
    func deleteLensShare(input: DeleteLensShareInput) async throws -> DeleteLensShareOutputResponse
    {
        typealias deleteLensShareContinuation = CheckedContinuation<DeleteLensShareOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLensShareContinuation) in
            deleteLensShare(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete an existing workload.
    func deleteWorkload(input: DeleteWorkloadInput) async throws -> DeleteWorkloadOutputResponse
    {
        typealias deleteWorkloadContinuation = CheckedContinuation<DeleteWorkloadOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteWorkloadContinuation) in
            deleteWorkload(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a workload share.
    func deleteWorkloadShare(input: DeleteWorkloadShareInput) async throws -> DeleteWorkloadShareOutputResponse
    {
        typealias deleteWorkloadShareContinuation = CheckedContinuation<DeleteWorkloadShareOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteWorkloadShareContinuation) in
            deleteWorkloadShare(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Disassociate a lens from a workload. Up to 10 lenses can be disassociated from a workload in a single API operation. The Amazon Web Services Well-Architected Framework lens (wellarchitected) cannot be removed from a workload.
    func disassociateLenses(input: DisassociateLensesInput) async throws -> DisassociateLensesOutputResponse
    {
        typealias disassociateLensesContinuation = CheckedContinuation<DisassociateLensesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateLensesContinuation) in
            disassociateLenses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Export an existing lens. Lenses are defined in JSON. For more information, see [JSON format specification](https://docs.aws.amazon.com/wellarchitected/latest/userguide/lenses-format-specification.html) in the Well-Architected Tool User Guide. Only the owner of a lens can export it. Disclaimer Do not include or gather personal identifiable information (PII) of end users or other identifiable individuals in or via your custom lenses. If your custom lens or those shared with you and used in your account do include or collect PII you are responsible for: ensuring that the included PII is processed in accordance with applicable law, providing adequate privacy notices, and obtaining necessary consents for processing such data.
    func exportLens(input: ExportLensInput) async throws -> ExportLensOutputResponse
    {
        typealias exportLensContinuation = CheckedContinuation<ExportLensOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: exportLensContinuation) in
            exportLens(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get the answer to a specific question in a workload review.
    func getAnswer(input: GetAnswerInput) async throws -> GetAnswerOutputResponse
    {
        typealias getAnswerContinuation = CheckedContinuation<GetAnswerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAnswerContinuation) in
            getAnswer(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get an existing lens.
    func getLens(input: GetLensInput) async throws -> GetLensOutputResponse
    {
        typealias getLensContinuation = CheckedContinuation<GetLensOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLensContinuation) in
            getLens(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get lens review.
    func getLensReview(input: GetLensReviewInput) async throws -> GetLensReviewOutputResponse
    {
        typealias getLensReviewContinuation = CheckedContinuation<GetLensReviewOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLensReviewContinuation) in
            getLensReview(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get lens review report.
    func getLensReviewReport(input: GetLensReviewReportInput) async throws -> GetLensReviewReportOutputResponse
    {
        typealias getLensReviewReportContinuation = CheckedContinuation<GetLensReviewReportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLensReviewReportContinuation) in
            getLensReviewReport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get lens version differences.
    func getLensVersionDifference(input: GetLensVersionDifferenceInput) async throws -> GetLensVersionDifferenceOutputResponse
    {
        typealias getLensVersionDifferenceContinuation = CheckedContinuation<GetLensVersionDifferenceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLensVersionDifferenceContinuation) in
            getLensVersionDifference(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get a milestone for an existing workload.
    func getMilestone(input: GetMilestoneInput) async throws -> GetMilestoneOutputResponse
    {
        typealias getMilestoneContinuation = CheckedContinuation<GetMilestoneOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMilestoneContinuation) in
            getMilestone(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get an existing workload.
    func getWorkload(input: GetWorkloadInput) async throws -> GetWorkloadOutputResponse
    {
        typealias getWorkloadContinuation = CheckedContinuation<GetWorkloadOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getWorkloadContinuation) in
            getWorkload(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Import a new lens. The lens cannot be applied to workloads or shared with other Amazon Web Services accounts until it's published with [CreateLensVersion] Lenses are defined in JSON. For more information, see [JSON format specification](https://docs.aws.amazon.com/wellarchitected/latest/userguide/lenses-format-specification.html) in the Well-Architected Tool User Guide. A custom lens cannot exceed 500 KB in size. Disclaimer Do not include or gather personal identifiable information (PII) of end users or other identifiable individuals in or via your custom lenses. If your custom lens or those shared with you and used in your account do include or collect PII you are responsible for: ensuring that the included PII is processed in accordance with applicable law, providing adequate privacy notices, and obtaining necessary consents for processing such data.
    func importLens(input: ImportLensInput) async throws -> ImportLensOutputResponse
    {
        typealias importLensContinuation = CheckedContinuation<ImportLensOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: importLensContinuation) in
            importLens(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List of answers.
    func listAnswers(input: ListAnswersInput) async throws -> ListAnswersOutputResponse
    {
        typealias listAnswersContinuation = CheckedContinuation<ListAnswersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listAnswersContinuation) in
            listAnswers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List lens review improvements.
    func listLensReviewImprovements(input: ListLensReviewImprovementsInput) async throws -> ListLensReviewImprovementsOutputResponse
    {
        typealias listLensReviewImprovementsContinuation = CheckedContinuation<ListLensReviewImprovementsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLensReviewImprovementsContinuation) in
            listLensReviewImprovements(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List lens reviews.
    func listLensReviews(input: ListLensReviewsInput) async throws -> ListLensReviewsOutputResponse
    {
        typealias listLensReviewsContinuation = CheckedContinuation<ListLensReviewsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLensReviewsContinuation) in
            listLensReviews(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the lens shares associated with the lens.
    func listLensShares(input: ListLensSharesInput) async throws -> ListLensSharesOutputResponse
    {
        typealias listLensSharesContinuation = CheckedContinuation<ListLensSharesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLensSharesContinuation) in
            listLensShares(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the available lenses.
    func listLenses(input: ListLensesInput) async throws -> ListLensesOutputResponse
    {
        typealias listLensesContinuation = CheckedContinuation<ListLensesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLensesContinuation) in
            listLenses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List all milestones for an existing workload.
    func listMilestones(input: ListMilestonesInput) async throws -> ListMilestonesOutputResponse
    {
        typealias listMilestonesContinuation = CheckedContinuation<ListMilestonesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listMilestonesContinuation) in
            listMilestones(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List lens notifications.
    func listNotifications(input: ListNotificationsInput) async throws -> ListNotificationsOutputResponse
    {
        typealias listNotificationsContinuation = CheckedContinuation<ListNotificationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listNotificationsContinuation) in
            listNotifications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the workload invitations.
    func listShareInvitations(input: ListShareInvitationsInput) async throws -> ListShareInvitationsOutputResponse
    {
        typealias listShareInvitationsContinuation = CheckedContinuation<ListShareInvitationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listShareInvitationsContinuation) in
            listShareInvitations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the tags for a resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the workload shares associated with the workload.
    func listWorkloadShares(input: ListWorkloadSharesInput) async throws -> ListWorkloadSharesOutputResponse
    {
        typealias listWorkloadSharesContinuation = CheckedContinuation<ListWorkloadSharesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorkloadSharesContinuation) in
            listWorkloadShares(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List workloads. Paginated.
    func listWorkloads(input: ListWorkloadsInput) async throws -> ListWorkloadsOutputResponse
    {
        typealias listWorkloadsContinuation = CheckedContinuation<ListWorkloadsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listWorkloadsContinuation) in
            listWorkloads(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds one or more tags to the specified resource.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes specified tags from a resource. To specify multiple tags, use separate tagKeys parameters, for example: DELETE /tags/WorkloadArn?tagKeys=key1&tagKeys=key2
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update the answer to a specific question in a workload review.
    func updateAnswer(input: UpdateAnswerInput) async throws -> UpdateAnswerOutputResponse
    {
        typealias updateAnswerContinuation = CheckedContinuation<UpdateAnswerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateAnswerContinuation) in
            updateAnswer(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update lens review.
    func updateLensReview(input: UpdateLensReviewInput) async throws -> UpdateLensReviewOutputResponse
    {
        typealias updateLensReviewContinuation = CheckedContinuation<UpdateLensReviewOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateLensReviewContinuation) in
            updateLensReview(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update a workload invitation.
    func updateShareInvitation(input: UpdateShareInvitationInput) async throws -> UpdateShareInvitationOutputResponse
    {
        typealias updateShareInvitationContinuation = CheckedContinuation<UpdateShareInvitationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateShareInvitationContinuation) in
            updateShareInvitation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update an existing workload.
    func updateWorkload(input: UpdateWorkloadInput) async throws -> UpdateWorkloadOutputResponse
    {
        typealias updateWorkloadContinuation = CheckedContinuation<UpdateWorkloadOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateWorkloadContinuation) in
            updateWorkload(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update a workload share.
    func updateWorkloadShare(input: UpdateWorkloadShareInput) async throws -> UpdateWorkloadShareOutputResponse
    {
        typealias updateWorkloadShareContinuation = CheckedContinuation<UpdateWorkloadShareOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateWorkloadShareContinuation) in
            updateWorkloadShare(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Upgrade lens review.
    func upgradeLensReview(input: UpgradeLensReviewInput) async throws -> UpgradeLensReviewOutputResponse
    {
        typealias upgradeLensReviewContinuation = CheckedContinuation<UpgradeLensReviewOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: upgradeLensReviewContinuation) in
            upgradeLensReview(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
