// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to use this operation with the given parameters.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Action: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case status = "Status"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionStatus.self, forKey: .status)
        status = statusDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension BudgetsClientTypes.Action: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Action(actionId: \(Swift.String(describing: actionId)), actionThreshold: \(Swift.String(describing: actionThreshold)), actionType: \(Swift.String(describing: actionType)), approvalModel: \(Swift.String(describing: approvalModel)), budgetName: \(Swift.String(describing: budgetName)), definition: \(Swift.String(describing: definition)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), notificationType: \(Swift.String(describing: notificationType)), status: \(Swift.String(describing: status)), subscribers: \(Swift.String(describing: subscribers)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			A budget action resource.
    /// 		</p>
    public struct Action: Swift.Equatable {
        /// <p>
        /// 			A system-generated universally unique identifier (UUID) for the action.
        /// 		</p>
        public let actionId: Swift.String?
        /// <p>
        /// 			The trigger threshold of the action.
        /// 		</p>
        public let actionThreshold: BudgetsClientTypes.ActionThreshold?
        /// <p>
        /// 			The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
        /// 		</p>
        public let actionType: BudgetsClientTypes.ActionType?
        /// <p>
        /// 			This specifies if the action needs manual or automatic approval.
        /// 		</p>
        public let approvalModel: BudgetsClientTypes.ApprovalModel?
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        public let budgetName: Swift.String?
        /// <p>
        /// 			Where you specify all of the type-specific parameters.
        /// 		</p>
        public let definition: BudgetsClientTypes.Definition?
        /// <p>
        /// 			The role passed for action execution and reversion. Roles and actions must be in the same account.
        /// 		</p>
        public let executionRoleArn: Swift.String?
        /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
        public let notificationType: BudgetsClientTypes.NotificationType?
        /// <p>
        /// 			The status of action.
        /// 		</p>
        public let status: BudgetsClientTypes.ActionStatus?
        /// <p> A list of subscribers.</p>
        public let subscribers: [BudgetsClientTypes.Subscriber]?

        public init (
            actionId: Swift.String? = nil,
            actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
            actionType: BudgetsClientTypes.ActionType? = nil,
            approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
            budgetName: Swift.String? = nil,
            definition: BudgetsClientTypes.Definition? = nil,
            executionRoleArn: Swift.String? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.actionId = actionId
            self.actionThreshold = actionThreshold
            self.actionType = actionType
            self.approvalModel = approvalModel
            self.budgetName = budgetName
            self.definition = definition
            self.executionRoleArn = executionRoleArn
            self.notificationType = notificationType
            self.status = status
            self.subscribers = subscribers
        }
    }

}

extension BudgetsClientTypes.ActionHistory: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionHistoryDetails = "ActionHistoryDetails"
        case eventType = "EventType"
        case status = "Status"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionHistoryDetails = actionHistoryDetails {
            try encodeContainer.encode(actionHistoryDetails, forKey: .actionHistoryDetails)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionStatus.self, forKey: .status)
        status = statusDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let actionHistoryDetailsDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionHistoryDetails.self, forKey: .actionHistoryDetails)
        actionHistoryDetails = actionHistoryDetailsDecoded
    }
}

extension BudgetsClientTypes.ActionHistory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionHistory(actionHistoryDetails: \(Swift.String(describing: actionHistoryDetails)), eventType: \(Swift.String(describing: eventType)), status: \(Swift.String(describing: status)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			The historical records for a budget action.
    /// 		</p>
    public struct ActionHistory: Swift.Equatable {
        /// <p>
        /// 			The description of details of the event.
        /// 		</p>
        public let actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails?
        /// <p>
        /// 			This distinguishes between whether the events are triggered by the user or generated by the system.
        /// 		</p>
        public let eventType: BudgetsClientTypes.EventType?
        /// <p>
        /// 			The status of action at the time of the event.
        /// 		</p>
        public let status: BudgetsClientTypes.ActionStatus?
        /// <p> A generic time stamp. In Java, it is transformed to a <code>Date</code> object.</p>
        public let timestamp: ClientRuntime.Date?

        public init (
            actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails? = nil,
            eventType: BudgetsClientTypes.EventType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.actionHistoryDetails = actionHistoryDetails
            self.eventType = eventType
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension BudgetsClientTypes.ActionHistoryDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension BudgetsClientTypes.ActionHistoryDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionHistoryDetails(action: \(Swift.String(describing: action)), message: \(Swift.String(describing: message)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			The description of details of the event.
    /// 		</p>
    public struct ActionHistoryDetails: Swift.Equatable {
        /// <p>
        /// 			The budget action resource.
        /// 		</p>
        public let action: BudgetsClientTypes.Action?
        /// <p> A generic string.</p>
        public let message: Swift.String?

        public init (
            action: BudgetsClientTypes.Action? = nil,
            message: Swift.String? = nil
        )
        {
            self.action = action
            self.message = message
        }
    }

}

extension BudgetsClientTypes {
    public enum ActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executionFailure
        case executionInProgress
        case executionSuccess
        case pending
        case resetFailure
        case resetInProgress
        case reverseFailure
        case reverseInProgress
        case reverseSuccess
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionStatus] {
            return [
                .executionFailure,
                .executionInProgress,
                .executionSuccess,
                .pending,
                .resetFailure,
                .resetInProgress,
                .reverseFailure,
                .reverseInProgress,
                .reverseSuccess,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executionFailure: return "EXECUTION_FAILURE"
            case .executionInProgress: return "EXECUTION_IN_PROGRESS"
            case .executionSuccess: return "EXECUTION_SUCCESS"
            case .pending: return "PENDING"
            case .resetFailure: return "RESET_FAILURE"
            case .resetInProgress: return "RESET_IN_PROGRESS"
            case .reverseFailure: return "REVERSE_FAILURE"
            case .reverseInProgress: return "REVERSE_IN_PROGRESS"
            case .reverseSuccess: return "REVERSE_SUCCESS"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionStatus(rawValue: rawValue) ?? ActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    public enum ActionSubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopEc2
        case stopRds
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionSubType] {
            return [
                .stopEc2,
                .stopRds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopEc2: return "STOP_EC2_INSTANCES"
            case .stopRds: return "STOP_RDS_INSTANCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionSubType(rawValue: rawValue) ?? ActionSubType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.ActionThreshold: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionThresholdType = "ActionThresholdType"
        case actionThresholdValue = "ActionThresholdValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionThresholdType = actionThresholdType {
            try encodeContainer.encode(actionThresholdType.rawValue, forKey: .actionThresholdType)
        }
        if actionThresholdValue != 0.0 {
            try encodeContainer.encode(actionThresholdValue, forKey: .actionThresholdValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionThresholdValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .actionThresholdValue)
        actionThresholdValue = actionThresholdValueDecoded
        let actionThresholdTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ThresholdType.self, forKey: .actionThresholdType)
        actionThresholdType = actionThresholdTypeDecoded
    }
}

extension BudgetsClientTypes.ActionThreshold: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionThreshold(actionThresholdType: \(Swift.String(describing: actionThresholdType)), actionThresholdValue: \(Swift.String(describing: actionThresholdValue)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			The trigger threshold of the action.
    /// 		</p>
    public struct ActionThreshold: Swift.Equatable {
        /// <p> The type of threshold for a notification.</p>
        public let actionThresholdType: BudgetsClientTypes.ThresholdType?
        /// <p> The threshold of a notification.</p>
        public let actionThresholdValue: Swift.Double

        public init (
            actionThresholdType: BudgetsClientTypes.ThresholdType? = nil,
            actionThresholdValue: Swift.Double = 0.0
        )
        {
            self.actionThresholdType = actionThresholdType
            self.actionThresholdValue = actionThresholdValue
        }
    }

}

extension BudgetsClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case scp
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .iam,
                .scp,
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "APPLY_IAM_POLICY"
            case .scp: return "APPLY_SCP_POLICY"
            case .ssm: return "RUN_SSM_DOCUMENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    public enum ApprovalModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalModel] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApprovalModel(rawValue: rawValue) ?? ApprovalModel.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.Budget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetLimit = "BudgetLimit"
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case calculatedSpend = "CalculatedSpend"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case lastUpdatedTime = "LastUpdatedTime"
        case plannedBudgetLimits = "PlannedBudgetLimits"
        case timePeriod = "TimePeriod"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetLimit = budgetLimit {
            try encodeContainer.encode(budgetLimit, forKey: .budgetLimit)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let calculatedSpend = calculatedSpend {
            try encodeContainer.encode(calculatedSpend, forKey: .calculatedSpend)
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .costFilters)
            for (dictKey0, costfilters0) in costFilters {
                try costFiltersContainer.encode(costfilters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let costTypes = costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let plannedBudgetLimits = plannedBudgetLimits {
            var plannedBudgetLimitsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .plannedBudgetLimits)
            for (dictKey0, plannedbudgetlimits0) in plannedBudgetLimits {
                try plannedBudgetLimitsContainer.encode(plannedbudgetlimits0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetLimitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .budgetLimit)
        budgetLimit = budgetLimitDecoded
        let plannedBudgetLimitsContainer = try containerValues.decodeIfPresent([Swift.String: BudgetsClientTypes.Spend?].self, forKey: .plannedBudgetLimits)
        var plannedBudgetLimitsDecoded0: [Swift.String:BudgetsClientTypes.Spend]? = nil
        if let plannedBudgetLimitsContainer = plannedBudgetLimitsContainer {
            plannedBudgetLimitsDecoded0 = [Swift.String:BudgetsClientTypes.Spend]()
            for (key0, spend0) in plannedBudgetLimitsContainer {
                if let spend0 = spend0 {
                    plannedBudgetLimitsDecoded0?[key0] = spend0
                }
            }
        }
        plannedBudgetLimits = plannedBudgetLimitsDecoded0
        let costFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [Swift.String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [Swift.String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let calculatedSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CalculatedSpend.self, forKey: .calculatedSpend)
        calculatedSpend = calculatedSpendDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension BudgetsClientTypes.Budget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Budget(budgetLimit: \(Swift.String(describing: budgetLimit)), budgetName: \(Swift.String(describing: budgetName)), budgetType: \(Swift.String(describing: budgetType)), calculatedSpend: \(Swift.String(describing: calculatedSpend)), costFilters: \(Swift.String(describing: costFilters)), costTypes: \(Swift.String(describing: costTypes)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), plannedBudgetLimits: \(Swift.String(describing: plannedBudgetLimits)), timePeriod: \(Swift.String(describing: timePeriod)), timeUnit: \(Swift.String(describing: timeUnit)))"}
}

extension BudgetsClientTypes {
    /// <p>Represents the output of the <code>CreateBudget</code> operation. The content consists of the detailed metadata and data file information, and the current status of the <code>budget</code> object.</p>
    /// 		       <p>This is the ARN pattern for a budget: </p>
    /// 		       <p>
    ///             <code>arn:aws:budgets::AccountId:budget/budgetName</code>
    ///          </p>
    public struct Budget: Swift.Equatable {
        /// <p>The total amount of cost, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage that you want to track with your budget.</p>
        /// 		       <p>
        ///             <code>BudgetLimit</code> is required for cost or usage budgets, but optional for RI or Savings Plans utilization or coverage budgets. RI and Savings Plans utilization or coverage budgets default to <code>100</code>, which is the only valid value for RI or Savings Plans utilization or coverage budgets. You can't use <code>BudgetLimit</code> with <code>PlannedBudgetLimits</code> for <code>CreateBudget</code> and <code>UpdateBudget</code> actions. </p>
        public let budgetLimit: BudgetsClientTypes.Spend?
        /// <p>The name of a budget. The name must be unique within an account. The <code>:</code> and <code>\</code> characters aren't allowed in <code>BudgetName</code>.</p>
        public let budgetName: Swift.String?
        /// <p>Whether this budget tracks costs, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage.</p>
        public let budgetType: BudgetsClientTypes.BudgetType?
        /// <p>The actual and forecasted cost or usage that the budget tracks.</p>
        public let calculatedSpend: BudgetsClientTypes.CalculatedSpend?
        /// <p>The cost filters, such as service or tag, that are applied to a budget.</p>
        /// 		       <p>AWS Budgets supports the following services as a filter for RI budgets:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>Amazon Elastic Compute Cloud - Compute</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Amazon Redshift</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Amazon Relational Database Service</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Amazon ElastiCache</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Amazon Elasticsearch Service</p>
        /// 			         </li>
        ///          </ul>
        public let costFilters: [Swift.String:[Swift.String]]?
        /// <p>The types of costs that are included in this <code>COST</code> budget.</p>
        /// 		       <p>
        ///             <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, and <code>SAVINGS_PLANS_COVERAGE</code> budgets do not have <code>CostTypes</code>.</p>
        public let costTypes: BudgetsClientTypes.CostTypes?
        /// <p>The last time that you updated this budget.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>A map containing multiple <code>BudgetLimit</code>, including current or future limits.</p>
        /// 		       <p>
        ///             <code>PlannedBudgetLimits</code> is available for cost or usage budget and supports monthly and quarterly <code>TimeUnit</code>. </p>
        /// 		       <p>For monthly budgets, provide 12 months of <code>PlannedBudgetLimits</code> values. This must start from the current month and include the next 11 months. The <code>key</code> is the start of the month, <code>UTC</code> in epoch seconds. </p>
        /// 		       <p>For quarterly budgets, provide 4 quarters of <code>PlannedBudgetLimits</code> value entries in standard calendar quarter increments. This must start from the current quarter and include the next 3 quarters. The <code>key</code> is the start of the quarter, <code>UTC</code> in epoch seconds. </p>
        /// 		       <p>If the planned budget expires before 12 months for monthly or 4 quarters for quarterly, provide the <code>PlannedBudgetLimits</code> values only for the remaining periods.</p>
        /// 		       <p>If the budget begins at a date in the future, provide <code>PlannedBudgetLimits</code> values from the start date of the budget. </p>
        /// 		       <p>After all of the <code>BudgetLimit</code> values in <code>PlannedBudgetLimits</code> are used, the budget continues to use the last limit as the <code>BudgetLimit</code>. At that point, the planned budget provides the same experience as a fixed budget. </p>
        /// 		       <p>
        ///             <code>DescribeBudget</code> and <code>DescribeBudgets</code> response along with <code>PlannedBudgetLimits</code> will also contain <code>BudgetLimit</code> representing the current month or quarter limit present in <code>PlannedBudgetLimits</code>. This only applies to budgets created with <code>PlannedBudgetLimits</code>. Budgets created without <code>PlannedBudgetLimits</code> will only contain <code>BudgetLimit</code>, and no <code>PlannedBudgetLimits</code>.</p>
        public let plannedBudgetLimits: [Swift.String:BudgetsClientTypes.Spend]?
        /// <p>The period of time that is covered by a budget. The period has a start date and an end date. The start date must come before the end date. The end date must come before <code>06/15/87 00:00 UTC</code>. </p>
        /// 		       <p>If you create your budget and don't specify a start date, AWS defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose <code>DAILY</code>, and didn't set a start date, AWS set your start date to <code>01/24/18 00:00 UTC</code>. If you chose <code>MONTHLY</code>, AWS set your start date to <code>01/01/18 00:00 UTC</code>. If you didn't specify an end date, AWS set your end date to <code>06/15/87 00:00 UTC</code>. The defaults are the same for the AWS Billing and Cost Management console and the API. </p>
        /// 		       <p>You can change either date with the <code>UpdateBudget</code> operation.</p>
        /// 		       <p>After the end date, AWS deletes the budget and all associated notifications and subscribers.</p>
        public let timePeriod: BudgetsClientTypes.TimePeriod?
        /// <p>The length of time until a budget resets the actual and forecasted spend.</p>
        public let timeUnit: BudgetsClientTypes.TimeUnit?

        public init (
            budgetLimit: BudgetsClientTypes.Spend? = nil,
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            calculatedSpend: BudgetsClientTypes.CalculatedSpend? = nil,
            costFilters: [Swift.String:[Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            plannedBudgetLimits: [Swift.String:BudgetsClientTypes.Spend]? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.budgetLimit = budgetLimit
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.calculatedSpend = calculatedSpend
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.lastUpdatedTime = lastUpdatedTime
            self.plannedBudgetLimits = plannedBudgetLimits
            self.timePeriod = timePeriod
            self.timeUnit = timeUnit
        }
    }

}

extension BudgetsClientTypes.BudgetPerformanceHistory: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case budgetedAndActualAmountsList = "BudgetedAndActualAmountsList"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let budgetedAndActualAmountsList = budgetedAndActualAmountsList {
            var budgetedAndActualAmountsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .budgetedAndActualAmountsList)
            for budgetedandactualamountslist0 in budgetedAndActualAmountsList {
                try budgetedAndActualAmountsListContainer.encode(budgetedandactualamountslist0)
            }
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .costFilters)
            for (dictKey0, costfilters0) in costFilters {
                try costFiltersContainer.encode(costfilters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let costTypes = costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let costFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [Swift.String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [Swift.String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let budgetedAndActualAmountsListContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.BudgetedAndActualAmounts?].self, forKey: .budgetedAndActualAmountsList)
        var budgetedAndActualAmountsListDecoded0:[BudgetsClientTypes.BudgetedAndActualAmounts]? = nil
        if let budgetedAndActualAmountsListContainer = budgetedAndActualAmountsListContainer {
            budgetedAndActualAmountsListDecoded0 = [BudgetsClientTypes.BudgetedAndActualAmounts]()
            for structure0 in budgetedAndActualAmountsListContainer {
                if let structure0 = structure0 {
                    budgetedAndActualAmountsListDecoded0?.append(structure0)
                }
            }
        }
        budgetedAndActualAmountsList = budgetedAndActualAmountsListDecoded0
    }
}

extension BudgetsClientTypes.BudgetPerformanceHistory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BudgetPerformanceHistory(budgetName: \(Swift.String(describing: budgetName)), budgetType: \(Swift.String(describing: budgetType)), budgetedAndActualAmountsList: \(Swift.String(describing: budgetedAndActualAmountsList)), costFilters: \(Swift.String(describing: costFilters)), costTypes: \(Swift.String(describing: costTypes)), timeUnit: \(Swift.String(describing: timeUnit)))"}
}

extension BudgetsClientTypes {
    /// <p>A history of the state of a budget at the end of the budget's specified time period.</p>
    public struct BudgetPerformanceHistory: Swift.Equatable {
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        public let budgetName: Swift.String?
        /// <p> The type of a budget. It must be one of the following types: </p>
        /// 		       <p>
        ///             <code>COST</code>, <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, or <code>SAVINGS_PLANS_COVERAGE</code>.</p>
        public let budgetType: BudgetsClientTypes.BudgetType?
        /// <p>A list of amounts of cost or usage that you created budgets for, compared to your actual costs or usage.</p>
        public let budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]?
        /// <p>The history of the cost filters for a budget during the specified time period.</p>
        public let costFilters: [Swift.String:[Swift.String]]?
        /// <p>The history of the cost types for a budget during the specified time period.</p>
        public let costTypes: BudgetsClientTypes.CostTypes?
        /// <p> The time unit of the budget, such as MONTHLY or QUARTERLY.</p>
        public let timeUnit: BudgetsClientTypes.TimeUnit?

        public init (
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]? = nil,
            costFilters: [Swift.String:[Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.budgetedAndActualAmountsList = budgetedAndActualAmountsList
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.timeUnit = timeUnit
        }
    }

}

extension BudgetsClientTypes {
    /// <p> The type of a budget. It must be one of the following types: </p>
    /// 		       <p>
    ///             <code>COST</code>, <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, or <code>SAVINGS_PLANS_COVERAGE</code>.</p>
    public enum BudgetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cost
        case ricoverage
        case riutilization
        case spcoverage
        case sputilization
        case usage
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetType] {
            return [
                .cost,
                .ricoverage,
                .riutilization,
                .spcoverage,
                .sputilization,
                .usage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cost: return "COST"
            case .ricoverage: return "RI_COVERAGE"
            case .riutilization: return "RI_UTILIZATION"
            case .spcoverage: return "SAVINGS_PLANS_COVERAGE"
            case .sputilization: return "SAVINGS_PLANS_UTILIZATION"
            case .usage: return "USAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BudgetType(rawValue: rawValue) ?? BudgetType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.BudgetedAndActualAmounts: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualAmount = "ActualAmount"
        case budgetedAmount = "BudgetedAmount"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualAmount = actualAmount {
            try encodeContainer.encode(actualAmount, forKey: .actualAmount)
        }
        if let budgetedAmount = budgetedAmount {
            try encodeContainer.encode(budgetedAmount, forKey: .budgetedAmount)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetedAmountDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .budgetedAmount)
        budgetedAmount = budgetedAmountDecoded
        let actualAmountDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .actualAmount)
        actualAmount = actualAmountDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
    }
}

extension BudgetsClientTypes.BudgetedAndActualAmounts: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BudgetedAndActualAmounts(actualAmount: \(Swift.String(describing: actualAmount)), budgetedAmount: \(Swift.String(describing: budgetedAmount)), timePeriod: \(Swift.String(describing: timePeriod)))"}
}

extension BudgetsClientTypes {
    /// <p>The amount of cost or usage that you created the budget for, compared to your actual costs or usage.</p>
    public struct BudgetedAndActualAmounts: Swift.Equatable {
        /// <p>Your actual costs or usage for a budget period.</p>
        public let actualAmount: BudgetsClientTypes.Spend?
        /// <p>The amount of cost or usage that you created the budget for.</p>
        public let budgetedAmount: BudgetsClientTypes.Spend?
        /// <p>The time period covered by this budget comparison.</p>
        public let timePeriod: BudgetsClientTypes.TimePeriod?

        public init (
            actualAmount: BudgetsClientTypes.Spend? = nil,
            budgetedAmount: BudgetsClientTypes.Spend? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil
        )
        {
            self.actualAmount = actualAmount
            self.budgetedAmount = budgetedAmount
            self.timePeriod = timePeriod
        }
    }

}

extension BudgetsClientTypes.CalculatedSpend: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualSpend = "ActualSpend"
        case forecastedSpend = "ForecastedSpend"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualSpend = actualSpend {
            try encodeContainer.encode(actualSpend, forKey: .actualSpend)
        }
        if let forecastedSpend = forecastedSpend {
            try encodeContainer.encode(forecastedSpend, forKey: .forecastedSpend)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actualSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .actualSpend)
        actualSpend = actualSpendDecoded
        let forecastedSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .forecastedSpend)
        forecastedSpend = forecastedSpendDecoded
    }
}

extension BudgetsClientTypes.CalculatedSpend: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedSpend(actualSpend: \(Swift.String(describing: actualSpend)), forecastedSpend: \(Swift.String(describing: forecastedSpend)))"}
}

extension BudgetsClientTypes {
    /// <p>The spend objects that are associated with this budget. The <code>actualSpend</code> tracks how much you've used, cost, usage, RI units, or Savings Plans units and the <code>forecastedSpend</code> tracks how much you are predicted to spend based on your historical usage profile.</p>
    /// 		       <p>For example, if it is the 20th of the month and you have spent <code>50</code> dollars on Amazon EC2, your <code>actualSpend</code> is <code>50 USD</code>, and your <code>forecastedSpend</code> is <code>75 USD</code>.</p>
    public struct CalculatedSpend: Swift.Equatable {
        /// <p>The amount of cost, usage, RI units, or Savings Plans units that you have used.</p>
        public let actualSpend: BudgetsClientTypes.Spend?
        /// <p>The amount of cost, usage, RI units, or Savings Plans units that you are forecasted to use.</p>
        public let forecastedSpend: BudgetsClientTypes.Spend?

        public init (
            actualSpend: BudgetsClientTypes.Spend? = nil,
            forecastedSpend: BudgetsClientTypes.Spend? = nil
        )
        {
            self.actualSpend = actualSpend
            self.forecastedSpend = forecastedSpend
        }
    }

}

extension BudgetsClientTypes {
    /// <p> The comparison operator of a notification. Currently the service supports the following operators:</p>
    /// 		       <p>
    ///             <code>GREATER_THAN</code>, <code>LESS_THAN</code>, <code>EQUAL_TO</code>
    ///          </p>
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equalTo
        case greaterThan
        case lessThan
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equalTo,
                .greaterThan,
                .lessThan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.CostTypes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeCredit = "IncludeCredit"
        case includeDiscount = "IncludeDiscount"
        case includeOtherSubscription = "IncludeOtherSubscription"
        case includeRecurring = "IncludeRecurring"
        case includeRefund = "IncludeRefund"
        case includeSubscription = "IncludeSubscription"
        case includeSupport = "IncludeSupport"
        case includeTax = "IncludeTax"
        case includeUpfront = "IncludeUpfront"
        case useAmortized = "UseAmortized"
        case useBlended = "UseBlended"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeCredit = includeCredit {
            try encodeContainer.encode(includeCredit, forKey: .includeCredit)
        }
        if let includeDiscount = includeDiscount {
            try encodeContainer.encode(includeDiscount, forKey: .includeDiscount)
        }
        if let includeOtherSubscription = includeOtherSubscription {
            try encodeContainer.encode(includeOtherSubscription, forKey: .includeOtherSubscription)
        }
        if let includeRecurring = includeRecurring {
            try encodeContainer.encode(includeRecurring, forKey: .includeRecurring)
        }
        if let includeRefund = includeRefund {
            try encodeContainer.encode(includeRefund, forKey: .includeRefund)
        }
        if let includeSubscription = includeSubscription {
            try encodeContainer.encode(includeSubscription, forKey: .includeSubscription)
        }
        if let includeSupport = includeSupport {
            try encodeContainer.encode(includeSupport, forKey: .includeSupport)
        }
        if let includeTax = includeTax {
            try encodeContainer.encode(includeTax, forKey: .includeTax)
        }
        if let includeUpfront = includeUpfront {
            try encodeContainer.encode(includeUpfront, forKey: .includeUpfront)
        }
        if let useAmortized = useAmortized {
            try encodeContainer.encode(useAmortized, forKey: .useAmortized)
        }
        if let useBlended = useBlended {
            try encodeContainer.encode(useBlended, forKey: .useBlended)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeTaxDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTax)
        includeTax = includeTaxDecoded
        let includeSubscriptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSubscription)
        includeSubscription = includeSubscriptionDecoded
        let useBlendedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBlended)
        useBlended = useBlendedDecoded
        let includeRefundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeRefund)
        includeRefund = includeRefundDecoded
        let includeCreditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCredit)
        includeCredit = includeCreditDecoded
        let includeUpfrontDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeUpfront)
        includeUpfront = includeUpfrontDecoded
        let includeRecurringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeRecurring)
        includeRecurring = includeRecurringDecoded
        let includeOtherSubscriptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOtherSubscription)
        includeOtherSubscription = includeOtherSubscriptionDecoded
        let includeSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSupport)
        includeSupport = includeSupportDecoded
        let includeDiscountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDiscount)
        includeDiscount = includeDiscountDecoded
        let useAmortizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAmortized)
        useAmortized = useAmortizedDecoded
    }
}

extension BudgetsClientTypes.CostTypes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CostTypes(includeCredit: \(Swift.String(describing: includeCredit)), includeDiscount: \(Swift.String(describing: includeDiscount)), includeOtherSubscription: \(Swift.String(describing: includeOtherSubscription)), includeRecurring: \(Swift.String(describing: includeRecurring)), includeRefund: \(Swift.String(describing: includeRefund)), includeSubscription: \(Swift.String(describing: includeSubscription)), includeSupport: \(Swift.String(describing: includeSupport)), includeTax: \(Swift.String(describing: includeTax)), includeUpfront: \(Swift.String(describing: includeUpfront)), useAmortized: \(Swift.String(describing: useAmortized)), useBlended: \(Swift.String(describing: useBlended)))"}
}

extension BudgetsClientTypes {
    /// <p>The types of cost that are included in a <code>COST</code> budget, such as tax and subscriptions.</p>
    /// 		       <p>
    ///             <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, and <code>SAVINGS_PLANS_COVERAGE</code> budgets do not have <code>CostTypes</code>.</p>
    public struct CostTypes: Swift.Equatable {
        /// <p>Specifies whether a budget includes credits.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeCredit: Swift.Bool?
        /// <p>Specifies whether a budget includes discounts.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeDiscount: Swift.Bool?
        /// <p>Specifies whether a budget includes non-RI subscription costs.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeOtherSubscription: Swift.Bool?
        /// <p>Specifies whether a budget includes recurring fees such as monthly RI fees.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeRecurring: Swift.Bool?
        /// <p>Specifies whether a budget includes refunds.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeRefund: Swift.Bool?
        /// <p>Specifies whether a budget includes subscriptions.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeSubscription: Swift.Bool?
        /// <p>Specifies whether a budget includes support subscription fees.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeSupport: Swift.Bool?
        /// <p>Specifies whether a budget includes taxes.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeTax: Swift.Bool?
        /// <p>Specifies whether a budget includes upfront RI costs.</p>
        /// 		       <p>The default value is <code>true</code>.</p>
        public let includeUpfront: Swift.Bool?
        /// <p>Specifies whether a budget uses the amortized rate.</p>
        /// 		       <p>The default value is <code>false</code>.</p>
        public let useAmortized: Swift.Bool?
        /// <p>Specifies whether a budget uses a blended rate.</p>
        /// 		       <p>The default value is <code>false</code>.</p>
        public let useBlended: Swift.Bool?

        public init (
            includeCredit: Swift.Bool? = nil,
            includeDiscount: Swift.Bool? = nil,
            includeOtherSubscription: Swift.Bool? = nil,
            includeRecurring: Swift.Bool? = nil,
            includeRefund: Swift.Bool? = nil,
            includeSubscription: Swift.Bool? = nil,
            includeSupport: Swift.Bool? = nil,
            includeTax: Swift.Bool? = nil,
            includeUpfront: Swift.Bool? = nil,
            useAmortized: Swift.Bool? = nil,
            useBlended: Swift.Bool? = nil
        )
        {
            self.includeCredit = includeCredit
            self.includeDiscount = includeDiscount
            self.includeOtherSubscription = includeOtherSubscription
            self.includeRecurring = includeRecurring
            self.includeRefund = includeRefund
            self.includeSubscription = includeSubscription
            self.includeSupport = includeSupport
            self.includeTax = includeTax
            self.includeUpfront = includeUpfront
            self.useAmortized = useAmortized
            self.useBlended = useBlended
        }
    }

}

public struct CreateBudgetActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBudgetActionOutputError>
}

extension CreateBudgetActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBudgetActionInput(accountId: \(Swift.String(describing: accountId)), actionThreshold: \(Swift.String(describing: actionThreshold)), actionType: \(Swift.String(describing: actionType)), approvalModel: \(Swift.String(describing: approvalModel)), budgetName: \(Swift.String(describing: budgetName)), definition: \(Swift.String(describing: definition)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), notificationType: \(Swift.String(describing: notificationType)), subscribers: \(Swift.String(describing: subscribers)))"}
}

extension CreateBudgetActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionThreshold = actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }
}

public struct CreateBudgetActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBudgetActionOutputError>
}

public struct CreateBudgetActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBudgetActionOutputError>
}

public struct CreateBudgetActionInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    /// 			The trigger threshold of the action.
    /// 		</p>
    public let actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// <p>
    ///          The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
    ///       </p>
    public let actionType: BudgetsClientTypes.ActionType?
    /// <p>
    ///          This specifies if the action needs manual or automatic approval.
    ///       </p>
    public let approvalModel: BudgetsClientTypes.ApprovalModel?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p>
    /// 			Specifies all of the type-specific parameters.
    /// 		</p>
    public let definition: BudgetsClientTypes.Definition?
    /// <p>
    ///          The role passed for action execution and reversion. Roles and actions must be in the same account.
    ///       </p>
    public let executionRoleArn: Swift.String?
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    public let notificationType: BudgetsClientTypes.NotificationType?
    /// <p> A list of subscribers.</p>
    public let subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        accountId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        actionType: BudgetsClientTypes.ActionType? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionThreshold = actionThreshold
        self.actionType = actionType
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct CreateBudgetActionInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let notificationType: BudgetsClientTypes.NotificationType?
    public let actionType: BudgetsClientTypes.ActionType?
    public let actionThreshold: BudgetsClientTypes.ActionThreshold?
    public let definition: BudgetsClientTypes.Definition?
    public let executionRoleArn: Swift.String?
    public let approvalModel: BudgetsClientTypes.ApprovalModel?
    public let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension CreateBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBudgetActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBudgetActionOutputResponse(accountId: \(Swift.String(describing: accountId)), actionId: \(Swift.String(describing: actionId)), budgetName: \(Swift.String(describing: budgetName)))"}
}

extension CreateBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
        }
    }
}

public struct CreateBudgetActionOutputResponse: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct CreateBudgetActionOutputResponseBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let actionId: Swift.String?
}

extension CreateBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

public struct CreateBudgetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBudgetOutputError>
}

extension CreateBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBudgetInput(accountId: \(Swift.String(describing: accountId)), budget: \(Swift.String(describing: budget)), notificationsWithSubscribers: \(Swift.String(describing: notificationsWithSubscribers)))"}
}

extension CreateBudgetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budget = budget {
            try encodeContainer.encode(budget, forKey: .budget)
        }
        if let notificationsWithSubscribers = notificationsWithSubscribers {
            var notificationsWithSubscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationsWithSubscribers)
            for notificationwithsubscriberslist0 in notificationsWithSubscribers {
                try notificationsWithSubscribersContainer.encode(notificationwithsubscriberslist0)
            }
        }
    }
}

public struct CreateBudgetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBudgetOutputError>
}

public struct CreateBudgetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBudgetOutputError>
}

/// <p> Request of CreateBudget </p>
public struct CreateBudgetInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget.</p>
    public let accountId: Swift.String?
    /// <p>The budget object that you want to create.</p>
    public let budget: BudgetsClientTypes.Budget?
    /// <p>A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your <code>CreateBudget</code> call, AWS creates the notifications and subscribers for you.</p>
    public let notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]?

    public init (
        accountId: Swift.String? = nil,
        budget: BudgetsClientTypes.Budget? = nil,
        notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]? = nil
    )
    {
        self.accountId = accountId
        self.budget = budget
        self.notificationsWithSubscribers = notificationsWithSubscribers
    }
}

struct CreateBudgetInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budget: BudgetsClientTypes.Budget?
    public let notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]?
}

extension CreateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .budget)
        budget = budgetDecoded
        let notificationsWithSubscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.NotificationWithSubscribers?].self, forKey: .notificationsWithSubscribers)
        var notificationsWithSubscribersDecoded0:[BudgetsClientTypes.NotificationWithSubscribers]? = nil
        if let notificationsWithSubscribersContainer = notificationsWithSubscribersContainer {
            notificationsWithSubscribersDecoded0 = [BudgetsClientTypes.NotificationWithSubscribers]()
            for structure0 in notificationsWithSubscribersContainer {
                if let structure0 = structure0 {
                    notificationsWithSubscribersDecoded0?.append(structure0)
                }
            }
        }
        notificationsWithSubscribers = notificationsWithSubscribersDecoded0
    }
}

extension CreateBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBudgetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBudgetOutputResponse()"}
}

extension CreateBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of CreateBudget </p>
public struct CreateBudgetOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateBudgetOutputResponseBody: Swift.Equatable {
}

extension CreateBudgetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateNotificationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNotificationOutputError>
}

extension CreateNotificationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNotificationInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), notification: \(Swift.String(describing: notification)), subscribers: \(Swift.String(describing: subscribers)))"}
}

extension CreateNotificationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }
}

public struct CreateNotificationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNotificationOutputError>
}

public struct CreateNotificationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNotificationOutputError>
}

/// <p> Request of CreateNotification </p>
public struct CreateNotificationInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a notification for.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget that you want AWS to notify you about. Budget names must be unique within an account.</p>
    public let budgetName: Swift.String?
    /// <p>The notification that you want to create.</p>
    public let notification: BudgetsClientTypes.Notification?
    /// <p>A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.</p>
    public let subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscribers = subscribers
    }
}

struct CreateNotificationInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let notification: BudgetsClientTypes.Notification?
    public let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension CreateNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotificationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNotificationOutputResponse()"}
}

extension CreateNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of CreateNotification </p>
public struct CreateNotificationOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateNotificationOutputResponseBody: Swift.Equatable {
}

extension CreateNotificationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateSubscriberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubscriberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubscriberOutputError>
}

extension CreateSubscriberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriberInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), notification: \(Swift.String(describing: notification)), subscriber: \(Swift.String(describing: subscriber)))"}
}

extension CreateSubscriberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

public struct CreateSubscriberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubscriberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubscriberOutputError>
}

public struct CreateSubscriberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubscriberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubscriberOutputError>
}

/// <p> Request of CreateSubscriber </p>
public struct CreateSubscriberInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a subscriber for.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget that you want to subscribe to. Budget names must be unique within an account.</p>
    public let budgetName: Swift.String?
    /// <p>The notification that you want to create a subscriber for.</p>
    public let notification: BudgetsClientTypes.Notification?
    /// <p>The subscriber that you want to associate with a budget notification.</p>
    public let subscriber: BudgetsClientTypes.Subscriber?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct CreateSubscriberInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let notification: BudgetsClientTypes.Notification?
    public let subscriber: BudgetsClientTypes.Subscriber?
}

extension CreateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension CreateSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriberOutputResponse()"}
}

extension CreateSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of CreateSubscriber </p>
public struct CreateSubscriberOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateSubscriberOutputResponseBody: Swift.Equatable {
}

extension CreateSubscriberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreationLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreationLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension CreationLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreationLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've exceeded the notification or subscriber limit.</p>
public struct CreationLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CreationLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CreationLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Definition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamActionDefinition = "IamActionDefinition"
        case scpActionDefinition = "ScpActionDefinition"
        case ssmActionDefinition = "SsmActionDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamActionDefinition = iamActionDefinition {
            try encodeContainer.encode(iamActionDefinition, forKey: .iamActionDefinition)
        }
        if let scpActionDefinition = scpActionDefinition {
            try encodeContainer.encode(scpActionDefinition, forKey: .scpActionDefinition)
        }
        if let ssmActionDefinition = ssmActionDefinition {
            try encodeContainer.encode(ssmActionDefinition, forKey: .ssmActionDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.IamActionDefinition.self, forKey: .iamActionDefinition)
        iamActionDefinition = iamActionDefinitionDecoded
        let scpActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ScpActionDefinition.self, forKey: .scpActionDefinition)
        scpActionDefinition = scpActionDefinitionDecoded
        let ssmActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.SsmActionDefinition.self, forKey: .ssmActionDefinition)
        ssmActionDefinition = ssmActionDefinitionDecoded
    }
}

extension BudgetsClientTypes.Definition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Definition(iamActionDefinition: \(Swift.String(describing: iamActionDefinition)), scpActionDefinition: \(Swift.String(describing: scpActionDefinition)), ssmActionDefinition: \(Swift.String(describing: ssmActionDefinition)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			Specifies all of the type-specific parameters.
    /// 		</p>
    public struct Definition: Swift.Equatable {
        /// <p>
        /// 			The AWS Identity and Access Management (IAM) action definition details.
        /// 		</p>
        public let iamActionDefinition: BudgetsClientTypes.IamActionDefinition?
        /// <p>
        /// 			The service control policies (SCPs) action definition details.
        /// 		</p>
        public let scpActionDefinition: BudgetsClientTypes.ScpActionDefinition?
        /// <p>
        /// 			The AWS Systems Manager (SSM) action definition details.
        /// 		</p>
        public let ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition?

        public init (
            iamActionDefinition: BudgetsClientTypes.IamActionDefinition? = nil,
            scpActionDefinition: BudgetsClientTypes.ScpActionDefinition? = nil,
            ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition? = nil
        )
        {
            self.iamActionDefinition = iamActionDefinition
            self.scpActionDefinition = scpActionDefinition
            self.ssmActionDefinition = ssmActionDefinition
        }
    }

}

public struct DeleteBudgetActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBudgetActionOutputError>
}

extension DeleteBudgetActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBudgetActionInput(accountId: \(Swift.String(describing: accountId)), actionId: \(Swift.String(describing: actionId)), budgetName: \(Swift.String(describing: budgetName)))"}
}

extension DeleteBudgetActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DeleteBudgetActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBudgetActionOutputError>
}

public struct DeleteBudgetActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBudgetActionOutputError>
}

public struct DeleteBudgetActionInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let actionId: Swift.String?
}

extension DeleteBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DeleteBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBudgetActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBudgetActionOutputResponse(accountId: \(Swift.String(describing: accountId)), action: \(Swift.String(describing: action)), budgetName: \(Swift.String(describing: budgetName)))"}
}

extension DeleteBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DeleteBudgetActionOutputResponse: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    /// 			A budget action resource.
    /// 		</p>
    public let action: BudgetsClientTypes.Action?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionOutputResponseBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let action: BudgetsClientTypes.Action?
}

extension DeleteBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

public struct DeleteBudgetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBudgetOutputError>
}

extension DeleteBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBudgetInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)))"}
}

extension DeleteBudgetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DeleteBudgetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBudgetOutputError>
}

public struct DeleteBudgetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBudgetOutputError>
}

/// <p> Request of DeleteBudget </p>
public struct DeleteBudgetInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to delete.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget that you want to delete.</p>
    public let budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
}

extension DeleteBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DeleteBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBudgetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBudgetOutputResponse()"}
}

extension DeleteBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of DeleteBudget </p>
public struct DeleteBudgetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBudgetOutputResponseBody: Swift.Equatable {
}

extension DeleteBudgetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteNotificationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNotificationOutputError>
}

extension DeleteNotificationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNotificationInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), notification: \(Swift.String(describing: notification)))"}
}

extension DeleteNotificationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

public struct DeleteNotificationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNotificationOutputError>
}

public struct DeleteNotificationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNotificationOutputError>
}

/// <p> Request of DeleteNotification </p>
public struct DeleteNotificationInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to delete.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget whose notification you want to delete.</p>
    public let budgetName: Swift.String?
    /// <p>The notification that you want to delete.</p>
    public let notification: BudgetsClientTypes.Notification?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
    }
}

struct DeleteNotificationInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let notification: BudgetsClientTypes.Notification?
}

extension DeleteNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
    }
}

extension DeleteNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNotificationOutputResponse()"}
}

extension DeleteNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of DeleteNotification </p>
public struct DeleteNotificationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteNotificationOutputResponseBody: Swift.Equatable {
}

extension DeleteNotificationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSubscriberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubscriberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubscriberOutputError>
}

extension DeleteSubscriberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSubscriberInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), notification: \(Swift.String(describing: notification)), subscriber: \(Swift.String(describing: subscriber)))"}
}

extension DeleteSubscriberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

public struct DeleteSubscriberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubscriberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubscriberOutputError>
}

public struct DeleteSubscriberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubscriberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubscriberOutputError>
}

/// <p> Request of DeleteSubscriber </p>
public struct DeleteSubscriberInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to delete.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget whose subscriber you want to delete.</p>
    public let budgetName: Swift.String?
    /// <p>The notification whose subscriber you want to delete.</p>
    public let notification: BudgetsClientTypes.Notification?
    /// <p>The subscriber that you want to delete.</p>
    public let subscriber: BudgetsClientTypes.Subscriber?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct DeleteSubscriberInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let notification: BudgetsClientTypes.Notification?
    public let subscriber: BudgetsClientTypes.Subscriber?
}

extension DeleteSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension DeleteSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSubscriberOutputResponse()"}
}

extension DeleteSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of DeleteSubscriber </p>
public struct DeleteSubscriberOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSubscriberOutputResponseBody: Swift.Equatable {
}

extension DeleteSubscriberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeBudgetActionHistoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionHistoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionHistoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionHistoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionHistoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionHistoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionHistoriesOutputError>
}

extension DescribeBudgetActionHistoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionHistoriesInput(accountId: \(Swift.String(describing: accountId)), actionId: \(Swift.String(describing: actionId)), budgetName: \(Swift.String(describing: budgetName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), timePeriod: \(Swift.String(describing: timePeriod)))"}
}

extension DescribeBudgetActionHistoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct DescribeBudgetActionHistoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionHistoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionHistoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionHistoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionHistoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionHistoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionHistoriesOutputError>
}

public struct DescribeBudgetActionHistoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionHistoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionHistoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionHistoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionHistoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionHistoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionHistoriesOutputError>
}

public struct DescribeBudgetActionHistoriesInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Swift.Int?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?
    /// <p>The period of time that is covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
    public let timePeriod: BudgetsClientTypes.TimePeriod?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetActionHistoriesInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let actionId: Swift.String?
    public let timePeriod: BudgetsClientTypes.TimePeriod?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBudgetActionHistoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionHistoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionHistoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionHistoriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionHistoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionHistoriesOutputResponse(actionHistories: \(Swift.String(describing: actionHistories)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetActionHistoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBudgetActionHistoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionHistories = output.actionHistories
            self.nextToken = output.nextToken
        } else {
            self.actionHistories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionHistoriesOutputResponse: Swift.Equatable {
    /// <p>
    ///          The historical record of the budget action resource.
    ///       </p>
    public let actionHistories: [BudgetsClientTypes.ActionHistory]?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?

    public init (
        actionHistories: [BudgetsClientTypes.ActionHistory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionHistories = actionHistories
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionHistoriesOutputResponseBody: Swift.Equatable {
    public let actionHistories: [BudgetsClientTypes.ActionHistory]?
    public let nextToken: Swift.String?
}

extension DescribeBudgetActionHistoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionHistories = "ActionHistories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionHistoriesContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.ActionHistory?].self, forKey: .actionHistories)
        var actionHistoriesDecoded0:[BudgetsClientTypes.ActionHistory]? = nil
        if let actionHistoriesContainer = actionHistoriesContainer {
            actionHistoriesDecoded0 = [BudgetsClientTypes.ActionHistory]()
            for structure0 in actionHistoriesContainer {
                if let structure0 = structure0 {
                    actionHistoriesDecoded0?.append(structure0)
                }
            }
        }
        actionHistories = actionHistoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionOutputError>
}

extension DescribeBudgetActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionInput(accountId: \(Swift.String(describing: accountId)), actionId: \(Swift.String(describing: actionId)), budgetName: \(Swift.String(describing: budgetName)))"}
}

extension DescribeBudgetActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DescribeBudgetActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionOutputError>
}

public struct DescribeBudgetActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionOutputError>
}

public struct DescribeBudgetActionInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let actionId: Swift.String?
}

extension DescribeBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DescribeBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionOutputResponse(accountId: \(Swift.String(describing: accountId)), action: \(Swift.String(describing: action)), budgetName: \(Swift.String(describing: budgetName)))"}
}

extension DescribeBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DescribeBudgetActionOutputResponse: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A budget action resource.
    ///       </p>
    public let action: BudgetsClientTypes.Action?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionOutputResponseBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let action: BudgetsClientTypes.Action?
}

extension DescribeBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

public struct DescribeBudgetActionsForAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionsForAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionsForAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionsForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionsForAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionsForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionsForAccountOutputError>
}

extension DescribeBudgetActionsForAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionsForAccountInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBudgetActionsForAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionsForAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionsForAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionsForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionsForAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionsForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionsForAccountOutputError>
}

public struct DescribeBudgetActionsForAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionsForAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionsForAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionsForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionsForAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionsForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionsForAccountOutputError>
}

public struct DescribeBudgetActionsForAccountInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Swift.Int?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBudgetActionsForAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionsForAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionsForAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionsForAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionsForAccountOutputResponse(actions: \(Swift.String(describing: actions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBudgetActionsForAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForAccountOutputResponse: Swift.Equatable {
    /// <p>
    ///          A list of the budget action resources information.
    ///       </p>
    public let actions: [BudgetsClientTypes.Action]?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?

    public init (
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountOutputResponseBody: Swift.Equatable {
    public let actions: [BudgetsClientTypes.Action]?
    public let nextToken: Swift.String?
}

extension DescribeBudgetActionsForAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[BudgetsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [BudgetsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetActionsForBudgetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionsForBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionsForBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionsForBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionsForBudgetOutputError>
}

extension DescribeBudgetActionsForBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionsForBudgetInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForBudgetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBudgetActionsForBudgetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionsForBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionsForBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionsForBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionsForBudgetOutputError>
}

public struct DescribeBudgetActionsForBudgetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetActionsForBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetActionsForBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetActionsForBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetActionsForBudgetOutputError>
}

public struct DescribeBudgetActionsForBudgetInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Swift.Int?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBudgetActionsForBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionsForBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionsForBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionsForBudgetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetActionsForBudgetOutputResponse(actions: \(Swift.String(describing: actions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBudgetActionsForBudgetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForBudgetOutputResponse: Swift.Equatable {
    /// <p>
    ///          A list of the budget action resources information.
    ///       </p>
    public let actions: [BudgetsClientTypes.Action]?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?

    public init (
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetOutputResponseBody: Swift.Equatable {
    public let actions: [BudgetsClientTypes.Action]?
    public let nextToken: Swift.String?
}

extension DescribeBudgetActionsForBudgetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[BudgetsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [BudgetsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetOutputError>
}

extension DescribeBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)))"}
}

extension DescribeBudgetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DescribeBudgetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetOutputError>
}

public struct DescribeBudgetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetOutputError>
}

/// <p> Request of DescribeBudget </p>
public struct DescribeBudgetInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want a description of.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget that you want a description of.</p>
    public let budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
}

extension DescribeBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DescribeBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetOutputResponse(budget: \(Swift.String(describing: budget)))"}
}

extension DescribeBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBudgetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budget = output.budget
        } else {
            self.budget = nil
        }
    }
}

/// <p> Response of DescribeBudget </p>
public struct DescribeBudgetOutputResponse: Swift.Equatable {
    /// <p>The description of the budget.</p>
    public let budget: BudgetsClientTypes.Budget?

    public init (
        budget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.budget = budget
    }
}

struct DescribeBudgetOutputResponseBody: Swift.Equatable {
    public let budget: BudgetsClientTypes.Budget?
}

extension DescribeBudgetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budget = "Budget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .budget)
        budget = budgetDecoded
    }
}

public struct DescribeBudgetPerformanceHistoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetPerformanceHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetPerformanceHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetPerformanceHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetPerformanceHistoryOutputError>
}

extension DescribeBudgetPerformanceHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetPerformanceHistoryInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), timePeriod: \(Swift.String(describing: timePeriod)))"}
}

extension DescribeBudgetPerformanceHistoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct DescribeBudgetPerformanceHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetPerformanceHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetPerformanceHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetPerformanceHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetPerformanceHistoryOutputError>
}

public struct DescribeBudgetPerformanceHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetPerformanceHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetPerformanceHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetPerformanceHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetPerformanceHistoryOutputError>
}

public struct DescribeBudgetPerformanceHistoryInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Swift.Int?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?
    /// <p>Retrieves how often the budget went into an <code>ALARM</code> state for the specified time period.</p>
    public let timePeriod: BudgetsClientTypes.TimePeriod?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetPerformanceHistoryInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let timePeriod: BudgetsClientTypes.TimePeriod?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBudgetPerformanceHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetPerformanceHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetPerformanceHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetPerformanceHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetPerformanceHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetPerformanceHistoryOutputResponse(budgetPerformanceHistory: \(Swift.String(describing: budgetPerformanceHistory)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetPerformanceHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBudgetPerformanceHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgetPerformanceHistory = output.budgetPerformanceHistory
            self.nextToken = output.nextToken
        } else {
            self.budgetPerformanceHistory = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetPerformanceHistoryOutputResponse: Swift.Equatable {
    /// <p>The history of how often the budget has gone into an <code>ALARM</code> state.</p>
    ///          <p>For <code>DAILY</code> budgets, the history saves the state of the budget for the last 60 days. For <code>MONTHLY</code> budgets, the history saves the state of the budget for the current month plus the last 12 months. For <code>QUARTERLY</code> budgets, the history saves the state of the budget for the last four quarters.</p>
    public let budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory?
    /// <p> A generic string.</p>
    public let nextToken: Swift.String?

    public init (
        budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgetPerformanceHistory = budgetPerformanceHistory
        self.nextToken = nextToken
    }
}

struct DescribeBudgetPerformanceHistoryOutputResponseBody: Swift.Equatable {
    public let budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory?
    public let nextToken: Swift.String?
}

extension DescribeBudgetPerformanceHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetPerformanceHistory = "BudgetPerformanceHistory"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetPerformanceHistoryDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetPerformanceHistory.self, forKey: .budgetPerformanceHistory)
        budgetPerformanceHistory = budgetPerformanceHistoryDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetsOutputError>
}

extension DescribeBudgetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetsInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBudgetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetsOutputError>
}

public struct DescribeBudgetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBudgetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBudgetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBudgetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBudgetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBudgetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBudgetsOutputError>
}

/// <p> Request of DescribeBudgets </p>
public struct DescribeBudgetsInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budgets that you want descriptions of.</p>
    public let accountId: Swift.String?
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    public let nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBudgetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBudgetsOutputResponse(budgets: \(Swift.String(describing: budgets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBudgetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBudgetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.nextToken = output.nextToken
        } else {
            self.budgets = nil
            self.nextToken = nil
        }
    }
}

/// <p> Response of DescribeBudgets </p>
public struct DescribeBudgetsOutputResponse: Swift.Equatable {
    /// <p>A list of budgets.</p>
    public let budgets: [BudgetsClientTypes.Budget]?
    /// <p>The pagination token in the service response that indicates the next set of results that you can retrieve.</p>
    public let nextToken: Swift.String?

    public init (
        budgets: [BudgetsClientTypes.Budget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsOutputResponseBody: Swift.Equatable {
    public let budgets: [BudgetsClientTypes.Budget]?
    public let nextToken: Swift.String?
}

extension DescribeBudgetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Budget?].self, forKey: .budgets)
        var budgetsDecoded0:[BudgetsClientTypes.Budget]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [BudgetsClientTypes.Budget]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeNotificationsForBudgetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNotificationsForBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNotificationsForBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNotificationsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNotificationsForBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNotificationsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNotificationsForBudgetOutputError>
}

extension DescribeNotificationsForBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNotificationsForBudgetInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeNotificationsForBudgetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeNotificationsForBudgetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNotificationsForBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNotificationsForBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNotificationsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNotificationsForBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNotificationsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNotificationsForBudgetOutputError>
}

public struct DescribeNotificationsForBudgetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNotificationsForBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNotificationsForBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNotificationsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNotificationsForBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNotificationsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNotificationsForBudgetOutputError>
}

/// <p> Request of DescribeNotificationsForBudget </p>
public struct DescribeNotificationsForBudgetInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose notifications you want descriptions of.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget whose notifications you want descriptions of.</p>
    public let budgetName: Swift.String?
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    public let nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeNotificationsForBudgetInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeNotificationsForBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeNotificationsForBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationsForBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNotificationsForBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationsForBudgetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNotificationsForBudgetOutputResponse(nextToken: \(Swift.String(describing: nextToken)), notifications: \(Swift.String(describing: notifications)))"}
}

extension DescribeNotificationsForBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeNotificationsForBudgetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

/// <p> Response of GetNotificationsForBudget </p>
public struct DescribeNotificationsForBudgetOutputResponse: Swift.Equatable {
    /// <p>The pagination token in the service response that indicates the next set of results that you can retrieve.</p>
    public let nextToken: Swift.String?
    /// <p>A list of notifications that are associated with a budget.</p>
    public let notifications: [BudgetsClientTypes.Notification]?

    public init (
        nextToken: Swift.String? = nil,
        notifications: [BudgetsClientTypes.Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct DescribeNotificationsForBudgetOutputResponseBody: Swift.Equatable {
    public let notifications: [BudgetsClientTypes.Notification]?
    public let nextToken: Swift.String?
}

extension DescribeNotificationsForBudgetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notifications = "Notifications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[BudgetsClientTypes.Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [BudgetsClientTypes.Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSubscribersForNotificationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubscribersForNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubscribersForNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubscribersForNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubscribersForNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubscribersForNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubscribersForNotificationOutputError>
}

extension DescribeSubscribersForNotificationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSubscribersForNotificationInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), notification: \(Swift.String(describing: notification)))"}
}

extension DescribeSubscribersForNotificationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

public struct DescribeSubscribersForNotificationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubscribersForNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubscribersForNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubscribersForNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubscribersForNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubscribersForNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubscribersForNotificationOutputError>
}

public struct DescribeSubscribersForNotificationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubscribersForNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubscribersForNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubscribersForNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubscribersForNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubscribersForNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubscribersForNotificationOutputError>
}

/// <p> Request of DescribeSubscribersForNotification </p>
public struct DescribeSubscribersForNotificationInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscribers you want descriptions of.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget whose subscribers you want descriptions of.</p>
    public let budgetName: Swift.String?
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    public let nextToken: Swift.String?
    /// <p>The notification whose subscribers you want to list.</p>
    public let notification: BudgetsClientTypes.Notification?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notification = notification
    }
}

struct DescribeSubscribersForNotificationInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let notification: BudgetsClientTypes.Notification?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeSubscribersForNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubscribersForNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubscribersForNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSubscribersForNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubscribersForNotificationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSubscribersForNotificationOutputResponse(nextToken: \(Swift.String(describing: nextToken)), subscribers: \(Swift.String(describing: subscribers)))"}
}

extension DescribeSubscribersForNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSubscribersForNotificationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscribers = output.subscribers
        } else {
            self.nextToken = nil
            self.subscribers = nil
        }
    }
}

/// <p> Response of DescribeSubscribersForNotification </p>
public struct DescribeSubscribersForNotificationOutputResponse: Swift.Equatable {
    /// <p>The pagination token in the service response that indicates the next set of results that you can retrieve.</p>
    public let nextToken: Swift.String?
    /// <p>A list of subscribers that are associated with a notification.</p>
    public let subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        nextToken: Swift.String? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscribers = subscribers
    }
}

struct DescribeSubscribersForNotificationOutputResponseBody: Swift.Equatable {
    public let subscribers: [BudgetsClientTypes.Subscriber]?
    public let nextToken: Swift.String?
}

extension DescribeSubscribersForNotificationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DuplicateRecordException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateRecordException(message: \(Swift.String(describing: message)))"}
}

extension DuplicateRecordException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateRecordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The budget name already exists. Budget names must be unique within an account.</p>
public struct DuplicateRecordException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRecordExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateRecordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createaction
        case deleteaction
        case executeaction
        case system
        case updateaction
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .createaction,
                .deleteaction,
                .executeaction,
                .system,
                .updateaction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createaction: return "CREATE_ACTION"
            case .deleteaction: return "DELETE_ACTION"
            case .executeaction: return "EXECUTE_ACTION"
            case .system: return "SYSTEM"
            case .updateaction: return "UPDATE_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

public struct ExecuteBudgetActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteBudgetActionOutputError>
}

extension ExecuteBudgetActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteBudgetActionInput(accountId: \(Swift.String(describing: accountId)), actionId: \(Swift.String(describing: actionId)), budgetName: \(Swift.String(describing: budgetName)), executionType: \(Swift.String(describing: executionType)))"}
}

extension ExecuteBudgetActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let executionType = executionType {
            try encodeContainer.encode(executionType.rawValue, forKey: .executionType)
        }
    }
}

public struct ExecuteBudgetActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteBudgetActionOutputError>
}

public struct ExecuteBudgetActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteBudgetActionOutputError>
}

public struct ExecuteBudgetActionInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p>
    ///          The type of execution.
    ///       </p>
    public let executionType: BudgetsClientTypes.ExecutionType?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let actionId: Swift.String?
    public let executionType: BudgetsClientTypes.ExecutionType?
}

extension ExecuteBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension ExecuteBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteBudgetActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteBudgetActionOutputResponse(accountId: \(Swift.String(describing: accountId)), actionId: \(Swift.String(describing: actionId)), budgetName: \(Swift.String(describing: budgetName)), executionType: \(Swift.String(describing: executionType)))"}
}

extension ExecuteBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecuteBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
            self.executionType = output.executionType
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
            self.executionType = nil
        }
    }
}

public struct ExecuteBudgetActionOutputResponse: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p>
    ///          The type of execution.
    ///       </p>
    public let executionType: BudgetsClientTypes.ExecutionType?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionOutputResponseBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let actionId: Swift.String?
    public let executionType: BudgetsClientTypes.ExecutionType?
}

extension ExecuteBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension BudgetsClientTypes {
    public enum ExecutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approvebudgetaction
        case resetbudgetaction
        case retrybudgetaction
        case reversebudgetaction
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionType] {
            return [
                .approvebudgetaction,
                .resetbudgetaction,
                .retrybudgetaction,
                .reversebudgetaction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approvebudgetaction: return "APPROVE_BUDGET_ACTION"
            case .resetbudgetaction: return "RESET_BUDGET_ACTION"
            case .retrybudgetaction: return "RETRY_BUDGET_ACTION"
            case .reversebudgetaction: return "REVERSE_BUDGET_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionType(rawValue: rawValue) ?? ExecutionType.sdkUnknown(rawValue)
        }
    }
}

extension ExpiredNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpiredNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension ExpiredNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token expired.</p>
public struct ExpiredNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExpiredNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.IamActionDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case policyArn = "PolicyArn"
        case roles = "Roles"
        case users = "Users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groups0 in groups {
                try groupsContainer.encode(groups0)
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for roles0 in roles {
                try rolesContainer.encode(roles0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for users0 in users {
                try usersContainer.encode(users0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roles)
        var rolesDecoded0:[Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String]()
            for string0 in rolesContainer {
                if let string0 = string0 {
                    rolesDecoded0?.append(string0)
                }
            }
        }
        roles = rolesDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .users)
        var usersDecoded0:[Swift.String]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [Swift.String]()
            for string0 in usersContainer {
                if let string0 = string0 {
                    usersDecoded0?.append(string0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension BudgetsClientTypes.IamActionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IamActionDefinition(groups: \(Swift.String(describing: groups)), policyArn: \(Swift.String(describing: policyArn)), roles: \(Swift.String(describing: roles)), users: \(Swift.String(describing: users)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			The AWS Identity and Access Management (IAM) action definition details.
    /// 		</p>
    public struct IamActionDefinition: Swift.Equatable {
        /// <p>
        /// 			A list of groups to be attached. There must be at least one group.
        /// 		</p>
        public let groups: [Swift.String]?
        /// <p>
        /// 			The Amazon Resource Name (ARN) of the policy to be attached.
        /// 		</p>
        public let policyArn: Swift.String?
        /// <p>
        /// 			A list of roles to be attached. There must be at least one role.
        /// 		</p>
        public let roles: [Swift.String]?
        /// <p>
        /// 			A list of users to be attached. There must be at least one user.
        /// 		</p>
        public let users: [Swift.String]?

        public init (
            groups: [Swift.String]? = nil,
            policyArn: Swift.String? = nil,
            roles: [Swift.String]? = nil,
            users: [Swift.String]? = nil
        )
        {
            self.groups = groups
            self.policyArn = policyArn
            self.roles = roles
            self.users = users
        }
    }

}

extension InternalErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error on the server occurred during the processing of your request. Try again later.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token is invalid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error on the client occurred. Typically, the cause is an invalid input value.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We can’t locate the resource that you specified.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Notification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case notificationState = "NotificationState"
        case notificationType = "NotificationType"
        case threshold = "Threshold"
        case thresholdType = "ThresholdType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let notificationState = notificationState {
            try encodeContainer.encode(notificationState.rawValue, forKey: .notificationState)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if threshold != 0.0 {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let thresholdType = thresholdType {
            try encodeContainer.encode(thresholdType.rawValue, forKey: .thresholdType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let thresholdDecoded = try containerValues.decode(Swift.Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let thresholdTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ThresholdType.self, forKey: .thresholdType)
        thresholdType = thresholdTypeDecoded
        let notificationStateDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationState.self, forKey: .notificationState)
        notificationState = notificationStateDecoded
    }
}

extension BudgetsClientTypes.Notification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Notification(comparisonOperator: \(Swift.String(describing: comparisonOperator)), notificationState: \(Swift.String(describing: notificationState)), notificationType: \(Swift.String(describing: notificationType)), threshold: \(Swift.String(describing: threshold)), thresholdType: \(Swift.String(describing: thresholdType)))"}
}

extension BudgetsClientTypes {
    /// <p>A notification that is associated with a budget. A budget can have up to ten notifications. </p>
    /// 		       <p>Each notification must have at least one subscriber. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers.</p>
    /// 		       <p>For example, if you have a budget for 200 dollars and you want to be notified when you go over 160 dollars, create a notification with the following parameters:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A notificationType of <code>ACTUAL</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>A <code>thresholdType</code> of <code>PERCENTAGE</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>A <code>comparisonOperator</code> of <code>GREATER_THAN</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>A notification <code>threshold</code> of <code>80</code>
    ///                </p>
    /// 			         </li>
    ///          </ul>
    public struct Notification: Swift.Equatable {
        /// <p>The comparison that is used for this notification.</p>
        public let comparisonOperator: BudgetsClientTypes.ComparisonOperator?
        /// <p>Whether this notification is in alarm. If a budget notification is in the <code>ALARM</code> state, you have passed the set threshold for the budget.</p>
        public let notificationState: BudgetsClientTypes.NotificationState?
        /// <p>Whether the notification is for how much you have spent (<code>ACTUAL</code>) or for how much you're forecasted to spend (<code>FORECASTED</code>).</p>
        public let notificationType: BudgetsClientTypes.NotificationType?
        /// <p>The threshold that is associated with a notification. Thresholds are always a percentage, and many customers find value being alerted between 50% - 200% of the budgeted amount. The maximum limit for your threshold is 1,000,000% above the budgeted amount.</p>
        public let threshold: Swift.Double
        /// <p>The type of threshold for a notification. For <code>ABSOLUTE_VALUE</code> thresholds, AWS notifies you when you go over or are forecasted to go over your total cost threshold. For <code>PERCENTAGE</code> thresholds, AWS notifies you when you go over or are forecasted to go over a certain percentage of your forecasted spend. For example, if you have a budget for 200 dollars and you have a <code>PERCENTAGE</code> threshold of 80%, AWS notifies you when you go over 160 dollars.</p>
        public let thresholdType: BudgetsClientTypes.ThresholdType?

        public init (
            comparisonOperator: BudgetsClientTypes.ComparisonOperator? = nil,
            notificationState: BudgetsClientTypes.NotificationState? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            threshold: Swift.Double = 0.0,
            thresholdType: BudgetsClientTypes.ThresholdType? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.notificationState = notificationState
            self.notificationType = notificationType
            self.threshold = threshold
            self.thresholdType = thresholdType
        }
    }

}

extension BudgetsClientTypes {
    public enum NotificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alarm
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationState] {
            return [
                .alarm,
                .ok,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "ALARM"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationState(rawValue: rawValue) ?? NotificationState.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actual
        case forecasted
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .actual,
                .forecasted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actual: return "ACTUAL"
            case .forecasted: return "FORECASTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.NotificationWithSubscribers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension BudgetsClientTypes.NotificationWithSubscribers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationWithSubscribers(notification: \(Swift.String(describing: notification)), subscribers: \(Swift.String(describing: subscribers)))"}
}

extension BudgetsClientTypes {
    /// <p>A notification with subscribers. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers.</p>
    public struct NotificationWithSubscribers: Swift.Equatable {
        /// <p>The notification that is associated with a budget.</p>
        public let notification: BudgetsClientTypes.Notification?
        /// <p>A list of subscribers who are subscribed to this notification.</p>
        public let subscribers: [BudgetsClientTypes.Subscriber]?

        public init (
            notification: BudgetsClientTypes.Notification? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.notification = notification
            self.subscribers = subscribers
        }
    }

}

extension ResourceLockedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLockedException(message: \(Swift.String(describing: message)))"}
}

extension ResourceLockedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLockedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The request was received and recognized by the server, but the server rejected that
///       particular method for the requested resource. </p>
public struct ResourceLockedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLockedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceLockedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.ScpActionDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
        case targetIds = "TargetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let targetIds = targetIds {
            var targetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIds)
            for targetids0 in targetIds {
                try targetIdsContainer.encode(targetids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let targetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetIds)
        var targetIdsDecoded0:[Swift.String]? = nil
        if let targetIdsContainer = targetIdsContainer {
            targetIdsDecoded0 = [Swift.String]()
            for string0 in targetIdsContainer {
                if let string0 = string0 {
                    targetIdsDecoded0?.append(string0)
                }
            }
        }
        targetIds = targetIdsDecoded0
    }
}

extension BudgetsClientTypes.ScpActionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScpActionDefinition(policyId: \(Swift.String(describing: policyId)), targetIds: \(Swift.String(describing: targetIds)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			The service control policies (SCP) action definition details.
    /// 		</p>
    public struct ScpActionDefinition: Swift.Equatable {
        /// <p>
        /// 			The policy ID attached.
        /// 		</p>
        public let policyId: Swift.String?
        /// <p>
        /// 			A list of target IDs.
        /// 		</p>
        public let targetIds: [Swift.String]?

        public init (
            policyId: Swift.String? = nil,
            targetIds: [Swift.String]? = nil
        )
        {
            self.policyId = policyId
            self.targetIds = targetIds
        }
    }

}

extension BudgetsClientTypes.Spend: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension BudgetsClientTypes.Spend: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Spend(amount: \(Swift.String(describing: amount)), unit: \(Swift.String(describing: unit)))"}
}

extension BudgetsClientTypes {
    /// <p>The amount of cost or usage that is measured for a budget.</p>
    /// 		       <p>For example, a <code>Spend</code> for <code>3 GB</code> of S3 usage would have the following parameters:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>An <code>Amount</code> of <code>3</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>A <code>unit</code> of <code>GB</code>
    ///                </p>
    /// 			         </li>
    ///          </ul>
    public struct Spend: Swift.Equatable {
        /// <p>The cost or usage amount that is associated with a budget forecast, actual spend, or budget threshold.</p>
        public let amount: Swift.String?
        /// <p>The unit of measurement that is used for the budget forecast, actual spend, or budget threshold, such as dollars or GB.</p>
        public let unit: Swift.String?

        public init (
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension BudgetsClientTypes.SsmActionDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionSubType = "ActionSubType"
        case instanceIds = "InstanceIds"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionSubType = actionSubType {
            try encodeContainer.encode(actionSubType.rawValue, forKey: .actionSubType)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceids0 in instanceIds {
                try instanceIdsContainer.encode(instanceids0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionSubTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionSubType.self, forKey: .actionSubType)
        actionSubType = actionSubTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension BudgetsClientTypes.SsmActionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SsmActionDefinition(actionSubType: \(Swift.String(describing: actionSubType)), instanceIds: \(Swift.String(describing: instanceIds)), region: \(Swift.String(describing: region)))"}
}

extension BudgetsClientTypes {
    /// <p>
    /// 			The AWS Systems Manager (SSM) action definition details.
    /// 		</p>
    public struct SsmActionDefinition: Swift.Equatable {
        /// <p>
        /// 			The action subType.
        /// 		</p>
        public let actionSubType: BudgetsClientTypes.ActionSubType?
        /// <p>
        /// 			The EC2 and RDS instance IDs.
        /// 		</p>
        public let instanceIds: [Swift.String]?
        /// <p>
        /// 			The Region to run the SSM document.
        /// 		</p>
        public let region: Swift.String?

        public init (
            actionSubType: BudgetsClientTypes.ActionSubType? = nil,
            instanceIds: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.actionSubType = actionSubType
            self.instanceIds = instanceIds
            self.region = region
        }
    }

}

extension BudgetsClientTypes.Subscriber: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case subscriptionType = "SubscriptionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let subscriptionType = subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
    }
}

extension BudgetsClientTypes.Subscriber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subscriber(address: \(Swift.String(describing: address)), subscriptionType: \(Swift.String(describing: subscriptionType)))"}
}

extension BudgetsClientTypes {
    /// <p>The subscriber to a budget notification. The subscriber consists of a subscription type and either an Amazon SNS topic or an email address.</p>
    /// 		       <p>For example, an email subscriber would have the following parameters:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <code>subscriptionType</code> of <code>EMAIL</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An <code>address</code> of <code>example@example.com</code>
    ///                </p>
    /// 			         </li>
    ///          </ul>
    public struct Subscriber: Swift.Equatable {
        /// <p>The address that AWS sends budget notifications to, either an SNS topic or an email.</p>
        /// 		       <p>When you create a subscriber, the value of <code>Address</code> can't contain line breaks.</p>
        public let address: Swift.String?
        /// <p>The type of notification that AWS sends to a subscriber.</p>
        public let subscriptionType: BudgetsClientTypes.SubscriptionType?

        public init (
            address: Swift.String? = nil,
            subscriptionType: BudgetsClientTypes.SubscriptionType? = nil
        )
        {
            self.address = address
            self.subscriptionType = subscriptionType
        }
    }

}

extension BudgetsClientTypes {
    /// <p> The subscription type of the subscriber. It can be SMS or EMAIL.</p>
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .email,
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    /// <p> The type of threshold for a notification.</p>
    public enum ThresholdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absoluteValue
        case percentage
        case sdkUnknown(Swift.String)

        public static var allCases: [ThresholdType] {
            return [
                .absoluteValue,
                .percentage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absoluteValue: return "ABSOLUTE_VALUE"
            case .percentage: return "PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThresholdType(rawValue: rawValue) ?? ThresholdType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.TimePeriod: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end.timeIntervalSince1970, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .end)
        end = endDecoded
    }
}

extension BudgetsClientTypes.TimePeriod: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimePeriod(end: \(Swift.String(describing: end)), start: \(Swift.String(describing: start)))"}
}

extension BudgetsClientTypes {
    /// <p>The period of time that is covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
    public struct TimePeriod: Swift.Equatable {
        /// <p>The end date for a budget. If you didn't specify an end date, AWS set your end date to <code>06/15/87 00:00 UTC</code>. The defaults are the same for the AWS Billing and Cost Management console and the API.</p>
        /// 		       <p>After the end date, AWS deletes the budget and all associated notifications and subscribers. You can change your end date with the <code>UpdateBudget</code> operation.</p>
        public let end: ClientRuntime.Date?
        /// <p>The start date for a budget. If you created your budget and didn't specify a start date, AWS defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose <code>DAILY</code>, and didn't set a start date, AWS set your start date to <code>01/24/18 00:00 UTC</code>. If you chose <code>MONTHLY</code>, AWS set your start date to <code>01/01/18 00:00 UTC</code>. The defaults are the same for the AWS Billing and Cost Management console and the API.</p>
        /// 		       <p>You can change your start date with the <code>UpdateBudget</code> operation.</p>
        public let start: ClientRuntime.Date?

        public init (
            end: ClientRuntime.Date? = nil,
            start: ClientRuntime.Date? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension BudgetsClientTypes {
    /// <p> The time unit of the budget, such as MONTHLY or QUARTERLY.</p>
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case annually
        case daily
        case monthly
        case quarterly
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .annually,
                .daily,
                .monthly,
                .quarterly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .annually: return "ANNUALLY"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .quarterly: return "QUARTERLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

public struct UpdateBudgetActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBudgetActionOutputError>
}

extension UpdateBudgetActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBudgetActionInput(accountId: \(Swift.String(describing: accountId)), actionId: \(Swift.String(describing: actionId)), actionThreshold: \(Swift.String(describing: actionThreshold)), approvalModel: \(Swift.String(describing: approvalModel)), budgetName: \(Swift.String(describing: budgetName)), definition: \(Swift.String(describing: definition)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), notificationType: \(Swift.String(describing: notificationType)), subscribers: \(Swift.String(describing: subscribers)))"}
}

extension UpdateBudgetActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let approvalModel = approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }
}

public struct UpdateBudgetActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBudgetActionOutputError>
}

public struct UpdateBudgetActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBudgetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBudgetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBudgetActionOutputError>
}

public struct UpdateBudgetActionInput: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: Swift.String?
    /// <p>
    /// 			The trigger threshold of the action.
    /// 		</p>
    public let actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// <p>
    ///          This specifies if the action needs manual or automatic approval.
    ///       </p>
    public let approvalModel: BudgetsClientTypes.ApprovalModel?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p>
    /// 			Specifies all of the type-specific parameters.
    /// 		</p>
    public let definition: BudgetsClientTypes.Definition?
    /// <p>
    ///          The role passed for action execution and reversion. Roles and actions must be in the same account.
    ///       </p>
    public let executionRoleArn: Swift.String?
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    public let notificationType: BudgetsClientTypes.NotificationType?
    /// <p> A list of subscribers.</p>
    public let subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.actionThreshold = actionThreshold
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct UpdateBudgetActionInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let actionId: Swift.String?
    public let notificationType: BudgetsClientTypes.NotificationType?
    public let actionThreshold: BudgetsClientTypes.ActionThreshold?
    public let definition: BudgetsClientTypes.Definition?
    public let executionRoleArn: Swift.String?
    public let approvalModel: BudgetsClientTypes.ApprovalModel?
    public let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension UpdateBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension UpdateBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBudgetActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBudgetActionOutputResponse(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), newAction: \(Swift.String(describing: newAction)), oldAction: \(Swift.String(describing: oldAction)))"}
}

extension UpdateBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.budgetName = output.budgetName
            self.newAction = output.newAction
            self.oldAction = output.oldAction
        } else {
            self.accountId = nil
            self.budgetName = nil
            self.newAction = nil
            self.oldAction = nil
        }
    }
}

public struct UpdateBudgetActionOutputResponse: Swift.Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: Swift.String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: Swift.String?
    /// <p>
    ///          The updated action resource information.
    ///       </p>
    public let newAction: BudgetsClientTypes.Action?
    /// <p>
    ///          The previous action resource information.
    ///       </p>
    public let oldAction: BudgetsClientTypes.Action?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newAction: BudgetsClientTypes.Action? = nil,
        oldAction: BudgetsClientTypes.Action? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newAction = newAction
        self.oldAction = oldAction
    }
}

struct UpdateBudgetActionOutputResponseBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let oldAction: BudgetsClientTypes.Action?
    public let newAction: BudgetsClientTypes.Action?
}

extension UpdateBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newAction = "NewAction"
        case oldAction = "OldAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldActionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .oldAction)
        oldAction = oldActionDecoded
        let newActionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .newAction)
        newAction = newActionDecoded
    }
}

public struct UpdateBudgetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBudgetOutputError>
}

extension UpdateBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBudgetInput(accountId: \(Swift.String(describing: accountId)), newBudget: \(Swift.String(describing: newBudget)))"}
}

extension UpdateBudgetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let newBudget = newBudget {
            try encodeContainer.encode(newBudget, forKey: .newBudget)
        }
    }
}

public struct UpdateBudgetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBudgetOutputError>
}

public struct UpdateBudgetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBudgetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBudgetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBudgetOutputError>
}

/// <p> Request of UpdateBudget </p>
public struct UpdateBudgetInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to update.</p>
    public let accountId: Swift.String?
    /// <p>The budget that you want to update your budget to.</p>
    public let newBudget: BudgetsClientTypes.Budget?

    public init (
        accountId: Swift.String? = nil,
        newBudget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.accountId = accountId
        self.newBudget = newBudget
    }
}

struct UpdateBudgetInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let newBudget: BudgetsClientTypes.Budget?
}

extension UpdateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let newBudgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .newBudget)
        newBudget = newBudgetDecoded
    }
}

extension UpdateBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBudgetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBudgetOutputResponse()"}
}

extension UpdateBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of UpdateBudget </p>
public struct UpdateBudgetOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateBudgetOutputResponseBody: Swift.Equatable {
}

extension UpdateBudgetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateNotificationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNotificationOutputError>
}

extension UpdateNotificationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNotificationInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), newNotification: \(Swift.String(describing: newNotification)), oldNotification: \(Swift.String(describing: oldNotification)))"}
}

extension UpdateNotificationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newNotification = newNotification {
            try encodeContainer.encode(newNotification, forKey: .newNotification)
        }
        if let oldNotification = oldNotification {
            try encodeContainer.encode(oldNotification, forKey: .oldNotification)
        }
    }
}

public struct UpdateNotificationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNotificationOutputError>
}

public struct UpdateNotificationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNotificationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNotificationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNotificationOutputError>
}

/// <p> Request of UpdateNotification </p>
public struct UpdateNotificationInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to update.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget whose notification you want to update.</p>
    public let budgetName: Swift.String?
    /// <p>The updated notification to be associated with a budget.</p>
    public let newNotification: BudgetsClientTypes.Notification?
    /// <p>The previous notification that is associated with a budget.</p>
    public let oldNotification: BudgetsClientTypes.Notification?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newNotification: BudgetsClientTypes.Notification? = nil,
        oldNotification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newNotification = newNotification
        self.oldNotification = oldNotification
    }
}

struct UpdateNotificationInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let oldNotification: BudgetsClientTypes.Notification?
    public let newNotification: BudgetsClientTypes.Notification?
}

extension UpdateNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldNotificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .oldNotification)
        oldNotification = oldNotificationDecoded
        let newNotificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .newNotification)
        newNotification = newNotificationDecoded
    }
}

extension UpdateNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNotificationOutputResponse()"}
}

extension UpdateNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of UpdateNotification </p>
public struct UpdateNotificationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateNotificationOutputResponseBody: Swift.Equatable {
}

extension UpdateNotificationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateSubscriberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubscriberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubscriberOutputError>
}

extension UpdateSubscriberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriberInput(accountId: \(Swift.String(describing: accountId)), budgetName: \(Swift.String(describing: budgetName)), newSubscriber: \(Swift.String(describing: newSubscriber)), notification: \(Swift.String(describing: notification)), oldSubscriber: \(Swift.String(describing: oldSubscriber)))"}
}

extension UpdateSubscriberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newSubscriber = newSubscriber {
            try encodeContainer.encode(newSubscriber, forKey: .newSubscriber)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let oldSubscriber = oldSubscriber {
            try encodeContainer.encode(oldSubscriber, forKey: .oldSubscriber)
        }
    }
}

public struct UpdateSubscriberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubscriberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubscriberOutputError>
}

public struct UpdateSubscriberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubscriberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubscriberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubscriberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubscriberOutputError>
}

/// <p> Request of UpdateSubscriber </p>
public struct UpdateSubscriberInput: Swift.Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to update.</p>
    public let accountId: Swift.String?
    /// <p>The name of the budget whose subscriber you want to update.</p>
    public let budgetName: Swift.String?
    /// <p>The updated subscriber that is associated with a budget notification.</p>
    public let newSubscriber: BudgetsClientTypes.Subscriber?
    /// <p>The notification whose subscriber you want to update.</p>
    public let notification: BudgetsClientTypes.Notification?
    /// <p>The previous subscriber that is associated with a budget notification.</p>
    public let oldSubscriber: BudgetsClientTypes.Subscriber?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newSubscriber: BudgetsClientTypes.Subscriber? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        oldSubscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newSubscriber = newSubscriber
        self.notification = notification
        self.oldSubscriber = oldSubscriber
    }
}

struct UpdateSubscriberInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let budgetName: Swift.String?
    public let notification: BudgetsClientTypes.Notification?
    public let oldSubscriber: BudgetsClientTypes.Subscriber?
    public let newSubscriber: BudgetsClientTypes.Subscriber?
}

extension UpdateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let oldSubscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .oldSubscriber)
        oldSubscriber = oldSubscriberDecoded
        let newSubscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .newSubscriber)
        newSubscriber = newSubscriberDecoded
    }
}

extension UpdateSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriberOutputResponse()"}
}

extension UpdateSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of UpdateSubscriber </p>
public struct UpdateSubscriberOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateSubscriberOutputResponseBody: Swift.Equatable {
}

extension UpdateSubscriberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
