// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptEnvironmentAccountConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEnvironmentAccountConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEnvironmentAccountConnectionOutputError>
}

extension AcceptEnvironmentAccountConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptEnvironmentAccountConnectionInput(id: \(Swift.String(describing: id)))"}
}

extension AcceptEnvironmentAccountConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct AcceptEnvironmentAccountConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEnvironmentAccountConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEnvironmentAccountConnectionOutputError>
}

public struct AcceptEnvironmentAccountConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEnvironmentAccountConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEnvironmentAccountConnectionOutputError>
}

public struct AcceptEnvironmentAccountConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEnvironmentAccountConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AcceptEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEnvironmentAccountConnectionOutputError>
}

public struct AcceptEnvironmentAccountConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEnvironmentAccountConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AcceptEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEnvironmentAccountConnectionOutputError>
}

public struct AcceptEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct AcceptEnvironmentAccountConnectionInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension AcceptEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension AcceptEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptEnvironmentAccountConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptEnvironmentAccountConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptEnvironmentAccountConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptEnvironmentAccountConnectionOutputResponse(environmentAccountConnection: \(Swift.String(describing: environmentAccountConnection)))"}
}

extension AcceptEnvironmentAccountConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptEnvironmentAccountConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct AcceptEnvironmentAccountConnectionOutputResponse: Swift.Equatable {
    /// The environment account connection data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init (
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct AcceptEnvironmentAccountConnectionOutputResponseBody: Swift.Equatable {
    public let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension AcceptEnvironmentAccountConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There isn't sufficient access for performing this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProtonClientTypes.AccountSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineProvisioningRepository
        case pipelineServiceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineProvisioningRepository = pipelineProvisioningRepository {
            try encodeContainer.encode(pipelineProvisioningRepository, forKey: .pipelineProvisioningRepository)
        }
        if let pipelineServiceRoleArn = pipelineServiceRoleArn {
            try encodeContainer.encode(pipelineServiceRoleArn, forKey: .pipelineServiceRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineServiceRoleArn)
        pipelineServiceRoleArn = pipelineServiceRoleArnDecoded
        let pipelineProvisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranch.self, forKey: .pipelineProvisioningRepository)
        pipelineProvisioningRepository = pipelineProvisioningRepositoryDecoded
    }
}

extension ProtonClientTypes.AccountSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountSettings(pipelineProvisioningRepository: \(Swift.String(describing: pipelineProvisioningRepository)), pipelineServiceRoleArn: \(Swift.String(describing: pipelineServiceRoleArn)))"}
}

extension ProtonClientTypes {
    /// The Proton pipeline service role and repository data.
    public struct AccountSettings: Swift.Equatable {
        /// The repository that you provide with pull request provisioning. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
        public var pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranch?
        /// The Amazon Resource Name (ARN) of the Proton pipeline service role.
        public var pipelineServiceRoleArn: Swift.String?

        public init (
            pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranch? = nil,
            pipelineServiceRoleArn: Swift.String? = nil
        )
        {
            self.pipelineProvisioningRepository = pipelineProvisioningRepository
            self.pipelineServiceRoleArn = pipelineServiceRoleArn
        }
    }

}

public struct CancelEnvironmentDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelEnvironmentDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelEnvironmentDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelEnvironmentDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelEnvironmentDeploymentOutputError>
}

extension CancelEnvironmentDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelEnvironmentDeploymentInput(environmentName: \(Swift.String(describing: environmentName)))"}
}

extension CancelEnvironmentDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
    }
}

public struct CancelEnvironmentDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelEnvironmentDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelEnvironmentDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelEnvironmentDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelEnvironmentDeploymentOutputError>
}

public struct CancelEnvironmentDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelEnvironmentDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelEnvironmentDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelEnvironmentDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelEnvironmentDeploymentOutputError>
}

public struct CancelEnvironmentDeploymentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelEnvironmentDeploymentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelEnvironmentDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelEnvironmentDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelEnvironmentDeploymentOutputError>
}

public struct CancelEnvironmentDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelEnvironmentDeploymentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelEnvironmentDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelEnvironmentDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelEnvironmentDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelEnvironmentDeploymentOutputError>
}

public struct CancelEnvironmentDeploymentInput: Swift.Equatable {
    /// The name of the environment with the deployment to cancel.
    /// This member is required.
    public var environmentName: Swift.String?

    public init (
        environmentName: Swift.String? = nil
    )
    {
        self.environmentName = environmentName
    }
}

struct CancelEnvironmentDeploymentInputBody: Swift.Equatable {
    public let environmentName: Swift.String?
}

extension CancelEnvironmentDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
    }
}

extension CancelEnvironmentDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelEnvironmentDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelEnvironmentDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelEnvironmentDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelEnvironmentDeploymentOutputResponse(environment: \(Swift.String(describing: environment)))"}
}

extension CancelEnvironmentDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelEnvironmentDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct CancelEnvironmentDeploymentOutputResponse: Swift.Equatable {
    /// The environment summary data that's returned by Proton.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init (
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct CancelEnvironmentDeploymentOutputResponseBody: Swift.Equatable {
    public let environment: ProtonClientTypes.Environment?
}

extension CancelEnvironmentDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct CancelServiceInstanceDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServiceInstanceDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelServiceInstanceDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelServiceInstanceDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServiceInstanceDeploymentOutputError>
}

extension CancelServiceInstanceDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelServiceInstanceDeploymentInput(serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension CancelServiceInstanceDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceInstanceName = serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct CancelServiceInstanceDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServiceInstanceDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelServiceInstanceDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelServiceInstanceDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServiceInstanceDeploymentOutputError>
}

public struct CancelServiceInstanceDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServiceInstanceDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelServiceInstanceDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelServiceInstanceDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServiceInstanceDeploymentOutputError>
}

public struct CancelServiceInstanceDeploymentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServiceInstanceDeploymentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelServiceInstanceDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelServiceInstanceDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServiceInstanceDeploymentOutputError>
}

public struct CancelServiceInstanceDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServiceInstanceDeploymentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelServiceInstanceDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelServiceInstanceDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServiceInstanceDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServiceInstanceDeploymentOutputError>
}

public struct CancelServiceInstanceDeploymentInput: Swift.Equatable {
    /// The name of the service instance with the deployment to cancel.
    /// This member is required.
    public var serviceInstanceName: Swift.String?
    /// The name of the service with the service instance deployment to cancel.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct CancelServiceInstanceDeploymentInputBody: Swift.Equatable {
    public let serviceInstanceName: Swift.String?
    public let serviceName: Swift.String?
}

extension CancelServiceInstanceDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension CancelServiceInstanceDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelServiceInstanceDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelServiceInstanceDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelServiceInstanceDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelServiceInstanceDeploymentOutputResponse(serviceInstance: \(Swift.String(describing: serviceInstance)))"}
}

extension CancelServiceInstanceDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelServiceInstanceDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstance = output.serviceInstance
        } else {
            self.serviceInstance = nil
        }
    }
}

public struct CancelServiceInstanceDeploymentOutputResponse: Swift.Equatable {
    /// The service instance summary data that's returned by Proton.
    /// This member is required.
    public var serviceInstance: ProtonClientTypes.ServiceInstance?

    public init (
        serviceInstance: ProtonClientTypes.ServiceInstance? = nil
    )
    {
        self.serviceInstance = serviceInstance
    }
}

struct CancelServiceInstanceDeploymentOutputResponseBody: Swift.Equatable {
    public let serviceInstance: ProtonClientTypes.ServiceInstance?
}

extension CancelServiceInstanceDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstance
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceInstance.self, forKey: .serviceInstance)
        serviceInstance = serviceInstanceDecoded
    }
}

public struct CancelServicePipelineDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServicePipelineDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelServicePipelineDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelServicePipelineDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServicePipelineDeploymentOutputError>
}

extension CancelServicePipelineDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelServicePipelineDeploymentInput(serviceName: \(Swift.String(describing: serviceName)))"}
}

extension CancelServicePipelineDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct CancelServicePipelineDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServicePipelineDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelServicePipelineDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelServicePipelineDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServicePipelineDeploymentOutputError>
}

public struct CancelServicePipelineDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServicePipelineDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelServicePipelineDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelServicePipelineDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServicePipelineDeploymentOutputError>
}

public struct CancelServicePipelineDeploymentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServicePipelineDeploymentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelServicePipelineDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelServicePipelineDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServicePipelineDeploymentOutputError>
}

public struct CancelServicePipelineDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelServicePipelineDeploymentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelServicePipelineDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelServicePipelineDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelServicePipelineDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelServicePipelineDeploymentOutputError>
}

public struct CancelServicePipelineDeploymentInput: Swift.Equatable {
    /// The name of the service with the service pipeline deployment to cancel.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        serviceName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
    }
}

struct CancelServicePipelineDeploymentInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
}

extension CancelServicePipelineDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension CancelServicePipelineDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelServicePipelineDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelServicePipelineDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelServicePipelineDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelServicePipelineDeploymentOutputResponse(pipeline: \(Swift.String(describing: pipeline)))"}
}

extension CancelServicePipelineDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelServicePipelineDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct CancelServicePipelineDeploymentOutputResponse: Swift.Equatable {
    /// The service pipeline detail data that's returned by Proton.
    /// This member is required.
    public var pipeline: ProtonClientTypes.ServicePipeline?

    public init (
        pipeline: ProtonClientTypes.ServicePipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct CancelServicePipelineDeploymentOutputResponseBody: Swift.Equatable {
    public let pipeline: ProtonClientTypes.ServicePipeline?
}

extension CancelServicePipelineDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServicePipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension ProtonClientTypes.CompatibleEnvironmentTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ProtonClientTypes.CompatibleEnvironmentTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompatibleEnvironmentTemplate(majorVersion: \(Swift.String(describing: majorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// Compatible environment template data.
    public struct CompatibleEnvironmentTemplate: Swift.Equatable {
        /// The major version of the compatible environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The compatible environment template name.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            majorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.CompatibleEnvironmentTemplateInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ProtonClientTypes.CompatibleEnvironmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompatibleEnvironmentTemplateInput(majorVersion: \(Swift.String(describing: majorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// Compatible environment template data.
    public struct CompatibleEnvironmentTemplateInput: Swift.Equatable {
        /// The major version of the compatible environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The compatible environment template name.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            majorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request couldn't be made due to a conflicting operation or resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateEnvironmentAccountConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentAccountConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentAccountConnectionOutputError>
}

extension CreateEnvironmentAccountConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentAccountConnectionInput(clientToken: \(Swift.String(describing: clientToken)), environmentName: \(Swift.String(describing: environmentName)), managementAccountId: \(Swift.String(describing: managementAccountId)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEnvironmentAccountConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case environmentName
        case managementAccountId
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let managementAccountId = managementAccountId {
            try encodeContainer.encode(managementAccountId, forKey: .managementAccountId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEnvironmentAccountConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentAccountConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentAccountConnectionOutputError>
}

public struct CreateEnvironmentAccountConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentAccountConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentAccountConnectionOutputError>
}

public struct CreateEnvironmentAccountConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentAccountConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentAccountConnectionOutputError>
}

public struct CreateEnvironmentAccountConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentAccountConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentAccountConnectionOutputError>
}

public struct CreateEnvironmentAccountConnectionInput: Swift.Equatable {
    /// When included, if two identical requests are made with the same client token, Proton returns the environment account connection that the first request created.
    public var clientToken: Swift.String?
    /// The name of the Proton environment that's created in the associated management account.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The ID of the management account that accepts or rejects the environment account connection. You create an manage the Proton environment in this account. If the management account accepts the environment account connection, Proton can use the associated IAM role to provision environment infrastructure resources in the associated environment account.
    /// This member is required.
    public var managementAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that's created in the environment account. Proton uses this role to provision infrastructure resources in the associated environment account.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Tags for your environment account connection. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/adminguide/resources.html) in the Proton Administrator Guide.
    public var tags: [ProtonClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        managementAccountId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.managementAccountId = managementAccountId
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateEnvironmentAccountConnectionInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let managementAccountId: Swift.String?
    public let roleArn: Swift.String?
    public let environmentName: Swift.String?
    public let tags: [ProtonClientTypes.Tag]?
}

extension CreateEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case environmentName
        case managementAccountId
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let managementAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementAccountId)
        managementAccountId = managementAccountIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentAccountConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentAccountConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentAccountConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentAccountConnectionOutputResponse(environmentAccountConnection: \(Swift.String(describing: environmentAccountConnection)))"}
}

extension CreateEnvironmentAccountConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentAccountConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct CreateEnvironmentAccountConnectionOutputResponse: Swift.Equatable {
    /// The environment account connection detail data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init (
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct CreateEnvironmentAccountConnectionOutputResponseBody: Swift.Equatable {
    public let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension CreateEnvironmentAccountConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

public struct CreateEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(description: \(Swift.String(describing: description)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioningRepository: \(Swift.String(describing: provisioningRepository)), spec: \(Swift.String(describing: spec)), tags: \(Swift.String(describing: tags)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension CreateEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioningRepository = provisioningRepository {
            try encodeContainer.encode(provisioningRepository, forKey: .provisioningRepository)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct CreateEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// A description of the environment that's being created and deployed.
    public var description: Swift.String?
    /// The ID of the environment account connection that you provide if you're provisioning your environment infrastructure resources to an environment account. You must include either the environmentAccountConnectionId or protonServiceRoleArn parameter and value and omit the provisioningRepository parameter and values. For more information, see [Environment account connections](https://docs.aws.amazon.com/proton/latest/adminguide/ag-env-account-connections.html) in the Proton Administrator guide.
    public var environmentAccountConnectionId: Swift.String?
    /// The name of the environment.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf. You must include either the environmentAccountConnectionId or protonServiceRoleArn parameter and value and omit the provisioningRepository parameter when you use standard provisioning.
    public var protonServiceRoleArn: Swift.String?
    /// The repository that you provide with pull request provisioning. If you provide this parameter, you must omit the environmentAccountConnectionId and protonServiceRoleArn parameters. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
    public var provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    /// A link to a YAML formatted spec file that provides inputs as defined in the environment template bundle schema file. For more information, see [Environments](https://docs.aws.amazon.com/proton/latest/adminguide/ag-environments.html) in the Proton Administrator Guide.
    /// This member is required.
    public var spec: Swift.String?
    /// Create tags for your environment. For more information, see Proton resources and tagging in the [Proton Administrator Guide](https://docs.aws.amazon.com/proton/latest/adminguide/resources.html) or [Proton User Guide](https://docs.aws.amazon.com/proton/latest/userguide/resources.html).
    public var tags: [ProtonClientTypes.Tag]?
    /// The major version of the environment template.
    /// This member is required.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the environment template.
    public var templateMinorVersion: Swift.String?
    /// The name of the environment template. For more information, see [Environment Templates](https://docs.aws.amazon.com/proton/latest/adminguide/ag-templates.html) in the Proton Administrator Guide.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        description: Swift.String? = nil,
        environmentAccountConnectionId: Swift.String? = nil,
        name: Swift.String? = nil,
        protonServiceRoleArn: Swift.String? = nil,
        provisioningRepository: ProtonClientTypes.RepositoryBranchInput? = nil,
        spec: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.description = description
        self.environmentAccountConnectionId = environmentAccountConnectionId
        self.name = name
        self.protonServiceRoleArn = protonServiceRoleArn
        self.provisioningRepository = provisioningRepository
        self.spec = spec
        self.tags = tags
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
        self.templateName = templateName
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let templateName: Swift.String?
    public let templateMajorVersion: Swift.String?
    public let templateMinorVersion: Swift.String?
    public let description: Swift.String?
    public let spec: Swift.String?
    public let protonServiceRoleArn: Swift.String?
    public let environmentAccountConnectionId: Swift.String?
    public let tags: [ProtonClientTypes.Tag]?
    public let provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let provisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranchInput.self, forKey: .provisioningRepository)
        provisioningRepository = provisioningRepositoryDecoded
    }
}

extension CreateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentOutputResponse(environment: \(Swift.String(describing: environment)))"}
}

extension CreateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Swift.Equatable {
    /// The environment detail data that's returned by Proton.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init (
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct CreateEnvironmentOutputResponseBody: Swift.Equatable {
    public let environment: ProtonClientTypes.Environment?
}

extension CreateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct CreateEnvironmentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateOutputError>
}

extension CreateEnvironmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentTemplateInput(description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), provisioning: \(Swift.String(describing: provisioning)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEnvironmentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case provisioning
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioning = provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEnvironmentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateOutputError>
}

public struct CreateEnvironmentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateOutputError>
}

public struct CreateEnvironmentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateOutputError>
}

public struct CreateEnvironmentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateOutputError>
}

public struct CreateEnvironmentTemplateInput: Swift.Equatable {
    /// A description of the environment template.
    public var description: Swift.String?
    /// The environment template name as displayed in the developer interface.
    public var displayName: Swift.String?
    /// A customer provided encryption key that Proton uses to encrypt data.
    public var encryptionKey: Swift.String?
    /// The name of the environment template.
    /// This member is required.
    public var name: Swift.String?
    /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
    public var provisioning: ProtonClientTypes.Provisioning?
    /// Create tags for your environment template. For more information, see Proton resources and tagging in the [Proton Administrator Guide](https://docs.aws.amazon.com/proton/latest/adminguide/resources.html) or [Proton User Guide](https://docs.aws.amazon.com/proton/latest/userguide/resources.html).
    public var tags: [ProtonClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioning: ProtonClientTypes.Provisioning? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.encryptionKey = encryptionKey
        self.name = name
        self.provisioning = provisioning
        self.tags = tags
    }
}

struct CreateEnvironmentTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let displayName: Swift.String?
    public let description: Swift.String?
    public let encryptionKey: Swift.String?
    public let provisioning: ProtonClientTypes.Provisioning?
    public let tags: [ProtonClientTypes.Tag]?
}

extension CreateEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case provisioning
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentTemplateOutputResponse(environmentTemplate: \(Swift.String(describing: environmentTemplate)))"}
}

extension CreateEnvironmentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct CreateEnvironmentTemplateOutputResponse: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init (
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct CreateEnvironmentTemplateOutputResponseBody: Swift.Equatable {
    public let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension CreateEnvironmentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

public struct CreateEnvironmentTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateVersionOutputError>
}

extension CreateEnvironmentTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentTemplateVersionInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), majorVersion: \(Swift.String(describing: majorVersion)), source: \(Swift.String(describing: source)), tags: \(Swift.String(describing: tags)), templateName: \(Swift.String(describing: templateName)))"}
}

extension CreateEnvironmentTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case majorVersion
        case source
        case tags
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct CreateEnvironmentTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateVersionOutputError>
}

public struct CreateEnvironmentTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateVersionOutputError>
}

public struct CreateEnvironmentTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateVersionOutputError>
}

public struct CreateEnvironmentTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentTemplateVersionOutputError>
}

public struct CreateEnvironmentTemplateVersionInput: Swift.Equatable {
    /// When included, if two identical requests are made with the same client token, Proton returns the environment template version that the first request created.
    public var clientToken: Swift.String?
    /// A description of the new version of an environment template.
    public var description: Swift.String?
    /// To create a new minor version of the environment template, include a major Version. To create a new major and minor version of the environment template, exclude major Version.
    public var majorVersion: Swift.String?
    /// An object that includes the template bundle S3 bucket path and name for the new version of an template.
    /// This member is required.
    public var source: ProtonClientTypes.TemplateVersionSourceInput?
    /// Create tags for a new version of an environment template.
    public var tags: [ProtonClientTypes.Tag]?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        source: ProtonClientTypes.TemplateVersionSourceInput? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.majorVersion = majorVersion
        self.source = source
        self.tags = tags
        self.templateName = templateName
    }
}

struct CreateEnvironmentTemplateVersionInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let templateName: Swift.String?
    public let description: Swift.String?
    public let majorVersion: Swift.String?
    public let source: ProtonClientTypes.TemplateVersionSourceInput?
    public let tags: [ProtonClientTypes.Tag]?
}

extension CreateEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case majorVersion
        case source
        case tags
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionSourceInput.self, forKey: .source)
        source = sourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentTemplateVersionOutputResponse(environmentTemplateVersion: \(Swift.String(describing: environmentTemplateVersion)))"}
}

extension CreateEnvironmentTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct CreateEnvironmentTemplateVersionOutputResponse: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init (
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct CreateEnvironmentTemplateVersionOutputResponseBody: Swift.Equatable {
    public let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension CreateEnvironmentTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryInput(connectionArn: \(Swift.String(describing: connectionArn)), encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)))"}
}

extension CreateRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn
        case encryptionKey
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of your Amazon Web Services CodeStar connection. For more information, see [Setting up for Proton](https://docs.aws.amazon.com/setting-up-for-service) in the Proton Administrator Guide.
    /// This member is required.
    public var connectionArn: Swift.String?
    /// The ARN of your customer Amazon Web Services Key Management Service (Amazon Web Services KMS) key.
    public var encryptionKey: Swift.String?
    /// The repository name, for example myrepos/myrepo.
    /// This member is required.
    public var name: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var provider: ProtonClientTypes.RepositoryProvider?

    public init (
        connectionArn: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: ProtonClientTypes.RepositoryProvider? = nil
    )
    {
        self.connectionArn = connectionArn
        self.encryptionKey = encryptionKey
        self.name = name
        self.provider = provider
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    public let provider: ProtonClientTypes.RepositoryProvider?
    public let name: Swift.String?
    public let connectionArn: Swift.String?
    public let encryptionKey: Swift.String?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn
        case encryptionKey
        case name
        case provider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension CreateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension CreateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Swift.Equatable {
    /// The repository detail data that's returned by Proton.
    /// This member is required.
    public var repository: ProtonClientTypes.Repository?

    public init (
        repository: ProtonClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: ProtonClientTypes.Repository?
}

extension CreateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct CreateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInput(branchName: \(Swift.String(describing: branchName)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), repositoryConnectionArn: \(Swift.String(describing: repositoryConnectionArn)), repositoryId: \(Swift.String(describing: repositoryId)), spec: \(Swift.String(describing: spec)), tags: \(Swift.String(describing: tags)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension CreateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
        case name
        case repositoryConnectionArn
        case repositoryId
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let repositoryConnectionArn = repositoryConnectionArn {
            try encodeContainer.encode(repositoryConnectionArn, forKey: .repositoryConnectionArn)
        }
        if let repositoryId = repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct CreateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInput: Swift.Equatable {
    /// The name of the code repository branch that holds the code that's deployed in Proton. Don't include this parameter if your service template doesn't include a service pipeline.
    public var branchName: Swift.String?
    /// A description of the Proton service.
    public var description: Swift.String?
    /// The service name.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the repository connection. For more information, see [Set up repository connection](https://docs.aws.amazon.com/proton/latest/adminguide/setting-up-for-service.html#setting-up-vcontrol) in the Proton Administrator Guide and [Setting up with Proton](https://docs.aws.amazon.com/proton/latest/userguide/proton-setup.html#setup-repo-connection) in the Proton User Guide. Don't include this parameter if your service template doesn't include a service pipeline.
    public var repositoryConnectionArn: Swift.String?
    /// The ID of the code repository. Don't include this parameter if your service template doesn't include a service pipeline.
    public var repositoryId: Swift.String?
    /// A link to a spec file that provides inputs as defined in the service template bundle schema file. The spec file is in YAML format. Don’t include pipeline inputs in the spec if your service template doesn’t include a service pipeline. For more information, see [Create a service](https://docs.aws.amazon.com/proton/latest/adminguide/ag-create-svc.html.html) in the Proton Administrator Guide and [Create a service](https://docs.aws.amazon.com/proton/latest/userguide/ug-svc-create.html) in the Proton User Guide.
    /// This member is required.
    public var spec: Swift.String?
    /// Create tags for your service. For more information, see Proton resources and tagging in the [Proton Administrator Guide](https://docs.aws.amazon.com/proton/latest/adminguide/resources.html) or [Proton User Guide](https://docs.aws.amazon.com/proton/latest/userguide/resources.html).
    public var tags: [ProtonClientTypes.Tag]?
    /// The major version of the service template that was used to create the service.
    /// This member is required.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the service template that was used to create the service.
    public var templateMinorVersion: Swift.String?
    /// The name of the service template that's used to create the service.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        branchName: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        repositoryConnectionArn: Swift.String? = nil,
        repositoryId: Swift.String? = nil,
        spec: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.description = description
        self.name = name
        self.repositoryConnectionArn = repositoryConnectionArn
        self.repositoryId = repositoryId
        self.spec = spec
        self.tags = tags
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
        self.templateName = templateName
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let templateName: Swift.String?
    public let templateMajorVersion: Swift.String?
    public let templateMinorVersion: Swift.String?
    public let spec: Swift.String?
    public let repositoryConnectionArn: Swift.String?
    public let repositoryId: Swift.String?
    public let branchName: Swift.String?
    public let tags: [ProtonClientTypes.Tag]?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
        case name
        case repositoryConnectionArn
        case repositoryId
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let repositoryConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryConnectionArn)
        repositoryConnectionArn = repositoryConnectionArnDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// The service detail data that's returned by Proton.
    /// This member is required.
    public var service: ProtonClientTypes.Service?

    public init (
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    public let service: ProtonClientTypes.Service?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

public struct CreateServiceTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateOutputError>
}

extension CreateServiceTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceTemplateInput(description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), pipelineProvisioning: \(Swift.String(describing: pipelineProvisioning)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateServiceTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case pipelineProvisioning
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineProvisioning = pipelineProvisioning {
            try encodeContainer.encode(pipelineProvisioning.rawValue, forKey: .pipelineProvisioning)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServiceTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateOutputError>
}

public struct CreateServiceTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateOutputError>
}

public struct CreateServiceTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateOutputError>
}

public struct CreateServiceTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateOutputError>
}

public struct CreateServiceTemplateInput: Swift.Equatable {
    /// A description of the service template.
    public var description: Swift.String?
    /// The name of the service template as displayed in the developer interface.
    public var displayName: Swift.String?
    /// A customer provided encryption key that's used to encrypt data.
    public var encryptionKey: Swift.String?
    /// The name of the service template.
    /// This member is required.
    public var name: Swift.String?
    /// Proton includes a service pipeline for your service by default. When included, this parameter indicates that an Proton service pipeline won't be included for your service. Once specified, this parameter can't be changed. For more information, see [Service template bundles](https://docs.aws.amazon.com/proton/latest/adminguide/ag-template-bundles.html) in the Proton Administrator Guide.
    public var pipelineProvisioning: ProtonClientTypes.Provisioning?
    /// Create tags for your service template. For more information, see Proton resources and tagging in the [Proton Administrator Guide](https://docs.aws.amazon.com/proton/latest/adminguide/resources.html) or [Proton User Guide](https://docs.aws.amazon.com/proton/latest/userguide/resources.html).
    public var tags: [ProtonClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        name: Swift.String? = nil,
        pipelineProvisioning: ProtonClientTypes.Provisioning? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.encryptionKey = encryptionKey
        self.name = name
        self.pipelineProvisioning = pipelineProvisioning
        self.tags = tags
    }
}

struct CreateServiceTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let displayName: Swift.String?
    public let description: Swift.String?
    public let encryptionKey: Swift.String?
    public let pipelineProvisioning: ProtonClientTypes.Provisioning?
    public let tags: [ProtonClientTypes.Tag]?
}

extension CreateServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case pipelineProvisioning
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let pipelineProvisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .pipelineProvisioning)
        pipelineProvisioning = pipelineProvisioningDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceTemplateOutputResponse(serviceTemplate: \(Swift.String(describing: serviceTemplate)))"}
}

extension CreateServiceTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct CreateServiceTemplateOutputResponse: Swift.Equatable {
    /// The service template detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init (
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct CreateServiceTemplateOutputResponseBody: Swift.Equatable {
    public let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension CreateServiceTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

public struct CreateServiceTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateVersionOutputError>
}

extension CreateServiceTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceTemplateVersionInput(clientToken: \(Swift.String(describing: clientToken)), compatibleEnvironmentTemplates: \(Swift.String(describing: compatibleEnvironmentTemplates)), description: \(Swift.String(describing: description)), majorVersion: \(Swift.String(describing: majorVersion)), source: \(Swift.String(describing: source)), tags: \(Swift.String(describing: tags)), templateName: \(Swift.String(describing: templateName)))"}
}

extension CreateServiceTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case source
        case tags
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let compatibleEnvironmentTemplates = compatibleEnvironmentTemplates {
            var compatibleEnvironmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleEnvironmentTemplates)
            for compatibleenvironmenttemplateinputlist0 in compatibleEnvironmentTemplates {
                try compatibleEnvironmentTemplatesContainer.encode(compatibleenvironmenttemplateinputlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct CreateServiceTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateVersionOutputError>
}

public struct CreateServiceTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateVersionOutputError>
}

public struct CreateServiceTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateVersionOutputError>
}

public struct CreateServiceTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceTemplateVersionOutputError>
}

public struct CreateServiceTemplateVersionInput: Swift.Equatable {
    /// When included, if two identical requests are made with the same client token, Proton returns the service template version that the first request created.
    public var clientToken: Swift.String?
    /// An array of compatible environment template objects for the new version of a service template.
    /// This member is required.
    public var compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
    /// A description of the new version of a service template.
    public var description: Swift.String?
    /// To create a new minor version of the service template, include a major Version. To create a new major and minor version of the service template, exclude major Version.
    public var majorVersion: Swift.String?
    /// An object that includes the template bundle S3 bucket path and name for the new version of a service template.
    /// This member is required.
    public var source: ProtonClientTypes.TemplateVersionSourceInput?
    /// Create tags for a new version of a service template.
    public var tags: [ProtonClientTypes.Tag]?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil,
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        source: ProtonClientTypes.TemplateVersionSourceInput? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
        self.description = description
        self.majorVersion = majorVersion
        self.source = source
        self.tags = tags
        self.templateName = templateName
    }
}

struct CreateServiceTemplateVersionInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let templateName: Swift.String?
    public let description: Swift.String?
    public let majorVersion: Swift.String?
    public let source: ProtonClientTypes.TemplateVersionSourceInput?
    public let compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
    public let tags: [ProtonClientTypes.Tag]?
}

extension CreateServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case source
        case tags
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionSourceInput.self, forKey: .source)
        source = sourceDecoded
        let compatibleEnvironmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.CompatibleEnvironmentTemplateInput?].self, forKey: .compatibleEnvironmentTemplates)
        var compatibleEnvironmentTemplatesDecoded0:[ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil
        if let compatibleEnvironmentTemplatesContainer = compatibleEnvironmentTemplatesContainer {
            compatibleEnvironmentTemplatesDecoded0 = [ProtonClientTypes.CompatibleEnvironmentTemplateInput]()
            for structure0 in compatibleEnvironmentTemplatesContainer {
                if let structure0 = structure0 {
                    compatibleEnvironmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        compatibleEnvironmentTemplates = compatibleEnvironmentTemplatesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceTemplateVersionOutputResponse(serviceTemplateVersion: \(Swift.String(describing: serviceTemplateVersion)))"}
}

extension CreateServiceTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct CreateServiceTemplateVersionOutputResponse: Swift.Equatable {
    /// The service template version summary of detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init (
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct CreateServiceTemplateVersionOutputResponseBody: Swift.Equatable {
    public let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension CreateServiceTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

public struct CreateTemplateSyncConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTemplateSyncConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTemplateSyncConfigOutputError>
}

extension CreateTemplateSyncConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTemplateSyncConfigInput(branch: \(Swift.String(describing: branch)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryProvider: \(Swift.String(describing: repositoryProvider)), subdirectory: \(Swift.String(describing: subdirectory)), templateName: \(Swift.String(describing: templateName)), templateType: \(Swift.String(describing: templateType)))"}
}

extension CreateTemplateSyncConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

public struct CreateTemplateSyncConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTemplateSyncConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTemplateSyncConfigOutputError>
}

public struct CreateTemplateSyncConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTemplateSyncConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTemplateSyncConfigOutputError>
}

public struct CreateTemplateSyncConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTemplateSyncConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTemplateSyncConfigOutputError>
}

public struct CreateTemplateSyncConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTemplateSyncConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTemplateSyncConfigOutputError>
}

public struct CreateTemplateSyncConfigInput: Swift.Equatable {
    /// The branch of the registered repository for your template.
    /// This member is required.
    public var branch: Swift.String?
    /// The name of your repository, for example myrepos/myrepo.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The provider type for your repository.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// A repository subdirectory path to your template bundle directory. When included, Proton limits the template bundle search to this repository directory.
    public var subdirectory: Swift.String?
    /// The name of your registered template.
    /// This member is required.
    public var templateName: Swift.String?
    /// The type of the registered template.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init (
        branch: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        subdirectory: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.branch = branch
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.subdirectory = subdirectory
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct CreateTemplateSyncConfigInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let templateType: ProtonClientTypes.TemplateType?
    public let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    public let repositoryName: Swift.String?
    public let branch: Swift.String?
    public let subdirectory: Swift.String?
}

extension CreateTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
    }
}

extension CreateTemplateSyncConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateSyncConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTemplateSyncConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateSyncConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTemplateSyncConfigOutputResponse(templateSyncConfig: \(Swift.String(describing: templateSyncConfig)))"}
}

extension CreateTemplateSyncConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTemplateSyncConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct CreateTemplateSyncConfigOutputResponse: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init (
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct CreateTemplateSyncConfigOutputResponseBody: Swift.Equatable {
    public let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension CreateTemplateSyncConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

public struct DeleteEnvironmentAccountConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentAccountConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentAccountConnectionOutputError>
}

extension DeleteEnvironmentAccountConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentAccountConnectionInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteEnvironmentAccountConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteEnvironmentAccountConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentAccountConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentAccountConnectionOutputError>
}

public struct DeleteEnvironmentAccountConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentAccountConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentAccountConnectionOutputError>
}

public struct DeleteEnvironmentAccountConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentAccountConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentAccountConnectionOutputError>
}

public struct DeleteEnvironmentAccountConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentAccountConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentAccountConnectionOutputError>
}

public struct DeleteEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteEnvironmentAccountConnectionInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DeleteEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentAccountConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentAccountConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentAccountConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentAccountConnectionOutputResponse(environmentAccountConnection: \(Swift.String(describing: environmentAccountConnection)))"}
}

extension DeleteEnvironmentAccountConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEnvironmentAccountConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct DeleteEnvironmentAccountConnectionOutputResponse: Swift.Equatable {
    /// The environment account connection detail data that's returned by Proton.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init (
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct DeleteEnvironmentAccountConnectionOutputResponseBody: Swift.Equatable {
    public let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension DeleteEnvironmentAccountConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

public struct DeleteEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

extension DeleteEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The name of the environment to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentOutputResponse(environment: \(Swift.String(describing: environment)))"}
}

extension DeleteEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct DeleteEnvironmentOutputResponse: Swift.Equatable {
    /// The environment detail data that's returned by Proton.
    public var environment: ProtonClientTypes.Environment?

    public init (
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct DeleteEnvironmentOutputResponseBody: Swift.Equatable {
    public let environment: ProtonClientTypes.Environment?
}

extension DeleteEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct DeleteEnvironmentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateOutputError>
}

extension DeleteEnvironmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentTemplateInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteEnvironmentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEnvironmentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateOutputError>
}

public struct DeleteEnvironmentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateOutputError>
}

public struct DeleteEnvironmentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateOutputError>
}

public struct DeleteEnvironmentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateOutputError>
}

public struct DeleteEnvironmentTemplateInput: Swift.Equatable {
    /// The name of the environment template to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEnvironmentTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEnvironmentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentTemplateOutputResponse(environmentTemplate: \(Swift.String(describing: environmentTemplate)))"}
}

extension DeleteEnvironmentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEnvironmentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct DeleteEnvironmentTemplateOutputResponse: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init (
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct DeleteEnvironmentTemplateOutputResponseBody: Swift.Equatable {
    public let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension DeleteEnvironmentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

public struct DeleteEnvironmentTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateVersionOutputError>
}

extension DeleteEnvironmentTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentTemplateVersionInput(majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension DeleteEnvironmentTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct DeleteEnvironmentTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateVersionOutputError>
}

public struct DeleteEnvironmentTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateVersionOutputError>
}

public struct DeleteEnvironmentTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateVersionOutputError>
}

public struct DeleteEnvironmentTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentTemplateVersionOutputError>
}

public struct DeleteEnvironmentTemplateVersionInput: Swift.Equatable {
    /// The environment template major version to delete.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// The environment template minor version to delete.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct DeleteEnvironmentTemplateVersionInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
    public let minorVersion: Swift.String?
}

extension DeleteEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension DeleteEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentTemplateVersionOutputResponse(environmentTemplateVersion: \(Swift.String(describing: environmentTemplateVersion)))"}
}

extension DeleteEnvironmentTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEnvironmentTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct DeleteEnvironmentTemplateVersionOutputResponse: Swift.Equatable {
    /// The environment template version detail data that's returned by Proton.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init (
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct DeleteEnvironmentTemplateVersionOutputResponseBody: Swift.Equatable {
    public let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension DeleteEnvironmentTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

public struct DeleteRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

extension DeleteRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryInput(name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)))"}
}

extension DeleteRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInput: Swift.Equatable {
    /// The name of the repository.
    /// This member is required.
    public var name: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var provider: ProtonClientTypes.RepositoryProvider?

    public init (
        name: Swift.String? = nil,
        provider: ProtonClientTypes.RepositoryProvider? = nil
    )
    {
        self.name = name
        self.provider = provider
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    public let provider: ProtonClientTypes.RepositoryProvider?
    public let name: Swift.String?
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension DeleteRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Swift.Equatable {
    /// The repository detail data that's returned by Proton.
    public var repository: ProtonClientTypes.Repository?

    public init (
        repository: ProtonClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: ProtonClientTypes.Repository?
}

extension DeleteRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DeleteServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

extension DeleteServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The name of the service to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {
    /// The service detail data that's returned by Proton.
    public var service: ProtonClientTypes.Service?

    public init (
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
    public let service: ProtonClientTypes.Service?
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

public struct DeleteServiceTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateOutputError>
}

extension DeleteServiceTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceTemplateInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteServiceTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteServiceTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateOutputError>
}

public struct DeleteServiceTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateOutputError>
}

public struct DeleteServiceTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateOutputError>
}

public struct DeleteServiceTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateOutputError>
}

public struct DeleteServiceTemplateInput: Swift.Equatable {
    /// The name of the service template to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteServiceTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteServiceTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceTemplateOutputResponse(serviceTemplate: \(Swift.String(describing: serviceTemplate)))"}
}

extension DeleteServiceTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteServiceTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct DeleteServiceTemplateOutputResponse: Swift.Equatable {
    /// The service template detail data that's returned by Proton.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init (
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct DeleteServiceTemplateOutputResponseBody: Swift.Equatable {
    public let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension DeleteServiceTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

public struct DeleteServiceTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateVersionOutputError>
}

extension DeleteServiceTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceTemplateVersionInput(majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension DeleteServiceTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct DeleteServiceTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateVersionOutputError>
}

public struct DeleteServiceTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateVersionOutputError>
}

public struct DeleteServiceTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateVersionOutputError>
}

public struct DeleteServiceTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceTemplateVersionOutputError>
}

public struct DeleteServiceTemplateVersionInput: Swift.Equatable {
    /// The service template major version to delete.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// The service template minor version to delete.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct DeleteServiceTemplateVersionInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
    public let minorVersion: Swift.String?
}

extension DeleteServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension DeleteServiceTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceTemplateVersionOutputResponse(serviceTemplateVersion: \(Swift.String(describing: serviceTemplateVersion)))"}
}

extension DeleteServiceTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteServiceTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct DeleteServiceTemplateVersionOutputResponse: Swift.Equatable {
    /// The service template version detail data that's returned by Proton.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init (
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct DeleteServiceTemplateVersionOutputResponseBody: Swift.Equatable {
    public let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension DeleteServiceTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

public struct DeleteTemplateSyncConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTemplateSyncConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTemplateSyncConfigOutputError>
}

extension DeleteTemplateSyncConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTemplateSyncConfigInput(templateName: \(Swift.String(describing: templateName)), templateType: \(Swift.String(describing: templateType)))"}
}

extension DeleteTemplateSyncConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

public struct DeleteTemplateSyncConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTemplateSyncConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTemplateSyncConfigOutputError>
}

public struct DeleteTemplateSyncConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTemplateSyncConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTemplateSyncConfigOutputError>
}

public struct DeleteTemplateSyncConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTemplateSyncConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTemplateSyncConfigOutputError>
}

public struct DeleteTemplateSyncConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTemplateSyncConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTemplateSyncConfigOutputError>
}

public struct DeleteTemplateSyncConfigInput: Swift.Equatable {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init (
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct DeleteTemplateSyncConfigInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let templateType: ProtonClientTypes.TemplateType?
}

extension DeleteTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
    }
}

extension DeleteTemplateSyncConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTemplateSyncConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTemplateSyncConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateSyncConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTemplateSyncConfigOutputResponse(templateSyncConfig: \(Swift.String(describing: templateSyncConfig)))"}
}

extension DeleteTemplateSyncConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteTemplateSyncConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct DeleteTemplateSyncConfigOutputResponse: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init (
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct DeleteTemplateSyncConfigOutputResponseBody: Swift.Equatable {
    public let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension DeleteTemplateSyncConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

extension ProtonClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case deleteComplete
        case deleteFailed
        case deleteInProgress
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .cancelled,
                .cancelling,
                .deleteComplete,
                .deleteFailed,
                .deleteInProgress,
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    public enum DeploymentUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case currentVersion
        case majorVersion
        case minorVersion
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentUpdateType] {
            return [
                .currentVersion,
                .majorVersion,
                .minorVersion,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .currentVersion: return "CURRENT_VERSION"
            case .majorVersion: return "MAJOR_VERSION"
            case .minorVersion: return "MINOR_VERSION"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentUpdateType(rawValue: rawValue) ?? DeploymentUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.Environment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case description
        case environmentAccountConnectionId
        case environmentAccountId
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case name
        case protonServiceRoleArn
        case provisioning
        case provisioningRepository
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let environmentAccountId = environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let lastDeploymentAttemptedAt = lastDeploymentAttemptedAt {
            try encodeContainer.encode(lastDeploymentAttemptedAt.timeIntervalSince1970, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = lastDeploymentSucceededAt {
            try encodeContainer.encode(lastDeploymentSucceededAt.timeIntervalSince1970, forKey: .lastDeploymentSucceededAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioning = provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let provisioningRepository = provisioningRepository {
            try encodeContainer.encode(provisioningRepository, forKey: .provisioningRepository)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
        let provisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranch.self, forKey: .provisioningRepository)
        provisioningRepository = provisioningRepositoryDecoded
    }
}

extension ProtonClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), deploymentStatusMessage: \(Swift.String(describing: deploymentStatusMessage)), description: \(Swift.String(describing: description)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), environmentAccountId: \(Swift.String(describing: environmentAccountId)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioning: \(Swift.String(describing: provisioning)), provisioningRepository: \(Swift.String(describing: provisioningRepository)), spec: \(Swift.String(describing: spec)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// The environment detail data. An Proton environment is a set resources shared across an Proton service.
    public struct Environment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the environment was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The environment deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// An environment deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The ID of the environment account connection that's used to provision infrastructure resources in an environment account.
        public var environmentAccountConnectionId: Swift.String?
        /// The ID of the environment account that the environment infrastructure resources are provisioned in.
        public var environmentAccountId: Swift.String?
        /// The time when a deployment of the environment was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the environment was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The name of the environment.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf.
        public var protonServiceRoleArn: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The repository that you provide with pull request provisioning. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
        public var provisioningRepository: ProtonClientTypes.RepositoryBranch?
        /// The environment spec.
        public var spec: Swift.String?
        /// The ID of the major version of the environment template.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The ID of the minor version of the environment template.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentAccountConnectionId: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            protonServiceRoleArn: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            provisioningRepository: ProtonClientTypes.RepositoryBranch? = nil,
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.environmentAccountId = environmentAccountId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioning = provisioning
            self.provisioningRepository = provisioningRepository
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentAccountConnection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environmentAccountId
        case environmentName
        case id
        case lastModifiedAt
        case managementAccountId
        case requestedAt
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let environmentAccountId = environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let managementAccountId = managementAccountId {
            try encodeContainer.encode(managementAccountId, forKey: .managementAccountId)
        }
        if let requestedAt = requestedAt {
            try encodeContainer.encode(requestedAt.timeIntervalSince1970, forKey: .requestedAt)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let managementAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementAccountId)
        managementAccountId = managementAccountIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let requestedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestedAt)
        requestedAt = requestedAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ProtonClientTypes.EnvironmentAccountConnection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentAccountConnection(arn: \(Swift.String(describing: arn)), environmentAccountId: \(Swift.String(describing: environmentAccountId)), environmentName: \(Swift.String(describing: environmentName)), id: \(Swift.String(describing: id)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), managementAccountId: \(Swift.String(describing: managementAccountId)), requestedAt: \(Swift.String(describing: requestedAt)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension ProtonClientTypes {
    /// The environment account connection detail data.
    public struct EnvironmentAccountConnection: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment account connection.
        /// This member is required.
        public var arn: Swift.String?
        /// The environment account that's connected to the environment account connection.
        /// This member is required.
        public var environmentAccountId: Swift.String?
        /// The name of the environment that's associated with the environment account connection.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the environment account connection.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the environment account connection was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the management account that's connected to the environment account connection.
        /// This member is required.
        public var managementAccountId: Swift.String?
        /// The time when the environment account connection request was made.
        /// This member is required.
        public var requestedAt: ClientRuntime.Date?
        /// The IAM service role that's associated with the environment account connection.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the environment account connection.
        /// This member is required.
        public var status: ProtonClientTypes.EnvironmentAccountConnectionStatus?

        public init (
            arn: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            managementAccountId: Swift.String? = nil,
            requestedAt: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: ProtonClientTypes.EnvironmentAccountConnectionStatus? = nil
        )
        {
            self.arn = arn
            self.environmentAccountId = environmentAccountId
            self.environmentName = environmentName
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.managementAccountId = managementAccountId
            self.requestedAt = requestedAt
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension ProtonClientTypes {
    public enum EnvironmentAccountConnectionRequesterAccountType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case environmentAccount
        case managementAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentAccountConnectionRequesterAccountType] {
            return [
                .environmentAccount,
                .managementAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .environmentAccount: return "ENVIRONMENT_ACCOUNT"
            case .managementAccount: return "MANAGEMENT_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentAccountConnectionRequesterAccountType(rawValue: rawValue) ?? EnvironmentAccountConnectionRequesterAccountType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    public enum EnvironmentAccountConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentAccountConnectionStatus] {
            return [
                .connected,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentAccountConnectionStatus(rawValue: rawValue) ?? EnvironmentAccountConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.EnvironmentAccountConnectionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environmentAccountId
        case environmentName
        case id
        case lastModifiedAt
        case managementAccountId
        case requestedAt
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let environmentAccountId = environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let managementAccountId = managementAccountId {
            try encodeContainer.encode(managementAccountId, forKey: .managementAccountId)
        }
        if let requestedAt = requestedAt {
            try encodeContainer.encode(requestedAt.timeIntervalSince1970, forKey: .requestedAt)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let managementAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementAccountId)
        managementAccountId = managementAccountIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let requestedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestedAt)
        requestedAt = requestedAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ProtonClientTypes.EnvironmentAccountConnectionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentAccountConnectionSummary(arn: \(Swift.String(describing: arn)), environmentAccountId: \(Swift.String(describing: environmentAccountId)), environmentName: \(Swift.String(describing: environmentName)), id: \(Swift.String(describing: id)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), managementAccountId: \(Swift.String(describing: managementAccountId)), requestedAt: \(Swift.String(describing: requestedAt)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension ProtonClientTypes {
    /// A summary of the environment account connection detail data.
    public struct EnvironmentAccountConnectionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment account connection.
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the environment account that's connected to the environment account connection.
        /// This member is required.
        public var environmentAccountId: Swift.String?
        /// The name of the environment that's associated with the environment account connection.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the environment account connection.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the environment account connection was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the management account that's connected to the environment account connection.
        /// This member is required.
        public var managementAccountId: Swift.String?
        /// The time when the environment account connection request was made.
        /// This member is required.
        public var requestedAt: ClientRuntime.Date?
        /// The IAM service role that's associated with the environment account connection.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the environment account connection.
        /// This member is required.
        public var status: ProtonClientTypes.EnvironmentAccountConnectionStatus?

        public init (
            arn: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            managementAccountId: Swift.String? = nil,
            requestedAt: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: ProtonClientTypes.EnvironmentAccountConnectionStatus? = nil
        )
        {
            self.arn = arn
            self.environmentAccountId = environmentAccountId
            self.environmentName = environmentName
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.managementAccountId = managementAccountId
            self.requestedAt = requestedAt
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension ProtonClientTypes.EnvironmentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case description
        case environmentAccountConnectionId
        case environmentAccountId
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case name
        case protonServiceRoleArn
        case provisioning
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let environmentAccountId = environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let lastDeploymentAttemptedAt = lastDeploymentAttemptedAt {
            try encodeContainer.encode(lastDeploymentAttemptedAt.timeIntervalSince1970, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = lastDeploymentSucceededAt {
            try encodeContainer.encode(lastDeploymentSucceededAt.timeIntervalSince1970, forKey: .lastDeploymentSucceededAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioning = provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
    }
}

extension ProtonClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), deploymentStatusMessage: \(Swift.String(describing: deploymentStatusMessage)), description: \(Swift.String(describing: description)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), environmentAccountId: \(Swift.String(describing: environmentAccountId)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioning: \(Swift.String(describing: provisioning)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// A summary of the environment detail data.
    public struct EnvironmentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the environment was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The environment deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// An environment deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The ID of the environment account connection that the environment is associated with.
        public var environmentAccountConnectionId: Swift.String?
        /// The ID of the environment account that the environment infrastructure resources are provisioned in.
        public var environmentAccountId: Swift.String?
        /// The time when a deployment of the environment was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the environment was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The name of the environment.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf.
        public var protonServiceRoleArn: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The major version of the environment template.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the environment template.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentAccountConnectionId: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            protonServiceRoleArn: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.environmentAccountId = environmentAccountId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioning = provisioning
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case encryptionKey
        case lastModifiedAt
        case name
        case provisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioning = provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let recommendedVersion = recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplate(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), encryptionKey: \(Swift.String(describing: encryptionKey)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), provisioning: \(Swift.String(describing: provisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)))"}
}

extension ProtonClientTypes {
    /// The environment template data.
    public struct EnvironmentTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the environment template.
        public var description: Swift.String?
        /// The name of the environment template as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The customer provided encryption key for the environment template.
        public var encryptionKey: Swift.String?
        /// The time when the environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the environment template.
        /// This member is required.
        public var name: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The ID of the recommended version of the environment template.
        public var recommendedVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            encryptionKey: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.provisioning = provisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplateFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplateFilter(majorVersion: \(Swift.String(describing: majorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// A search filter for environment templates.
    public struct EnvironmentTemplateFilter: Swift.Equatable {
        /// Include majorVersion to filter search for a major version.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// Include templateName to filter search for a template name.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            majorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case lastModifiedAt
        case name
        case provisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioning = provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let recommendedVersion = recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplateSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), provisioning: \(Swift.String(describing: provisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)))"}
}

extension ProtonClientTypes {
    /// The environment template data.
    public struct EnvironmentTemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the environment template.
        public var description: Swift.String?
        /// The name of the environment template as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The time when the environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the environment template.
        /// This member is required.
        public var name: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The recommended version of the environment template.
        public var recommendedVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.provisioning = provisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case schema
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplateVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplateVersion(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), schema: \(Swift.String(describing: schema)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// The environment template version data.
    public struct EnvironmentTemplateVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of an environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the version of an environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the minor version of an environment template.
        public var description: Swift.String?
        /// The time when the version of an environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of an environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The minor version of an environment template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the environment template.
        public var recommendedMinorVersion: Swift.String?
        /// The schema of the version of an environment template.
        public var schema: Swift.String?
        /// The status of the version of an environment template.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// The status message of the version of an environment template.
        public var statusMessage: Swift.String?
        /// The name of the version of an environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            schema: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.schema = schema
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplateVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplateVersionSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// A summary of the version of an environment template detail data.
    public struct EnvironmentTemplateVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of an environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the version of an environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the version of an environment template.
        public var description: Swift.String?
        /// The time when the version of an environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of an environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The version of an environment template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the environment template.
        public var recommendedMinorVersion: Swift.String?
        /// The status of the version of an environment template.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// The status message of the version of an environment template.
        public var statusMessage: Swift.String?
        /// The name of the version of an environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension GetAccountSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsInput()"}
}

extension GetAccountSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccountSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInput: Swift.Equatable {

    public init() {}
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsOutputResponse(accountSettings: \(Swift.String(describing: accountSettings)))"}
}

extension GetAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct GetAccountSettingsOutputResponse: Swift.Equatable {
    /// The Proton pipeline service role detail data that's returned by Proton.
    public var accountSettings: ProtonClientTypes.AccountSettings?

    public init (
        accountSettings: ProtonClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputResponseBody: Swift.Equatable {
    public let accountSettings: ProtonClientTypes.AccountSettings?
}

extension GetAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

public struct GetEnvironmentAccountConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentAccountConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentAccountConnectionOutputError>
}

extension GetEnvironmentAccountConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentAccountConnectionInput(id: \(Swift.String(describing: id)))"}
}

extension GetEnvironmentAccountConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetEnvironmentAccountConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentAccountConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentAccountConnectionOutputError>
}

public struct GetEnvironmentAccountConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentAccountConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentAccountConnectionOutputError>
}

public struct GetEnvironmentAccountConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentAccountConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentAccountConnectionOutputError>
}

public struct GetEnvironmentAccountConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentAccountConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentAccountConnectionOutputError>
}

public struct GetEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetEnvironmentAccountConnectionInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension GetEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentAccountConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentAccountConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentAccountConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentAccountConnectionOutputResponse(environmentAccountConnection: \(Swift.String(describing: environmentAccountConnection)))"}
}

extension GetEnvironmentAccountConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentAccountConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct GetEnvironmentAccountConnectionOutputResponse: Swift.Equatable {
    /// The environment account connection detail data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init (
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct GetEnvironmentAccountConnectionOutputResponseBody: Swift.Equatable {
    public let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension GetEnvironmentAccountConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

public struct GetEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

extension GetEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentInput(name: \(Swift.String(describing: name)))"}
}

extension GetEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The name of the environment that you want to get the detail data for.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentOutputResponse(environment: \(Swift.String(describing: environment)))"}
}

extension GetEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Swift.Equatable {
    /// The environment detail data that's returned by Proton.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init (
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputResponseBody: Swift.Equatable {
    public let environment: ProtonClientTypes.Environment?
}

extension GetEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct GetEnvironmentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateOutputError>
}

extension GetEnvironmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentTemplateInput(name: \(Swift.String(describing: name)))"}
}

extension GetEnvironmentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetEnvironmentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateOutputError>
}

public struct GetEnvironmentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateOutputError>
}

public struct GetEnvironmentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateOutputError>
}

public struct GetEnvironmentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateOutputError>
}

public struct GetEnvironmentTemplateInput: Swift.Equatable {
    /// The name of the environment template that you want to get the detail data for.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetEnvironmentTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetEnvironmentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentTemplateOutputResponse(environmentTemplate: \(Swift.String(describing: environmentTemplate)))"}
}

extension GetEnvironmentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct GetEnvironmentTemplateOutputResponse: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init (
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct GetEnvironmentTemplateOutputResponseBody: Swift.Equatable {
    public let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension GetEnvironmentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

public struct GetEnvironmentTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateVersionOutputError>
}

extension GetEnvironmentTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentTemplateVersionInput(majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension GetEnvironmentTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct GetEnvironmentTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateVersionOutputError>
}

public struct GetEnvironmentTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateVersionOutputError>
}

public struct GetEnvironmentTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateVersionOutputError>
}

public struct GetEnvironmentTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentTemplateVersionOutputError>
}

public struct GetEnvironmentTemplateVersionInput: Swift.Equatable {
    /// To view environment template major version detail data, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To view environment template minor version detail data, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct GetEnvironmentTemplateVersionInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
    public let minorVersion: Swift.String?
}

extension GetEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension GetEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentTemplateVersionOutputResponse(environmentTemplateVersion: \(Swift.String(describing: environmentTemplateVersion)))"}
}

extension GetEnvironmentTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct GetEnvironmentTemplateVersionOutputResponse: Swift.Equatable {
    /// The environment template version detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init (
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct GetEnvironmentTemplateVersionOutputResponseBody: Swift.Equatable {
    public let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension GetEnvironmentTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

public struct GetRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryOutputError>
}

extension GetRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryInput(name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)))"}
}

extension GetRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }
}

public struct GetRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryOutputError>
}

public struct GetRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryOutputError>
}

public struct GetRepositoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryOutputError>
}

public struct GetRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryOutputError>
}

public struct GetRepositoryInput: Swift.Equatable {
    /// The repository name, for example myrepos/myrepo.
    /// This member is required.
    public var name: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var provider: ProtonClientTypes.RepositoryProvider?

    public init (
        name: Swift.String? = nil,
        provider: ProtonClientTypes.RepositoryProvider? = nil
    )
    {
        self.name = name
        self.provider = provider
    }
}

struct GetRepositoryInputBody: Swift.Equatable {
    public let provider: ProtonClientTypes.RepositoryProvider?
    public let name: Swift.String?
}

extension GetRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension GetRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct GetRepositoryOutputResponse: Swift.Equatable {
    /// The repository detail data that's returned by Proton.
    /// This member is required.
    public var repository: ProtonClientTypes.Repository?

    public init (
        repository: ProtonClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct GetRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: ProtonClientTypes.Repository?
}

extension GetRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct GetRepositorySyncStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositorySyncStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositorySyncStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositorySyncStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositorySyncStatusOutputError>
}

extension GetRepositorySyncStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositorySyncStatusInput(branch: \(Swift.String(describing: branch)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryProvider: \(Swift.String(describing: repositoryProvider)), syncType: \(Swift.String(describing: syncType)))"}
}

extension GetRepositorySyncStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType.rawValue, forKey: .syncType)
        }
    }
}

public struct GetRepositorySyncStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositorySyncStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositorySyncStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositorySyncStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositorySyncStatusOutputError>
}

public struct GetRepositorySyncStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositorySyncStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositorySyncStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositorySyncStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositorySyncStatusOutputError>
}

public struct GetRepositorySyncStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositorySyncStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRepositorySyncStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositorySyncStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositorySyncStatusOutputError>
}

public struct GetRepositorySyncStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositorySyncStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRepositorySyncStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositorySyncStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositorySyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositorySyncStatusOutputError>
}

public struct GetRepositorySyncStatusInput: Swift.Equatable {
    /// The repository branch.
    /// This member is required.
    public var branch: Swift.String?
    /// The repository name.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// The repository sync type.
    /// This member is required.
    public var syncType: ProtonClientTypes.SyncType?

    public init (
        branch: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        syncType: ProtonClientTypes.SyncType? = nil
    )
    {
        self.branch = branch
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.syncType = syncType
    }
}

struct GetRepositorySyncStatusInputBody: Swift.Equatable {
    public let repositoryName: Swift.String?
    public let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    public let branch: Swift.String?
    public let syncType: ProtonClientTypes.SyncType?
}

extension GetRepositorySyncStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.SyncType.self, forKey: .syncType)
        syncType = syncTypeDecoded
    }
}

extension GetRepositorySyncStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositorySyncStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositorySyncStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositorySyncStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositorySyncStatusOutputResponse(latestSync: \(Swift.String(describing: latestSync)))"}
}

extension GetRepositorySyncStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositorySyncStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.latestSync = output.latestSync
        } else {
            self.latestSync = nil
        }
    }
}

public struct GetRepositorySyncStatusOutputResponse: Swift.Equatable {
    /// The repository sync status detail data that's returned by Proton.
    public var latestSync: ProtonClientTypes.RepositorySyncAttempt?

    public init (
        latestSync: ProtonClientTypes.RepositorySyncAttempt? = nil
    )
    {
        self.latestSync = latestSync
    }
}

struct GetRepositorySyncStatusOutputResponseBody: Swift.Equatable {
    public let latestSync: ProtonClientTypes.RepositorySyncAttempt?
}

extension GetRepositorySyncStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestSync
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositorySyncAttempt.self, forKey: .latestSync)
        latestSync = latestSyncDecoded
    }
}

public struct GetServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

extension GetServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceInput(name: \(Swift.String(describing: name)))"}
}

extension GetServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInput: Swift.Equatable {
    /// The name of the service that you want to get the detail data for.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetServiceInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct GetServiceInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceInstanceOutputError>
}

extension GetServiceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceInstanceInput(name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension GetServiceInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct GetServiceInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceInstanceOutputError>
}

public struct GetServiceInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceInstanceOutputError>
}

public struct GetServiceInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetServiceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceInstanceOutputError>
}

public struct GetServiceInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetServiceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceInstanceOutputError>
}

public struct GetServiceInstanceInput: Swift.Equatable {
    /// The name of a service instance that you want to get the detail data for.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the service that the service instance belongs to.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        name: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.name = name
        self.serviceName = serviceName
    }
}

struct GetServiceInstanceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let serviceName: Swift.String?
}

extension GetServiceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension GetServiceInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceInstanceOutputResponse(serviceInstance: \(Swift.String(describing: serviceInstance)))"}
}

extension GetServiceInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstance = output.serviceInstance
        } else {
            self.serviceInstance = nil
        }
    }
}

public struct GetServiceInstanceOutputResponse: Swift.Equatable {
    /// The service instance detail data that's returned by Proton.
    /// This member is required.
    public var serviceInstance: ProtonClientTypes.ServiceInstance?

    public init (
        serviceInstance: ProtonClientTypes.ServiceInstance? = nil
    )
    {
        self.serviceInstance = serviceInstance
    }
}

struct GetServiceInstanceOutputResponseBody: Swift.Equatable {
    public let serviceInstance: ProtonClientTypes.ServiceInstance?
}

extension GetServiceInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstance
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceInstance.self, forKey: .serviceInstance)
        serviceInstance = serviceInstanceDecoded
    }
}

extension GetServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension GetServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct GetServiceOutputResponse: Swift.Equatable {
    /// The service detail data that's returned by Proton.
    public var service: ProtonClientTypes.Service?

    public init (
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct GetServiceOutputResponseBody: Swift.Equatable {
    public let service: ProtonClientTypes.Service?
}

extension GetServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

public struct GetServiceTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateOutputError>
}

extension GetServiceTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceTemplateInput(name: \(Swift.String(describing: name)))"}
}

extension GetServiceTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetServiceTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateOutputError>
}

public struct GetServiceTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateOutputError>
}

public struct GetServiceTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateOutputError>
}

public struct GetServiceTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateOutputError>
}

public struct GetServiceTemplateInput: Swift.Equatable {
    /// The name of the service template that you want to get detail data for.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetServiceTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetServiceTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceTemplateOutputResponse(serviceTemplate: \(Swift.String(describing: serviceTemplate)))"}
}

extension GetServiceTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct GetServiceTemplateOutputResponse: Swift.Equatable {
    /// The service template detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init (
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct GetServiceTemplateOutputResponseBody: Swift.Equatable {
    public let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension GetServiceTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

public struct GetServiceTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateVersionOutputError>
}

extension GetServiceTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceTemplateVersionInput(majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension GetServiceTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct GetServiceTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateVersionOutputError>
}

public struct GetServiceTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateVersionOutputError>
}

public struct GetServiceTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateVersionOutputError>
}

public struct GetServiceTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceTemplateVersionOutputError>
}

public struct GetServiceTemplateVersionInput: Swift.Equatable {
    /// To view service template major version detail data, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To view service template minor version detail data, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct GetServiceTemplateVersionInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
    public let minorVersion: Swift.String?
}

extension GetServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension GetServiceTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceTemplateVersionOutputResponse(serviceTemplateVersion: \(Swift.String(describing: serviceTemplateVersion)))"}
}

extension GetServiceTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct GetServiceTemplateVersionOutputResponse: Swift.Equatable {
    /// The service template version detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init (
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct GetServiceTemplateVersionOutputResponseBody: Swift.Equatable {
    public let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension GetServiceTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

public struct GetTemplateSyncConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncConfigOutputError>
}

extension GetTemplateSyncConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTemplateSyncConfigInput(templateName: \(Swift.String(describing: templateName)), templateType: \(Swift.String(describing: templateType)))"}
}

extension GetTemplateSyncConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

public struct GetTemplateSyncConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncConfigOutputError>
}

public struct GetTemplateSyncConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncConfigOutputError>
}

public struct GetTemplateSyncConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncConfigOutputError>
}

public struct GetTemplateSyncConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncConfigOutputError>
}

public struct GetTemplateSyncConfigInput: Swift.Equatable {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init (
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct GetTemplateSyncConfigInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let templateType: ProtonClientTypes.TemplateType?
}

extension GetTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
    }
}

extension GetTemplateSyncConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTemplateSyncConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTemplateSyncConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateSyncConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTemplateSyncConfigOutputResponse(templateSyncConfig: \(Swift.String(describing: templateSyncConfig)))"}
}

extension GetTemplateSyncConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTemplateSyncConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct GetTemplateSyncConfigOutputResponse: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init (
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct GetTemplateSyncConfigOutputResponseBody: Swift.Equatable {
    public let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension GetTemplateSyncConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

public struct GetTemplateSyncStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTemplateSyncStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTemplateSyncStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncStatusOutputError>
}

extension GetTemplateSyncStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTemplateSyncStatusInput(templateName: \(Swift.String(describing: templateName)), templateType: \(Swift.String(describing: templateType)), templateVersion: \(Swift.String(describing: templateVersion)))"}
}

extension GetTemplateSyncStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
        case templateVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
        if let templateVersion = templateVersion {
            try encodeContainer.encode(templateVersion, forKey: .templateVersion)
        }
    }
}

public struct GetTemplateSyncStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTemplateSyncStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTemplateSyncStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncStatusOutputError>
}

public struct GetTemplateSyncStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTemplateSyncStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTemplateSyncStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncStatusOutputError>
}

public struct GetTemplateSyncStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTemplateSyncStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTemplateSyncStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncStatusOutputError>
}

public struct GetTemplateSyncStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTemplateSyncStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTemplateSyncStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTemplateSyncStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTemplateSyncStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTemplateSyncStatusOutputError>
}

public struct GetTemplateSyncStatusInput: Swift.Equatable {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?
    /// The template version.
    /// This member is required.
    public var templateVersion: Swift.String?

    public init (
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil,
        templateVersion: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.templateType = templateType
        self.templateVersion = templateVersion
    }
}

struct GetTemplateSyncStatusInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let templateType: ProtonClientTypes.TemplateType?
    public let templateVersion: Swift.String?
}

extension GetTemplateSyncStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
        case templateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let templateVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
    }
}

extension GetTemplateSyncStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTemplateSyncStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTemplateSyncStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateSyncStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTemplateSyncStatusOutputResponse(desiredState: \(Swift.String(describing: desiredState)), latestSuccessfulSync: \(Swift.String(describing: latestSuccessfulSync)), latestSync: \(Swift.String(describing: latestSync)))"}
}

extension GetTemplateSyncStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTemplateSyncStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.desiredState = output.desiredState
            self.latestSuccessfulSync = output.latestSuccessfulSync
            self.latestSync = output.latestSync
        } else {
            self.desiredState = nil
            self.latestSuccessfulSync = nil
            self.latestSync = nil
        }
    }
}

public struct GetTemplateSyncStatusOutputResponse: Swift.Equatable {
    /// The template sync desired state that's returned by Proton.
    public var desiredState: ProtonClientTypes.Revision?
    /// The details of the last successful sync that's returned by Proton.
    public var latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt?
    /// The details of the last sync that's returned by Proton.
    public var latestSync: ProtonClientTypes.ResourceSyncAttempt?

    public init (
        desiredState: ProtonClientTypes.Revision? = nil,
        latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt? = nil,
        latestSync: ProtonClientTypes.ResourceSyncAttempt? = nil
    )
    {
        self.desiredState = desiredState
        self.latestSuccessfulSync = latestSuccessfulSync
        self.latestSync = latestSync
    }
}

struct GetTemplateSyncStatusOutputResponseBody: Swift.Equatable {
    public let latestSync: ProtonClientTypes.ResourceSyncAttempt?
    public let latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt?
    public let desiredState: ProtonClientTypes.Revision?
}

extension GetTemplateSyncStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case latestSuccessfulSync
        case latestSync
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncAttempt.self, forKey: .latestSync)
        latestSync = latestSyncDecoded
        let latestSuccessfulSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncAttempt.self, forKey: .latestSuccessfulSync)
        latestSuccessfulSync = latestSuccessfulSyncDecoded
        let desiredStateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Revision.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed to register with the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListEnvironmentAccountConnectionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentAccountConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentAccountConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentAccountConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentAccountConnectionsOutputError>
}

extension ListEnvironmentAccountConnectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentAccountConnectionsInput(environmentName: \(Swift.String(describing: environmentName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), requestedBy: \(Swift.String(describing: requestedBy)), statuses: \(Swift.String(describing: statuses)))"}
}

extension ListEnvironmentAccountConnectionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case maxResults
        case nextToken
        case requestedBy
        case statuses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let requestedBy = requestedBy {
            try encodeContainer.encode(requestedBy.rawValue, forKey: .requestedBy)
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for environmentaccountconnectionstatuslist0 in statuses {
                try statusesContainer.encode(environmentaccountconnectionstatuslist0.rawValue)
            }
        }
    }
}

public struct ListEnvironmentAccountConnectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentAccountConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentAccountConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentAccountConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentAccountConnectionsOutputError>
}

public struct ListEnvironmentAccountConnectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentAccountConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentAccountConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentAccountConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentAccountConnectionsOutputError>
}

public struct ListEnvironmentAccountConnectionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentAccountConnectionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentAccountConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentAccountConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentAccountConnectionsOutputError>
}

public struct ListEnvironmentAccountConnectionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentAccountConnectionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentAccountConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentAccountConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentAccountConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentAccountConnectionsOutputError>
}

public struct ListEnvironmentAccountConnectionsInput: Swift.Equatable {
    /// The environment name that's associated with each listed environment account connection.
    public var environmentName: Swift.String?
    /// The maximum number of environment account connections to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next environment account connection in the array of environment account connections, after the list of environment account connections that was previously requested.
    public var nextToken: Swift.String?
    /// The type of account making the ListEnvironmentAccountConnections request.
    /// This member is required.
    public var requestedBy: ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType?
    /// The status details for each listed environment account connection.
    public var statuses: [ProtonClientTypes.EnvironmentAccountConnectionStatus]?

    public init (
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        requestedBy: ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType? = nil,
        statuses: [ProtonClientTypes.EnvironmentAccountConnectionStatus]? = nil
    )
    {
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.requestedBy = requestedBy
        self.statuses = statuses
    }
}

struct ListEnvironmentAccountConnectionsInputBody: Swift.Equatable {
    public let requestedBy: ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType?
    public let environmentName: Swift.String?
    public let statuses: [ProtonClientTypes.EnvironmentAccountConnectionStatus]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListEnvironmentAccountConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case maxResults
        case nextToken
        case requestedBy
        case statuses
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedByDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType.self, forKey: .requestedBy)
        requestedBy = requestedByDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let statusesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentAccountConnectionStatus?].self, forKey: .statuses)
        var statusesDecoded0:[ProtonClientTypes.EnvironmentAccountConnectionStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [ProtonClientTypes.EnvironmentAccountConnectionStatus]()
            for string0 in statusesContainer {
                if let string0 = string0 {
                    statusesDecoded0?.append(string0)
                }
            }
        }
        statuses = statusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnvironmentAccountConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentAccountConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentAccountConnectionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentAccountConnectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentAccountConnectionsOutputResponse(environmentAccountConnections: \(Swift.String(describing: environmentAccountConnections)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentAccountConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentAccountConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnections = output.environmentAccountConnections
            self.nextToken = output.nextToken
        } else {
            self.environmentAccountConnections = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentAccountConnectionsOutputResponse: Swift.Equatable {
    /// An array of environment account connections with details that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnections: [ProtonClientTypes.EnvironmentAccountConnectionSummary]?
    /// A token to indicate the location of the next environment account connection in the array of environment account connections, after the current requested list of environment account connections.
    public var nextToken: Swift.String?

    public init (
        environmentAccountConnections: [ProtonClientTypes.EnvironmentAccountConnectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentAccountConnections = environmentAccountConnections
        self.nextToken = nextToken
    }
}

struct ListEnvironmentAccountConnectionsOutputResponseBody: Swift.Equatable {
    public let environmentAccountConnections: [ProtonClientTypes.EnvironmentAccountConnectionSummary]?
    public let nextToken: Swift.String?
}

extension ListEnvironmentAccountConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnections
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentAccountConnectionSummary?].self, forKey: .environmentAccountConnections)
        var environmentAccountConnectionsDecoded0:[ProtonClientTypes.EnvironmentAccountConnectionSummary]? = nil
        if let environmentAccountConnectionsContainer = environmentAccountConnectionsContainer {
            environmentAccountConnectionsDecoded0 = [ProtonClientTypes.EnvironmentAccountConnectionSummary]()
            for structure0 in environmentAccountConnectionsContainer {
                if let structure0 = structure0 {
                    environmentAccountConnectionsDecoded0?.append(structure0)
                }
            }
        }
        environmentAccountConnections = environmentAccountConnectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEnvironmentOutputsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentOutputsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentOutputsOutputError>
}

extension ListEnvironmentOutputsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentOutputsInput(environmentName: \(Swift.String(describing: environmentName)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentOutputsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEnvironmentOutputsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentOutputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentOutputsOutputError>
}

public struct ListEnvironmentOutputsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentOutputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentOutputsOutputError>
}

public struct ListEnvironmentOutputsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentOutputsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentOutputsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentOutputsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentOutputsOutputError>
}

public struct ListEnvironmentOutputsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentOutputsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentOutputsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentOutputsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentOutputsOutputError>
}

public struct ListEnvironmentOutputsInput: Swift.Equatable {
    /// The environment name.
    /// This member is required.
    public var environmentName: Swift.String?
    /// A token to indicate the location of the next environment output in the array of environment outputs, after the list of environment outputs that was previously requested.
    public var nextToken: Swift.String?

    public init (
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ListEnvironmentOutputsInputBody: Swift.Equatable {
    public let environmentName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListEnvironmentOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentOutputsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentOutputsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentOutputsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentOutputsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentOutputsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), outputs: \(Swift.String(describing: outputs)))"}
}

extension ListEnvironmentOutputsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentOutputsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outputs = output.outputs
        } else {
            self.nextToken = nil
            self.outputs = nil
        }
    }
}

public struct ListEnvironmentOutputsOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next environment output in the array of environment outputs, after the current requested list of environment outputs.
    public var nextToken: Swift.String?
    /// An array of environment outputs with detail data.
    /// This member is required.
    public var outputs: [ProtonClientTypes.Output]?

    public init (
        nextToken: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil
    )
    {
        self.nextToken = nextToken
        self.outputs = outputs
    }
}

struct ListEnvironmentOutputsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let outputs: [ProtonClientTypes.Output]?
}

extension ListEnvironmentOutputsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outputs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

public struct ListEnvironmentProvisionedResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentProvisionedResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentProvisionedResourcesOutputError>
}

extension ListEnvironmentProvisionedResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentProvisionedResourcesInput(environmentName: \(Swift.String(describing: environmentName)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentProvisionedResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEnvironmentProvisionedResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentProvisionedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentProvisionedResourcesOutputError>
}

public struct ListEnvironmentProvisionedResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentProvisionedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentProvisionedResourcesOutputError>
}

public struct ListEnvironmentProvisionedResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentProvisionedResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentProvisionedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentProvisionedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentProvisionedResourcesOutputError>
}

public struct ListEnvironmentProvisionedResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentProvisionedResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentProvisionedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentProvisionedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentProvisionedResourcesOutputError>
}

public struct ListEnvironmentProvisionedResourcesInput: Swift.Equatable {
    /// The environment name.
    /// This member is required.
    public var environmentName: Swift.String?
    /// A token to indicate the location of the next environment provisioned resource in the array of environment provisioned resources, after the list of environment provisioned resources that was previously requested.
    public var nextToken: Swift.String?

    public init (
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ListEnvironmentProvisionedResourcesInputBody: Swift.Equatable {
    public let environmentName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListEnvironmentProvisionedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentProvisionedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentProvisionedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentProvisionedResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentProvisionedResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentProvisionedResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), provisionedResources: \(Swift.String(describing: provisionedResources)))"}
}

extension ListEnvironmentProvisionedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentProvisionedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedResources = output.provisionedResources
        } else {
            self.nextToken = nil
            self.provisionedResources = nil
        }
    }
}

public struct ListEnvironmentProvisionedResourcesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next environment provisioned resource in the array of provisioned resources, after the current requested list of environment provisioned resources.
    public var nextToken: Swift.String?
    /// An array of environment provisioned resources.
    /// This member is required.
    public var provisionedResources: [ProtonClientTypes.ProvisionedResource]?

    public init (
        nextToken: Swift.String? = nil,
        provisionedResources: [ProtonClientTypes.ProvisionedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedResources = provisionedResources
    }
}

struct ListEnvironmentProvisionedResourcesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let provisionedResources: [ProtonClientTypes.ProvisionedResource]?
}

extension ListEnvironmentProvisionedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ProvisionedResource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[ProtonClientTypes.ProvisionedResource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [ProtonClientTypes.ProvisionedResource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
    }
}

public struct ListEnvironmentTemplateVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplateVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentTemplateVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentTemplateVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplateVersionsOutputError>
}

extension ListEnvironmentTemplateVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentTemplateVersionsInput(majorVersion: \(Swift.String(describing: majorVersion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ListEnvironmentTemplateVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct ListEnvironmentTemplateVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplateVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentTemplateVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentTemplateVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplateVersionsOutputError>
}

public struct ListEnvironmentTemplateVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplateVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentTemplateVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentTemplateVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplateVersionsOutputError>
}

public struct ListEnvironmentTemplateVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplateVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentTemplateVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentTemplateVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplateVersionsOutputError>
}

public struct ListEnvironmentTemplateVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplateVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentTemplateVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentTemplateVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplateVersionsOutputError>
}

public struct ListEnvironmentTemplateVersionsInput: Swift.Equatable {
    /// To view a list of minor of versions under a major version of an environment template, include major Version. To view a list of major versions of an environment template, exclude major Version.
    public var majorVersion: Swift.String?
    /// The maximum number of major or minor versions of an environment template to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next major or minor version in the array of major or minor versions of an environment template, after the list of major or minor versions that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        majorVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

struct ListEnvironmentTemplateVersionsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
}

extension ListEnvironmentTemplateVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ListEnvironmentTemplateVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentTemplateVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentTemplateVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentTemplateVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentTemplateVersionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), templateVersions: \(Swift.String(describing: templateVersions)))"}
}

extension ListEnvironmentTemplateVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentTemplateVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateVersions = output.templateVersions
        } else {
            self.nextToken = nil
            self.templateVersions = nil
        }
    }
}

public struct ListEnvironmentTemplateVersionsOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next major or minor version in the array of major or minor versions of an environment template, after the list of major or minor versions that was previously requested.
    public var nextToken: Swift.String?
    /// An array of major or minor versions of an environment template detail data.
    /// This member is required.
    public var templateVersions: [ProtonClientTypes.EnvironmentTemplateVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templateVersions: [ProtonClientTypes.EnvironmentTemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateVersions = templateVersions
    }
}

struct ListEnvironmentTemplateVersionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let templateVersions: [ProtonClientTypes.EnvironmentTemplateVersionSummary]?
}

extension ListEnvironmentTemplateVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateVersionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentTemplateVersionSummary?].self, forKey: .templateVersions)
        var templateVersionsDecoded0:[ProtonClientTypes.EnvironmentTemplateVersionSummary]? = nil
        if let templateVersionsContainer = templateVersionsContainer {
            templateVersionsDecoded0 = [ProtonClientTypes.EnvironmentTemplateVersionSummary]()
            for structure0 in templateVersionsContainer {
                if let structure0 = structure0 {
                    templateVersionsDecoded0?.append(structure0)
                }
            }
        }
        templateVersions = templateVersionsDecoded0
    }
}

public struct ListEnvironmentTemplatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplatesOutputError>
}

extension ListEnvironmentTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentTemplatesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEnvironmentTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplatesOutputError>
}

public struct ListEnvironmentTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplatesOutputError>
}

public struct ListEnvironmentTemplatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplatesOutputError>
}

public struct ListEnvironmentTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentTemplatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentTemplatesOutputError>
}

public struct ListEnvironmentTemplatesInput: Swift.Equatable {
    /// The maximum number of environment templates to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next environment template in the array of environment templates, after the list of environment templates that was previously requested.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentTemplatesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListEnvironmentTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnvironmentTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentTemplatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentTemplatesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), templates: \(Swift.String(describing: templates)))"}
}

extension ListEnvironmentTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListEnvironmentTemplatesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next environment template in the array of environment templates, after the current requested list of environment templates.
    public var nextToken: Swift.String?
    /// An array of environment templates with detail data.
    /// This member is required.
    public var templates: [ProtonClientTypes.EnvironmentTemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templates: [ProtonClientTypes.EnvironmentTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListEnvironmentTemplatesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let templates: [ProtonClientTypes.EnvironmentTemplateSummary]?
}

extension ListEnvironmentTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentTemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[ProtonClientTypes.EnvironmentTemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [ProtonClientTypes.EnvironmentTemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
    }
}

public struct ListEnvironmentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

extension ListEnvironmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentsInput(environmentTemplates: \(Swift.String(describing: environmentTemplates)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplates
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentTemplates = environmentTemplates {
            var environmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentTemplates)
            for environmenttemplatefilterlist0 in environmentTemplates {
                try environmentTemplatesContainer.encode(environmenttemplatefilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEnvironmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// An array of the versions of the environment template.
    public var environmentTemplates: [ProtonClientTypes.EnvironmentTemplateFilter]?
    /// The maximum number of environments to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next environment in the array of environments, after the list of environments that was previously requested.
    public var nextToken: Swift.String?

    public init (
        environmentTemplates: [ProtonClientTypes.EnvironmentTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentTemplates = environmentTemplates
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let environmentTemplates: [ProtonClientTypes.EnvironmentTemplateFilter]?
}

extension ListEnvironmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplates
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let environmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentTemplateFilter?].self, forKey: .environmentTemplates)
        var environmentTemplatesDecoded0:[ProtonClientTypes.EnvironmentTemplateFilter]? = nil
        if let environmentTemplatesContainer = environmentTemplatesContainer {
            environmentTemplatesDecoded0 = [ProtonClientTypes.EnvironmentTemplateFilter]()
            for structure0 in environmentTemplatesContainer {
                if let structure0 = structure0 {
                    environmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        environmentTemplates = environmentTemplatesDecoded0
    }
}

extension ListEnvironmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentsOutputResponse(environments: \(Swift.String(describing: environments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Swift.Equatable {
    /// An array of environment detail data summaries.
    /// This member is required.
    public var environments: [ProtonClientTypes.EnvironmentSummary]?
    /// A token to indicate the location of the next environment in the array of environments, after the current requested list of environments.
    public var nextToken: Swift.String?

    public init (
        environments: [ProtonClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let environments: [ProtonClientTypes.EnvironmentSummary]?
}

extension ListEnvironmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let environmentsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentSummary?].self, forKey: .environments)
        var environmentsDecoded0:[ProtonClientTypes.EnvironmentSummary]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [ProtonClientTypes.EnvironmentSummary]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
    }
}

public struct ListRepositoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

extension ListRepositoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoriesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRepositoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRepositoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRepositoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRepositoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRepositoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRepositoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInput: Swift.Equatable {
    /// The maximum number of repositories to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next repository in the array of repositories, after the list of repositories previously requested.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRepositoriesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoriesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), repositories: \(Swift.String(describing: repositories)))"}
}

extension ListRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next repository in the array of repositories, after the current requested list of repositories.
    public var nextToken: Swift.String?
    /// An array of repositories.
    /// This member is required.
    public var repositories: [ProtonClientTypes.RepositorySummary]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [ProtonClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let repositories: [ProtonClientTypes.RepositorySummary]?
}

extension ListRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let repositoriesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[ProtonClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [ProtonClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
    }
}

public struct ListRepositorySyncDefinitionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositorySyncDefinitionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositorySyncDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositorySyncDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositorySyncDefinitionsOutputError>
}

extension ListRepositorySyncDefinitionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositorySyncDefinitionsInput(nextToken: \(Swift.String(describing: nextToken)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryProvider: \(Swift.String(describing: repositoryProvider)), syncType: \(Swift.String(describing: syncType)))"}
}

extension ListRepositorySyncDefinitionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType.rawValue, forKey: .syncType)
        }
    }
}

public struct ListRepositorySyncDefinitionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositorySyncDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositorySyncDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositorySyncDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositorySyncDefinitionsOutputError>
}

public struct ListRepositorySyncDefinitionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositorySyncDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositorySyncDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositorySyncDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositorySyncDefinitionsOutputError>
}

public struct ListRepositorySyncDefinitionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositorySyncDefinitionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRepositorySyncDefinitionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRepositorySyncDefinitionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositorySyncDefinitionsOutputError>
}

public struct ListRepositorySyncDefinitionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositorySyncDefinitionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRepositorySyncDefinitionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRepositorySyncDefinitionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositorySyncDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositorySyncDefinitionsOutputError>
}

public struct ListRepositorySyncDefinitionsInput: Swift.Equatable {
    /// A token to indicate the location of the next repository sync definition in the array of repository sync definitions, after the list of repository sync definitions previously requested.
    public var nextToken: Swift.String?
    /// The repository name.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// The sync type. The only supported value is TEMPLATE_SYNC.
    /// This member is required.
    public var syncType: ProtonClientTypes.SyncType?

    public init (
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        syncType: ProtonClientTypes.SyncType? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.syncType = syncType
    }
}

struct ListRepositorySyncDefinitionsInputBody: Swift.Equatable {
    public let repositoryName: Swift.String?
    public let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    public let syncType: ProtonClientTypes.SyncType?
    public let nextToken: Swift.String?
}

extension ListRepositorySyncDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.SyncType.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositorySyncDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositorySyncDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositorySyncDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositorySyncDefinitionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositorySyncDefinitionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), syncDefinitions: \(Swift.String(describing: syncDefinitions)))"}
}

extension ListRepositorySyncDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositorySyncDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.syncDefinitions = output.syncDefinitions
        } else {
            self.nextToken = nil
            self.syncDefinitions = nil
        }
    }
}

public struct ListRepositorySyncDefinitionsOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next repository sync definition in the array of repository sync definitions, after the current requested list of repository sync definitions.
    public var nextToken: Swift.String?
    /// An array of repository sync definitions.
    /// This member is required.
    public var syncDefinitions: [ProtonClientTypes.RepositorySyncDefinition]?

    public init (
        nextToken: Swift.String? = nil,
        syncDefinitions: [ProtonClientTypes.RepositorySyncDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncDefinitions = syncDefinitions
    }
}

struct ListRepositorySyncDefinitionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let syncDefinitions: [ProtonClientTypes.RepositorySyncDefinition]?
}

extension ListRepositorySyncDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case syncDefinitions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let syncDefinitionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.RepositorySyncDefinition?].self, forKey: .syncDefinitions)
        var syncDefinitionsDecoded0:[ProtonClientTypes.RepositorySyncDefinition]? = nil
        if let syncDefinitionsContainer = syncDefinitionsContainer {
            syncDefinitionsDecoded0 = [ProtonClientTypes.RepositorySyncDefinition]()
            for structure0 in syncDefinitionsContainer {
                if let structure0 = structure0 {
                    syncDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        syncDefinitions = syncDefinitionsDecoded0
    }
}

public struct ListServiceInstanceOutputsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceOutputsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstanceOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstanceOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceOutputsOutputError>
}

extension ListServiceInstanceOutputsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceInstanceOutputsInput(nextToken: \(Swift.String(describing: nextToken)), serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ListServiceInstanceOutputsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceInstanceName = serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct ListServiceInstanceOutputsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceOutputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstanceOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstanceOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceOutputsOutputError>
}

public struct ListServiceInstanceOutputsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceOutputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstanceOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstanceOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceOutputsOutputError>
}

public struct ListServiceInstanceOutputsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceOutputsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServiceInstanceOutputsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceInstanceOutputsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceOutputsOutputError>
}

public struct ListServiceInstanceOutputsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceOutputsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServiceInstanceOutputsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceInstanceOutputsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceOutputsOutputError>
}

public struct ListServiceInstanceOutputsInput: Swift.Equatable {
    /// A token to indicate the location of the next output in the array of outputs, after the list of outputs that was previously requested.
    public var nextToken: Swift.String?
    /// The service instance name.
    /// This member is required.
    public var serviceInstanceName: Swift.String?
    /// The service name.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct ListServiceInstanceOutputsInputBody: Swift.Equatable {
    public let serviceInstanceName: Swift.String?
    public let serviceName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListServiceInstanceOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceInstanceOutputsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceInstanceOutputsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceInstanceOutputsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceInstanceOutputsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceInstanceOutputsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), outputs: \(Swift.String(describing: outputs)))"}
}

extension ListServiceInstanceOutputsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceInstanceOutputsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outputs = output.outputs
        } else {
            self.nextToken = nil
            self.outputs = nil
        }
    }
}

public struct ListServiceInstanceOutputsOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next output in the array of outputs, after the current requested list of outputs.
    public var nextToken: Swift.String?
    /// An array of service instance infrastructure as code outputs.
    /// This member is required.
    public var outputs: [ProtonClientTypes.Output]?

    public init (
        nextToken: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil
    )
    {
        self.nextToken = nextToken
        self.outputs = outputs
    }
}

struct ListServiceInstanceOutputsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let outputs: [ProtonClientTypes.Output]?
}

extension ListServiceInstanceOutputsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outputs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

public struct ListServiceInstanceProvisionedResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceProvisionedResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstanceProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstanceProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceProvisionedResourcesOutputError>
}

extension ListServiceInstanceProvisionedResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceInstanceProvisionedResourcesInput(nextToken: \(Swift.String(describing: nextToken)), serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ListServiceInstanceProvisionedResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceInstanceName = serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct ListServiceInstanceProvisionedResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceProvisionedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstanceProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstanceProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceProvisionedResourcesOutputError>
}

public struct ListServiceInstanceProvisionedResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceProvisionedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstanceProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstanceProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceProvisionedResourcesOutputError>
}

public struct ListServiceInstanceProvisionedResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceProvisionedResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServiceInstanceProvisionedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceInstanceProvisionedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceProvisionedResourcesOutputError>
}

public struct ListServiceInstanceProvisionedResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstanceProvisionedResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServiceInstanceProvisionedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceInstanceProvisionedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstanceProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstanceProvisionedResourcesOutputError>
}

public struct ListServiceInstanceProvisionedResourcesInput: Swift.Equatable {
    /// A token to indicate the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
    public var nextToken: Swift.String?
    /// The service instance name.
    /// This member is required.
    public var serviceInstanceName: Swift.String?
    /// The service name.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct ListServiceInstanceProvisionedResourcesInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
    public let serviceInstanceName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListServiceInstanceProvisionedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceInstanceProvisionedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceInstanceProvisionedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceInstanceProvisionedResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceInstanceProvisionedResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceInstanceProvisionedResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), provisionedResources: \(Swift.String(describing: provisionedResources)))"}
}

extension ListServiceInstanceProvisionedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceInstanceProvisionedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedResources = output.provisionedResources
        } else {
            self.nextToken = nil
            self.provisionedResources = nil
        }
    }
}

public struct ListServiceInstanceProvisionedResourcesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
    public var nextToken: Swift.String?
    /// An array of provisioned resources for a service instance.
    /// This member is required.
    public var provisionedResources: [ProtonClientTypes.ProvisionedResource]?

    public init (
        nextToken: Swift.String? = nil,
        provisionedResources: [ProtonClientTypes.ProvisionedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedResources = provisionedResources
    }
}

struct ListServiceInstanceProvisionedResourcesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let provisionedResources: [ProtonClientTypes.ProvisionedResource]?
}

extension ListServiceInstanceProvisionedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ProvisionedResource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[ProtonClientTypes.ProvisionedResource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [ProtonClientTypes.ProvisionedResource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
    }
}

public struct ListServiceInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstancesOutputError>
}

extension ListServiceInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ListServiceInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct ListServiceInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstancesOutputError>
}

public struct ListServiceInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstancesOutputError>
}

public struct ListServiceInstancesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstancesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServiceInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstancesOutputError>
}

public struct ListServiceInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceInstancesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServiceInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceInstancesOutputError>
}

public struct ListServiceInstancesInput: Swift.Equatable {
    /// The maximum number of service instances to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next service in the array of service instances, after the list of service instances that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service that the service instance belongs to.
    public var serviceName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

struct ListServiceInstancesInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServiceInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceInstancesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), serviceInstances: \(Swift.String(describing: serviceInstances)))"}
}

extension ListServiceInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceInstances = output.serviceInstances
        } else {
            self.nextToken = nil
            self.serviceInstances = nil
        }
    }
}

public struct ListServiceInstancesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next service instance in the array of service instances, after the current requested list of service instances.
    public var nextToken: Swift.String?
    /// An array of service instances with summaries of detail data.
    /// This member is required.
    public var serviceInstances: [ProtonClientTypes.ServiceInstanceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        serviceInstances: [ProtonClientTypes.ServiceInstanceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceInstances = serviceInstances
    }
}

struct ListServiceInstancesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let serviceInstances: [ProtonClientTypes.ServiceInstanceSummary]?
}

extension ListServiceInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstances
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceInstancesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceInstanceSummary?].self, forKey: .serviceInstances)
        var serviceInstancesDecoded0:[ProtonClientTypes.ServiceInstanceSummary]? = nil
        if let serviceInstancesContainer = serviceInstancesContainer {
            serviceInstancesDecoded0 = [ProtonClientTypes.ServiceInstanceSummary]()
            for structure0 in serviceInstancesContainer {
                if let structure0 = structure0 {
                    serviceInstancesDecoded0?.append(structure0)
                }
            }
        }
        serviceInstances = serviceInstancesDecoded0
    }
}

public struct ListServicePipelineOutputsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineOutputsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicePipelineOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicePipelineOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineOutputsOutputError>
}

extension ListServicePipelineOutputsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicePipelineOutputsInput(nextToken: \(Swift.String(describing: nextToken)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ListServicePipelineOutputsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct ListServicePipelineOutputsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineOutputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicePipelineOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicePipelineOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineOutputsOutputError>
}

public struct ListServicePipelineOutputsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineOutputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicePipelineOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicePipelineOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineOutputsOutputError>
}

public struct ListServicePipelineOutputsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineOutputsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServicePipelineOutputsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicePipelineOutputsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineOutputsOutputError>
}

public struct ListServicePipelineOutputsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineOutputsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServicePipelineOutputsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicePipelineOutputsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineOutputsOutputError>
}

public struct ListServicePipelineOutputsInput: Swift.Equatable {
    /// A token to indicate the location of the next output in the array of outputs, after the list of outputs that was previously requested.
    public var nextToken: Swift.String?
    /// The service name.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

struct ListServicePipelineOutputsInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListServicePipelineOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServicePipelineOutputsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicePipelineOutputsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicePipelineOutputsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicePipelineOutputsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicePipelineOutputsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), outputs: \(Swift.String(describing: outputs)))"}
}

extension ListServicePipelineOutputsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicePipelineOutputsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outputs = output.outputs
        } else {
            self.nextToken = nil
            self.outputs = nil
        }
    }
}

public struct ListServicePipelineOutputsOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next output in the array of outputs, after the current requested list of outputs.
    public var nextToken: Swift.String?
    /// An array of outputs.
    /// This member is required.
    public var outputs: [ProtonClientTypes.Output]?

    public init (
        nextToken: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil
    )
    {
        self.nextToken = nextToken
        self.outputs = outputs
    }
}

struct ListServicePipelineOutputsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let outputs: [ProtonClientTypes.Output]?
}

extension ListServicePipelineOutputsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outputs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

public struct ListServicePipelineProvisionedResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineProvisionedResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicePipelineProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicePipelineProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineProvisionedResourcesOutputError>
}

extension ListServicePipelineProvisionedResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicePipelineProvisionedResourcesInput(nextToken: \(Swift.String(describing: nextToken)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ListServicePipelineProvisionedResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct ListServicePipelineProvisionedResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineProvisionedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicePipelineProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicePipelineProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineProvisionedResourcesOutputError>
}

public struct ListServicePipelineProvisionedResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineProvisionedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicePipelineProvisionedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicePipelineProvisionedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineProvisionedResourcesOutputError>
}

public struct ListServicePipelineProvisionedResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineProvisionedResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServicePipelineProvisionedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicePipelineProvisionedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineProvisionedResourcesOutputError>
}

public struct ListServicePipelineProvisionedResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicePipelineProvisionedResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServicePipelineProvisionedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicePipelineProvisionedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicePipelineProvisionedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicePipelineProvisionedResourcesOutputError>
}

public struct ListServicePipelineProvisionedResourcesInput: Swift.Equatable {
    /// A token to indicate the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
    public var nextToken: Swift.String?
    /// The service name.
    /// This member is required.
    public var serviceName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

struct ListServicePipelineProvisionedResourcesInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListServicePipelineProvisionedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServicePipelineProvisionedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicePipelineProvisionedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicePipelineProvisionedResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicePipelineProvisionedResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicePipelineProvisionedResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), provisionedResources: \(Swift.String(describing: provisionedResources)))"}
}

extension ListServicePipelineProvisionedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicePipelineProvisionedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedResources = output.provisionedResources
        } else {
            self.nextToken = nil
            self.provisionedResources = nil
        }
    }
}

public struct ListServicePipelineProvisionedResourcesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
    public var nextToken: Swift.String?
    /// An array of provisioned resources for a service and pipeline.
    /// This member is required.
    public var provisionedResources: [ProtonClientTypes.ProvisionedResource]?

    public init (
        nextToken: Swift.String? = nil,
        provisionedResources: [ProtonClientTypes.ProvisionedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedResources = provisionedResources
    }
}

struct ListServicePipelineProvisionedResourcesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let provisionedResources: [ProtonClientTypes.ProvisionedResource]?
}

extension ListServicePipelineProvisionedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ProvisionedResource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[ProtonClientTypes.ProvisionedResource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [ProtonClientTypes.ProvisionedResource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
    }
}

public struct ListServiceTemplateVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplateVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceTemplateVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceTemplateVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplateVersionsOutputError>
}

extension ListServiceTemplateVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceTemplateVersionsInput(majorVersion: \(Swift.String(describing: majorVersion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ListServiceTemplateVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct ListServiceTemplateVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplateVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceTemplateVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceTemplateVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplateVersionsOutputError>
}

public struct ListServiceTemplateVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplateVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceTemplateVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceTemplateVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplateVersionsOutputError>
}

public struct ListServiceTemplateVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplateVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServiceTemplateVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceTemplateVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplateVersionsOutputError>
}

public struct ListServiceTemplateVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplateVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServiceTemplateVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceTemplateVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplateVersionsOutputError>
}

public struct ListServiceTemplateVersionsInput: Swift.Equatable {
    /// To view a list of minor of versions under a major version of a service template, include major Version. To view a list of major versions of a service template, exclude major Version.
    public var majorVersion: Swift.String?
    /// The maximum number of major or minor versions of a service template to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next major or minor version in the array of major or minor versions of a service template, after the list of major or minor versions that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        majorVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

struct ListServiceTemplateVersionsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
}

extension ListServiceTemplateVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ListServiceTemplateVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceTemplateVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceTemplateVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceTemplateVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceTemplateVersionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), templateVersions: \(Swift.String(describing: templateVersions)))"}
}

extension ListServiceTemplateVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceTemplateVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateVersions = output.templateVersions
        } else {
            self.nextToken = nil
            self.templateVersions = nil
        }
    }
}

public struct ListServiceTemplateVersionsOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next major or minor version in the array of major or minor versions of a service template, after the current requested list of service major or minor versions.
    public var nextToken: Swift.String?
    /// An array of major or minor versions of a service template with detail data.
    /// This member is required.
    public var templateVersions: [ProtonClientTypes.ServiceTemplateVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templateVersions: [ProtonClientTypes.ServiceTemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateVersions = templateVersions
    }
}

struct ListServiceTemplateVersionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let templateVersions: [ProtonClientTypes.ServiceTemplateVersionSummary]?
}

extension ListServiceTemplateVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateVersionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceTemplateVersionSummary?].self, forKey: .templateVersions)
        var templateVersionsDecoded0:[ProtonClientTypes.ServiceTemplateVersionSummary]? = nil
        if let templateVersionsContainer = templateVersionsContainer {
            templateVersionsDecoded0 = [ProtonClientTypes.ServiceTemplateVersionSummary]()
            for structure0 in templateVersionsContainer {
                if let structure0 = structure0 {
                    templateVersionsDecoded0?.append(structure0)
                }
            }
        }
        templateVersions = templateVersionsDecoded0
    }
}

public struct ListServiceTemplatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplatesOutputError>
}

extension ListServiceTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceTemplatesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServiceTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServiceTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplatesOutputError>
}

public struct ListServiceTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplatesOutputError>
}

public struct ListServiceTemplatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServiceTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplatesOutputError>
}

public struct ListServiceTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceTemplatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServiceTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceTemplatesOutputError>
}

public struct ListServiceTemplatesInput: Swift.Equatable {
    /// The maximum number of service templates to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next service template in the array of service templates, after the list of service templates previously requested.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceTemplatesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServiceTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceTemplatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceTemplatesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), templates: \(Swift.String(describing: templates)))"}
}

extension ListServiceTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListServiceTemplatesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next service template in the array of service templates, after the current requested list of service templates.
    public var nextToken: Swift.String?
    /// An array of service templates with detail data.
    /// This member is required.
    public var templates: [ProtonClientTypes.ServiceTemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templates: [ProtonClientTypes.ServiceTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListServiceTemplatesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let templates: [ProtonClientTypes.ServiceTemplateSummary]?
}

extension ListServiceTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceTemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[ProtonClientTypes.ServiceTemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [ProtonClientTypes.ServiceTemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
    }
}

public struct ListServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

extension ListServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Swift.Equatable {
    /// The maximum number of services to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next service in the array of services, after the list of services that was previously requested.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), services: \(Swift.String(describing: services)))"}
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next service in the array of services, after the current requested list of services.
    public var nextToken: Swift.String?
    /// An array of services with summaries of detail data.
    /// This member is required.
    public var services: [ProtonClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        services: [ProtonClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let services: [ProtonClientTypes.ServiceSummary]?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case services
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let servicesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceSummary?].self, forKey: .services)
        var servicesDecoded0:[ProtonClientTypes.ServiceSummary]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ProtonClientTypes.ServiceSummary]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags to list.
    public var maxResults: Swift.Int?
    /// A token to indicate the location of the next resource tag in the array of resource tags, after the list of resource tags that was previously requested.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for the listed tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A token to indicate the location of the next resource tag in the array of resource tags, after the current requested list of resource tags.
    public var nextToken: Swift.String?
    /// An array of resource tags with detail data.
    /// This member is required.
    public var tags: [ProtonClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [ProtonClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct NotifyResourceDeploymentStatusChangeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyResourceDeploymentStatusChangeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyResourceDeploymentStatusChangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyResourceDeploymentStatusChangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyResourceDeploymentStatusChangeOutputError>
}

extension NotifyResourceDeploymentStatusChangeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyResourceDeploymentStatusChangeInput(deploymentId: \(Swift.String(describing: deploymentId)), outputs: \(Swift.String(describing: outputs)), resourceArn: \(Swift.String(describing: resourceArn)), status: \(Swift.String(describing: status)), statusMessage: \"CONTENT_REDACTED\")"}
}

extension NotifyResourceDeploymentStatusChangeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case outputs
        case resourceArn
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for outputslist0 in outputs {
                try outputsContainer.encode(outputslist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }
}

public struct NotifyResourceDeploymentStatusChangeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyResourceDeploymentStatusChangeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyResourceDeploymentStatusChangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyResourceDeploymentStatusChangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyResourceDeploymentStatusChangeOutputError>
}

public struct NotifyResourceDeploymentStatusChangeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyResourceDeploymentStatusChangeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyResourceDeploymentStatusChangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyResourceDeploymentStatusChangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyResourceDeploymentStatusChangeOutputError>
}

public struct NotifyResourceDeploymentStatusChangeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyResourceDeploymentStatusChangeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: NotifyResourceDeploymentStatusChangeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyResourceDeploymentStatusChangeInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyResourceDeploymentStatusChangeOutputError>
}

public struct NotifyResourceDeploymentStatusChangeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyResourceDeploymentStatusChangeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: NotifyResourceDeploymentStatusChangeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyResourceDeploymentStatusChangeInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyResourceDeploymentStatusChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyResourceDeploymentStatusChangeOutputError>
}

public struct NotifyResourceDeploymentStatusChangeInput: Swift.Equatable {
    /// The deployment ID for your provisioned resource.
    public var deploymentId: Swift.String?
    /// The provisioned resource state change detail data that's returned by Proton.
    public var outputs: [ProtonClientTypes.Output]?
    /// The provisioned resource Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The status of your provisioned resource.
    /// This member is required.
    public var status: ProtonClientTypes.ResourceDeploymentStatus?
    /// The deployment status message for your provisioned resource.
    public var statusMessage: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil,
        resourceArn: Swift.String? = nil,
        status: ProtonClientTypes.ResourceDeploymentStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.outputs = outputs
        self.resourceArn = resourceArn
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct NotifyResourceDeploymentStatusChangeInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let status: ProtonClientTypes.ResourceDeploymentStatus?
    public let outputs: [ProtonClientTypes.Output]?
    public let deploymentId: Swift.String?
    public let statusMessage: Swift.String?
}

extension NotifyResourceDeploymentStatusChangeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case outputs
        case resourceArn
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceDeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension NotifyResourceDeploymentStatusChangeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyResourceDeploymentStatusChangeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyResourceDeploymentStatusChangeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyResourceDeploymentStatusChangeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyResourceDeploymentStatusChangeOutputResponse()"}
}

extension NotifyResourceDeploymentStatusChangeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct NotifyResourceDeploymentStatusChangeOutputResponse: Swift.Equatable {

    public init() {}
}

struct NotifyResourceDeploymentStatusChangeOutputResponseBody: Swift.Equatable {
}

extension NotifyResourceDeploymentStatusChangeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ProtonClientTypes.Output: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case valueString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let valueString = valueString {
            try encodeContainer.encode(valueString, forKey: .valueString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueString)
        valueString = valueStringDecoded
    }
}

extension ProtonClientTypes.Output: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension ProtonClientTypes {
    /// An infrastructure as code defined resource output.
    public struct Output: Swift.Equatable {
        /// The output key.
        public var key: Swift.String?
        /// The output value.
        public var valueString: Swift.String?

        public init (
            key: Swift.String? = nil,
            valueString: Swift.String? = nil
        )
        {
            self.key = key
            self.valueString = valueString
        }
    }

}

extension ProtonClientTypes.ProvisionedResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case name
        case provisioningEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioningEngine = provisioningEngine {
            try encodeContainer.encode(provisioningEngine.rawValue, forKey: .provisioningEngine)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let provisioningEngineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ProvisionedResourceEngine.self, forKey: .provisioningEngine)
        provisioningEngine = provisioningEngineDecoded
    }
}

extension ProtonClientTypes.ProvisionedResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedResource(identifier: \(Swift.String(describing: identifier)), name: \(Swift.String(describing: name)), provisioningEngine: \(Swift.String(describing: provisioningEngine)))"}
}

extension ProtonClientTypes {
    /// Detail data for a provisioned resource.
    public struct ProvisionedResource: Swift.Equatable {
        /// The provisioned resource identifier.
        public var identifier: Swift.String?
        /// The provisioned resource name.
        public var name: Swift.String?
        /// The resource provisioning engine. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
        public var provisioningEngine: ProtonClientTypes.ProvisionedResourceEngine?

        public init (
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            provisioningEngine: ProtonClientTypes.ProvisionedResourceEngine? = nil
        )
        {
            self.identifier = identifier
            self.name = name
            self.provisioningEngine = provisioningEngine
        }
    }

}

extension ProtonClientTypes {
    /// List of provisioning engines
    public enum ProvisionedResourceEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudformation
        case terraform
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedResourceEngine] {
            return [
                .cloudformation,
                .terraform,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case .terraform: return "TERRAFORM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedResourceEngine(rawValue: rawValue) ?? ProvisionedResourceEngine.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    public enum Provisioning: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [Provisioning] {
            return [
                .customerManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerManaged: return "CUSTOMER_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Provisioning(rawValue: rawValue) ?? Provisioning.sdkUnknown(rawValue)
        }
    }
}

public struct RejectEnvironmentAccountConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectEnvironmentAccountConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectEnvironmentAccountConnectionOutputError>
}

extension RejectEnvironmentAccountConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectEnvironmentAccountConnectionInput(id: \(Swift.String(describing: id)))"}
}

extension RejectEnvironmentAccountConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct RejectEnvironmentAccountConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectEnvironmentAccountConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectEnvironmentAccountConnectionOutputError>
}

public struct RejectEnvironmentAccountConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectEnvironmentAccountConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectEnvironmentAccountConnectionOutputError>
}

public struct RejectEnvironmentAccountConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectEnvironmentAccountConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RejectEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectEnvironmentAccountConnectionOutputError>
}

public struct RejectEnvironmentAccountConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectEnvironmentAccountConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RejectEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectEnvironmentAccountConnectionOutputError>
}

public struct RejectEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection to reject.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct RejectEnvironmentAccountConnectionInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension RejectEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension RejectEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectEnvironmentAccountConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectEnvironmentAccountConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectEnvironmentAccountConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectEnvironmentAccountConnectionOutputResponse(environmentAccountConnection: \(Swift.String(describing: environmentAccountConnection)))"}
}

extension RejectEnvironmentAccountConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RejectEnvironmentAccountConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct RejectEnvironmentAccountConnectionOutputResponse: Swift.Equatable {
    /// The environment connection account detail data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init (
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct RejectEnvironmentAccountConnectionOutputResponseBody: Swift.Equatable {
    public let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension RejectEnvironmentAccountConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

extension ProtonClientTypes.Repository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectionArn
        case encryptionKey
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension ProtonClientTypes.Repository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Repository(arn: \(Swift.String(describing: arn)), connectionArn: \(Swift.String(describing: connectionArn)), encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)))"}
}

extension ProtonClientTypes {
    /// Detail date for a repository that has been registered with Proton.
    public struct Repository: Swift.Equatable {
        /// The repository Amazon Resource Name (ARN).
        /// This member is required.
        public var arn: Swift.String?
        /// The repository Amazon Web Services CodeStar connection that connects Proton to your repository.
        /// This member is required.
        public var connectionArn: Swift.String?
        /// Your customer Amazon Web Services KMS encryption key.
        public var encryptionKey: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init (
            arn: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.arn = arn
            self.connectionArn = connectionArn
            self.encryptionKey = encryptionKey
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes.RepositoryBranch: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case branch
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension ProtonClientTypes.RepositoryBranch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryBranch(arn: \(Swift.String(describing: arn)), branch: \(Swift.String(describing: branch)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)))"}
}

extension ProtonClientTypes {
    /// Detail data for a repository branch. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
    public struct RepositoryBranch: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the repository branch.
        /// This member is required.
        public var arn: Swift.String?
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init (
            arn: Swift.String? = nil,
            branch: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.arn = arn
            self.branch = branch
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes.RepositoryBranchInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension ProtonClientTypes.RepositoryBranchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryBranchInput(branch: \(Swift.String(describing: branch)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)))"}
}

extension ProtonClientTypes {
    /// Detail input data for a repository branch. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
    public struct RepositoryBranchInput: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init (
            branch: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.branch = branch
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes {
    public enum RepositoryProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bitbucket
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryProvider] {
            return [
                .bitbucket,
                .github,
                .githubEnterprise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bitbucket: return "BITBUCKET"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositoryProvider(rawValue: rawValue) ?? RepositoryProvider.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.RepositorySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ProtonClientTypes.RepositorySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositorySummary(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)))"}
}

extension ProtonClientTypes {
    /// A summary of detail data for a registered repository.
    public struct RepositorySummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for a repository.
        /// This member is required.
        public var arn: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes.RepositorySyncAttempt: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case startedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for repositorysyncevents0 in events {
                try eventsContainer.encode(repositorysyncevents0)
            }
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositorySyncStatus.self, forKey: .status)
        status = statusDecoded
        let eventsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.RepositorySyncEvent?].self, forKey: .events)
        var eventsDecoded0:[ProtonClientTypes.RepositorySyncEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [ProtonClientTypes.RepositorySyncEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension ProtonClientTypes.RepositorySyncAttempt: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositorySyncAttempt(events: \(Swift.String(describing: events)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)))"}
}

extension ProtonClientTypes {
    /// Detail data for a repository sync attempt activated by a push to a repository.
    public struct RepositorySyncAttempt: Swift.Equatable {
        /// Detail data for sync attempt events.
        /// This member is required.
        public var events: [ProtonClientTypes.RepositorySyncEvent]?
        /// The time when the sync attempt started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The sync attempt status.
        /// This member is required.
        public var status: ProtonClientTypes.RepositorySyncStatus?

        public init (
            events: [ProtonClientTypes.RepositorySyncEvent]? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: ProtonClientTypes.RepositorySyncStatus? = nil
        )
        {
            self.events = events
            self.startedAt = startedAt
            self.status = status
        }
    }

}

extension ProtonClientTypes.RepositorySyncDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case directory
        case parent
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let directory = directory {
            try encodeContainer.encode(directory, forKey: .directory)
        }
        if let parent = parent {
            try encodeContainer.encode(parent, forKey: .parent)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let parentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parent)
        parent = parentDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let directoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directory)
        directory = directoryDecoded
    }
}

extension ProtonClientTypes.RepositorySyncDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositorySyncDefinition(branch: \(Swift.String(describing: branch)), directory: \(Swift.String(describing: directory)), parent: \(Swift.String(describing: parent)), target: \(Swift.String(describing: target)))"}
}

extension ProtonClientTypes {
    /// The repository sync definition.
    public struct RepositorySyncDefinition: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The directory in the repository.
        /// This member is required.
        public var directory: Swift.String?
        /// The resource that is synced from.
        /// This member is required.
        public var parent: Swift.String?
        /// The resource that is synced to.
        /// This member is required.
        public var target: Swift.String?

        public init (
            branch: Swift.String? = nil,
            directory: Swift.String? = nil,
            parent: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.branch = branch
            self.directory = directory
            self.parent = parent
            self.target = target
        }
    }

}

extension ProtonClientTypes.RepositorySyncEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case externalId
        case time
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let timeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .time)
        time = timeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
    }
}

extension ProtonClientTypes.RepositorySyncEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositorySyncEvent(event: \(Swift.String(describing: event)), externalId: \(Swift.String(describing: externalId)), time: \(Swift.String(describing: time)), type: \(Swift.String(describing: type)))"}
}

extension ProtonClientTypes {
    /// Repository sync event detail data for a sync attempt.
    public struct RepositorySyncEvent: Swift.Equatable {
        /// Event detail for a repository sync attempt.
        /// This member is required.
        public var event: Swift.String?
        /// The external ID of the sync event.
        public var externalId: Swift.String?
        /// The time that the sync event occurred.
        /// This member is required.
        public var time: ClientRuntime.Date?
        /// The type of event.
        /// This member is required.
        public var type: Swift.String?

        public init (
            event: Swift.String? = nil,
            externalId: Swift.String? = nil,
            time: ClientRuntime.Date? = nil,
            type: Swift.String? = nil
        )
        {
            self.event = event
            self.externalId = externalId
            self.time = time
            self.type = type
        }
    }

}

extension ProtonClientTypes {
    public enum RepositorySyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The repository sync attempt has failed.
        case failed
        /// A repository sync attempt has been created and will begin soon.
        case initiated
        /// A repository sync attempt has started and work is being done to reconcile the branch.
        case inProgress
        /// The repository sync attempt didn't execute and was queued.
        case queued
        /// The repository sync attempt has completed successfully.
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositorySyncStatus] {
            return [
                .failed,
                .initiated,
                .inProgress,
                .queued,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initiated: return "INITIATED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositorySyncStatus(rawValue: rawValue) ?? RepositorySyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    /// The state that a PR-based deployment can be updated to.
    public enum ResourceDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceDeploymentStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceDeploymentStatus(rawValue: rawValue) ?? ResourceDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource wasn't found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProtonClientTypes.ResourceSyncAttempt: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case initialRevision
        case startedAt
        case status
        case target
        case targetRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for resourcesyncevents0 in events {
                try eventsContainer.encode(resourcesyncevents0)
            }
        }
        if let initialRevision = initialRevision {
            try encodeContainer.encode(initialRevision, forKey: .initialRevision)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetRevision = targetRevision {
            try encodeContainer.encode(targetRevision, forKey: .targetRevision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialRevisionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Revision.self, forKey: .initialRevision)
        initialRevision = initialRevisionDecoded
        let targetRevisionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Revision.self, forKey: .targetRevision)
        targetRevision = targetRevisionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncStatus.self, forKey: .status)
        status = statusDecoded
        let eventsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ResourceSyncEvent?].self, forKey: .events)
        var eventsDecoded0:[ProtonClientTypes.ResourceSyncEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [ProtonClientTypes.ResourceSyncEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension ProtonClientTypes.ResourceSyncAttempt: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSyncAttempt(events: \(Swift.String(describing: events)), initialRevision: \(Swift.String(describing: initialRevision)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), target: \(Swift.String(describing: target)), targetRevision: \(Swift.String(describing: targetRevision)))"}
}

extension ProtonClientTypes {
    /// Detail data for a resource sync attempt activated by a push to a repository.
    public struct ResourceSyncAttempt: Swift.Equatable {
        /// An array of events with detail data.
        /// This member is required.
        public var events: [ProtonClientTypes.ResourceSyncEvent]?
        /// Detail data for the initial repository commit, path and push.
        /// This member is required.
        public var initialRevision: ProtonClientTypes.Revision?
        /// The time when the sync attempt started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The status of the sync attempt.
        /// This member is required.
        public var status: ProtonClientTypes.ResourceSyncStatus?
        /// The resource that is synced to.
        /// This member is required.
        public var target: Swift.String?
        /// Detail data for the target revision.
        /// This member is required.
        public var targetRevision: ProtonClientTypes.Revision?

        public init (
            events: [ProtonClientTypes.ResourceSyncEvent]? = nil,
            initialRevision: ProtonClientTypes.Revision? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: ProtonClientTypes.ResourceSyncStatus? = nil,
            target: Swift.String? = nil,
            targetRevision: ProtonClientTypes.Revision? = nil
        )
        {
            self.events = events
            self.initialRevision = initialRevision
            self.startedAt = startedAt
            self.status = status
            self.target = target
            self.targetRevision = targetRevision
        }
    }

}

extension ProtonClientTypes.ResourceSyncEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case externalId
        case time
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let timeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .time)
        time = timeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
    }
}

extension ProtonClientTypes.ResourceSyncEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSyncEvent(event: \(Swift.String(describing: event)), externalId: \(Swift.String(describing: externalId)), time: \(Swift.String(describing: time)), type: \(Swift.String(describing: type)))"}
}

extension ProtonClientTypes {
    /// Detail data for a resource sync event.
    public struct ResourceSyncEvent: Swift.Equatable {
        /// A resource sync event.
        /// This member is required.
        public var event: Swift.String?
        /// The external ID for the event.
        public var externalId: Swift.String?
        /// The time when the event occurred.
        /// This member is required.
        public var time: ClientRuntime.Date?
        /// The type of event.
        /// This member is required.
        public var type: Swift.String?

        public init (
            event: Swift.String? = nil,
            externalId: Swift.String? = nil,
            time: ClientRuntime.Date? = nil,
            type: Swift.String? = nil
        )
        {
            self.event = event
            self.externalId = externalId
            self.time = time
            self.type = type
        }
    }

}

extension ProtonClientTypes {
    public enum ResourceSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Syncing has failed.
        case failed
        /// A sync attempt has been created and will begin soon.
        case initiated
        /// Syncing has started and work is being done to reconcile state.
        case inProgress
        /// Syncing has completed successfully.
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSyncStatus] {
            return [
                .failed,
                .initiated,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initiated: return "INITIATED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceSyncStatus(rawValue: rawValue) ?? ResourceSyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.Revision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case directory
        case repositoryName
        case repositoryProvider
        case sha
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let directory = directory {
            try encodeContainer.encode(directory, forKey: .directory)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let sha = sha {
            try encodeContainer.encode(sha, forKey: .sha)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let shaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha)
        sha = shaDecoded
        let directoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directory)
        directory = directoryDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension ProtonClientTypes.Revision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Revision(branch: \(Swift.String(describing: branch)), directory: \(Swift.String(describing: directory)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryProvider: \(Swift.String(describing: repositoryProvider)), sha: \(Swift.String(describing: sha)))"}
}

extension ProtonClientTypes {
    /// Revision detail data for a commit and push that activates a sync attempt
    public struct Revision: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The repository directory changed by a commit and push that activated the sync attempt.
        /// This member is required.
        public var directory: Swift.String?
        /// The repository name.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
        /// The secure hash algorithm (SHA) hash for the revision.
        /// This member is required.
        public var sha: Swift.String?

        public init (
            branch: Swift.String? = nil,
            directory: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
            sha: Swift.String? = nil
        )
        {
            self.branch = branch
            self.directory = directory
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.sha = sha
        }
    }

}

extension ProtonClientTypes.S3ObjectSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension ProtonClientTypes.S3ObjectSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3ObjectSource(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)))"}
}

extension ProtonClientTypes {
    /// Template bundle S3 bucket data.
    public struct S3ObjectSource: Swift.Equatable {
        /// The name of the S3 bucket that contains a template bundle.
        /// This member is required.
        public var bucket: Swift.String?
        /// The path to the S3 bucket that contains a template bundle.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension ProtonClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case branchName
        case createdAt
        case description
        case lastModifiedAt
        case name
        case pipeline
        case repositoryConnectionArn
        case repositoryId
        case spec
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipeline = pipeline {
            try encodeContainer.encode(pipeline, forKey: .pipeline)
        }
        if let repositoryConnectionArn = repositoryConnectionArn {
            try encodeContainer.encode(repositoryConnectionArn, forKey: .repositoryConnectionArn)
        }
        if let repositoryId = repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let pipelineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServicePipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let repositoryConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryConnectionArn)
        repositoryConnectionArn = repositoryConnectionArnDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension ProtonClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(arn: \(Swift.String(describing: arn)), branchName: \(Swift.String(describing: branchName)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), pipeline: \(Swift.String(describing: pipeline)), repositoryConnectionArn: \(Swift.String(describing: repositoryConnectionArn)), repositoryId: \(Swift.String(describing: repositoryId)), spec: \(Swift.String(describing: spec)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// The service detail data.
    public struct Service: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service.
        /// This member is required.
        public var arn: Swift.String?
        /// The name of the code repository branch that holds the code that's deployed in Proton.
        public var branchName: Swift.String?
        /// The time when the service was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of a service.
        public var description: Swift.String?
        /// The time when the service was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service.
        /// This member is required.
        public var name: Swift.String?
        /// The service pipeline detail data.
        public var pipeline: ProtonClientTypes.ServicePipeline?
        /// The Amazon Resource Name (ARN) of the repository connection. For more information, see [Set up a repository connection](https://docs.aws.amazon.com/proton/latest/adminguide/setting-up-for-service.html#setting-up-vcontrol) in the Proton Administrator Guide and [Setting up with Proton](https://docs.aws.amazon.com/proton/latest/userguide/proton-setup.html#setup-repo-connection) in the Proton User Guide.
        public var repositoryConnectionArn: Swift.String?
        /// The ID of the source code repository.
        public var repositoryId: Swift.String?
        /// The formatted specification that defines the service.
        /// This member is required.
        public var spec: Swift.String?
        /// The status of the service.
        /// This member is required.
        public var status: ProtonClientTypes.ServiceStatus?
        /// A service status message.
        public var statusMessage: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            branchName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pipeline: ProtonClientTypes.ServicePipeline? = nil,
            repositoryConnectionArn: Swift.String? = nil,
            repositoryId: Swift.String? = nil,
            spec: Swift.String? = nil,
            status: ProtonClientTypes.ServiceStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.branchName = branchName
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipeline = pipeline
            self.repositoryConnectionArn = repositoryConnectionArn
            self.repositoryId = repositoryId
            self.spec = spec
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case environmentName
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case name
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let lastDeploymentAttemptedAt = lastDeploymentAttemptedAt {
            try encodeContainer.encode(lastDeploymentAttemptedAt.timeIntervalSince1970, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = lastDeploymentSucceededAt {
            try encodeContainer.encode(lastDeploymentSucceededAt.timeIntervalSince1970, forKey: .lastDeploymentSucceededAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
    }
}

extension ProtonClientTypes.ServiceInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceInstance(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), deploymentStatusMessage: \(Swift.String(describing: deploymentStatusMessage)), environmentName: \(Swift.String(describing: environmentName)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)), spec: \(Swift.String(describing: spec)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// The service instance detail data.
    public struct ServiceInstance: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service instance.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service instance was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The service instance deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// A service instance deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The name of the environment that the service instance was deployed into.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The time when a deployment of the service instance was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the service instance was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The name of the service instance.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the service that the service instance belongs to.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The service spec that was used to create the service instance.
        public var spec: Swift.String?
        /// The major version of the service template that was used to create the service instance.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the service template that was used to create the service instance.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template that was used to create the service instance.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.name = name
            self.serviceName = serviceName
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceInstanceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case environmentName
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case name
        case serviceName
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let lastDeploymentAttemptedAt = lastDeploymentAttemptedAt {
            try encodeContainer.encode(lastDeploymentAttemptedAt.timeIntervalSince1970, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = lastDeploymentSucceededAt {
            try encodeContainer.encode(lastDeploymentSucceededAt.timeIntervalSince1970, forKey: .lastDeploymentSucceededAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
    }
}

extension ProtonClientTypes.ServiceInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceInstanceSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), deploymentStatusMessage: \(Swift.String(describing: deploymentStatusMessage)), environmentName: \(Swift.String(describing: environmentName)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// A summary of the service instance detail data.
    public struct ServiceInstanceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service instance.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service instance was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The service instance deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// A service instance deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The name of the environment that the service instance was deployed into.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The time when a deployment of the service was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the service was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The name of the service instance.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the service that the service instance belongs to.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The service instance template major version.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The service instance template minor version.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.name = name
            self.serviceName = serviceName
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServicePipeline: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let lastDeploymentAttemptedAt = lastDeploymentAttemptedAt {
            try encodeContainer.encode(lastDeploymentAttemptedAt.timeIntervalSince1970, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = lastDeploymentSucceededAt {
            try encodeContainer.encode(lastDeploymentSucceededAt.timeIntervalSince1970, forKey: .lastDeploymentSucceededAt)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
    }
}

extension ProtonClientTypes.ServicePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServicePipeline(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), deploymentStatusMessage: \(Swift.String(describing: deploymentStatusMessage)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), spec: \(Swift.String(describing: spec)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// The service pipeline detail data.
    public struct ServicePipeline: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service pipeline.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service pipeline was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The deployment status of the service pipeline.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// A service pipeline deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The time when a deployment of the service pipeline was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the service pipeline was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The service spec that was used to create the service pipeline.
        public var spec: Swift.String?
        /// The major version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A quota was exceeded. For more information, see [Proton Quotas](https://docs.aws.amazon.com/proton/latest/adminguide/ag-limits.html) in the Proton Administrator Guide.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProtonClientTypes {
    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createFailedCleanupComplete
        case createFailedCleanupFailed
        case createFailedCleanupInProgress
        case createInProgress
        case deleteFailed
        case deleteInProgress
        case updateCompleteCleanupFailed
        case updateFailed
        case updateFailedCleanupComplete
        case updateFailedCleanupFailed
        case updateFailedCleanupInProgress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .active,
                .createFailed,
                .createFailedCleanupComplete,
                .createFailedCleanupFailed,
                .createFailedCleanupInProgress,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateCompleteCleanupFailed,
                .updateFailed,
                .updateFailedCleanupComplete,
                .updateFailedCleanupFailed,
                .updateFailedCleanupInProgress,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createFailedCleanupComplete: return "CREATE_FAILED_CLEANUP_COMPLETE"
            case .createFailedCleanupFailed: return "CREATE_FAILED_CLEANUP_FAILED"
            case .createFailedCleanupInProgress: return "CREATE_FAILED_CLEANUP_IN_PROGRESS"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateCompleteCleanupFailed: return "UPDATE_COMPLETE_CLEANUP_FAILED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateFailedCleanupComplete: return "UPDATE_FAILED_CLEANUP_COMPLETE"
            case .updateFailedCleanupFailed: return "UPDATE_FAILED_CLEANUP_FAILED"
            case .updateFailedCleanupInProgress: return "UPDATE_FAILED_CLEANUP_IN_PROGRESS"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.ServiceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case name
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ProtonClientTypes.ServiceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// A summary of the service detail data.
    public struct ServiceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the service.
        public var description: Swift.String?
        /// The time when the service was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the service.
        /// This member is required.
        public var status: ProtonClientTypes.ServiceStatus?
        /// A service status message.
        public var statusMessage: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: ProtonClientTypes.ServiceStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case encryptionKey
        case lastModifiedAt
        case name
        case pipelineProvisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineProvisioning = pipelineProvisioning {
            try encodeContainer.encode(pipelineProvisioning.rawValue, forKey: .pipelineProvisioning)
        }
        if let recommendedVersion = recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let pipelineProvisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .pipelineProvisioning)
        pipelineProvisioning = pipelineProvisioningDecoded
    }
}

extension ProtonClientTypes.ServiceTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplate(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), encryptionKey: \(Swift.String(describing: encryptionKey)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), pipelineProvisioning: \(Swift.String(describing: pipelineProvisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)))"}
}

extension ProtonClientTypes {
    /// The service template detail data.
    public struct ServiceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the service template.
        public var description: Swift.String?
        /// The service template name as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The customer provided service template encryption key that's used to encrypt data.
        public var encryptionKey: Swift.String?
        /// The time when the service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service template.
        /// This member is required.
        public var name: Swift.String?
        /// If pipelineProvisioning is true, a service pipeline is included in the service template. Otherwise, a service pipeline isn't included in the service template.
        public var pipelineProvisioning: ProtonClientTypes.Provisioning?
        /// The recommended version of the service template.
        public var recommendedVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            encryptionKey: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pipelineProvisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipelineProvisioning = pipelineProvisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes.ServiceTemplateSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case lastModifiedAt
        case name
        case pipelineProvisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineProvisioning = pipelineProvisioning {
            try encodeContainer.encode(pipelineProvisioning.rawValue, forKey: .pipelineProvisioning)
        }
        if let recommendedVersion = recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let pipelineProvisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .pipelineProvisioning)
        pipelineProvisioning = pipelineProvisioningDecoded
    }
}

extension ProtonClientTypes.ServiceTemplateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplateSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), pipelineProvisioning: \(Swift.String(describing: pipelineProvisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)))"}
}

extension ProtonClientTypes {
    /// The service template summary data.
    public struct ServiceTemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the service template.
        public var description: Swift.String?
        /// The service template name as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The time when the service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service template.
        /// This member is required.
        public var name: Swift.String?
        /// If pipelineProvisioning is true, a service pipeline is included in the service template, otherwise a service pipeline isn't included in the service template.
        public var pipelineProvisioning: ProtonClientTypes.Provisioning?
        /// The recommended version of the service template.
        public var recommendedVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pipelineProvisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipelineProvisioning = pipelineProvisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes.ServiceTemplateVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case compatibleEnvironmentTemplates
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case schema
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let compatibleEnvironmentTemplates = compatibleEnvironmentTemplates {
            var compatibleEnvironmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleEnvironmentTemplates)
            for compatibleenvironmenttemplatelist0 in compatibleEnvironmentTemplates {
                try compatibleEnvironmentTemplatesContainer.encode(compatibleenvironmenttemplatelist0)
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let compatibleEnvironmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.CompatibleEnvironmentTemplate?].self, forKey: .compatibleEnvironmentTemplates)
        var compatibleEnvironmentTemplatesDecoded0:[ProtonClientTypes.CompatibleEnvironmentTemplate]? = nil
        if let compatibleEnvironmentTemplatesContainer = compatibleEnvironmentTemplatesContainer {
            compatibleEnvironmentTemplatesDecoded0 = [ProtonClientTypes.CompatibleEnvironmentTemplate]()
            for structure0 in compatibleEnvironmentTemplatesContainer {
                if let structure0 = structure0 {
                    compatibleEnvironmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        compatibleEnvironmentTemplates = compatibleEnvironmentTemplatesDecoded0
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ProtonClientTypes.ServiceTemplateVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplateVersion(arn: \(Swift.String(describing: arn)), compatibleEnvironmentTemplates: \(Swift.String(describing: compatibleEnvironmentTemplates)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), schema: \(Swift.String(describing: schema)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// The version of a service template detail data.
    public struct ServiceTemplateVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of a service template.
        /// This member is required.
        public var arn: Swift.String?
        /// An array of compatible environment template names for the major version of a service template.
        /// This member is required.
        public var compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplate]?
        /// The time when the version of a service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the version of a service template.
        public var description: Swift.String?
        /// The time when the version of a service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of a service template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The minor version of a service template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the service template.
        public var recommendedMinorVersion: Swift.String?
        /// The schema of the version of a service template.
        public var schema: Swift.String?
        /// The service template version status.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// A service template version status message.
        public var statusMessage: Swift.String?
        /// The name of the version of a service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplate]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            schema: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.schema = schema
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceTemplateVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = lastModifiedAt {
            try encodeContainer.encode(lastModifiedAt.timeIntervalSince1970, forKey: .lastModifiedAt)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
    }
}

extension ProtonClientTypes.ServiceTemplateVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplateVersionSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), templateName: \(Swift.String(describing: templateName)))"}
}

extension ProtonClientTypes {
    /// A summary of the service template version detail data.
    public struct ServiceTemplateVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of a service template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the version of a service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the version of a service template.
        public var description: Swift.String?
        /// The time when the version of a service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of a service template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The minor version of a service template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the service template.
        public var recommendedMinorVersion: Swift.String?
        /// The service template minor version status.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// A service template minor version status message.
        public var statusMessage: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes {
    public enum SyncType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case templateSync
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncType] {
            return [
                .templateSync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .templateSync: return "TEMPLATE_SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncType(rawValue: rawValue) ?? SyncType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ProtonClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ProtonClientTypes {
    /// A description of a resource tag.
    public struct Tag: Swift.Equatable {
        /// The key of the resource tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the resource tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that the resource tag is applied to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of resource tags to apply to a resource.
    /// This member is required.
    public var tags: [ProtonClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [ProtonClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ProtonClientTypes.TemplateSyncConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
    }
}

extension ProtonClientTypes.TemplateSyncConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TemplateSyncConfig(branch: \(Swift.String(describing: branch)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryProvider: \(Swift.String(describing: repositoryProvider)), subdirectory: \(Swift.String(describing: subdirectory)), templateName: \(Swift.String(describing: templateName)), templateType: \(Swift.String(describing: templateType)))"}
}

extension ProtonClientTypes {
    /// The detail data for a template sync configuration.
    public struct TemplateSyncConfig: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The name of the repository, for example myrepos/myrepo.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
        /// A subdirectory path to your template bundle version.
        public var subdirectory: Swift.String?
        /// The template name.
        /// This member is required.
        public var templateName: Swift.String?
        /// The template type.
        /// This member is required.
        public var templateType: ProtonClientTypes.TemplateType?

        public init (
            branch: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
            subdirectory: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: ProtonClientTypes.TemplateType? = nil
        )
        {
            self.branch = branch
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.subdirectory = subdirectory
            self.templateName = templateName
            self.templateType = templateType
        }
    }

}

extension ProtonClientTypes {
    public enum TemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case environment
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .environment,
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .environment: return "ENVIRONMENT"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateType(rawValue: rawValue) ?? TemplateType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.TemplateVersionSourceInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(ProtonClientTypes.S3ObjectSource.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ProtonClientTypes {
    /// Template version source data.
    public enum TemplateVersionSourceInput: Swift.Equatable {
        /// An S3 source object that includes the template bundle S3 path and name for a template minor version.
        case s3(ProtonClientTypes.S3ObjectSource)
        case sdkUnknown(Swift.String)
    }

}

extension ProtonClientTypes {
    public enum TemplateVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case published
        case registrationFailed
        case registrationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateVersionStatus] {
            return [
                .draft,
                .published,
                .registrationFailed,
                .registrationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case .registrationFailed: return "REGISTRATION_FAILED"
            case .registrationInProgress: return "REGISTRATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateVersionStatus(rawValue: rawValue) ?? TemplateVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that the tag is to be removed from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys indicating the resource tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAccountSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

extension UpdateAccountSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccountSettingsInput(pipelineProvisioningRepository: \(Swift.String(describing: pipelineProvisioningRepository)), pipelineServiceRoleArn: \(Swift.String(describing: pipelineServiceRoleArn)))"}
}

extension UpdateAccountSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineProvisioningRepository
        case pipelineServiceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineProvisioningRepository = pipelineProvisioningRepository {
            try encodeContainer.encode(pipelineProvisioningRepository, forKey: .pipelineProvisioningRepository)
        }
        if let pipelineServiceRoleArn = pipelineServiceRoleArn {
            try encodeContainer.encode(pipelineServiceRoleArn, forKey: .pipelineServiceRoleArn)
        }
    }
}

public struct UpdateAccountSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// The repository that you provide with pull request provisioning. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
    public var pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    /// The Amazon Resource Name (ARN) of the Proton pipeline service role. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
    public var pipelineServiceRoleArn: Swift.String?

    public init (
        pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranchInput? = nil,
        pipelineServiceRoleArn: Swift.String? = nil
    )
    {
        self.pipelineProvisioningRepository = pipelineProvisioningRepository
        self.pipelineServiceRoleArn = pipelineServiceRoleArn
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    public let pipelineServiceRoleArn: Swift.String?
    public let pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranchInput?
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineProvisioningRepository
        case pipelineServiceRoleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineServiceRoleArn)
        pipelineServiceRoleArn = pipelineServiceRoleArnDecoded
        let pipelineProvisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranchInput.self, forKey: .pipelineProvisioningRepository)
        pipelineProvisioningRepository = pipelineProvisioningRepositoryDecoded
    }
}

extension UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccountSettingsOutputResponse(accountSettings: \(Swift.String(describing: accountSettings)))"}
}

extension UpdateAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct UpdateAccountSettingsOutputResponse: Swift.Equatable {
    /// The Proton pipeline service role repository detail data that's returned by Proton.
    /// This member is required.
    public var accountSettings: ProtonClientTypes.AccountSettings?

    public init (
        accountSettings: ProtonClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct UpdateAccountSettingsOutputResponseBody: Swift.Equatable {
    public let accountSettings: ProtonClientTypes.AccountSettings?
}

extension UpdateAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

public struct UpdateEnvironmentAccountConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentAccountConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentAccountConnectionOutputError>
}

extension UpdateEnvironmentAccountConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentAccountConnectionInput(id: \(Swift.String(describing: id)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension UpdateEnvironmentAccountConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateEnvironmentAccountConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentAccountConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentAccountConnectionOutputError>
}

public struct UpdateEnvironmentAccountConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentAccountConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentAccountConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentAccountConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentAccountConnectionOutputError>
}

public struct UpdateEnvironmentAccountConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentAccountConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentAccountConnectionOutputError>
}

public struct UpdateEnvironmentAccountConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentAccountConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentAccountConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentAccountConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentAccountConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentAccountConnectionOutputError>
}

public struct UpdateEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection to update.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that is associated with the environment account connection to update.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.roleArn = roleArn
    }
}

struct UpdateEnvironmentAccountConnectionInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let roleArn: Swift.String?
}

extension UpdateEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentAccountConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentAccountConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentAccountConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentAccountConnectionOutputResponse(environmentAccountConnection: \(Swift.String(describing: environmentAccountConnection)))"}
}

extension UpdateEnvironmentAccountConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentAccountConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct UpdateEnvironmentAccountConnectionOutputResponse: Swift.Equatable {
    /// The environment account connection detail data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init (
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct UpdateEnvironmentAccountConnectionOutputResponseBody: Swift.Equatable {
    public let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension UpdateEnvironmentAccountConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(deploymentType: \(Swift.String(describing: deploymentType)), description: \(Swift.String(describing: description)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioningRepository: \(Swift.String(describing: provisioningRepository)), spec: \(Swift.String(describing: spec)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)))"}
}

extension UpdateEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioningRepository = provisioningRepository {
            try encodeContainer.encode(provisioningRepository, forKey: .provisioningRepository)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// There are four modes for updating an environment as described in the following. The deploymentType field defines the mode. NONE In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. CURRENT_VERSION In this mode, the environment is deployed and updated with the new spec that you provide. Only requested parameters are updated. Don’t include minor or major version parameters when you use this deployment-type. MINOR_VERSION In this mode, the environment is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can also specify a different minor version of the current major version in use. MAJOR_VERSION In this mode, the environment is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can also specify a different major version that is higher than the major version in use and a minor version (optional).
    /// This member is required.
    public var deploymentType: ProtonClientTypes.DeploymentUpdateType?
    /// A description of the environment update.
    public var description: Swift.String?
    /// The ID of the environment account connection. You can only update to a new environment account connection if it was created in the same environment account that the current environment account connection was created in and is associated with the current environment.
    public var environmentAccountConnectionId: Swift.String?
    /// The name of the environment to update.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make API calls to other services your behalf.
    public var protonServiceRoleArn: Swift.String?
    /// The repository that you provide with pull request provisioning. Provisioning by pull request is currently in feature preview and is only usable with Terraform based Proton Templates. To learn more about [Amazon Web Services Feature Preview terms](https://aws.amazon.com/service-terms), see section 2 on Beta and Previews.
    public var provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    /// The formatted specification that defines the update.
    public var spec: Swift.String?
    /// The major version of the environment to update.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the environment to update.
    public var templateMinorVersion: Swift.String?

    public init (
        deploymentType: ProtonClientTypes.DeploymentUpdateType? = nil,
        description: Swift.String? = nil,
        environmentAccountConnectionId: Swift.String? = nil,
        name: Swift.String? = nil,
        protonServiceRoleArn: Swift.String? = nil,
        provisioningRepository: ProtonClientTypes.RepositoryBranchInput? = nil,
        spec: Swift.String? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil
    )
    {
        self.deploymentType = deploymentType
        self.description = description
        self.environmentAccountConnectionId = environmentAccountConnectionId
        self.name = name
        self.protonServiceRoleArn = protonServiceRoleArn
        self.provisioningRepository = provisioningRepository
        self.spec = spec
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let spec: Swift.String?
    public let templateMajorVersion: Swift.String?
    public let templateMinorVersion: Swift.String?
    public let protonServiceRoleArn: Swift.String?
    public let deploymentType: ProtonClientTypes.DeploymentUpdateType?
    public let environmentAccountConnectionId: Swift.String?
    public let provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentUpdateType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let provisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranchInput.self, forKey: .provisioningRepository)
        provisioningRepository = provisioningRepositoryDecoded
    }
}

extension UpdateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentOutputResponse(environment: \(Swift.String(describing: environment)))"}
}

extension UpdateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct UpdateEnvironmentOutputResponse: Swift.Equatable {
    /// The environment detail data that's returned by Proton.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init (
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct UpdateEnvironmentOutputResponseBody: Swift.Equatable {
    public let environment: ProtonClientTypes.Environment?
}

extension UpdateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

public struct UpdateEnvironmentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateOutputError>
}

extension UpdateEnvironmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentTemplateInput(description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), name: \(Swift.String(describing: name)))"}
}

extension UpdateEnvironmentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateEnvironmentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateOutputError>
}

public struct UpdateEnvironmentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateOutputError>
}

public struct UpdateEnvironmentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateOutputError>
}

public struct UpdateEnvironmentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateOutputError>
}

public struct UpdateEnvironmentTemplateInput: Swift.Equatable {
    /// A description of the environment template update.
    public var description: Swift.String?
    /// The name of the environment template to update as displayed in the developer interface.
    public var displayName: Swift.String?
    /// The name of the environment template to update.
    /// This member is required.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
    }
}

struct UpdateEnvironmentTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let displayName: Swift.String?
    public let description: Swift.String?
}

extension UpdateEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateEnvironmentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentTemplateOutputResponse(environmentTemplate: \(Swift.String(describing: environmentTemplate)))"}
}

extension UpdateEnvironmentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct UpdateEnvironmentTemplateOutputResponse: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init (
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct UpdateEnvironmentTemplateOutputResponseBody: Swift.Equatable {
    public let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension UpdateEnvironmentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

public struct UpdateEnvironmentTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateVersionOutputError>
}

extension UpdateEnvironmentTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentTemplateVersionInput(description: \(Swift.String(describing: description)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)))"}
}

extension UpdateEnvironmentTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case majorVersion
        case minorVersion
        case status
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct UpdateEnvironmentTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateVersionOutputError>
}

public struct UpdateEnvironmentTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateVersionOutputError>
}

public struct UpdateEnvironmentTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateVersionOutputError>
}

public struct UpdateEnvironmentTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentTemplateVersionOutputError>
}

public struct UpdateEnvironmentTemplateVersionInput: Swift.Equatable {
    /// A description of environment template version to update.
    public var description: Swift.String?
    /// To update a major version of an environment template, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To update a minor version of an environment template, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The status of the environment template minor version to update.
    public var status: ProtonClientTypes.TemplateVersionStatus?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        status: ProtonClientTypes.TemplateVersionStatus? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.description = description
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.status = status
        self.templateName = templateName
    }
}

struct UpdateEnvironmentTemplateVersionInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
    public let minorVersion: Swift.String?
    public let description: Swift.String?
    public let status: ProtonClientTypes.TemplateVersionStatus?
}

extension UpdateEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case majorVersion
        case minorVersion
        case status
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentTemplateVersionOutputResponse(environmentTemplateVersion: \(Swift.String(describing: environmentTemplateVersion)))"}
}

extension UpdateEnvironmentTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct UpdateEnvironmentTemplateVersionOutputResponse: Swift.Equatable {
    /// The environment template version detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init (
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct UpdateEnvironmentTemplateVersionOutputResponseBody: Swift.Equatable {
    public let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension UpdateEnvironmentTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

public struct UpdateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

extension UpdateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), spec: \(Swift.String(describing: spec)))"}
}

extension UpdateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The edited service description.
    public var description: Swift.String?
    /// The name of the service to edit.
    /// This member is required.
    public var name: Swift.String?
    /// Lists the service instances to add and the existing service instances to remain. Omit the existing service instances to delete from the list. Don't include edits to the existing service instances or pipeline. For more information, see Edit a service in the [Proton Administrator Guide](https://docs.aws.amazon.com/proton/latest/adminguide/ag-svc-update.html) or the [Proton User Guide](https://docs.aws.amazon.com/proton/latest/userguide/ug-svc-update.html).
    public var spec: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        spec: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.spec = spec
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let spec: Swift.String?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case spec
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
    }
}

public struct UpdateServiceInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceInstanceOutputError>
}

extension UpdateServiceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInstanceInput(deploymentType: \(Swift.String(describing: deploymentType)), name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)), spec: \(Swift.String(describing: spec)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)))"}
}

extension UpdateServiceInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case name
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
    }
}

public struct UpdateServiceInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceInstanceOutputError>
}

public struct UpdateServiceInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceInstanceOutputError>
}

public struct UpdateServiceInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceInstanceOutputError>
}

public struct UpdateServiceInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceInstanceOutputError>
}

public struct UpdateServiceInstanceInput: Swift.Equatable {
    /// The deployment type. There are four modes for updating a service instance as described in the following. The deploymentType field defines the mode. NONE In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. CURRENT_VERSION In this mode, the service instance is deployed and updated with the new spec that you provide. Only requested parameters are updated. Don’t include minor or major version parameters when you use this deployment-type. MINOR_VERSION In this mode, the service instance is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can also specify a different minor version of the current major version in use. MAJOR_VERSION In this mode, the service instance is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can also specify a different major version that is higher than the major version in use and a minor version (optional).
    /// This member is required.
    public var deploymentType: ProtonClientTypes.DeploymentUpdateType?
    /// The name of the service instance to update.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the service that the service instance belongs to.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The formatted specification that defines the service instance update.
    public var spec: Swift.String?
    /// The major version of the service template to update.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the service template to update.
    public var templateMinorVersion: Swift.String?

    public init (
        deploymentType: ProtonClientTypes.DeploymentUpdateType? = nil,
        name: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        spec: Swift.String? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil
    )
    {
        self.deploymentType = deploymentType
        self.name = name
        self.serviceName = serviceName
        self.spec = spec
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
    }
}

struct UpdateServiceInstanceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let serviceName: Swift.String?
    public let deploymentType: ProtonClientTypes.DeploymentUpdateType?
    public let spec: Swift.String?
    public let templateMajorVersion: Swift.String?
    public let templateMinorVersion: Swift.String?
}

extension UpdateServiceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case name
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentUpdateType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
    }
}

extension UpdateServiceInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInstanceOutputResponse(serviceInstance: \(Swift.String(describing: serviceInstance)))"}
}

extension UpdateServiceInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstance = output.serviceInstance
        } else {
            self.serviceInstance = nil
        }
    }
}

public struct UpdateServiceInstanceOutputResponse: Swift.Equatable {
    /// The service instance summary data returned by Proton.
    /// This member is required.
    public var serviceInstance: ProtonClientTypes.ServiceInstance?

    public init (
        serviceInstance: ProtonClientTypes.ServiceInstance? = nil
    )
    {
        self.serviceInstance = serviceInstance
    }
}

struct UpdateServiceInstanceOutputResponseBody: Swift.Equatable {
    public let serviceInstance: ProtonClientTypes.ServiceInstance?
}

extension UpdateServiceInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstance
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceInstance.self, forKey: .serviceInstance)
        serviceInstance = serviceInstanceDecoded
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// The service detail data that's returned by Proton.
    /// This member is required.
    public var service: ProtonClientTypes.Service?

    public init (
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    public let service: ProtonClientTypes.Service?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

public struct UpdateServicePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServicePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServicePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServicePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServicePipelineOutputError>
}

extension UpdateServicePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServicePipelineInput(deploymentType: \(Swift.String(describing: deploymentType)), serviceName: \(Swift.String(describing: serviceName)), spec: \(Swift.String(describing: spec)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)))"}
}

extension UpdateServicePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
    }
}

public struct UpdateServicePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServicePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServicePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServicePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServicePipelineOutputError>
}

public struct UpdateServicePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServicePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServicePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServicePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServicePipelineOutputError>
}

public struct UpdateServicePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServicePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServicePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServicePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServicePipelineOutputError>
}

public struct UpdateServicePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServicePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServicePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServicePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServicePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServicePipelineOutputError>
}

public struct UpdateServicePipelineInput: Swift.Equatable {
    /// The deployment type. There are four modes for updating a service pipeline as described in the following. The deploymentType field defines the mode. NONE In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. CURRENT_VERSION In this mode, the service pipeline is deployed and updated with the new spec that you provide. Only requested parameters are updated. Don’t include minor or major version parameters when you use this deployment-type. MINOR_VERSION In this mode, the service pipeline is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can also specify a different minor version of the current major version in use. MAJOR_VERSION In this mode, the service pipeline is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can also specify a different major version that is higher than the major version in use and a minor version (optional).
    /// This member is required.
    public var deploymentType: ProtonClientTypes.DeploymentUpdateType?
    /// The name of the service to that the pipeline is associated with.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The spec for the service pipeline to update.
    /// This member is required.
    public var spec: Swift.String?
    /// The major version of the service template that was used to create the service that the pipeline is associated with.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the service template that was used to create the service that the pipeline is associated with.
    public var templateMinorVersion: Swift.String?

    public init (
        deploymentType: ProtonClientTypes.DeploymentUpdateType? = nil,
        serviceName: Swift.String? = nil,
        spec: Swift.String? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil
    )
    {
        self.deploymentType = deploymentType
        self.serviceName = serviceName
        self.spec = spec
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
    }
}

struct UpdateServicePipelineInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
    public let spec: Swift.String?
    public let deploymentType: ProtonClientTypes.DeploymentUpdateType?
    public let templateMajorVersion: Swift.String?
    public let templateMinorVersion: Swift.String?
}

extension UpdateServicePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentUpdateType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
    }
}

extension UpdateServicePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServicePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServicePipelineOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServicePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServicePipelineOutputResponse(pipeline: \(Swift.String(describing: pipeline)))"}
}

extension UpdateServicePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServicePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct UpdateServicePipelineOutputResponse: Swift.Equatable {
    /// The pipeline details returned by Proton.
    /// This member is required.
    public var pipeline: ProtonClientTypes.ServicePipeline?

    public init (
        pipeline: ProtonClientTypes.ServicePipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdateServicePipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: ProtonClientTypes.ServicePipeline?
}

extension UpdateServicePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServicePipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

public struct UpdateServiceTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateOutputError>
}

extension UpdateServiceTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceTemplateInput(description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), name: \(Swift.String(describing: name)))"}
}

extension UpdateServiceTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateServiceTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateOutputError>
}

public struct UpdateServiceTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateOutputError>
}

public struct UpdateServiceTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateOutputError>
}

public struct UpdateServiceTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateOutputError>
}

public struct UpdateServiceTemplateInput: Swift.Equatable {
    /// A description of the service template update.
    public var description: Swift.String?
    /// The name of the service template to update as displayed in the developer interface.
    public var displayName: Swift.String?
    /// The name of the service template to update.
    /// This member is required.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
    }
}

struct UpdateServiceTemplateInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let displayName: Swift.String?
    public let description: Swift.String?
}

extension UpdateServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateServiceTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceTemplateOutputResponse(serviceTemplate: \(Swift.String(describing: serviceTemplate)))"}
}

extension UpdateServiceTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct UpdateServiceTemplateOutputResponse: Swift.Equatable {
    /// The service template detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init (
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct UpdateServiceTemplateOutputResponseBody: Swift.Equatable {
    public let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension UpdateServiceTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

public struct UpdateServiceTemplateVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateVersionOutputError>
}

extension UpdateServiceTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceTemplateVersionInput(compatibleEnvironmentTemplates: \(Swift.String(describing: compatibleEnvironmentTemplates)), description: \(Swift.String(describing: description)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)))"}
}

extension UpdateServiceTemplateVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case minorVersion
        case status
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleEnvironmentTemplates = compatibleEnvironmentTemplates {
            var compatibleEnvironmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleEnvironmentTemplates)
            for compatibleenvironmenttemplateinputlist0 in compatibleEnvironmentTemplates {
                try compatibleEnvironmentTemplatesContainer.encode(compatibleenvironmenttemplateinputlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct UpdateServiceTemplateVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateVersionOutputError>
}

public struct UpdateServiceTemplateVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceTemplateVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceTemplateVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateVersionOutputError>
}

public struct UpdateServiceTemplateVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateVersionOutputError>
}

public struct UpdateServiceTemplateVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceTemplateVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceTemplateVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceTemplateVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceTemplateVersionOutputError>
}

public struct UpdateServiceTemplateVersionInput: Swift.Equatable {
    /// An array of compatible environment names for a service template major or minor version to update.
    public var compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
    /// A description of a service template version to update.
    public var description: Swift.String?
    /// To update a major version of a service template, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To update a minor version of a service template, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The status of the service template minor version to update.
    public var status: ProtonClientTypes.TemplateVersionStatus?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init (
        compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil,
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        status: ProtonClientTypes.TemplateVersionStatus? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
        self.description = description
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.status = status
        self.templateName = templateName
    }
}

struct UpdateServiceTemplateVersionInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let majorVersion: Swift.String?
    public let minorVersion: Swift.String?
    public let description: Swift.String?
    public let status: ProtonClientTypes.TemplateVersionStatus?
    public let compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
}

extension UpdateServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case minorVersion
        case status
        case templateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let compatibleEnvironmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.CompatibleEnvironmentTemplateInput?].self, forKey: .compatibleEnvironmentTemplates)
        var compatibleEnvironmentTemplatesDecoded0:[ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil
        if let compatibleEnvironmentTemplatesContainer = compatibleEnvironmentTemplatesContainer {
            compatibleEnvironmentTemplatesDecoded0 = [ProtonClientTypes.CompatibleEnvironmentTemplateInput]()
            for structure0 in compatibleEnvironmentTemplatesContainer {
                if let structure0 = structure0 {
                    compatibleEnvironmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        compatibleEnvironmentTemplates = compatibleEnvironmentTemplatesDecoded0
    }
}

extension UpdateServiceTemplateVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceTemplateVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceTemplateVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceTemplateVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceTemplateVersionOutputResponse(serviceTemplateVersion: \(Swift.String(describing: serviceTemplateVersion)))"}
}

extension UpdateServiceTemplateVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct UpdateServiceTemplateVersionOutputResponse: Swift.Equatable {
    /// The service template version detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init (
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct UpdateServiceTemplateVersionOutputResponseBody: Swift.Equatable {
    public let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension UpdateServiceTemplateVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

public struct UpdateTemplateSyncConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTemplateSyncConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTemplateSyncConfigOutputError>
}

extension UpdateTemplateSyncConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTemplateSyncConfigInput(branch: \(Swift.String(describing: branch)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryProvider: \(Swift.String(describing: repositoryProvider)), subdirectory: \(Swift.String(describing: subdirectory)), templateName: \(Swift.String(describing: templateName)), templateType: \(Swift.String(describing: templateType)))"}
}

extension UpdateTemplateSyncConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let subdirectory = subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

public struct UpdateTemplateSyncConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTemplateSyncConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTemplateSyncConfigOutputError>
}

public struct UpdateTemplateSyncConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTemplateSyncConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTemplateSyncConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTemplateSyncConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTemplateSyncConfigOutputError>
}

public struct UpdateTemplateSyncConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTemplateSyncConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTemplateSyncConfigOutputError>
}

public struct UpdateTemplateSyncConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTemplateSyncConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateTemplateSyncConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTemplateSyncConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTemplateSyncConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTemplateSyncConfigOutputError>
}

public struct UpdateTemplateSyncConfigInput: Swift.Equatable {
    /// The repository branch.
    /// This member is required.
    public var branch: Swift.String?
    /// The name of the repository, for example myrepos/myrepo.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// A subdirectory path to your template bundle version. When included, limits the template bundle search to this repository directory.
    public var subdirectory: Swift.String?
    /// The synced template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The synced template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init (
        branch: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        subdirectory: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.branch = branch
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.subdirectory = subdirectory
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct UpdateTemplateSyncConfigInputBody: Swift.Equatable {
    public let templateName: Swift.String?
    public let templateType: ProtonClientTypes.TemplateType?
    public let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    public let repositoryName: Swift.String?
    public let branch: Swift.String?
    public let subdirectory: Swift.String?
}

extension UpdateTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
    }
}

extension UpdateTemplateSyncConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateSyncConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplateSyncConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateSyncConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTemplateSyncConfigOutputResponse(templateSyncConfig: \(Swift.String(describing: templateSyncConfig)))"}
}

extension UpdateTemplateSyncConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTemplateSyncConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct UpdateTemplateSyncConfigOutputResponse: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init (
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct UpdateTemplateSyncConfigOutputResponseBody: Swift.Equatable {
    public let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension UpdateTemplateSyncConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input is invalid or an out-of-range value was supplied for the input parameter.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
