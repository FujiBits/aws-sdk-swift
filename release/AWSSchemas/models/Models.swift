// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemasClientTypes {
    public enum CodeGenerationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeGenerationStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeGenerationStatus(rawValue: rawValue) ?? CodeGenerationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDiscovererInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discoverers"
    }
}

public struct CreateDiscovererInput: Swift.Equatable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true).
    var crossAccount: Swift.Bool?
    /// A description for the discoverer.
    var description: Swift.String?
    /// The ARN of the event bus.
    /// This member is required.
    var sourceArn: Swift.String?
    /// Tags associated with the resource.
    var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

struct CreateDiscovererInputBody: Swift.Equatable {
    let description: Swift.String?
    let sourceArn: Swift.String?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDiscovererInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case sourceArn = "SourceArn"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct CreateDiscovererOutputResponse: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    var description: Swift.String?
    /// The ARN of the discoverer.
    var discovererArn: Swift.String?
    /// The ID of the discoverer.
    var discovererId: Swift.String?
    /// The ARN of the event bus.
    var sourceArn: Swift.String?
    /// The state of the discoverer.
    var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct CreateDiscovererOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegistryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct CreateRegistryInput: Swift.Equatable {
    /// A description of the registry to be created.
    var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// Tags to associate with the registry.
    var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRegistryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct CreateRegistryOutputResponse: Swift.Equatable {
    /// The description of the registry.
    var description: Swift.String?
    /// The ARN of the registry.
    var registryArn: Swift.String?
    /// The name of the registry.
    var registryName: Swift.String?
    /// Tags associated with the registry.
    var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct CreateRegistryOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRegistryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The source of the schema definition.
    /// This member is required.
    var content: Swift.String?
    /// A description of the schema.
    var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// Tags associated with the schema.
    var tags: [Swift.String:Swift.String]?
    /// The type of schema.
    /// This member is required.
    var type: SchemasClientTypes.ModelType?

    public init (
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.tags = tags
        self.type = type
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    let content: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: SchemasClientTypes.ModelType?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case tags = "tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Swift.Equatable {
    /// The description of the schema.
    var description: Swift.String?
    /// The date and time that schema was modified.
    var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    var schemaArn: Swift.String?
    /// The name of the schema.
    var schemaName: Swift.String?
    /// The version number of the schema
    var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    var type: Swift.String?
    /// The date the schema version was created.
    var versionCreatedDate: ClientRuntime.Date?

    public init (
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct CreateSchemaOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension CreateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

extension DeleteDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DeleteDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension DeleteDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDiscovererOutputResponse: Swift.Equatable {

}

extension DeleteRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DeleteRegistryInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension DeleteRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRegistryOutputResponse: Swift.Equatable {

}

extension DeleteResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let registryName = registryName {
            let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The name of the registry.
    var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

}

extension DeleteSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

extension DeleteSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaOutputResponse: Swift.Equatable {

}

extension DeleteSchemaVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let schemaVersion = schemaVersion else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/version/\(schemaVersion.urlPercentEncoding())"
    }
}

public struct DeleteSchemaVersionInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// The version number of the schema
    /// This member is required.
    var schemaVersion: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension DeleteSchemaVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaVersionOutputResponse: Swift.Equatable {

}

extension DescribeCodeBindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let schemaVersion = schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension DescribeCodeBindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct DescribeCodeBindingInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    var schemaVersion: Swift.String?

    public init (
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension DescribeCodeBindingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCodeBindingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCodeBindingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCodeBindingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCodeBindingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct DescribeCodeBindingOutputResponse: Swift.Equatable {
    /// The time and date that the code binding was created.
    var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    var status: SchemasClientTypes.CodeGenerationStatus?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct DescribeCodeBindingOutputResponseBody: Swift.Equatable {
    let creationDate: ClientRuntime.Date?
    let lastModified: ClientRuntime.Date?
    let schemaVersion: Swift.String?
    let status: SchemasClientTypes.CodeGenerationStatus?
}

extension DescribeCodeBindingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct DescribeDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension DescribeDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct DescribeDiscovererOutputResponse: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    var description: Swift.String?
    /// The ARN of the discoverer.
    var discovererArn: Swift.String?
    /// The ID of the discoverer.
    var discovererId: Swift.String?
    /// The ARN of the event bus.
    var sourceArn: Swift.String?
    /// The state of the discoverer.
    var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct DescribeDiscovererOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

public struct DescribeRegistryInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension DescribeRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRegistryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct DescribeRegistryOutputResponse: Swift.Equatable {
    /// The description of the registry.
    var description: Swift.String?
    /// The ARN of the registry.
    var registryArn: Swift.String?
    /// The name of the registry.
    var registryName: Swift.String?
    /// Tags associated with the registry.
    var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct DescribeRegistryOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRegistryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let schemaVersion = schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension DescribeSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct DescribeSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    var schemaVersion: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension DescribeSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.content = nil
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct DescribeSchemaOutputResponse: Swift.Equatable {
    /// The source of the schema definition.
    var content: Swift.String?
    /// The description of the schema.
    var description: Swift.String?
    /// The date and time that schema was modified.
    var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    var schemaArn: Swift.String?
    /// The name of the schema.
    var schemaName: Swift.String?
    /// The version number of the schema
    var schemaVersion: Swift.String?
    /// Tags associated with the resource.
    var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    var type: Swift.String?
    /// The date the schema version was created.
    var versionCreatedDate: ClientRuntime.Date?

    public init (
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.content = content
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct DescribeSchemaOutputResponseBody: Swift.Equatable {
    let content: Swift.String?
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension DescribeSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}

extension SchemasClientTypes {
    public enum DiscovererState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscovererState] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiscovererState(rawValue: rawValue) ?? DiscovererState.sdkUnknown(rawValue)
        }
    }
}

extension SchemasClientTypes.DiscovererSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let discovererArn = discovererArn {
            try encodeContainer.encode(discovererArn, forKey: .discovererArn)
        }
        if let discovererId = discovererId {
            try encodeContainer.encode(discovererId, forKey: .discovererId)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchemasClientTypes {
    public struct DiscovererSummary: Swift.Equatable {
        /// The Status if the discoverer will discover schemas from events sent from another account.
        var crossAccount: Swift.Bool?
        /// The ARN of the discoverer.
        var discovererArn: Swift.String?
        /// The ID of the discoverer.
        var discovererId: Swift.String?
        /// The ARN of the event bus.
        var sourceArn: Swift.String?
        /// The state of the discoverer.
        var state: SchemasClientTypes.DiscovererState?
        /// Tags associated with the resource.
        var tags: [Swift.String:Swift.String]?

        public init (
            crossAccount: Swift.Bool? = nil,
            discovererArn: Swift.String? = nil,
            discovererId: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            state: SchemasClientTypes.DiscovererState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.crossAccount = crossAccount
            self.discovererArn = discovererArn
            self.discovererId = discovererId
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
        }
    }

}

extension ExportSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let schemaVersion = schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension ExportSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/export"
    }
}

public struct ExportSchemaInput: Swift.Equatable {
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    var schemaVersion: Swift.String?
    /// This member is required.
    var type: Swift.String?

    public init (
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

extension ExportSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.type = output.type
        } else {
            self.content = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.type = nil
        }
    }
}

public struct ExportSchemaOutputResponse: Swift.Equatable {
    var content: Swift.String?
    var schemaArn: Swift.String?
    var schemaName: Swift.String?
    var schemaVersion: Swift.String?
    var type: Swift.String?

    public init (
        content: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.content = content
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.type = type
    }
}

struct ExportSchemaOutputResponseBody: Swift.Equatable {
    let content: Swift.String?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let type: Swift.String?
}

extension ExportSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetCodeBindingSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let schemaVersion = schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension GetCodeBindingSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())/source"
    }
}

public struct GetCodeBindingSourceInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    var schemaVersion: Swift.String?

    public init (
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension GetCodeBindingSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCodeBindingSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCodeBindingSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCodeBindingSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.body = data
        } else {
            self.body = nil
        }
    }
}

public struct GetCodeBindingSourceOutputResponse: Swift.Equatable {
    var body: ClientRuntime.Data?

    public init (
        body: ClientRuntime.Data? = nil
    )
    {
        self.body = body
    }
}

struct GetCodeBindingSourceOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension GetCodeBindingSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetDiscoveredSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for __listofgetdiscoveredschemaversioniteminput0 in events {
                try eventsContainer.encode(__listofgetdiscoveredschemaversioniteminput0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension GetDiscoveredSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discover"
    }
}

public struct GetDiscoveredSchemaInput: Swift.Equatable {
    /// An array of strings where each string is a JSON event. These are the events that were used to generate the schema. The array includes a single type of event and has a maximum size of 10 events.
    /// This member is required.
    var events: [Swift.String]?
    /// The type of event.
    /// This member is required.
    var type: SchemasClientTypes.ModelType?

    public init (
        events: [Swift.String]? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.events = events
        self.type = type
    }
}

struct GetDiscoveredSchemaInputBody: Swift.Equatable {
    let events: [Swift.String]?
    let type: SchemasClientTypes.ModelType?
}

extension GetDiscoveredSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .events)
        var eventsDecoded0:[Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GetDiscoveredSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDiscoveredSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDiscoveredSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDiscoveredSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDiscoveredSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct GetDiscoveredSchemaOutputResponse: Swift.Equatable {
    /// The source of the schema definition.
    var content: Swift.String?

    public init (
        content: Swift.String? = nil
    )
    {
        self.content = content
    }
}

struct GetDiscoveredSchemaOutputResponseBody: Swift.Equatable {
    let content: Swift.String?
}

extension GetDiscoveredSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let registryName = registryName {
            let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The name of the registry.
    var registryName: Swift.String?

    public init (
        registryName: Swift.String? = nil
    )
    {
        self.registryName = registryName
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// The resource-based policy.
    var policy: Swift.String?
    /// The revision ID.
    var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GoneException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GoneExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct GoneException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct GoneExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension GoneExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDiscoverersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sourceArnPrefix = sourceArnPrefix {
            let sourceArnPrefixQueryItem = ClientRuntime.URLQueryItem(name: "sourceArnPrefix".urlPercentEncoding(), value: Swift.String(sourceArnPrefix).urlPercentEncoding())
            items.append(sourceArnPrefixQueryItem)
        }
        if let discovererIdPrefix = discovererIdPrefix {
            let discovererIdPrefixQueryItem = ClientRuntime.URLQueryItem(name: "discovererIdPrefix".urlPercentEncoding(), value: Swift.String(discovererIdPrefix).urlPercentEncoding())
            items.append(discovererIdPrefixQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListDiscoverersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/discoverers"
    }
}

public struct ListDiscoverersInput: Swift.Equatable {
    /// Specifying this limits the results to only those discoverer IDs that start with the specified prefix.
    var discovererIdPrefix: Swift.String?
    var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// Specifying this limits the results to only those ARNs that start with the specified prefix.
    var sourceArnPrefix: Swift.String?

    public init (
        discovererIdPrefix: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceArnPrefix: Swift.String? = nil
    )
    {
        self.discovererIdPrefix = discovererIdPrefix
        self.limit = limit
        self.nextToken = nextToken
        self.sourceArnPrefix = sourceArnPrefix
    }
}

extension ListDiscoverersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoverersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDiscoverersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoverersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDiscoverersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discoverers = output.discoverers
            self.nextToken = output.nextToken
        } else {
            self.discoverers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoverersOutputResponse: Swift.Equatable {
    /// An array of DiscovererSummary information.
    var discoverers: [SchemasClientTypes.DiscovererSummary]?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?

    public init (
        discoverers: [SchemasClientTypes.DiscovererSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoverers = discoverers
        self.nextToken = nextToken
    }
}

struct ListDiscoverersOutputResponseBody: Swift.Equatable {
    let discoverers: [SchemasClientTypes.DiscovererSummary]?
    let nextToken: Swift.String?
}

extension ListDiscoverersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoverers = "Discoverers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discoverersContainer = try containerValues.decodeIfPresent([SchemasClientTypes.DiscovererSummary?].self, forKey: .discoverers)
        var discoverersDecoded0:[SchemasClientTypes.DiscovererSummary]? = nil
        if let discoverersContainer = discoverersContainer {
            discoverersDecoded0 = [SchemasClientTypes.DiscovererSummary]()
            for structure0 in discoverersContainer {
                if let structure0 = structure0 {
                    discoverersDecoded0?.append(structure0)
                }
            }
        }
        discoverers = discoverersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRegistriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let scope = scope {
            let scopeQueryItem = ClientRuntime.URLQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope).urlPercentEncoding())
            items.append(scopeQueryItem)
        }
        if let registryNamePrefix = registryNamePrefix {
            let registryNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "registryNamePrefix".urlPercentEncoding(), value: Swift.String(registryNamePrefix).urlPercentEncoding())
            items.append(registryNamePrefixQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListRegistriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/registries"
    }
}

public struct ListRegistriesInput: Swift.Equatable {
    var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// Specifying this limits the results to only those registry names that start with the specified prefix.
    var registryNamePrefix: Swift.String?
    /// Can be set to Local or AWS to limit responses to your custom registries, or the ones provided by AWS.
    var scope: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryNamePrefix: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryNamePrefix = registryNamePrefix
        self.scope = scope
    }
}

extension ListRegistriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegistriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRegistriesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegistriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRegistriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct ListRegistriesOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// An array of registry summaries.
    var registries: [SchemasClientTypes.RegistrySummary]?

    public init (
        nextToken: Swift.String? = nil,
        registries: [SchemasClientTypes.RegistrySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct ListRegistriesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let registries: [SchemasClientTypes.RegistrySummary]?
}

extension ListRegistriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registries = "Registries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let registriesContainer = try containerValues.decodeIfPresent([SchemasClientTypes.RegistrySummary?].self, forKey: .registries)
        var registriesDecoded0:[SchemasClientTypes.RegistrySummary]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [SchemasClientTypes.RegistrySummary]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
    }
}

extension ListSchemaVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListSchemaVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/versions"
    }
}

public struct ListSchemaVersionsInput: Swift.Equatable {
    var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaName = schemaName
    }
}

extension ListSchemaVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemaVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemaVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemaVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSchemaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaVersions = output.schemaVersions
        } else {
            self.nextToken = nil
            self.schemaVersions = nil
        }
    }
}

public struct ListSchemaVersionsOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// An array of schema version summaries.
    var schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemaVersions: [SchemasClientTypes.SchemaVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaVersions = schemaVersions
    }
}

struct ListSchemaVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemaVersions: [SchemasClientTypes.SchemaVersionSummary]?
}

extension ListSchemaVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaVersions = "SchemaVersions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SchemasClientTypes.SchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SchemasClientTypes.SchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

extension ListSchemasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let schemaNamePrefix = schemaNamePrefix {
            let schemaNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "schemaNamePrefix".urlPercentEncoding(), value: Swift.String(schemaNamePrefix).urlPercentEncoding())
            items.append(schemaNamePrefixQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas"
    }
}

public struct ListSchemasInput: Swift.Equatable {
    var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// Specifying this limits the results to only those schema names that start with the specified prefix.
    var schemaNamePrefix: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaNamePrefix: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
        self.schemaNamePrefix = schemaNamePrefix
    }
}

extension ListSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemasOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// An array of schema summaries.
    var schemas: [SchemasClientTypes.SchemaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemas: [SchemasClientTypes.SchemaSummary]?
}

extension ListSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SchemasClientTypes.SchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemasClientTypes.SchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Key-value pairs associated with a resource.
    var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct PreconditionFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutCodeBindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let schemaVersion = schemaVersion {
            let schemaVersionQueryItem = ClientRuntime.URLQueryItem(name: "schemaVersion".urlPercentEncoding(), value: Swift.String(schemaVersion).urlPercentEncoding())
            items.append(schemaVersionQueryItem)
        }
        return items
    }
}

extension PutCodeBindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        guard let language = language else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())/language/\(language.urlPercentEncoding())"
    }
}

public struct PutCodeBindingInput: Swift.Equatable {
    /// The language of the code binding.
    /// This member is required.
    var language: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// Specifying this limits the results to only this schema version.
    var schemaVersion: Swift.String?

    public init (
        language: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil
    )
    {
        self.language = language
        self.registryName = registryName
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
    }
}

extension PutCodeBindingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCodeBindingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GoneException" : self = .goneException(try GoneException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutCodeBindingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case goneException(GoneException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCodeBindingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutCodeBindingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastModified = output.lastModified
            self.schemaVersion = output.schemaVersion
            self.status = output.status
        } else {
            self.creationDate = nil
            self.lastModified = nil
            self.schemaVersion = nil
            self.status = nil
        }
    }
}

public struct PutCodeBindingOutputResponse: Swift.Equatable {
    /// The time and date that the code binding was created.
    var creationDate: ClientRuntime.Date?
    /// The date and time that code bindings were modified.
    var lastModified: ClientRuntime.Date?
    /// The version number of the schema.
    var schemaVersion: Swift.String?
    /// The current status of code binding generation.
    var status: SchemasClientTypes.CodeGenerationStatus?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaVersion: Swift.String? = nil,
        status: SchemasClientTypes.CodeGenerationStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModified = lastModified
        self.schemaVersion = schemaVersion
        self.status = status
    }
}

struct PutCodeBindingOutputResponseBody: Swift.Equatable {
    let creationDate: ClientRuntime.Date?
    let lastModified: ClientRuntime.Date?
    let schemaVersion: Swift.String?
    let status: SchemasClientTypes.CodeGenerationStatus?
}

extension PutCodeBindingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModified = "LastModified"
        case schemaVersion = "SchemaVersion"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.CodeGenerationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PutResourcePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let registryName = registryName {
            let registryNameQueryItem = ClientRuntime.URLQueryItem(name: "registryName".urlPercentEncoding(), value: Swift.String(registryName).urlPercentEncoding())
            items.append(registryNameQueryItem)
        }
        return items
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/policy"
    }
}

/// The name of the policy.
public struct PutResourcePolicyInput: Swift.Equatable {
    /// The resource-based policy.
    /// This member is required.
    var policy: Swift.String?
    /// The name of the registry.
    var registryName: Swift.String?
    /// The revision ID of the policy.
    var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        registryName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.registryName = registryName
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case preconditionFailedException(PreconditionFailedException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {
    /// The resource-based policy.
    var policy: Swift.String?
    /// The revision ID of the policy.
    var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct PutResourcePolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension PutResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension SchemasClientTypes.RegistrySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryArn = registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchemasClientTypes {
    public struct RegistrySummary: Swift.Equatable {
        /// The ARN of the registry.
        var registryArn: Swift.String?
        /// The name of the registry.
        var registryName: Swift.String?
        /// Tags associated with the registry.
        var tags: [Swift.String:Swift.String]?

        public init (
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }
    }

}

extension SchemasClientTypes.SchemaSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case tags = "tags"
        case versionCount = "VersionCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versionCount = versionCount {
            try encodeContainer.encode(versionCount, forKey: .versionCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let versionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionCount)
        versionCount = versionCountDecoded
    }
}

extension SchemasClientTypes {
    /// A summary of schema details.
    public struct SchemaSummary: Swift.Equatable {
        /// The date and time that schema was modified.
        var lastModified: ClientRuntime.Date?
        /// The ARN of the schema.
        var schemaArn: Swift.String?
        /// The name of the schema.
        var schemaName: Swift.String?
        /// Tags associated with the schema.
        var tags: [Swift.String:Swift.String]?
        /// The number of versions available for the schema.
        var versionCount: Swift.Int?

        public init (
            lastModified: ClientRuntime.Date? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            versionCount: Swift.Int? = nil
        )
        {
            self.lastModified = lastModified
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.versionCount = versionCount
        }
    }

}

extension SchemasClientTypes.SchemaVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SchemasClientTypes {
    public struct SchemaVersionSummary: Swift.Equatable {
        /// The ARN of the schema version.
        var schemaArn: Swift.String?
        /// The name of the schema.
        var schemaName: Swift.String?
        /// The version number of the schema.
        var schemaVersion: Swift.String?
        /// The type of schema.
        var type: SchemasClientTypes.ModelType?

        public init (
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

extension SchemasClientTypes.SearchSchemaSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryName = "RegistryName"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersions = "SchemaVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryName = registryName {
            try encodeContainer.encode(registryName, forKey: .registryName)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let schemaVersions = schemaVersions {
            var schemaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaVersions)
            for __listofsearchschemaversionsummary0 in schemaVersions {
                try schemaVersionsContainer.encode(__listofsearchschemaversionsummary0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionsContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SearchSchemaVersionSummary?].self, forKey: .schemaVersions)
        var schemaVersionsDecoded0:[SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        if let schemaVersionsContainer = schemaVersionsContainer {
            schemaVersionsDecoded0 = [SchemasClientTypes.SearchSchemaVersionSummary]()
            for structure0 in schemaVersionsContainer {
                if let structure0 = structure0 {
                    schemaVersionsDecoded0?.append(structure0)
                }
            }
        }
        schemaVersions = schemaVersionsDecoded0
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaSummary: Swift.Equatable {
        /// The name of the registry.
        var registryName: Swift.String?
        /// The ARN of the schema.
        var schemaArn: Swift.String?
        /// The name of the schema.
        var schemaName: Swift.String?
        /// An array of schema version summaries.
        var schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]?

        public init (
            registryName: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaVersions: [SchemasClientTypes.SearchSchemaVersionSummary]? = nil
        )
        {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersions = schemaVersions
        }
    }

}

extension SchemasClientTypes.SearchSchemaVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case schemaVersion = "SchemaVersion"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SchemasClientTypes {
    public struct SearchSchemaVersionSummary: Swift.Equatable {
        /// The date the schema version was created.
        var createdDate: ClientRuntime.Date?
        /// The version number of the schema
        var schemaVersion: Swift.String?
        /// The type of schema.
        var type: SchemasClientTypes.ModelType?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            schemaVersion: Swift.String? = nil,
            type: SchemasClientTypes.ModelType? = nil
        )
        {
            self.createdDate = createdDate
            self.schemaVersion = schemaVersion
            self.type = type
        }
    }

}

extension SearchSchemasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let keywords = keywords {
            let keywordsQueryItem = ClientRuntime.URLQueryItem(name: "keywords".urlPercentEncoding(), value: Swift.String(keywords).urlPercentEncoding())
            items.append(keywordsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension SearchSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/search"
    }
}

public struct SearchSchemasInput: Swift.Equatable {
    /// Specifying this limits the results to only schemas that include the provided keywords.
    /// This member is required.
    var keywords: Swift.String?
    var limit: Swift.Int?
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?

    public init (
        keywords: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.limit = limit
        self.nextToken = nextToken
        self.registryName = registryName
    }
}

extension SearchSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchSchemasOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct SearchSchemasOutputResponse: Swift.Equatable {
    /// The token that specifies the next page of results to return. To request the first page, leave NextToken empty. The token will expire in 24 hours, and cannot be shared with other accounts.
    var nextToken: Swift.String?
    /// An array of SearchSchemaSummary information.
    var schemas: [SchemasClientTypes.SearchSchemaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [SchemasClientTypes.SearchSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct SearchSchemasOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schemas: [SchemasClientTypes.SearchSchemaSummary]?
}

extension SearchSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schemasContainer = try containerValues.decodeIfPresent([SchemasClientTypes.SearchSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[SchemasClientTypes.SearchSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SchemasClientTypes.SearchSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/start"
    }
}

public struct StartDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension StartDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StartDiscovererOutputResponse: Swift.Equatable {
    /// The ID of the discoverer.
    var discovererId: Swift.String?
    /// The state of the discoverer.
    var state: SchemasClientTypes.DiscovererState?

    public init (
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StartDiscovererOutputResponseBody: Swift.Equatable {
    let discovererId: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
}

extension StartDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

extension StopDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())/stop"
    }
}

public struct StopDiscovererInput: Swift.Equatable {
    /// The ID of the discoverer.
    /// This member is required.
    var discovererId: Swift.String?

    public init (
        discovererId: Swift.String? = nil
    )
    {
        self.discovererId = discovererId
    }
}

extension StopDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discovererId = output.discovererId
            self.state = output.state
        } else {
            self.discovererId = nil
            self.state = nil
        }
    }
}

public struct StopDiscovererOutputResponse: Swift.Equatable {
    /// The ID of the discoverer.
    var discovererId: Swift.String?
    /// The state of the discoverer.
    var state: SchemasClientTypes.DiscovererState?

    public init (
        discovererId: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil
    )
    {
        self.discovererId = discovererId
        self.state = state
    }
}

struct StopDiscovererOutputResponseBody: Swift.Equatable {
    let discovererId: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
}

extension StopDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discovererId = "DiscovererId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
    }
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    var resourceArn: Swift.String?
    /// Tags associated with the resource.
    /// This member is required.
    var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemasClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonschemadraft4
        case openapi3
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .jsonschemadraft4,
                .openapi3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonschemadraft4: return "JSONSchemaDraft4"
            case .openapi3: return "OpenApi3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code.
    /// This member is required.
    public var code: Swift.String?
    /// The message string of the error output.
    /// This member is required.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    var resourceArn: Swift.String?
    /// Keys of key-value pairs.
    /// This member is required.
    var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateDiscovererInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccount = crossAccount {
            try encodeContainer.encode(crossAccount, forKey: .crossAccount)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDiscovererInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let discovererId = discovererId else {
            return nil
        }
        return "/v1/discoverers/id/\(discovererId.urlPercentEncoding())"
    }
}

public struct UpdateDiscovererInput: Swift.Equatable {
    /// Support discovery of schemas in events sent to the bus from another account. (default: true)
    var crossAccount: Swift.Bool?
    /// The description of the discoverer to update.
    var description: Swift.String?
    /// The ID of the discoverer.
    /// This member is required.
    var discovererId: Swift.String?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererId: Swift.String? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererId = discovererId
    }
}

struct UpdateDiscovererInputBody: Swift.Equatable {
    let description: Swift.String?
    let crossAccount: Swift.Bool?
}

extension UpdateDiscovererInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
    }
}

extension UpdateDiscovererOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDiscovererOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDiscovererOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDiscovererOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDiscovererOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccount = output.crossAccount
            self.description = output.description
            self.discovererArn = output.discovererArn
            self.discovererId = output.discovererId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
        } else {
            self.crossAccount = nil
            self.description = nil
            self.discovererArn = nil
            self.discovererId = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct UpdateDiscovererOutputResponse: Swift.Equatable {
    /// The Status if the discoverer will discover schemas from events sent from another account.
    var crossAccount: Swift.Bool?
    /// The description of the discoverer.
    var description: Swift.String?
    /// The ARN of the discoverer.
    var discovererArn: Swift.String?
    /// The ID of the discoverer.
    var discovererId: Swift.String?
    /// The ARN of the event bus.
    var sourceArn: Swift.String?
    /// The state of the discoverer.
    var state: SchemasClientTypes.DiscovererState?
    /// Tags associated with the resource.
    var tags: [Swift.String:Swift.String]?

    public init (
        crossAccount: Swift.Bool? = nil,
        description: Swift.String? = nil,
        discovererArn: Swift.String? = nil,
        discovererId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        state: SchemasClientTypes.DiscovererState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.crossAccount = crossAccount
        self.description = description
        self.discovererArn = discovererArn
        self.discovererId = discovererId
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
    }
}

struct UpdateDiscovererOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let discovererArn: Swift.String?
    let discovererId: Swift.String?
    let sourceArn: Swift.String?
    let state: SchemasClientTypes.DiscovererState?
    let crossAccount: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateDiscovererOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccount = "CrossAccount"
        case description = "Description"
        case discovererArn = "DiscovererArn"
        case discovererId = "DiscovererId"
        case sourceArn = "SourceArn"
        case state = "State"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let discovererArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererArn)
        discovererArn = discovererArnDecoded
        let discovererIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discovererId)
        discovererId = discovererIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.DiscovererState.self, forKey: .state)
        state = stateDecoded
        let crossAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccount)
        crossAccount = crossAccountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateRegistryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())"
    }
}

/// Updates the registry.
public struct UpdateRegistryInput: Swift.Equatable {
    /// The description of the registry to update.
    var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?

    public init (
        description: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.description = description
        self.registryName = registryName
    }
}

struct UpdateRegistryInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateRegistryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegistryOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRegistryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.registryArn = output.registryArn
            self.registryName = output.registryName
            self.tags = output.tags
        } else {
            self.description = nil
            self.registryArn = nil
            self.registryName = nil
            self.tags = nil
        }
    }
}

public struct UpdateRegistryOutputResponse: Swift.Equatable {
    /// The description of the registry.
    var description: Swift.String?
    /// The ARN of the registry.
    var registryArn: Swift.String?
    /// The name of the registry.
    var registryName: Swift.String?
    /// Tags associated with the registry.
    var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

struct UpdateRegistryOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let registryArn: Swift.String?
    let registryName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateRegistryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case registryArn = "RegistryArn"
        case registryName = "RegistryName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryName)
        registryName = registryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientTokenId = clientTokenId {
            try encodeContainer.encode(clientTokenId, forKey: .clientTokenId)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let registryName = registryName else {
            return nil
        }
        guard let schemaName = schemaName else {
            return nil
        }
        return "/v1/registries/name/\(registryName.urlPercentEncoding())/schemas/name/\(schemaName.urlPercentEncoding())"
    }
}

public struct UpdateSchemaInput: Swift.Equatable {
    /// The ID of the client token.
    var clientTokenId: Swift.String?
    /// The source of the schema definition.
    var content: Swift.String?
    /// The description of the schema.
    var description: Swift.String?
    /// The name of the registry.
    /// This member is required.
    var registryName: Swift.String?
    /// The name of the schema.
    /// This member is required.
    var schemaName: Swift.String?
    /// The schema type for the events schema.
    var type: SchemasClientTypes.ModelType?

    public init (
        clientTokenId: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        type: SchemasClientTypes.ModelType? = nil
    )
    {
        self.clientTokenId = clientTokenId
        self.content = content
        self.description = description
        self.registryName = registryName
        self.schemaName = schemaName
        self.type = type
    }
}

struct UpdateSchemaInputBody: Swift.Equatable {
    let clientTokenId: Swift.String?
    let content: Swift.String?
    let description: Swift.String?
    let type: SchemasClientTypes.ModelType?
}

extension UpdateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTokenId = "ClientTokenId"
        case content = "Content"
        case description = "Description"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientTokenId)
        clientTokenId = clientTokenIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SchemasClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSchemaOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.lastModified = output.lastModified
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.schemaVersion = output.schemaVersion
            self.tags = output.tags
            self.type = output.type
            self.versionCreatedDate = output.versionCreatedDate
        } else {
            self.description = nil
            self.lastModified = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.schemaVersion = nil
            self.tags = nil
            self.type = nil
            self.versionCreatedDate = nil
        }
    }
}

public struct UpdateSchemaOutputResponse: Swift.Equatable {
    /// The description of the schema.
    var description: Swift.String?
    /// The date and time that schema was modified.
    var lastModified: ClientRuntime.Date?
    /// The ARN of the schema.
    var schemaArn: Swift.String?
    /// The name of the schema.
    var schemaName: Swift.String?
    /// The version number of the schema
    var schemaVersion: Swift.String?
    /// Key-value pairs associated with a resource.
    var tags: [Swift.String:Swift.String]?
    /// The type of the schema.
    var type: Swift.String?
    /// The date the schema version was created.
    var versionCreatedDate: ClientRuntime.Date?

    public init (
        description: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        versionCreatedDate: ClientRuntime.Date? = nil
    )
    {
        self.description = description
        self.lastModified = lastModified
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.type = type
        self.versionCreatedDate = versionCreatedDate
    }
}

struct UpdateSchemaOutputResponseBody: Swift.Equatable {
    let description: Swift.String?
    let lastModified: ClientRuntime.Date?
    let schemaArn: Swift.String?
    let schemaName: Swift.String?
    let schemaVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
    let versionCreatedDate: ClientRuntime.Date?
}

extension UpdateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModified = "LastModified"
        case schemaArn = "SchemaArn"
        case schemaName = "SchemaName"
        case schemaVersion = "SchemaVersion"
        case tags = "tags"
        case type = "Type"
        case versionCreatedDate = "VersionCreatedDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionCreatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .versionCreatedDate)
        versionCreatedDate = versionCreatedDateDecoded
    }
}
