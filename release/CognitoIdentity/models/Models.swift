// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CognitoIdentityClientTypes {
    public enum AmbiguousRoleResolutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRole
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AmbiguousRoleResolutionType] {
            return [
                .authenticatedRole,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRole: return "AuthenticatedRole"
            case .deny: return "Deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmbiguousRoleResolutionType(rawValue: rawValue) ?? AmbiguousRoleResolutionType.sdkUnknown(rawValue)
        }
    }
}

extension CognitoIdentityClientTypes.CognitoIdentityProvider: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "ClientId"
        case providerName = "ProviderName"
        case serverSideTokenCheck = "ServerSideTokenCheck"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if serverSideTokenCheck != false {
            try encodeContainer.encode(serverSideTokenCheck, forKey: .serverSideTokenCheck)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let serverSideTokenCheckDecoded = try containerValues.decode(Swift.Bool.self, forKey: .serverSideTokenCheck)
        serverSideTokenCheck = serverSideTokenCheckDecoded
    }
}

extension CognitoIdentityClientTypes.CognitoIdentityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoIdentityProvider(clientId: \(Swift.String(describing: clientId)), providerName: \(Swift.String(describing: providerName)), serverSideTokenCheck: \(Swift.String(describing: serverSideTokenCheck)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>A provider representing an Amazon Cognito user pool and its client ID.</p>
    public struct CognitoIdentityProvider: Swift.Equatable {
        /// <p>The client ID for the Amazon Cognito user pool.</p>
        public let clientId: Swift.String?
        /// <p>The provider name for an Amazon Cognito user pool. For example,
        ///             <code>cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789</code>.</p>
        public let providerName: Swift.String?
        /// <p>TRUE if server-side token validation is enabled for the identity providerâ€™s
        ///          token.</p>
        ///          <p>Once you set <code>ServerSideTokenCheck</code> to TRUE for an identity pool, that
        ///          identity pool will check with the integrated user pools to make sure that the user has not
        ///          been globally signed out or deleted before the identity pool provides an OIDC token or AWS
        ///          credentials for the user.</p>
        ///          <p>If the user is signed out or deleted, the identity pool will return a 400 Not
        ///          Authorized error.</p>
        public let serverSideTokenCheck: Swift.Bool

        public init (
            clientId: Swift.String? = nil,
            providerName: Swift.String? = nil,
            serverSideTokenCheck: Swift.Bool = false
        )
        {
            self.clientId = clientId
            self.providerName = providerName
            self.serverSideTokenCheck = serverSideTokenCheck
        }
    }

}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown if there are parallel requests to modify a resource.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned by a ConcurrentModificationException.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateIdentityPoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityPoolOutputError>
}

extension CreateIdentityPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityPoolInput(allowClassicFlow: \(Swift.String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(Swift.String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(Swift.String(describing: cognitoIdentityProviders)), developerProviderName: \(Swift.String(describing: developerProviderName)), identityPoolName: \(Swift.String(describing: identityPoolName)), identityPoolTags: \(Swift.String(describing: identityPoolTags)), openIdConnectProviderARNs: \(Swift.String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(Swift.String(describing: samlProviderARNs)), supportedLoginProviders: \(Swift.String(describing: supportedLoginProviders)))"}
}

extension CreateIdentityPoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if allowUnauthenticatedIdentities != false {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityproviderlist0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityproviderlist0)
            }
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityPoolTags)
            for (dictKey0, identitypooltagstype0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identitypooltagstype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for oidcproviderlist0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(oidcproviderlist0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for samlproviderlist0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(samlproviderlist0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityproviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityproviders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateIdentityPoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityPoolOutputError>
}

public struct CreateIdentityPoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityPoolOutputError>
}

/// <p>Input to the CreateIdentityPool action.</p>
public struct CreateIdentityPoolInput: Swift.Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Swift.Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Swift.Bool
    /// <p>An array of Amazon Cognito user pools and their client IDs.</p>
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users. This name acts as a
    ///          placeholder that allows your backend and the Cognito service to communicate about the
    ///          developer provider. For the <code>DeveloperProviderName</code>, you can use letters as well
    ///          as period (<code>.</code>), underscore (<code>_</code>), and dash
    ///          (<code>-</code>).</p>
    ///          <p>Once you have set a developer provider name, you cannot change it. Please take care
    ///          in setting this parameter.</p>
    public let developerProviderName: Swift.String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: Swift.String?
    /// <p>Tags to assign to the identity pool. A tag is a label that you can apply to identity
    ///          pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [Swift.String:Swift.String]?
    /// <p>The Amazon Resource Names (ARN) of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [Swift.String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [Swift.String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolInputBody: Swift.Equatable {
    public let identityPoolName: Swift.String?
    public let allowUnauthenticatedIdentities: Swift.Bool
    public let allowClassicFlow: Swift.Bool?
    public let supportedLoginProviders: [Swift.String:Swift.String]?
    public let developerProviderName: Swift.String?
    public let openIdConnectProviderARNs: [Swift.String]?
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    public let samlProviderARNs: [Swift.String]?
    public let identityPoolTags: [Swift.String:Swift.String]?
}

extension CreateIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension CreateIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIdentityPoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityPoolOutputResponse(allowClassicFlow: \(Swift.String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(Swift.String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(Swift.String(describing: cognitoIdentityProviders)), developerProviderName: \(Swift.String(describing: developerProviderName)), identityPoolId: \(Swift.String(describing: identityPoolId)), identityPoolName: \(Swift.String(describing: identityPoolName)), identityPoolTags: \(Swift.String(describing: identityPoolTags)), openIdConnectProviderARNs: \(Swift.String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(Swift.String(describing: samlProviderARNs)), supportedLoginProviders: \(Swift.String(describing: supportedLoginProviders)))"}
}

extension CreateIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct CreateIdentityPoolOutputResponse: Swift.Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Swift.Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Swift.Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: Swift.String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [Swift.String:Swift.String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [Swift.String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [Swift.String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityPoolName: Swift.String?
    public let allowUnauthenticatedIdentities: Swift.Bool
    public let allowClassicFlow: Swift.Bool?
    public let supportedLoginProviders: [Swift.String:Swift.String]?
    public let developerProviderName: Swift.String?
    public let openIdConnectProviderARNs: [Swift.String]?
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    public let samlProviderARNs: [Swift.String]?
    public let identityPoolTags: [Swift.String:Swift.String]?
}

extension CreateIdentityPoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension CognitoIdentityClientTypes.Credentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretKey = "SecretKey"
        case sessionToken = "SessionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let expiration = expiration {
            try encodeContainer.encode(expiration.timeIntervalSince1970, forKey: .expiration)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension CognitoIdentityClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credentials(accessKeyId: \(Swift.String(describing: accessKeyId)), expiration: \(Swift.String(describing: expiration)), secretKey: \(Swift.String(describing: secretKey)), sessionToken: \(Swift.String(describing: sessionToken)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>Credentials for the provided identity ID.</p>
    public struct Credentials: Swift.Equatable {
        /// <p>The Access Key portion of the credentials.</p>
        public let accessKeyId: Swift.String?
        /// <p>The date at which these credentials will expire.</p>
        public let expiration: ClientRuntime.Date?
        /// <p>The Secret Access Key portion of the credentials</p>
        public let secretKey: Swift.String?
        /// <p>The Session Token portion of the credentials</p>
        public let sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretKey = secretKey
            self.sessionToken = sessionToken
        }
    }

}

public struct DeleteIdentitiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentitiesOutputError>
}

extension DeleteIdentitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIdentitiesInput(identityIdsToDelete: \(Swift.String(describing: identityIdsToDelete)))"}
}

extension DeleteIdentitiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityIdsToDelete = identityIdsToDelete {
            var identityIdsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityIdsToDelete)
            for identityidlist0 in identityIdsToDelete {
                try identityIdsToDeleteContainer.encode(identityidlist0)
            }
        }
    }
}

public struct DeleteIdentitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentitiesOutputError>
}

public struct DeleteIdentitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentitiesOutputError>
}

/// <p>Input to the <code>DeleteIdentities</code> action.</p>
public struct DeleteIdentitiesInput: Swift.Equatable {
    /// <p>A list of 1-60 identities that you want to delete.</p>
    public let identityIdsToDelete: [Swift.String]?

    public init (
        identityIdsToDelete: [Swift.String]? = nil
    )
    {
        self.identityIdsToDelete = identityIdsToDelete
    }
}

struct DeleteIdentitiesInputBody: Swift.Equatable {
    public let identityIdsToDelete: [Swift.String]?
}

extension DeleteIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdsToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityIdsToDelete)
        var identityIdsToDeleteDecoded0:[Swift.String]? = nil
        if let identityIdsToDeleteContainer = identityIdsToDeleteContainer {
            identityIdsToDeleteDecoded0 = [Swift.String]()
            for string0 in identityIdsToDeleteContainer {
                if let string0 = string0 {
                    identityIdsToDeleteDecoded0?.append(string0)
                }
            }
        }
        identityIdsToDelete = identityIdsToDeleteDecoded0
    }
}

extension DeleteIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIdentitiesOutputResponse(unprocessedIdentityIds: \(Swift.String(describing: unprocessedIdentityIds)))"}
}

extension DeleteIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedIdentityIds = output.unprocessedIdentityIds
        } else {
            self.unprocessedIdentityIds = nil
        }
    }
}

/// <p>Returned in response to a successful <code>DeleteIdentities</code>
///          operation.</p>
public struct DeleteIdentitiesOutputResponse: Swift.Equatable {
    /// <p>An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and
    ///          IdentityId.</p>
    public let unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]?

    public init (
        unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]? = nil
    )
    {
        self.unprocessedIdentityIds = unprocessedIdentityIds
    }
}

struct DeleteIdentitiesOutputResponseBody: Swift.Equatable {
    public let unprocessedIdentityIds: [CognitoIdentityClientTypes.UnprocessedIdentityId]?
}

extension DeleteIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedIdentityIds = "UnprocessedIdentityIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedIdentityIdsContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.UnprocessedIdentityId?].self, forKey: .unprocessedIdentityIds)
        var unprocessedIdentityIdsDecoded0:[CognitoIdentityClientTypes.UnprocessedIdentityId]? = nil
        if let unprocessedIdentityIdsContainer = unprocessedIdentityIdsContainer {
            unprocessedIdentityIdsDecoded0 = [CognitoIdentityClientTypes.UnprocessedIdentityId]()
            for structure0 in unprocessedIdentityIdsContainer {
                if let structure0 = structure0 {
                    unprocessedIdentityIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedIdentityIds = unprocessedIdentityIdsDecoded0
    }
}

public struct DeleteIdentityPoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentityPoolOutputError>
}

extension DeleteIdentityPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIdentityPoolInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension DeleteIdentityPoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct DeleteIdentityPoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentityPoolOutputError>
}

public struct DeleteIdentityPoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentityPoolOutputError>
}

/// <p>Input to the DeleteIdentityPool action.</p>
public struct DeleteIdentityPoolInput: Swift.Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DeleteIdentityPoolInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
}

extension DeleteIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DeleteIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityPoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIdentityPoolOutputResponse()"}
}

extension DeleteIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIdentityPoolOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteIdentityPoolOutputResponseBody: Swift.Equatable {
}

extension DeleteIdentityPoolOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityOutputError>
}

extension DescribeIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityInput(identityId: \(Swift.String(describing: identityId)))"}
}

extension DescribeIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }
}

public struct DescribeIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityOutputError>
}

public struct DescribeIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityOutputError>
}

/// <p>Input to the <code>DescribeIdentity</code> action.</p>
public struct DescribeIdentityInput: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?

    public init (
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct DescribeIdentityInputBody: Swift.Equatable {
    public let identityId: Swift.String?
}

extension DescribeIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension DescribeIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityOutputResponse(creationDate: \(Swift.String(describing: creationDate)), identityId: \(Swift.String(describing: identityId)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), logins: \(Swift.String(describing: logins)))"}
}

extension DescribeIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.identityId = output.identityId
            self.lastModifiedDate = output.lastModifiedDate
            self.logins = output.logins
        } else {
            self.creationDate = nil
            self.identityId = nil
            self.lastModifiedDate = nil
            self.logins = nil
        }
    }
}

/// <p>A description of the identity.</p>
public struct DescribeIdentityOutputResponse: Swift.Equatable {
    /// <p>Date on which the identity was created.</p>
    public let creationDate: ClientRuntime.Date?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>Date on which the identity was last modified.</p>
    public let lastModifiedDate: ClientRuntime.Date?
    /// <p>The provider names.</p>
    public let logins: [Swift.String]?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        identityId: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        logins: [Swift.String]? = nil
    )
    {
        self.creationDate = creationDate
        self.identityId = identityId
        self.lastModifiedDate = lastModifiedDate
        self.logins = logins
    }
}

struct DescribeIdentityOutputResponseBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let logins: [Swift.String]?
    public let creationDate: ClientRuntime.Date?
    public let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logins)
        var loginsDecoded0:[Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

public struct DescribeIdentityPoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityPoolOutputError>
}

extension DescribeIdentityPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityPoolInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension DescribeIdentityPoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct DescribeIdentityPoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityPoolOutputError>
}

public struct DescribeIdentityPoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityPoolOutputError>
}

/// <p>Input to the DescribeIdentityPool action.</p>
public struct DescribeIdentityPoolInput: Swift.Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityPoolInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
}

extension DescribeIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DescribeIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityPoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityPoolOutputResponse(allowClassicFlow: \(Swift.String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(Swift.String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(Swift.String(describing: cognitoIdentityProviders)), developerProviderName: \(Swift.String(describing: developerProviderName)), identityPoolId: \(Swift.String(describing: identityPoolId)), identityPoolName: \(Swift.String(describing: identityPoolName)), identityPoolTags: \(Swift.String(describing: identityPoolTags)), openIdConnectProviderARNs: \(Swift.String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(Swift.String(describing: samlProviderARNs)), supportedLoginProviders: \(Swift.String(describing: supportedLoginProviders)))"}
}

extension DescribeIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct DescribeIdentityPoolOutputResponse: Swift.Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Swift.Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Swift.Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: Swift.String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [Swift.String:Swift.String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [Swift.String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [Swift.String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct DescribeIdentityPoolOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityPoolName: Swift.String?
    public let allowUnauthenticatedIdentities: Swift.Bool
    public let allowClassicFlow: Swift.Bool?
    public let supportedLoginProviders: [Swift.String:Swift.String]?
    public let developerProviderName: Swift.String?
    public let openIdConnectProviderARNs: [Swift.String]?
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    public let samlProviderARNs: [Swift.String]?
    public let identityPoolTags: [Swift.String:Swift.String]?
}

extension DescribeIdentityPoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension DeveloperUserAlreadyRegisteredException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeveloperUserAlreadyRegisteredException(message: \(Swift.String(describing: message)))"}
}

extension DeveloperUserAlreadyRegisteredException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeveloperUserAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided developer user identifier is already registered with Cognito under a
///          different identity ID.</p>
public struct DeveloperUserAlreadyRegisteredException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>This developer user identifier is already registered with Cognito.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeveloperUserAlreadyRegisteredExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DeveloperUserAlreadyRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoIdentityClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalServerError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessDenied,
                .internalServerError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "AccessDenied"
            case .internalServerError: return "InternalServerError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ExternalServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExternalServiceException(message: \(Swift.String(describing: message)))"}
}

extension ExternalServiceException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception thrown when a dependent service such as Facebook or Twitter is not
///          responding</p>
public struct ExternalServiceException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned by an ExternalServiceException</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExternalServiceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetCredentialsForIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCredentialsForIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCredentialsForIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCredentialsForIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCredentialsForIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCredentialsForIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCredentialsForIdentityOutputError>
}

extension GetCredentialsForIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCredentialsForIdentityInput(customRoleArn: \(Swift.String(describing: customRoleArn)), identityId: \(Swift.String(describing: identityId)), logins: \(Swift.String(describing: logins)))"}
}

extension GetCredentialsForIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRoleArn = customRoleArn {
            try encodeContainer.encode(customRoleArn, forKey: .customRoleArn)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetCredentialsForIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCredentialsForIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCredentialsForIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCredentialsForIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCredentialsForIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCredentialsForIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCredentialsForIdentityOutputError>
}

public struct GetCredentialsForIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCredentialsForIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCredentialsForIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCredentialsForIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCredentialsForIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCredentialsForIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCredentialsForIdentityOutputError>
}

/// <p>Input to the <code>GetCredentialsForIdentity</code> action.</p>
public struct GetCredentialsForIdentityInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the role to be assumed when multiple roles were
    ///          received in the token from the identity provider. For example, a SAML-based identity
    ///          provider. This parameter is optional for identity providers that do not support role
    ///          customization.</p>
    public let customRoleArn: Swift.String?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. The
    ///          name-value pair will follow the syntax "provider_name":
    ///          "provider_user_identifier".</p>
    ///          <p>Logins should not be specified when trying to get credentials for an unauthenticated
    ///          identity.</p>
    ///          <p>The Logins parameter is required when using identities associated with external
    ///          identity providers such as Facebook. For examples of <code>Logins</code> maps, see the code
    ///          examples in the <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/external-identity-providers.html">External Identity Providers</a> section of the Amazon Cognito Developer
    ///          Guide.</p>
    public let logins: [Swift.String:Swift.String]?

    public init (
        customRoleArn: Swift.String? = nil,
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.customRoleArn = customRoleArn
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetCredentialsForIdentityInputBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let logins: [Swift.String:Swift.String]?
    public let customRoleArn: Swift.String?
}

extension GetCredentialsForIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let customRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customRoleArn)
        customRoleArn = customRoleArnDecoded
    }
}

extension GetCredentialsForIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCredentialsForIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityPoolConfigurationException" : self = .invalidIdentityPoolConfigurationException(try InvalidIdentityPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCredentialsForIdentityOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidIdentityPoolConfigurationException(InvalidIdentityPoolConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCredentialsForIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCredentialsForIdentityOutputResponse(credentials: \(Swift.String(describing: credentials)), identityId: \(Swift.String(describing: identityId)))"}
}

extension GetCredentialsForIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCredentialsForIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.identityId = output.identityId
        } else {
            self.credentials = nil
            self.identityId = nil
        }
    }
}

/// <p>Returned in response to a successful <code>GetCredentialsForIdentity</code>
///          operation.</p>
public struct GetCredentialsForIdentityOutputResponse: Swift.Equatable {
    /// <p>Credentials for the provided identity ID.</p>
    public let credentials: CognitoIdentityClientTypes.Credentials?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?

    public init (
        credentials: CognitoIdentityClientTypes.Credentials? = nil,
        identityId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.identityId = identityId
    }
}

struct GetCredentialsForIdentityOutputResponseBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let credentials: CognitoIdentityClientTypes.Credentials?
}

extension GetCredentialsForIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

public struct GetIdInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdOutputError>
}

extension GetIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdInput(accountId: \(Swift.String(describing: accountId)), identityPoolId: \(Swift.String(describing: identityPoolId)), logins: \(Swift.String(describing: logins)))"}
}

extension GetIdInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetIdInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdOutputError>
}

public struct GetIdInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdOutputError>
}

/// <p>Input to the GetId action.</p>
public struct GetIdInput: Swift.Equatable {
    /// <p>A standard AWS account ID (9+ digits).</p>
    public let accountId: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. The
    ///          available provider names for <code>Logins</code> are as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Facebook: <code>graph.facebook.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Cognito user pool:
    ///                   <code>cognito-idp.<region>.amazonaws.com/<YOUR_USER_POOL_ID></code>,
    ///                for example, <code>cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789</code>.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>Google: <code>accounts.google.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon: <code>www.amazon.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Twitter: <code>api.twitter.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Digits: <code>www.digits.com</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let logins: [Swift.String:Swift.String]?

    public init (
        accountId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.identityPoolId = identityPoolId
        self.logins = logins
    }
}

struct GetIdInputBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let identityPoolId: Swift.String?
    public let logins: [Swift.String:Swift.String]?
}

extension GetIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdOutputResponse(identityId: \(Swift.String(describing: identityId)))"}
}

extension GetIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIdOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// <p>Returned in response to a GetId request.</p>
public struct GetIdOutputResponse: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?

    public init (
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct GetIdOutputResponseBody: Swift.Equatable {
    public let identityId: Swift.String?
}

extension GetIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

public struct GetIdentityPoolRolesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityPoolRolesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdentityPoolRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityPoolRolesOutputError>
}

extension GetIdentityPoolRolesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentityPoolRolesInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension GetIdentityPoolRolesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct GetIdentityPoolRolesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityPoolRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdentityPoolRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityPoolRolesOutputError>
}

public struct GetIdentityPoolRolesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityPoolRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdentityPoolRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityPoolRolesOutputError>
}

/// <p>Input to the <code>GetIdentityPoolRoles</code> action.</p>
public struct GetIdentityPoolRolesInput: Swift.Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetIdentityPoolRolesInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
}

extension GetIdentityPoolRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension GetIdentityPoolRolesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityPoolRolesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityPoolRolesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityPoolRolesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentityPoolRolesOutputResponse(identityPoolId: \(Swift.String(describing: identityPoolId)), roleMappings: \(Swift.String(describing: roleMappings)), roles: \(Swift.String(describing: roles)))"}
}

extension GetIdentityPoolRolesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIdentityPoolRolesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.roleMappings = output.roleMappings
            self.roles = output.roles
        } else {
            self.identityPoolId = nil
            self.roleMappings = nil
            self.roles = nil
        }
    }
}

/// <p>Returned in response to a successful <code>GetIdentityPoolRoles</code>
///          operation.</p>
public struct GetIdentityPoolRolesOutputResponse: Swift.Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>How users for a specific identity provider are to mapped to roles. This is a
    ///             String-to-<a>RoleMapping</a> object map. The string identifies the identity
    ///          provider, for example, "graph.facebook.com" or
    ///          "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id".</p>
    public let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
    /// <p>The map of roles associated with this pool. Currently only authenticated and
    ///          unauthenticated roles are supported.</p>
    public let roles: [Swift.String:Swift.String]?

    public init (
        identityPoolId: Swift.String? = nil,
        roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil,
        roles: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct GetIdentityPoolRolesOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let roles: [Swift.String:Swift.String]?
    public let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
}

extension GetIdentityPoolRolesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .roles)
        var rolesDecoded0: [Swift.String:Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String:Swift.String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([Swift.String: CognitoIdentityClientTypes.RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [Swift.String:CognitoIdentityClientTypes.RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

public struct GetOpenIdTokenForDeveloperIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpenIdTokenForDeveloperIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpenIdTokenForDeveloperIdentityOutputError>
}

extension GetOpenIdTokenForDeveloperIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpenIdTokenForDeveloperIdentityInput(identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)), logins: \(Swift.String(describing: logins)), principalTags: \(Swift.String(describing: principalTags)), tokenDuration: \(Swift.String(describing: tokenDuration)))"}
}

extension GetOpenIdTokenForDeveloperIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principalTags)
            for (dictKey0, principaltags0) in principalTags {
                try principalTagsContainer.encode(principaltags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tokenDuration = tokenDuration {
            try encodeContainer.encode(tokenDuration, forKey: .tokenDuration)
        }
    }
}

public struct GetOpenIdTokenForDeveloperIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpenIdTokenForDeveloperIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpenIdTokenForDeveloperIdentityOutputError>
}

public struct GetOpenIdTokenForDeveloperIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpenIdTokenForDeveloperIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpenIdTokenForDeveloperIdentityOutputError>
}

/// <p>Input to the <code>GetOpenIdTokenForDeveloperIdentity</code> action.</p>
public struct GetOpenIdTokenForDeveloperIdentityInput: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. Each
    ///          name-value pair represents a user from a public provider or developer provider. If the user
    ///          is from a developer provider, the name-value pair will follow the syntax
    ///             <code>"developer_provider_name": "developer_user_identifier"</code>. The developer
    ///          provider is the "domain" by which Cognito will refer to your users; you provided this
    ///          domain while creating/updating the identity pool. The developer user identifier is an
    ///          identifier from your backend that uniquely identifies a user. When you create an identity
    ///          pool, you can specify the supported logins.</p>
    public let logins: [Swift.String:Swift.String]?
    /// <p>Use this operation to configure attribute mappings for custom providers. </p>
    public let principalTags: [Swift.String:Swift.String]?
    /// <p>The expiration time of the token, in seconds. You can specify a custom expiration
    ///          time for the token so that you can cache it. If you don't provide an expiration time, the
    ///          token is valid for 15 minutes. You can exchange the token with Amazon STS for temporary AWS
    ///          credentials, which are valid for a maximum of one hour. The maximum token duration you can
    ///          set is 24 hours. You should take care in setting the expiration time for a token, as there
    ///          are significant security implications: an attacker could use a leaked token to access your
    ///          AWS resources for the token's duration.</p>
    ///          <note>
    ///             <p>Please provide for a small grace period, usually no more than 5 minutes, to account for clock skew.</p>
    ///          </note>
    public let tokenDuration: Swift.Int?

    public init (
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        tokenDuration: Swift.Int? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.logins = logins
        self.principalTags = principalTags
        self.tokenDuration = tokenDuration
    }
}

struct GetOpenIdTokenForDeveloperIdentityInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityId: Swift.String?
    public let logins: [Swift.String:Swift.String]?
    public let principalTags: [Swift.String:Swift.String]?
    public let tokenDuration: Swift.Int?
}

extension GetOpenIdTokenForDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
        let tokenDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tokenDuration)
        tokenDuration = tokenDurationDecoded
    }
}

extension GetOpenIdTokenForDeveloperIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpenIdTokenForDeveloperIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeveloperUserAlreadyRegisteredException" : self = .developerUserAlreadyRegisteredException(try DeveloperUserAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpenIdTokenForDeveloperIdentityOutputError: Swift.Error, Swift.Equatable {
    case developerUserAlreadyRegisteredException(DeveloperUserAlreadyRegisteredException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpenIdTokenForDeveloperIdentityOutputResponse(identityId: \(Swift.String(describing: identityId)), token: \(Swift.String(describing: token)))"}
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpenIdTokenForDeveloperIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// <p>Returned in response to a successful <code>GetOpenIdTokenForDeveloperIdentity</code>
///          request.</p>
public struct GetOpenIdTokenForDeveloperIdentityOutputResponse: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>An OpenID token.</p>
    public let token: Swift.String?

    public init (
        identityId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenForDeveloperIdentityOutputResponseBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let token: Swift.String?
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

public struct GetOpenIdTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpenIdTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpenIdTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpenIdTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpenIdTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpenIdTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpenIdTokenOutputError>
}

extension GetOpenIdTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpenIdTokenInput(identityId: \(Swift.String(describing: identityId)), logins: \(Swift.String(describing: logins)))"}
}

extension GetOpenIdTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetOpenIdTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpenIdTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpenIdTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpenIdTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpenIdTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpenIdTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpenIdTokenOutputError>
}

public struct GetOpenIdTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOpenIdTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOpenIdTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOpenIdTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOpenIdTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOpenIdTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOpenIdTokenOutputError>
}

/// <p>Input to the GetOpenIdToken action.</p>
public struct GetOpenIdTokenInput: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. When
    ///          using graph.facebook.com and www.amazon.com, supply the access_token returned from the
    ///          provider's authflow. For accounts.google.com, an Amazon Cognito user pool provider, or any
    ///          other OpenID Connect provider, always include the <code>id_token</code>.</p>
    public let logins: [Swift.String:Swift.String]?

    public init (
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetOpenIdTokenInputBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let logins: [Swift.String:Swift.String]?
}

extension GetOpenIdTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetOpenIdTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpenIdTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpenIdTokenOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIdTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOpenIdTokenOutputResponse(identityId: \(Swift.String(describing: identityId)), token: \(Swift.String(describing: token)))"}
}

extension GetOpenIdTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpenIdTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// <p>Returned in response to a successful GetOpenIdToken request.</p>
public struct GetOpenIdTokenOutputResponse: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID. Note that the IdentityId returned may
    ///          not match the one passed on input.</p>
    public let identityId: Swift.String?
    /// <p>An OpenID token, valid for 10 minutes.</p>
    public let token: Swift.String?

    public init (
        identityId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenOutputResponseBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let token: Swift.String?
}

extension GetOpenIdTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

public struct GetPrincipalTagAttributeMapInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPrincipalTagAttributeMapInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPrincipalTagAttributeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPrincipalTagAttributeMapOutputError>
}

extension GetPrincipalTagAttributeMapInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPrincipalTagAttributeMapInput(identityPoolId: \(Swift.String(describing: identityPoolId)), identityProviderName: \(Swift.String(describing: identityProviderName)))"}
}

extension GetPrincipalTagAttributeMapInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
    }
}

public struct GetPrincipalTagAttributeMapInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPrincipalTagAttributeMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPrincipalTagAttributeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPrincipalTagAttributeMapOutputError>
}

public struct GetPrincipalTagAttributeMapInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPrincipalTagAttributeMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPrincipalTagAttributeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPrincipalTagAttributeMapOutputError>
}

public struct GetPrincipalTagAttributeMapInput: Swift.Equatable {
    /// <p>You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.</p>
    public let identityPoolId: Swift.String?
    /// <p>You can use this operation to get the provider name.</p>
    public let identityProviderName: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
    }
}

struct GetPrincipalTagAttributeMapInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityProviderName: Swift.String?
}

extension GetPrincipalTagAttributeMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
    }
}

extension GetPrincipalTagAttributeMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPrincipalTagAttributeMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPrincipalTagAttributeMapOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPrincipalTagAttributeMapOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPrincipalTagAttributeMapOutputResponse(identityPoolId: \(Swift.String(describing: identityPoolId)), identityProviderName: \(Swift.String(describing: identityProviderName)), principalTags: \(Swift.String(describing: principalTags)), useDefaults: \(Swift.String(describing: useDefaults)))"}
}

extension GetPrincipalTagAttributeMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPrincipalTagAttributeMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct GetPrincipalTagAttributeMapOutputResponse: Swift.Equatable {
    /// <p>You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.</p>
    public let identityPoolId: Swift.String?
    /// <p>You can use this operation to get the provider name.</p>
    public let identityProviderName: Swift.String?
    /// <p>You can use this operation to add principal tags. The <code>PrincipalTags</code>operation enables you to reference user attributes in your IAM permissions policy.</p>
    public let principalTags: [Swift.String:Swift.String]?
    /// <p>You can use this operation to list </p>
    public let useDefaults: Swift.Bool?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct GetPrincipalTagAttributeMapOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityProviderName: Swift.String?
    public let useDefaults: Swift.Bool?
    public let principalTags: [Swift.String:Swift.String]?
}

extension GetPrincipalTagAttributeMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension CognitoIdentityClientTypes.IdentityDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logins)
            for loginslist0 in logins {
                try loginsContainer.encode(loginslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logins)
        var loginsDecoded0:[Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension CognitoIdentityClientTypes.IdentityDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityDescription(creationDate: \(Swift.String(describing: creationDate)), identityId: \(Swift.String(describing: identityId)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), logins: \(Swift.String(describing: logins)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>A description of the identity.</p>
    public struct IdentityDescription: Swift.Equatable {
        /// <p>Date on which the identity was created.</p>
        public let creationDate: ClientRuntime.Date?
        /// <p>A unique identifier in the format REGION:GUID.</p>
        public let identityId: Swift.String?
        /// <p>Date on which the identity was last modified.</p>
        public let lastModifiedDate: ClientRuntime.Date?
        /// <p>The provider names.</p>
        public let logins: [Swift.String]?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            identityId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            logins: [Swift.String]? = nil
        )
        {
            self.creationDate = creationDate
            self.identityId = identityId
            self.lastModifiedDate = lastModifiedDate
            self.logins = logins
        }
    }

}

extension CognitoIdentityClientTypes.IdentityPoolShortDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
    }
}

extension CognitoIdentityClientTypes.IdentityPoolShortDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityPoolShortDescription(identityPoolId: \(Swift.String(describing: identityPoolId)), identityPoolName: \(Swift.String(describing: identityPoolName)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>A description of the identity pool.</p>
    public struct IdentityPoolShortDescription: Swift.Equatable {
        /// <p>An identity pool ID in the format REGION:GUID.</p>
        public let identityPoolId: Swift.String?
        /// <p>A string that you provide.</p>
        public let identityPoolName: Swift.String?

        public init (
            identityPoolId: Swift.String? = nil,
            identityPoolName: Swift.String? = nil
        )
        {
            self.identityPoolId = identityPoolId
            self.identityPoolName = identityPoolName
        }
    }

}

extension InternalErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when the service encounters an error during processing the request.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>The message returned by an InternalErrorException.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIdentityPoolConfigurationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidIdentityPoolConfigurationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidIdentityPoolConfigurationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidIdentityPoolConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown if the identity pool has no role associated for the given auth type
///          (auth/unauth) or if the AssumeRole fails.</p>
public struct InvalidIdentityPoolConfigurationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned for an <code>InvalidIdentityPoolConfigurationException</code>
    ///          </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIdentityPoolConfigurationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidIdentityPoolConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown for missing or bad input parameter(s).</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned by an InvalidParameterException.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when the total number of user pools has exceeded a preset limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned by a LimitExceededException.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListIdentitiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentitiesOutputError>
}

extension ListIdentitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentitiesInput(hideDisabled: \(Swift.String(describing: hideDisabled)), identityPoolId: \(Swift.String(describing: identityPoolId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIdentitiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hideDisabled != false {
            try encodeContainer.encode(hideDisabled, forKey: .hideDisabled)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIdentitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentitiesOutputError>
}

public struct ListIdentitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentitiesOutputError>
}

/// <p>Input to the ListIdentities action.</p>
public struct ListIdentitiesInput: Swift.Equatable {
    /// <p>An optional boolean parameter that allows you to hide disabled identities. If
    ///          omitted, the ListIdentities API will include disabled identities in the response.</p>
    public let hideDisabled: Swift.Bool
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>The maximum number of identities to return.</p>
    public let maxResults: Swift.Int
    /// <p>A pagination token.</p>
    public let nextToken: Swift.String?

    public init (
        hideDisabled: Swift.Bool = false,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.hideDisabled = hideDisabled
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentitiesInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let hideDisabled: Swift.Bool
}

extension ListIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let hideDisabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hideDisabled)
        hideDisabled = hideDisabledDecoded
    }
}

extension ListIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentitiesOutputResponse(identities: \(Swift.String(describing: identities)), identityPoolId: \(Swift.String(describing: identityPoolId)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identities = output.identities
            self.identityPoolId = output.identityPoolId
            self.nextToken = output.nextToken
        } else {
            self.identities = nil
            self.identityPoolId = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response to a ListIdentities request.</p>
public struct ListIdentitiesOutputResponse: Swift.Equatable {
    /// <p>An object containing a set of identities and associated mappings.</p>
    public let identities: [CognitoIdentityClientTypes.IdentityDescription]?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>A pagination token.</p>
    public let nextToken: Swift.String?

    public init (
        identities: [CognitoIdentityClientTypes.IdentityDescription]? = nil,
        identityPoolId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identities = identities
        self.identityPoolId = identityPoolId
        self.nextToken = nextToken
    }
}

struct ListIdentitiesOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identities: [CognitoIdentityClientTypes.IdentityDescription]?
    public let nextToken: Swift.String?
}

extension ListIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identities = "Identities"
        case identityPoolId = "IdentityPoolId"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.IdentityDescription?].self, forKey: .identities)
        var identitiesDecoded0:[CognitoIdentityClientTypes.IdentityDescription]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [CognitoIdentityClientTypes.IdentityDescription]()
            for structure0 in identitiesContainer {
                if let structure0 = structure0 {
                    identitiesDecoded0?.append(structure0)
                }
            }
        }
        identities = identitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIdentityPoolsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityPoolsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentityPoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentityPoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityPoolsOutputError>
}

extension ListIdentityPoolsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentityPoolsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIdentityPoolsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIdentityPoolsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityPoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentityPoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentityPoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityPoolsOutputError>
}

public struct ListIdentityPoolsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityPoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentityPoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentityPoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityPoolsOutputError>
}

/// <p>Input to the ListIdentityPools action.</p>
public struct ListIdentityPoolsInput: Swift.Equatable {
    /// <p>The maximum number of identities to return.</p>
    public let maxResults: Swift.Int
    /// <p>A pagination token.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListIdentityPoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityPoolsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityPoolsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityPoolsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityPoolsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentityPoolsOutputResponse(identityPools: \(Swift.String(describing: identityPools)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIdentityPoolsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIdentityPoolsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPools = output.identityPools
            self.nextToken = output.nextToken
        } else {
            self.identityPools = nil
            self.nextToken = nil
        }
    }
}

/// <p>The result of a successful ListIdentityPools action.</p>
public struct ListIdentityPoolsOutputResponse: Swift.Equatable {
    /// <p>The identity pools returned by the ListIdentityPools action.</p>
    public let identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]?
    /// <p>A pagination token.</p>
    public let nextToken: Swift.String?

    public init (
        identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityPools = identityPools
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsOutputResponseBody: Swift.Equatable {
    public let identityPools: [CognitoIdentityClientTypes.IdentityPoolShortDescription]?
    public let nextToken: Swift.String?
}

extension ListIdentityPoolsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPools = "IdentityPools"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolsContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.IdentityPoolShortDescription?].self, forKey: .identityPools)
        var identityPoolsDecoded0:[CognitoIdentityClientTypes.IdentityPoolShortDescription]? = nil
        if let identityPoolsContainer = identityPoolsContainer {
            identityPoolsDecoded0 = [CognitoIdentityClientTypes.IdentityPoolShortDescription]()
            for structure0 in identityPoolsContainer {
                if let structure0 = structure0 {
                    identityPoolsDecoded0?.append(structure0)
                }
            }
        }
        identityPools = identityPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the identity pool that the tags are assigned
    ///          to.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The tags that are assigned to the identity pool.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct LookupDeveloperIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupDeveloperIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LookupDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LookupDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LookupDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupDeveloperIdentityOutputError>
}

extension LookupDeveloperIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LookupDeveloperIdentityInput(developerUserIdentifier: \(Swift.String(describing: developerUserIdentifier)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension LookupDeveloperIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerUserIdentifier = developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct LookupDeveloperIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupDeveloperIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LookupDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LookupDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LookupDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupDeveloperIdentityOutputError>
}

public struct LookupDeveloperIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupDeveloperIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LookupDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LookupDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LookupDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupDeveloperIdentityOutputError>
}

/// <p>Input to the <code>LookupDeveloperIdentityInput</code> action.</p>
public struct LookupDeveloperIdentityInput: Swift.Equatable {
    /// <p>A unique ID used by your backend authentication process to identify a user.
    ///          Typically, a developer identity provider would issue many developer user identifiers, in
    ///          keeping with the number of users.</p>
    public let developerUserIdentifier: Swift.String?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>The maximum number of identities to return.</p>
    public let maxResults: Swift.Int
    /// <p>A pagination token. The first call you make will have <code>NextToken</code> set to
    ///          null. After that the service will return <code>NextToken</code> values as needed. For
    ///          example, let's say you make a request with <code>MaxResults</code> set to 10, and there are
    ///          20 matches in the database. The service will return a pagination token as a part of the
    ///          response. This token can be used to call the API again and get results starting from the
    ///          11th match.</p>
    public let nextToken: Swift.String?

    public init (
        developerUserIdentifier: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityId: Swift.String?
    public let developerUserIdentifier: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension LookupDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupDeveloperIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupDeveloperIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LookupDeveloperIdentityOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupDeveloperIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LookupDeveloperIdentityOutputResponse(developerUserIdentifierList: \(Swift.String(describing: developerUserIdentifierList)), identityId: \(Swift.String(describing: identityId)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension LookupDeveloperIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LookupDeveloperIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.developerUserIdentifierList = output.developerUserIdentifierList
            self.identityId = output.identityId
            self.nextToken = output.nextToken
        } else {
            self.developerUserIdentifierList = nil
            self.identityId = nil
            self.nextToken = nil
        }
    }
}

/// <p>Returned in response to a successful <code>LookupDeveloperIdentity</code>
///          action.</p>
public struct LookupDeveloperIdentityOutputResponse: Swift.Equatable {
    /// <p>This is the list of developer user identifiers associated with an identity ID.
    ///          Cognito supports the association of multiple developer user identifiers with an identity
    ///          ID.</p>
    public let developerUserIdentifierList: [Swift.String]?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>A pagination token. The first call you make will have <code>NextToken</code> set to
    ///          null. After that the service will return <code>NextToken</code> values as needed. For
    ///          example, let's say you make a request with <code>MaxResults</code> set to 10, and there are
    ///          20 matches in the database. The service will return a pagination token as a part of the
    ///          response. This token can be used to call the API again and get results starting from the
    ///          11th match.</p>
    public let nextToken: Swift.String?

    public init (
        developerUserIdentifierList: [Swift.String]? = nil,
        identityId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.developerUserIdentifierList = developerUserIdentifierList
        self.identityId = identityId
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityOutputResponseBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let developerUserIdentifierList: [Swift.String]?
    public let nextToken: Swift.String?
}

extension LookupDeveloperIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerUserIdentifierList = "DeveloperUserIdentifierList"
        case identityId = "IdentityId"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .developerUserIdentifierList)
        var developerUserIdentifierListDecoded0:[Swift.String]? = nil
        if let developerUserIdentifierListContainer = developerUserIdentifierListContainer {
            developerUserIdentifierListDecoded0 = [Swift.String]()
            for string0 in developerUserIdentifierListContainer {
                if let string0 = string0 {
                    developerUserIdentifierListDecoded0?.append(string0)
                }
            }
        }
        developerUserIdentifierList = developerUserIdentifierListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CognitoIdentityClientTypes.MappingRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claim = "Claim"
        case matchType = "MatchType"
        case roleARN = "RoleARN"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claim = claim {
            try encodeContainer.encode(claim, forKey: .claim)
        }
        if let matchType = matchType {
            try encodeContainer.encode(matchType.rawValue, forKey: .matchType)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let claimDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .claim)
        claim = claimDecoded
        let matchTypeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.MappingRuleMatchType.self, forKey: .matchType)
        matchType = matchTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension CognitoIdentityClientTypes.MappingRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MappingRule(claim: \(Swift.String(describing: claim)), matchType: \(Swift.String(describing: matchType)), roleARN: \(Swift.String(describing: roleARN)), value: \(Swift.String(describing: value)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>A rule that maps a claim name, a claim value, and a match type to a role
    ///          ARN.</p>
    public struct MappingRule: Swift.Equatable {
        /// <p>The claim name that must be present in the token, for example, "isAdmin" or
        ///          "paid".</p>
        public let claim: Swift.String?
        /// <p>The match condition that specifies how closely the claim value in the IdP token must
        ///          match <code>Value</code>.</p>
        public let matchType: CognitoIdentityClientTypes.MappingRuleMatchType?
        /// <p>The role ARN.</p>
        public let roleARN: Swift.String?
        /// <p>A brief string that the claim must match, for example, "paid" or "yes".</p>
        public let value: Swift.String?

        public init (
            claim: Swift.String? = nil,
            matchType: CognitoIdentityClientTypes.MappingRuleMatchType? = nil,
            roleARN: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.claim = claim
            self.matchType = matchType
            self.roleARN = roleARN
            self.value = value
        }
    }

}

extension CognitoIdentityClientTypes {
    public enum MappingRuleMatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case notEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MappingRuleMatchType] {
            return [
                .contains,
                .equals,
                .notEqual,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equals: return "Equals"
            case .notEqual: return "NotEqual"
            case .startsWith: return "StartsWith"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MappingRuleMatchType(rawValue: rawValue) ?? MappingRuleMatchType.sdkUnknown(rawValue)
        }
    }
}

public struct MergeDeveloperIdentitiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MergeDeveloperIdentitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MergeDeveloperIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MergeDeveloperIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MergeDeveloperIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MergeDeveloperIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MergeDeveloperIdentitiesOutputError>
}

extension MergeDeveloperIdentitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MergeDeveloperIdentitiesInput(destinationUserIdentifier: \(Swift.String(describing: destinationUserIdentifier)), developerProviderName: \(Swift.String(describing: developerProviderName)), identityPoolId: \(Swift.String(describing: identityPoolId)), sourceUserIdentifier: \(Swift.String(describing: sourceUserIdentifier)))"}
}

extension MergeDeveloperIdentitiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationUserIdentifier = destinationUserIdentifier {
            try encodeContainer.encode(destinationUserIdentifier, forKey: .destinationUserIdentifier)
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let sourceUserIdentifier = sourceUserIdentifier {
            try encodeContainer.encode(sourceUserIdentifier, forKey: .sourceUserIdentifier)
        }
    }
}

public struct MergeDeveloperIdentitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MergeDeveloperIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MergeDeveloperIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MergeDeveloperIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MergeDeveloperIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MergeDeveloperIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MergeDeveloperIdentitiesOutputError>
}

public struct MergeDeveloperIdentitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MergeDeveloperIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MergeDeveloperIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MergeDeveloperIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MergeDeveloperIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MergeDeveloperIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MergeDeveloperIdentitiesOutputError>
}

/// <p>Input to the <code>MergeDeveloperIdentities</code> action.</p>
public struct MergeDeveloperIdentitiesInput: Swift.Equatable {
    /// <p>User identifier for the destination user. The value should be a
    ///             <code>DeveloperUserIdentifier</code>.</p>
    public let destinationUserIdentifier: Swift.String?
    /// <p>The "domain" by which Cognito will refer to your users. This is a (pseudo) domain
    ///          name that you provide while creating an identity pool. This name acts as a placeholder that
    ///          allows your backend and the Cognito service to communicate about the developer provider.
    ///          For the <code>DeveloperProviderName</code>, you can use letters as well as period (.),
    ///          underscore (_), and dash (-).</p>
    public let developerProviderName: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>User identifier for the source user. The value should be a
    ///             <code>DeveloperUserIdentifier</code>.</p>
    public let sourceUserIdentifier: Swift.String?

    public init (
        destinationUserIdentifier: Swift.String? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        sourceUserIdentifier: Swift.String? = nil
    )
    {
        self.destinationUserIdentifier = destinationUserIdentifier
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.sourceUserIdentifier = sourceUserIdentifier
    }
}

struct MergeDeveloperIdentitiesInputBody: Swift.Equatable {
    public let sourceUserIdentifier: Swift.String?
    public let destinationUserIdentifier: Swift.String?
    public let developerProviderName: Swift.String?
    public let identityPoolId: Swift.String?
}

extension MergeDeveloperIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUserIdentifier)
        sourceUserIdentifier = sourceUserIdentifierDecoded
        let destinationUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationUserIdentifier)
        destinationUserIdentifier = destinationUserIdentifierDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension MergeDeveloperIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeDeveloperIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeDeveloperIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeDeveloperIdentitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MergeDeveloperIdentitiesOutputResponse(identityId: \(Swift.String(describing: identityId)))"}
}

extension MergeDeveloperIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MergeDeveloperIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// <p>Returned in response to a successful <code>MergeDeveloperIdentities</code>
///          action.</p>
public struct MergeDeveloperIdentitiesOutputResponse: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?

    public init (
        identityId: Swift.String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct MergeDeveloperIdentitiesOutputResponseBody: Swift.Equatable {
    public let identityId: Swift.String?
}

extension MergeDeveloperIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension NotAuthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotAuthorizedException(message: \(Swift.String(describing: message)))"}
}

extension NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when a user is not authorized to access the requested resource.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned by a NotAuthorizedException</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceConflictException(message: \(Swift.String(describing: message)))"}
}

extension ResourceConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when a user tries to use a login which is already linked to another
///          account.</p>
public struct ResourceConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned by a ResourceConflictException.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when the requested resource (for example, a dataset or record) does not
///          exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message returned by a ResourceNotFoundException.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoIdentityClientTypes.RoleMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ambiguousRoleResolution = "AmbiguousRoleResolution"
        case rulesConfiguration = "RulesConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ambiguousRoleResolution = ambiguousRoleResolution {
            try encodeContainer.encode(ambiguousRoleResolution.rawValue, forKey: .ambiguousRoleResolution)
        }
        if let rulesConfiguration = rulesConfiguration {
            try encodeContainer.encode(rulesConfiguration, forKey: .rulesConfiguration)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.RoleMappingType.self, forKey: .type)
        type = typeDecoded
        let ambiguousRoleResolutionDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.AmbiguousRoleResolutionType.self, forKey: .ambiguousRoleResolution)
        ambiguousRoleResolution = ambiguousRoleResolutionDecoded
        let rulesConfigurationDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.RulesConfigurationType.self, forKey: .rulesConfiguration)
        rulesConfiguration = rulesConfigurationDecoded
    }
}

extension CognitoIdentityClientTypes.RoleMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoleMapping(ambiguousRoleResolution: \(Swift.String(describing: ambiguousRoleResolution)), rulesConfiguration: \(Swift.String(describing: rulesConfiguration)), type: \(Swift.String(describing: type)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>A role mapping.</p>
    public struct RoleMapping: Swift.Equatable {
        /// <p>If you specify Token or Rules as the <code>Type</code>,
        ///             <code>AmbiguousRoleResolution</code> is required.</p>
        ///          <p>Specifies the action to be taken if either no rules match the claim value for the
        ///             <code>Rules</code> type, or there is no <code>cognito:preferred_role</code> claim and
        ///          there are multiple <code>cognito:roles</code> matches for the <code>Token</code>
        ///          type.</p>
        public let ambiguousRoleResolution: CognitoIdentityClientTypes.AmbiguousRoleResolutionType?
        /// <p>The rules to be used for mapping users to roles.</p>
        ///          <p>If you specify Rules as the role mapping type, <code>RulesConfiguration</code> is
        ///          required.</p>
        public let rulesConfiguration: CognitoIdentityClientTypes.RulesConfigurationType?
        /// <p>The role mapping type. Token will use <code>cognito:roles</code> and
        ///             <code>cognito:preferred_role</code> claims from the Cognito identity provider token to
        ///          map groups to roles. Rules will attempt to match claims from the token to map to a
        ///          role.</p>
        public let type: CognitoIdentityClientTypes.RoleMappingType?

        public init (
            ambiguousRoleResolution: CognitoIdentityClientTypes.AmbiguousRoleResolutionType? = nil,
            rulesConfiguration: CognitoIdentityClientTypes.RulesConfigurationType? = nil,
            type: CognitoIdentityClientTypes.RoleMappingType? = nil
        )
        {
            self.ambiguousRoleResolution = ambiguousRoleResolution
            self.rulesConfiguration = rulesConfiguration
            self.type = type
        }
    }

}

extension CognitoIdentityClientTypes {
    public enum RoleMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rules
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleMappingType] {
            return [
                .rules,
                .token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rules: return "Rules"
            case .token: return "Token"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoleMappingType(rawValue: rawValue) ?? RoleMappingType.sdkUnknown(rawValue)
        }
    }
}

extension CognitoIdentityClientTypes.RulesConfigurationType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for mappingruleslist0 in rules {
                try rulesContainer.encode(mappingruleslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.MappingRule?].self, forKey: .rules)
        var rulesDecoded0:[CognitoIdentityClientTypes.MappingRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CognitoIdentityClientTypes.MappingRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CognitoIdentityClientTypes.RulesConfigurationType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RulesConfigurationType(rules: \(Swift.String(describing: rules)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>A container for rules.</p>
    public struct RulesConfigurationType: Swift.Equatable {
        /// <p>An array of rules. You can specify up to 25 rules per identity provider.</p>
        ///          <p>Rules are evaluated in order. The first one to match specifies the role.</p>
        public let rules: [CognitoIdentityClientTypes.MappingRule]?

        public init (
            rules: [CognitoIdentityClientTypes.MappingRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

public struct SetIdentityPoolRolesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolRolesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIdentityPoolRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolRolesOutputError>
}

extension SetIdentityPoolRolesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetIdentityPoolRolesInput(identityPoolId: \(Swift.String(describing: identityPoolId)), roleMappings: \(Swift.String(describing: roleMappings)), roles: \(Swift.String(describing: roles)))"}
}

extension SetIdentityPoolRolesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let roleMappings = roleMappings {
            var roleMappingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .roleMappings)
            for (dictKey0, rolemappingmap0) in roleMappings {
                try roleMappingsContainer.encode(rolemappingmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .roles)
            for (dictKey0, rolesmap0) in roles {
                try rolesContainer.encode(rolesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct SetIdentityPoolRolesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIdentityPoolRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolRolesOutputError>
}

public struct SetIdentityPoolRolesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIdentityPoolRolesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolRolesOutputError>
}

/// <p>Input to the <code>SetIdentityPoolRoles</code> action.</p>
public struct SetIdentityPoolRolesInput: Swift.Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>How users for a specific identity provider are to mapped to roles. This is a string
    ///          to <a>RoleMapping</a> object map. The string identifies the identity provider,
    ///          for example, "graph.facebook.com" or
    ///          "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id".</p>
    ///          <p>Up to 25 rules can be specified per identity provider.</p>
    public let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
    /// <p>The map of roles associated with this pool. For a given role, the key will be either
    ///          "authenticated" or "unauthenticated" and the value will be the Role ARN.</p>
    public let roles: [Swift.String:Swift.String]?

    public init (
        identityPoolId: Swift.String? = nil,
        roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil,
        roles: [Swift.String:Swift.String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct SetIdentityPoolRolesInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let roles: [Swift.String:Swift.String]?
    public let roleMappings: [Swift.String:CognitoIdentityClientTypes.RoleMapping]?
}

extension SetIdentityPoolRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .roles)
        var rolesDecoded0: [Swift.String:Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String:Swift.String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([Swift.String: CognitoIdentityClientTypes.RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [Swift.String:CognitoIdentityClientTypes.RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [Swift.String:CognitoIdentityClientTypes.RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

extension SetIdentityPoolRolesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetIdentityPoolRolesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityPoolRolesOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityPoolRolesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetIdentityPoolRolesOutputResponse()"}
}

extension SetIdentityPoolRolesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetIdentityPoolRolesOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetIdentityPoolRolesOutputResponseBody: Swift.Equatable {
}

extension SetIdentityPoolRolesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetPrincipalTagAttributeMapInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPrincipalTagAttributeMapInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPrincipalTagAttributeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPrincipalTagAttributeMapOutputError>
}

extension SetPrincipalTagAttributeMapInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetPrincipalTagAttributeMapInput(identityPoolId: \(Swift.String(describing: identityPoolId)), identityProviderName: \(Swift.String(describing: identityProviderName)), principalTags: \(Swift.String(describing: principalTags)), useDefaults: \(Swift.String(describing: useDefaults)))"}
}

extension SetPrincipalTagAttributeMapInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principalTags)
            for (dictKey0, principaltags0) in principalTags {
                try principalTagsContainer.encode(principaltags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDefaults = useDefaults {
            try encodeContainer.encode(useDefaults, forKey: .useDefaults)
        }
    }
}

public struct SetPrincipalTagAttributeMapInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPrincipalTagAttributeMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPrincipalTagAttributeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPrincipalTagAttributeMapOutputError>
}

public struct SetPrincipalTagAttributeMapInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPrincipalTagAttributeMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPrincipalTagAttributeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPrincipalTagAttributeMapOutputError>
}

public struct SetPrincipalTagAttributeMapInput: Swift.Equatable {
    /// <p>The ID of the Identity Pool you want to set attribute mappings for.</p>
    public let identityPoolId: Swift.String?
    /// <p>The provider name you want to use for attribute mappings.</p>
    public let identityProviderName: Swift.String?
    /// <p>You can use this operation to add principal tags.</p>
    public let principalTags: [Swift.String:Swift.String]?
    /// <p>You can use this operation to use default (username and clientID) attribute mappings.</p>
    public let useDefaults: Swift.Bool?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityProviderName: Swift.String?
    public let useDefaults: Swift.Bool?
    public let principalTags: [Swift.String:Swift.String]?
}

extension SetPrincipalTagAttributeMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension SetPrincipalTagAttributeMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetPrincipalTagAttributeMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPrincipalTagAttributeMapOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPrincipalTagAttributeMapOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetPrincipalTagAttributeMapOutputResponse(identityPoolId: \(Swift.String(describing: identityPoolId)), identityProviderName: \(Swift.String(describing: identityProviderName)), principalTags: \(Swift.String(describing: principalTags)), useDefaults: \(Swift.String(describing: useDefaults)))"}
}

extension SetPrincipalTagAttributeMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetPrincipalTagAttributeMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct SetPrincipalTagAttributeMapOutputResponse: Swift.Equatable {
    /// <p>The ID of the Identity Pool you want to set attribute mappings for.</p>
    public let identityPoolId: Swift.String?
    /// <p>The provider name you want to use for attribute mappings.</p>
    public let identityProviderName: Swift.String?
    /// <p>You can use this operation to add principal tags. The <code>PrincipalTags</code>operation enables you to reference user attributes in your IAM permissions policy.</p>
    public let principalTags: [Swift.String:Swift.String]?
    /// <p>You can use this operation to select default (username and clientID) attribute mappings.</p>
    public let useDefaults: Swift.Bool?

    public init (
        identityPoolId: Swift.String? = nil,
        identityProviderName: Swift.String? = nil,
        principalTags: [Swift.String:Swift.String]? = nil,
        useDefaults: Swift.Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityProviderName: Swift.String?
    public let useDefaults: Swift.Bool?
    public let principalTags: [Swift.String:Swift.String]?
}

extension SetPrincipalTagAttributeMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, identitypooltagstype0) in tags {
                try tagsContainer.encode(identitypooltagstype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the identity pool.</p>
    public let resourceArn: Swift.String?
    /// <p>The tags to assign to the identity pool.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when a request is throttled.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Message returned by a TooManyRequestsException</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnlinkDeveloperIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlinkDeveloperIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlinkDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlinkDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlinkDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlinkDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlinkDeveloperIdentityOutputError>
}

extension UnlinkDeveloperIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnlinkDeveloperIdentityInput(developerProviderName: \(Swift.String(describing: developerProviderName)), developerUserIdentifier: \(Swift.String(describing: developerUserIdentifier)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension UnlinkDeveloperIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let developerUserIdentifier = developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct UnlinkDeveloperIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlinkDeveloperIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlinkDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlinkDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlinkDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlinkDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlinkDeveloperIdentityOutputError>
}

public struct UnlinkDeveloperIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlinkDeveloperIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlinkDeveloperIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlinkDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlinkDeveloperIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlinkDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlinkDeveloperIdentityOutputError>
}

/// <p>Input to the <code>UnlinkDeveloperIdentity</code> action.</p>
public struct UnlinkDeveloperIdentityInput: Swift.Equatable {
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: Swift.String?
    /// <p>A unique ID used by your backend authentication process to identify a user.</p>
    public let developerUserIdentifier: Swift.String?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?

    public init (
        developerProviderName: Swift.String? = nil,
        developerUserIdentifier: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.developerProviderName = developerProviderName
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct UnlinkDeveloperIdentityInputBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let identityPoolId: Swift.String?
    public let developerProviderName: Swift.String?
    public let developerUserIdentifier: Swift.String?
}

extension UnlinkDeveloperIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
    }
}

extension UnlinkDeveloperIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlinkDeveloperIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlinkDeveloperIdentityOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlinkDeveloperIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnlinkDeveloperIdentityOutputResponse()"}
}

extension UnlinkDeveloperIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnlinkDeveloperIdentityOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnlinkDeveloperIdentityOutputResponseBody: Swift.Equatable {
}

extension UnlinkDeveloperIdentityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UnlinkIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlinkIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlinkIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlinkIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlinkIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlinkIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlinkIdentityOutputError>
}

extension UnlinkIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnlinkIdentityInput(identityId: \(Swift.String(describing: identityId)), logins: \(Swift.String(describing: logins)), loginsToRemove: \(Swift.String(describing: loginsToRemove)))"}
}

extension UnlinkIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let loginsToRemove = loginsToRemove {
            var loginsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loginsToRemove)
            for loginslist0 in loginsToRemove {
                try loginsToRemoveContainer.encode(loginslist0)
            }
        }
    }
}

public struct UnlinkIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlinkIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlinkIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlinkIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlinkIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlinkIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlinkIdentityOutputError>
}

public struct UnlinkIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnlinkIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnlinkIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnlinkIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnlinkIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnlinkIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnlinkIdentityOutputError>
}

/// <p>Input to the UnlinkIdentity action.</p>
public struct UnlinkIdentityInput: Swift.Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: Swift.String?
    /// <p>A set of optional name-value pairs that map provider names to provider
    ///          tokens.</p>
    public let logins: [Swift.String:Swift.String]?
    /// <p>Provider names to unlink from this identity.</p>
    public let loginsToRemove: [Swift.String]?

    public init (
        identityId: Swift.String? = nil,
        logins: [Swift.String:Swift.String]? = nil,
        loginsToRemove: [Swift.String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
        self.loginsToRemove = loginsToRemove
    }
}

struct UnlinkIdentityInputBody: Swift.Equatable {
    public let identityId: Swift.String?
    public let logins: [Swift.String:Swift.String]?
    public let loginsToRemove: [Swift.String]?
}

extension UnlinkIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .logins)
        var loginsDecoded0: [Swift.String:Swift.String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let loginsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loginsToRemove)
        var loginsToRemoveDecoded0:[Swift.String]? = nil
        if let loginsToRemoveContainer = loginsToRemoveContainer {
            loginsToRemoveDecoded0 = [Swift.String]()
            for string0 in loginsToRemoveContainer {
                if let string0 = string0 {
                    loginsToRemoveDecoded0?.append(string0)
                }
            }
        }
        loginsToRemove = loginsToRemoveDecoded0
    }
}

extension UnlinkIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlinkIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlinkIdentityOutputError: Swift.Error, Swift.Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlinkIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnlinkIdentityOutputResponse()"}
}

extension UnlinkIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnlinkIdentityOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnlinkIdentityOutputResponseBody: Swift.Equatable {
}

extension UnlinkIdentityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CognitoIdentityClientTypes.UnprocessedIdentityId: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(CognitoIdentityClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension CognitoIdentityClientTypes.UnprocessedIdentityId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnprocessedIdentityId(errorCode: \(Swift.String(describing: errorCode)), identityId: \(Swift.String(describing: identityId)))"}
}

extension CognitoIdentityClientTypes {
    /// <p>An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and
    ///          IdentityId.</p>
    public struct UnprocessedIdentityId: Swift.Equatable {
        /// <p>The error code indicating the type of error that occurred.</p>
        public let errorCode: CognitoIdentityClientTypes.ErrorCode?
        /// <p>A unique identifier in the format REGION:GUID.</p>
        public let identityId: Swift.String?

        public init (
            errorCode: CognitoIdentityClientTypes.ErrorCode? = nil,
            identityId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.identityId = identityId
        }
    }

}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for identitypooltagslisttype0 in tagKeys {
                try tagKeysContainer.encode(identitypooltagslisttype0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the identity pool.</p>
    public let resourceArn: Swift.String?
    /// <p>The keys of the tags to remove from the user pool.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateIdentityPoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityPoolOutputError>
}

extension UpdateIdentityPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityPoolInput(allowClassicFlow: \(Swift.String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(Swift.String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(Swift.String(describing: cognitoIdentityProviders)), developerProviderName: \(Swift.String(describing: developerProviderName)), identityPoolId: \(Swift.String(describing: identityPoolId)), identityPoolName: \(Swift.String(describing: identityPoolName)), identityPoolTags: \(Swift.String(describing: identityPoolTags)), openIdConnectProviderARNs: \(Swift.String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(Swift.String(describing: samlProviderARNs)), supportedLoginProviders: \(Swift.String(describing: supportedLoginProviders)))"}
}

extension UpdateIdentityPoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if allowUnauthenticatedIdentities != false {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityproviderlist0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityproviderlist0)
            }
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityPoolTags)
            for (dictKey0, identitypooltagstype0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identitypooltagstype0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for oidcproviderlist0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(oidcproviderlist0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for samlproviderlist0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(samlproviderlist0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityproviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityproviders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateIdentityPoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityPoolOutputError>
}

public struct UpdateIdentityPoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityPoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityPoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityPoolOutputError>
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct UpdateIdentityPoolInput: Swift.Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Swift.Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Swift.Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: Swift.String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [Swift.String:Swift.String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [Swift.String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [Swift.String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityPoolName: Swift.String?
    public let allowUnauthenticatedIdentities: Swift.Bool
    public let allowClassicFlow: Swift.Bool?
    public let supportedLoginProviders: [Swift.String:Swift.String]?
    public let developerProviderName: Swift.String?
    public let openIdConnectProviderARNs: [Swift.String]?
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    public let samlProviderARNs: [Swift.String]?
    public let identityPoolTags: [Swift.String:Swift.String]?
}

extension UpdateIdentityPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension UpdateIdentityPoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityPoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIdentityPoolOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityPoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityPoolOutputResponse(allowClassicFlow: \(Swift.String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(Swift.String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(Swift.String(describing: cognitoIdentityProviders)), developerProviderName: \(Swift.String(describing: developerProviderName)), identityPoolId: \(Swift.String(describing: identityPoolId)), identityPoolName: \(Swift.String(describing: identityPoolName)), identityPoolTags: \(Swift.String(describing: identityPoolTags)), openIdConnectProviderARNs: \(Swift.String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(Swift.String(describing: samlProviderARNs)), supportedLoginProviders: \(Swift.String(describing: supportedLoginProviders)))"}
}

extension UpdateIdentityPoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct UpdateIdentityPoolOutputResponse: Swift.Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Swift.Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Swift.Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: Swift.String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: Swift.String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: Swift.String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [Swift.String:Swift.String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [Swift.String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [Swift.String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [Swift.String:Swift.String]?

    public init (
        allowClassicFlow: Swift.Bool? = nil,
        allowUnauthenticatedIdentities: Swift.Bool = false,
        cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil,
        developerProviderName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        identityPoolName: Swift.String? = nil,
        identityPoolTags: [Swift.String:Swift.String]? = nil,
        openIdConnectProviderARNs: [Swift.String]? = nil,
        samlProviderARNs: [Swift.String]? = nil,
        supportedLoginProviders: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let identityPoolName: Swift.String?
    public let allowUnauthenticatedIdentities: Swift.Bool
    public let allowClassicFlow: Swift.Bool?
    public let supportedLoginProviders: [Swift.String:Swift.String]?
    public let developerProviderName: Swift.String?
    public let openIdConnectProviderARNs: [Swift.String]?
    public let cognitoIdentityProviders: [CognitoIdentityClientTypes.CognitoIdentityProvider]?
    public let samlProviderARNs: [Swift.String]?
    public let identityPoolTags: [Swift.String:Swift.String]?
}

extension UpdateIdentityPoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [Swift.String:Swift.String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [Swift.String:Swift.String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[Swift.String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [Swift.String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityClientTypes.CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityClientTypes.CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityClientTypes.CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[Swift.String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [Swift.String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}
