// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CloudSearchClientTypes.AccessPoliciesStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.AccessPoliciesStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPoliciesStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The configured access rules for the domain's document and search endpoints, and the current status of those rules.
    public struct AccessPoliciesStatus: Swift.Equatable {
        /// Access rules for a domain's document or search service endpoints. For more information, see [Configuring Access for a Search Domain](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-access.html) in the Amazon CloudSearch Developer Guide. The maximum size of a policy document is 100 KB.
        /// This member is required.
        public var options: Swift.String?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: Swift.String? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    public enum AlgorithmicStemming: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case light
        case minimal
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmicStemming] {
            return [
                .full,
                .light,
                .minimal,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "full"
            case .light: return "light"
            case .minimal: return "minimal"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmicStemming(rawValue: rawValue) ?? AlgorithmicStemming.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.AnalysisOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmicStemming = "AlgorithmicStemming"
        case japaneseTokenizationDictionary = "JapaneseTokenizationDictionary"
        case stemmingDictionary = "StemmingDictionary"
        case stopwords = "Stopwords"
        case synonyms = "Synonyms"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let algorithmicStemming = algorithmicStemming {
            try container.encode(algorithmicStemming, forKey: ClientRuntime.Key("AlgorithmicStemming"))
        }
        if let japaneseTokenizationDictionary = japaneseTokenizationDictionary {
            try container.encode(japaneseTokenizationDictionary, forKey: ClientRuntime.Key("JapaneseTokenizationDictionary"))
        }
        if let stemmingDictionary = stemmingDictionary {
            try container.encode(stemmingDictionary, forKey: ClientRuntime.Key("StemmingDictionary"))
        }
        if let stopwords = stopwords {
            try container.encode(stopwords, forKey: ClientRuntime.Key("Stopwords"))
        }
        if let synonyms = synonyms {
            try container.encode(synonyms, forKey: ClientRuntime.Key("Synonyms"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synonymsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .synonyms)
        synonyms = synonymsDecoded
        let stopwordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stopwords)
        stopwords = stopwordsDecoded
        let stemmingDictionaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stemmingDictionary)
        stemmingDictionary = stemmingDictionaryDecoded
        let japaneseTokenizationDictionaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .japaneseTokenizationDictionary)
        japaneseTokenizationDictionary = japaneseTokenizationDictionaryDecoded
        let algorithmicStemmingDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AlgorithmicStemming.self, forKey: .algorithmicStemming)
        algorithmicStemming = algorithmicStemmingDecoded
    }
}

extension CloudSearchClientTypes.AnalysisOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalysisOptions(algorithmicStemming: \(Swift.String(describing: algorithmicStemming)), japaneseTokenizationDictionary: \(Swift.String(describing: japaneseTokenizationDictionary)), stemmingDictionary: \(Swift.String(describing: stemmingDictionary)), stopwords: \(Swift.String(describing: stopwords)), synonyms: \(Swift.String(describing: synonyms)))"}
}

extension CloudSearchClientTypes {
    /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
    public struct AnalysisOptions: Swift.Equatable {
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see [Language Specific Text Processing Settings](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/text-processing.html#text-processing-settings) in the Amazon CloudSearch Developer Guide
        public var algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming?
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        public var japaneseTokenizationDictionary: Swift.String?
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        public var stemmingDictionary: Swift.String?
        /// A JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported.
        public var stopwords: Swift.String?
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see [Synonyms](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-analysis-schemes.html#synonyms) in the Amazon CloudSearch Developer Guide.
        public var synonyms: Swift.String?

        public init (
            algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming? = nil,
            japaneseTokenizationDictionary: Swift.String? = nil,
            stemmingDictionary: Swift.String? = nil,
            stopwords: Swift.String? = nil,
            synonyms: Swift.String? = nil
        )
        {
            self.algorithmicStemming = algorithmicStemming
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stemmingDictionary = stemmingDictionary
            self.stopwords = stopwords
            self.synonyms = synonyms
        }
    }

}

extension CloudSearchClientTypes.AnalysisScheme: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisOptions = "AnalysisOptions"
        case analysisSchemeLanguage = "AnalysisSchemeLanguage"
        case analysisSchemeName = "AnalysisSchemeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisOptions = analysisOptions {
            try container.encode(analysisOptions, forKey: ClientRuntime.Key("AnalysisOptions"))
        }
        if let analysisSchemeLanguage = analysisSchemeLanguage {
            try container.encode(analysisSchemeLanguage, forKey: ClientRuntime.Key("AnalysisSchemeLanguage"))
        }
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: ClientRuntime.Key("AnalysisSchemeName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSchemeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisSchemeName)
        analysisSchemeName = analysisSchemeNameDecoded
        let analysisSchemeLanguageDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisSchemeLanguage.self, forKey: .analysisSchemeLanguage)
        analysisSchemeLanguage = analysisSchemeLanguageDecoded
        let analysisOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisOptions.self, forKey: .analysisOptions)
        analysisOptions = analysisOptionsDecoded
    }
}

extension CloudSearchClientTypes.AnalysisScheme: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalysisScheme(analysisOptions: \(Swift.String(describing: analysisOptions)), analysisSchemeLanguage: \(Swift.String(describing: analysisSchemeLanguage)), analysisSchemeName: \(Swift.String(describing: analysisSchemeName)))"}
}

extension CloudSearchClientTypes {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    public struct AnalysisScheme: Swift.Equatable {
        /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
        public var analysisOptions: CloudSearchClientTypes.AnalysisOptions?
        /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
        /// This member is required.
        public var analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var analysisSchemeName: Swift.String?

        public init (
            analysisOptions: CloudSearchClientTypes.AnalysisOptions? = nil,
            analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage? = nil,
            analysisSchemeName: Swift.String? = nil
        )
        {
            self.analysisOptions = analysisOptions
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
        }
    }

}

extension CloudSearchClientTypes {
    /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
    public enum AnalysisSchemeLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ar
        case bg
        case ca
        case cs
        case da
        case de
        case el
        case en
        case es
        case eu
        case fa
        case fi
        case fr
        case ga
        case gl
        case he
        case hi
        case hu
        case hy
        case id
        case it
        case ja
        case ko
        case lv
        case mul
        case nl
        case no
        case pt
        case ro
        case ru
        case sv
        case th
        case tr
        case zhHans
        case zhHant
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisSchemeLanguage] {
            return [
                .ar,
                .bg,
                .ca,
                .cs,
                .da,
                .de,
                .el,
                .en,
                .es,
                .eu,
                .fa,
                .fi,
                .fr,
                .ga,
                .gl,
                .he,
                .hi,
                .hu,
                .hy,
                .id,
                .it,
                .ja,
                .ko,
                .lv,
                .mul,
                .nl,
                .no,
                .pt,
                .ro,
                .ru,
                .sv,
                .th,
                .tr,
                .zhHans,
                .zhHant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ar: return "ar"
            case .bg: return "bg"
            case .ca: return "ca"
            case .cs: return "cs"
            case .da: return "da"
            case .de: return "de"
            case .el: return "el"
            case .en: return "en"
            case .es: return "es"
            case .eu: return "eu"
            case .fa: return "fa"
            case .fi: return "fi"
            case .fr: return "fr"
            case .ga: return "ga"
            case .gl: return "gl"
            case .he: return "he"
            case .hi: return "hi"
            case .hu: return "hu"
            case .hy: return "hy"
            case .id: return "id"
            case .it: return "it"
            case .ja: return "ja"
            case .ko: return "ko"
            case .lv: return "lv"
            case .mul: return "mul"
            case .nl: return "nl"
            case .no: return "no"
            case .pt: return "pt"
            case .ro: return "ro"
            case .ru: return "ru"
            case .sv: return "sv"
            case .th: return "th"
            case .tr: return "tr"
            case .zhHans: return "zh-Hans"
            case .zhHant: return "zh-Hant"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisSchemeLanguage(rawValue: rawValue) ?? AnalysisSchemeLanguage.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.AnalysisSchemeStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisScheme.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.AnalysisSchemeStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalysisSchemeStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The status and configuration of an AnalysisScheme.
    public struct AnalysisSchemeStatus: Swift.Equatable {
        /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
        /// This member is required.
        public var options: CloudSearchClientTypes.AnalysisScheme?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.AnalysisScheme? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.AvailabilityOptionsStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if options != false {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.AvailabilityOptionsStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityOptionsStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The status and configuration of the domain's availability options.
    public struct AvailabilityOptionsStatus: Swift.Equatable {
        /// The availability options configured for the domain.
        /// This member is required.
        public var options: Swift.Bool
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: Swift.Bool = false,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension BaseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BaseException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension BaseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<BaseExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred while processing the request.
public struct BaseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BaseExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension BaseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BuildSuggestersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BuildSuggestersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BuildSuggestersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BuildSuggestersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BuildSuggestersOutputError>
}

extension BuildSuggestersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BuildSuggestersInput(domainName: \(Swift.String(describing: domainName)))"}
}

extension BuildSuggestersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("BuildSuggesters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct BuildSuggestersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BuildSuggestersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BuildSuggestersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BuildSuggestersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BuildSuggestersOutputError>
}

public struct BuildSuggestersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BuildSuggestersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BuildSuggestersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BuildSuggestersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BuildSuggestersOutputError>
}

public struct BuildSuggestersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BuildSuggestersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BuildSuggestersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BuildSuggestersInput
    public typealias MOutput = ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BuildSuggestersOutputError>
}

public struct BuildSuggestersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BuildSuggestersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BuildSuggestersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BuildSuggestersInput
    public typealias MOutput = ClientRuntime.OperationOutput<BuildSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BuildSuggestersOutputError>
}

/// Container for the parameters to the [BuildSuggester] operation. Specifies the name of the domain you want to update.
public struct BuildSuggestersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension BuildSuggestersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BuildSuggestersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BuildSuggestersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BuildSuggestersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BuildSuggestersOutputResponse(fieldNames: \(Swift.String(describing: fieldNames)))"}
}

extension BuildSuggestersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BuildSuggestersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fieldNames = output.fieldNames
        } else {
            self.fieldNames = nil
        }
    }
}

/// The result of a BuildSuggester request. Contains a list of the fields used for suggestions.
public struct BuildSuggestersOutputResponse: Swift.Equatable {
    /// A list of field names.
    public var fieldNames: [Swift.String]?

    public init (
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

struct BuildSuggestersOutputResponseBody: Swift.Equatable {
    public let fieldNames: [Swift.String]?
}

extension BuildSuggestersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldNames = "FieldNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("BuildSuggestersResult"))
        if containerValues.contains(.fieldNames) {
            struct KeyVal0{struct member{}}
            let fieldNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fieldNames)
            if let fieldNamesWrappedContainer = fieldNamesWrappedContainer {
                let fieldNamesContainer = try fieldNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldNamesBuffer:[Swift.String]? = nil
                if let fieldNamesContainer = fieldNamesContainer {
                    fieldNamesBuffer = [Swift.String]()
                    for stringContainer0 in fieldNamesContainer {
                        fieldNamesBuffer?.append(stringContainer0)
                    }
                }
                fieldNames = fieldNamesBuffer
            } else {
                fieldNames = []
            }
        } else {
            fieldNames = nil
        }
    }
}

public struct CreateDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

extension CreateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainInput(domainName: \(Swift.String(describing: domainName)))"}
}

extension CreateDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("CreateDomain", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

/// Container for the parameters to the [CreateDomain] operation. Specifies a name for the new search domain.
public struct CreateDomainInput: Swift.Equatable {
    /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExists" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainOutputResponse(domainStatus: \(Swift.String(describing: domainStatus)))"}
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// The result of a CreateDomainRequest. Contains the status of a newly created domain.
public struct CreateDomainOutputResponse: Swift.Equatable {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init (
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    public let domainStatus: CloudSearchClientTypes.DomainStatus?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDomainResult"))
        let domainStatusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension CloudSearchClientTypes.DateArrayOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes.DateArrayOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DateArrayOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sourceFields: \(Swift.String(describing: sourceFields)))"}
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
    public struct DateArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.DateOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes.DateOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DateOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sortEnabled: \(Swift.String(describing: sortEnabled)), sourceField: \(Swift.String(describing: sourceField)))"}
}

extension CloudSearchClientTypes {
    /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
    public struct DateOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

public struct DefineAnalysisSchemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineAnalysisSchemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineAnalysisSchemeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineAnalysisSchemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineAnalysisSchemeOutputError>
}

extension DefineAnalysisSchemeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineAnalysisSchemeInput(analysisScheme: \(Swift.String(describing: analysisScheme)), domainName: \(Swift.String(describing: domainName)))"}
}

extension DefineAnalysisSchemeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DefineAnalysisScheme", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DefineAnalysisSchemeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineAnalysisSchemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineAnalysisSchemeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineAnalysisSchemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineAnalysisSchemeOutputError>
}

public struct DefineAnalysisSchemeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineAnalysisSchemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineAnalysisSchemeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineAnalysisSchemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineAnalysisSchemeOutputError>
}

public struct DefineAnalysisSchemeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineAnalysisSchemeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DefineAnalysisSchemeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineAnalysisSchemeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineAnalysisSchemeOutputError>
}

public struct DefineAnalysisSchemeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineAnalysisSchemeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DefineAnalysisSchemeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineAnalysisSchemeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineAnalysisSchemeOutputError>
}

/// Container for the parameters to the [DefineAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme configuration.
public struct DefineAnalysisSchemeInput: Swift.Equatable {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisScheme?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        analysisScheme: CloudSearchClientTypes.AnalysisScheme? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisScheme = analysisScheme
        self.domainName = domainName
    }
}

extension DefineAnalysisSchemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineAnalysisSchemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineAnalysisSchemeOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineAnalysisSchemeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineAnalysisSchemeOutputResponse(analysisScheme: \(Swift.String(describing: analysisScheme)))"}
}

extension DefineAnalysisSchemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DefineAnalysisSchemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisScheme = output.analysisScheme
        } else {
            self.analysisScheme = nil
        }
    }
}

/// The result of a [DefineAnalysisScheme] request. Contains the status of the newly-configured analysis scheme.
public struct DefineAnalysisSchemeOutputResponse: Swift.Equatable {
    /// The status and configuration of an AnalysisScheme.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init (
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

struct DefineAnalysisSchemeOutputResponseBody: Swift.Equatable {
    public let analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?
}

extension DefineAnalysisSchemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineAnalysisSchemeResult"))
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisSchemeStatus.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

public struct DefineExpressionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineExpressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineExpressionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineExpressionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineExpressionOutputError>
}

extension DefineExpressionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineExpressionInput(domainName: \(Swift.String(describing: domainName)), expression: \(Swift.String(describing: expression)))"}
}

extension DefineExpressionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: ClientRuntime.Key("Expression"))
        }
        try container.encode("DefineExpression", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DefineExpressionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineExpressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineExpressionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineExpressionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineExpressionOutputError>
}

public struct DefineExpressionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineExpressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineExpressionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineExpressionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineExpressionOutputError>
}

public struct DefineExpressionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineExpressionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DefineExpressionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineExpressionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineExpressionOutputError>
}

public struct DefineExpressionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineExpressionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DefineExpressionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineExpressionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineExpressionOutputError>
}

/// Container for the parameters to the [DefineExpression] operation. Specifies the name of the domain you want to update and the expression you want to configure.
public struct DefineExpressionInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    /// This member is required.
    public var expression: CloudSearchClientTypes.Expression?

    public init (
        domainName: Swift.String? = nil,
        expression: CloudSearchClientTypes.Expression? = nil
    )
    {
        self.domainName = domainName
        self.expression = expression
    }
}

extension DefineExpressionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineExpressionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineExpressionOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineExpressionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineExpressionOutputResponse(expression: \(Swift.String(describing: expression)))"}
}

extension DefineExpressionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DefineExpressionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expression = output.expression
        } else {
            self.expression = nil
        }
    }
}

/// The result of a DefineExpression request. Contains the status of the newly-configured expression.
public struct DefineExpressionOutputResponse: Swift.Equatable {
    /// The value of an Expression and its current status.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init (
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

struct DefineExpressionOutputResponseBody: Swift.Equatable {
    public let expression: CloudSearchClientTypes.ExpressionStatus?
}

extension DefineExpressionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineExpressionResult"))
        let expressionDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ExpressionStatus.self, forKey: .expression)
        expression = expressionDecoded
    }
}

public struct DefineIndexFieldInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineIndexFieldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineIndexFieldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineIndexFieldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineIndexFieldOutputError>
}

extension DefineIndexFieldInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineIndexFieldInput(domainName: \(Swift.String(describing: domainName)), indexField: \(Swift.String(describing: indexField)))"}
}

extension DefineIndexFieldInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let indexField = indexField {
            try container.encode(indexField, forKey: ClientRuntime.Key("IndexField"))
        }
        try container.encode("DefineIndexField", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DefineIndexFieldInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineIndexFieldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineIndexFieldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineIndexFieldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineIndexFieldOutputError>
}

public struct DefineIndexFieldInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineIndexFieldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineIndexFieldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineIndexFieldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineIndexFieldOutputError>
}

public struct DefineIndexFieldInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineIndexFieldInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DefineIndexFieldInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineIndexFieldInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineIndexFieldOutputError>
}

public struct DefineIndexFieldInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineIndexFieldInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DefineIndexFieldInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineIndexFieldInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineIndexFieldOutputError>
}

/// Container for the parameters to the [DefineIndexField] operation. Specifies the name of the domain you want to update and the index field configuration.
public struct DefineIndexFieldInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The index field and field options you want to configure.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexField?

    public init (
        domainName: Swift.String? = nil,
        indexField: CloudSearchClientTypes.IndexField? = nil
    )
    {
        self.domainName = domainName
        self.indexField = indexField
    }
}

extension DefineIndexFieldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineIndexFieldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineIndexFieldOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineIndexFieldOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineIndexFieldOutputResponse(indexField: \(Swift.String(describing: indexField)))"}
}

extension DefineIndexFieldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DefineIndexFieldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexField = output.indexField
        } else {
            self.indexField = nil
        }
    }
}

/// The result of a [DefineIndexField] request. Contains the status of the newly-configured index field.
public struct DefineIndexFieldOutputResponse: Swift.Equatable {
    /// The value of an IndexField and its current status.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init (
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

struct DefineIndexFieldOutputResponseBody: Swift.Equatable {
    public let indexField: CloudSearchClientTypes.IndexFieldStatus?
}

extension DefineIndexFieldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexField = "IndexField"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineIndexFieldResult"))
        let indexFieldDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexFieldStatus.self, forKey: .indexField)
        indexField = indexFieldDecoded
    }
}

public struct DefineSuggesterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineSuggesterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineSuggesterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineSuggesterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineSuggesterOutputError>
}

extension DefineSuggesterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineSuggesterInput(domainName: \(Swift.String(describing: domainName)), suggester: \(Swift.String(describing: suggester)))"}
}

extension DefineSuggesterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggester = suggester {
            try container.encode(suggester, forKey: ClientRuntime.Key("Suggester"))
        }
        try container.encode("DefineSuggester", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DefineSuggesterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineSuggesterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineSuggesterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineSuggesterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineSuggesterOutputError>
}

public struct DefineSuggesterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineSuggesterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DefineSuggesterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DefineSuggesterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineSuggesterOutputError>
}

public struct DefineSuggesterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineSuggesterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DefineSuggesterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineSuggesterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineSuggesterOutputError>
}

public struct DefineSuggesterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DefineSuggesterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DefineSuggesterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DefineSuggesterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DefineSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DefineSuggesterOutputError>
}

/// Container for the parameters to the [DefineSuggester] operation. Specifies the name of the domain you want to update and the suggester configuration.
public struct DefineSuggesterInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.Suggester?

    public init (
        domainName: Swift.String? = nil,
        suggester: CloudSearchClientTypes.Suggester? = nil
    )
    {
        self.domainName = domainName
        self.suggester = suggester
    }
}

extension DefineSuggesterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineSuggesterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DefineSuggesterOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineSuggesterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefineSuggesterOutputResponse(suggester: \(Swift.String(describing: suggester)))"}
}

extension DefineSuggesterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DefineSuggesterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suggester = output.suggester
        } else {
            self.suggester = nil
        }
    }
}

/// The result of a DefineSuggester request. Contains the status of the newly-configured suggester.
public struct DefineSuggesterOutputResponse: Swift.Equatable {
    /// The value of a Suggester and its current status.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init (
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

struct DefineSuggesterOutputResponseBody: Swift.Equatable {
    public let suggester: CloudSearchClientTypes.SuggesterStatus?
}

extension DefineSuggesterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suggester = "Suggester"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineSuggesterResult"))
        let suggesterDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.SuggesterStatus.self, forKey: .suggester)
        suggester = suggesterDecoded
    }
}

public struct DeleteAnalysisSchemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalysisSchemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAnalysisSchemeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAnalysisSchemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalysisSchemeOutputError>
}

extension DeleteAnalysisSchemeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAnalysisSchemeInput(analysisSchemeName: \(Swift.String(describing: analysisSchemeName)), domainName: \(Swift.String(describing: domainName)))"}
}

extension DeleteAnalysisSchemeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: ClientRuntime.Key("AnalysisSchemeName"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DeleteAnalysisScheme", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteAnalysisSchemeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalysisSchemeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAnalysisSchemeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAnalysisSchemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalysisSchemeOutputError>
}

public struct DeleteAnalysisSchemeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalysisSchemeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAnalysisSchemeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAnalysisSchemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalysisSchemeOutputError>
}

public struct DeleteAnalysisSchemeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalysisSchemeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAnalysisSchemeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAnalysisSchemeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalysisSchemeOutputError>
}

public struct DeleteAnalysisSchemeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAnalysisSchemeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAnalysisSchemeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAnalysisSchemeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAnalysisSchemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAnalysisSchemeOutputError>
}

/// Container for the parameters to the [DeleteAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme you want to delete.
public struct DeleteAnalysisSchemeInput: Swift.Equatable {
    /// The name of the analysis scheme you want to delete.
    /// This member is required.
    public var analysisSchemeName: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        analysisSchemeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeName = analysisSchemeName
        self.domainName = domainName
    }
}

extension DeleteAnalysisSchemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAnalysisSchemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnalysisSchemeOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalysisSchemeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAnalysisSchemeOutputResponse(analysisScheme: \(Swift.String(describing: analysisScheme)))"}
}

extension DeleteAnalysisSchemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAnalysisSchemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisScheme = output.analysisScheme
        } else {
            self.analysisScheme = nil
        }
    }
}

/// The result of a DeleteAnalysisScheme request. Contains the status of the deleted analysis scheme.
public struct DeleteAnalysisSchemeOutputResponse: Swift.Equatable {
    /// The status of the analysis scheme being deleted.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init (
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

struct DeleteAnalysisSchemeOutputResponseBody: Swift.Equatable {
    public let analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?
}

extension DeleteAnalysisSchemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteAnalysisSchemeResult"))
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisSchemeStatus.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

public struct DeleteDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

extension DeleteDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainInput(domainName: \(Swift.String(describing: domainName)))"}
}

extension DeleteDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DeleteDomain", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

/// Container for the parameters to the [DeleteDomain] operation. Specifies the name of the domain you want to delete.
public struct DeleteDomainInput: Swift.Equatable {
    /// The name of the domain you want to permanently delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainOutputResponse(domainStatus: \(Swift.String(describing: domainStatus)))"}
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// The result of a DeleteDomain request. Contains the status of a newly deleted domain, or no status if the domain has already been completely deleted.
public struct DeleteDomainOutputResponse: Swift.Equatable {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init (
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct DeleteDomainOutputResponseBody: Swift.Equatable {
    public let domainStatus: CloudSearchClientTypes.DomainStatus?
}

extension DeleteDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDomainResult"))
        let domainStatusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

public struct DeleteExpressionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExpressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExpressionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExpressionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExpressionOutputError>
}

extension DeleteExpressionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteExpressionInput(domainName: \(Swift.String(describing: domainName)), expressionName: \(Swift.String(describing: expressionName)))"}
}

extension DeleteExpressionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: ClientRuntime.Key("ExpressionName"))
        }
        try container.encode("DeleteExpression", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteExpressionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExpressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExpressionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExpressionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExpressionOutputError>
}

public struct DeleteExpressionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExpressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExpressionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExpressionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExpressionOutputError>
}

public struct DeleteExpressionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExpressionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteExpressionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteExpressionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExpressionOutputError>
}

public struct DeleteExpressionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExpressionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteExpressionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteExpressionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExpressionOutputError>
}

/// Container for the parameters to the [DeleteExpression] operation. Specifies the name of the domain you want to update and the name of the expression you want to delete.
public struct DeleteExpressionInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the [Expression] to delete.
    /// This member is required.
    public var expressionName: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        expressionName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.expressionName = expressionName
    }
}

extension DeleteExpressionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteExpressionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExpressionOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExpressionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteExpressionOutputResponse(expression: \(Swift.String(describing: expression)))"}
}

extension DeleteExpressionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteExpressionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expression = output.expression
        } else {
            self.expression = nil
        }
    }
}

/// The result of a [DeleteExpression] request. Specifies the expression being deleted.
public struct DeleteExpressionOutputResponse: Swift.Equatable {
    /// The status of the expression being deleted.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init (
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

struct DeleteExpressionOutputResponseBody: Swift.Equatable {
    public let expression: CloudSearchClientTypes.ExpressionStatus?
}

extension DeleteExpressionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteExpressionResult"))
        let expressionDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ExpressionStatus.self, forKey: .expression)
        expression = expressionDecoded
    }
}

public struct DeleteIndexFieldInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexFieldInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIndexFieldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIndexFieldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexFieldOutputError>
}

extension DeleteIndexFieldInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIndexFieldInput(domainName: \(Swift.String(describing: domainName)), indexFieldName: \(Swift.String(describing: indexFieldName)))"}
}

extension DeleteIndexFieldInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: ClientRuntime.Key("IndexFieldName"))
        }
        try container.encode("DeleteIndexField", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteIndexFieldInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexFieldInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIndexFieldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIndexFieldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexFieldOutputError>
}

public struct DeleteIndexFieldInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexFieldInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIndexFieldInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIndexFieldInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexFieldOutputError>
}

public struct DeleteIndexFieldInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexFieldInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteIndexFieldInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteIndexFieldInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexFieldOutputError>
}

public struct DeleteIndexFieldInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIndexFieldInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteIndexFieldInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteIndexFieldInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIndexFieldOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIndexFieldOutputError>
}

/// Container for the parameters to the [DeleteIndexField] operation. Specifies the name of the domain you want to update and the name of the index field you want to delete.
public struct DeleteIndexFieldInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the index field your want to remove from the domain's indexing options.
    /// This member is required.
    public var indexFieldName: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        indexFieldName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.indexFieldName = indexFieldName
    }
}

extension DeleteIndexFieldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteIndexFieldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIndexFieldOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIndexFieldOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIndexFieldOutputResponse(indexField: \(Swift.String(describing: indexField)))"}
}

extension DeleteIndexFieldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteIndexFieldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexField = output.indexField
        } else {
            self.indexField = nil
        }
    }
}

/// The result of a [DeleteIndexField] request.
public struct DeleteIndexFieldOutputResponse: Swift.Equatable {
    /// The status of the index field being deleted.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init (
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

struct DeleteIndexFieldOutputResponseBody: Swift.Equatable {
    public let indexField: CloudSearchClientTypes.IndexFieldStatus?
}

extension DeleteIndexFieldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexField = "IndexField"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteIndexFieldResult"))
        let indexFieldDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexFieldStatus.self, forKey: .indexField)
        indexField = indexFieldDecoded
    }
}

public struct DeleteSuggesterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuggesterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSuggesterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSuggesterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuggesterOutputError>
}

extension DeleteSuggesterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSuggesterInput(domainName: \(Swift.String(describing: domainName)), suggesterName: \(Swift.String(describing: suggesterName)))"}
}

extension DeleteSuggesterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: ClientRuntime.Key("SuggesterName"))
        }
        try container.encode("DeleteSuggester", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteSuggesterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuggesterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSuggesterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSuggesterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuggesterOutputError>
}

public struct DeleteSuggesterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuggesterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSuggesterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSuggesterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuggesterOutputError>
}

public struct DeleteSuggesterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuggesterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSuggesterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSuggesterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuggesterOutputError>
}

public struct DeleteSuggesterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuggesterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSuggesterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSuggesterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuggesterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuggesterOutputError>
}

/// Container for the parameters to the [DeleteSuggester] operation. Specifies the name of the domain you want to update and name of the suggester you want to delete.
public struct DeleteSuggesterInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Specifies the name of the suggester you want to delete.
    /// This member is required.
    public var suggesterName: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        suggesterName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.suggesterName = suggesterName
    }
}

extension DeleteSuggesterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSuggesterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSuggesterOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSuggesterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSuggesterOutputResponse(suggester: \(Swift.String(describing: suggester)))"}
}

extension DeleteSuggesterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSuggesterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suggester = output.suggester
        } else {
            self.suggester = nil
        }
    }
}

/// The result of a DeleteSuggester request. Contains the status of the deleted suggester.
public struct DeleteSuggesterOutputResponse: Swift.Equatable {
    /// The status of the suggester being deleted.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init (
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

struct DeleteSuggesterOutputResponseBody: Swift.Equatable {
    public let suggester: CloudSearchClientTypes.SuggesterStatus?
}

extension DeleteSuggesterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suggester = "Suggester"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteSuggesterResult"))
        let suggesterDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.SuggesterStatus.self, forKey: .suggester)
        suggester = suggesterDecoded
    }
}

public struct DescribeAnalysisSchemesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAnalysisSchemesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAnalysisSchemesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAnalysisSchemesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAnalysisSchemesOutputError>
}

extension DescribeAnalysisSchemesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAnalysisSchemesInput(analysisSchemeNames: \(Swift.String(describing: analysisSchemeNames)), deployed: \(Swift.String(describing: deployed)), domainName: \(Swift.String(describing: domainName)))"}
}

extension DescribeAnalysisSchemesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisSchemeNames = analysisSchemeNames {
            var analysisSchemeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AnalysisSchemeNames"))
            for (index0, standardname0) in analysisSchemeNames.enumerated() {
                try analysisSchemeNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeAnalysisSchemes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeAnalysisSchemesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAnalysisSchemesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAnalysisSchemesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAnalysisSchemesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAnalysisSchemesOutputError>
}

public struct DescribeAnalysisSchemesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAnalysisSchemesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAnalysisSchemesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAnalysisSchemesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAnalysisSchemesOutputError>
}

public struct DescribeAnalysisSchemesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAnalysisSchemesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAnalysisSchemesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAnalysisSchemesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAnalysisSchemesOutputError>
}

public struct DescribeAnalysisSchemesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAnalysisSchemesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAnalysisSchemesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAnalysisSchemesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAnalysisSchemesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAnalysisSchemesOutputError>
}

/// Container for the parameters to the [DescribeAnalysisSchemes] operation. Specifies the name of the domain you want to describe. To limit the response to particular analysis schemes, specify the names of the analysis schemes you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAnalysisSchemesInput: Swift.Equatable {
    /// The analysis schemes you want to describe.
    public var analysisSchemeNames: [Swift.String]?
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        analysisSchemeNames: [Swift.String]? = nil,
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeNames = analysisSchemeNames
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeAnalysisSchemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAnalysisSchemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnalysisSchemesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisSchemesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAnalysisSchemesOutputResponse(analysisSchemes: \(Swift.String(describing: analysisSchemes)))"}
}

extension DescribeAnalysisSchemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAnalysisSchemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisSchemes = output.analysisSchemes
        } else {
            self.analysisSchemes = nil
        }
    }
}

/// The result of a DescribeAnalysisSchemes request. Contains the analysis schemes configured for the domain specified in the request.
public struct DescribeAnalysisSchemesOutputResponse: Swift.Equatable {
    /// The analysis scheme descriptions.
    /// This member is required.
    public var analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]?

    public init (
        analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]? = nil
    )
    {
        self.analysisSchemes = analysisSchemes
    }
}

struct DescribeAnalysisSchemesOutputResponseBody: Swift.Equatable {
    public let analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]?
}

extension DescribeAnalysisSchemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSchemes = "AnalysisSchemes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAnalysisSchemesResult"))
        if containerValues.contains(.analysisSchemes) {
            struct KeyVal0{struct member{}}
            let analysisSchemesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .analysisSchemes)
            if let analysisSchemesWrappedContainer = analysisSchemesWrappedContainer {
                let analysisSchemesContainer = try analysisSchemesWrappedContainer.decodeIfPresent([CloudSearchClientTypes.AnalysisSchemeStatus].self, forKey: .member)
                var analysisSchemesBuffer:[CloudSearchClientTypes.AnalysisSchemeStatus]? = nil
                if let analysisSchemesContainer = analysisSchemesContainer {
                    analysisSchemesBuffer = [CloudSearchClientTypes.AnalysisSchemeStatus]()
                    for structureContainer0 in analysisSchemesContainer {
                        analysisSchemesBuffer?.append(structureContainer0)
                    }
                }
                analysisSchemes = analysisSchemesBuffer
            } else {
                analysisSchemes = []
            }
        } else {
            analysisSchemes = nil
        }
    }
}

public struct DescribeAvailabilityOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailabilityOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityOptionsOutputError>
}

extension DescribeAvailabilityOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAvailabilityOptionsInput(deployed: \(Swift.String(describing: deployed)), domainName: \(Swift.String(describing: domainName)))"}
}

extension DescribeAvailabilityOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeAvailabilityOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeAvailabilityOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailabilityOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityOptionsOutputError>
}

public struct DescribeAvailabilityOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailabilityOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityOptionsOutputError>
}

public struct DescribeAvailabilityOptionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityOptionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAvailabilityOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAvailabilityOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityOptionsOutputError>
}

public struct DescribeAvailabilityOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityOptionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAvailabilityOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAvailabilityOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityOptionsOutputError>
}

/// Container for the parameters to the [DescribeAvailabilityOptions] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAvailabilityOptionsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeAvailabilityOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAvailabilityOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAvailabilityOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailabilityOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAvailabilityOptionsOutputResponse(availabilityOptions: \(Swift.String(describing: availabilityOptions)))"}
}

extension DescribeAvailabilityOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAvailabilityOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityOptions = output.availabilityOptions
        } else {
            self.availabilityOptions = nil
        }
    }
}

/// The result of a DescribeAvailabilityOptions request. Indicates whether or not the Multi-AZ option is enabled for the domain specified in the request.
public struct DescribeAvailabilityOptionsOutputResponse: Swift.Equatable {
    /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init (
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

struct DescribeAvailabilityOptionsOutputResponseBody: Swift.Equatable {
    public let availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?
}

extension DescribeAvailabilityOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityOptions = "AvailabilityOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAvailabilityOptionsResult"))
        let availabilityOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AvailabilityOptionsStatus.self, forKey: .availabilityOptions)
        availabilityOptions = availabilityOptionsDecoded
    }
}

public struct DescribeDomainEndpointOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainEndpointOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainEndpointOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainEndpointOptionsOutputError>
}

extension DescribeDomainEndpointOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainEndpointOptionsInput(deployed: \(Swift.String(describing: deployed)), domainName: \(Swift.String(describing: domainName)))"}
}

extension DescribeDomainEndpointOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeDomainEndpointOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDomainEndpointOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainEndpointOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainEndpointOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainEndpointOptionsOutputError>
}

public struct DescribeDomainEndpointOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainEndpointOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainEndpointOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainEndpointOptionsOutputError>
}

public struct DescribeDomainEndpointOptionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainEndpointOptionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDomainEndpointOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainEndpointOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainEndpointOptionsOutputError>
}

public struct DescribeDomainEndpointOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainEndpointOptionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDomainEndpointOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainEndpointOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainEndpointOptionsOutputError>
}

/// Container for the parameters to the [DescribeDomainEndpointOptions] operation. Specify the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeDomainEndpointOptionsInput: Swift.Equatable {
    /// Whether to retrieve the latest configuration (which might be in a Processing state) or the current, active configuration. Defaults to false.
    public var deployed: Swift.Bool?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeDomainEndpointOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDomainEndpointOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainEndpointOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainEndpointOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainEndpointOptionsOutputResponse(domainEndpointOptions: \(Swift.String(describing: domainEndpointOptions)))"}
}

extension DescribeDomainEndpointOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainEndpointOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainEndpointOptions = output.domainEndpointOptions
        } else {
            self.domainEndpointOptions = nil
        }
    }
}

/// The result of a DescribeDomainEndpointOptions request. Contains the status and configuration of a search domain's endpoint options.
public struct DescribeDomainEndpointOptionsOutputResponse: Swift.Equatable {
    /// The status and configuration of a search domain's endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init (
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

struct DescribeDomainEndpointOptionsOutputResponseBody: Swift.Equatable {
    public let domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?
}

extension DescribeDomainEndpointOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDomainEndpointOptionsResult"))
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainEndpointOptionsStatus.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
    }
}

public struct DescribeDomainsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainsOutputError>
}

extension DescribeDomainsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainsInput(domainNames: \(Swift.String(describing: domainNames)))"}
}

extension DescribeDomainsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainNames = domainNames {
            var domainNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainNames"))
            for (index0, domainname0) in domainNames.enumerated() {
                try domainNamesContainer.encode(domainname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeDomains", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDomainsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainsOutputError>
}

public struct DescribeDomainsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainsOutputError>
}

public struct DescribeDomainsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainsOutputError>
}

public struct DescribeDomainsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainsOutputError>
}

/// Container for the parameters to the [DescribeDomains] operation. By default shows the status of all domains. To restrict the response to particular domains, specify the names of the domains you want to describe.
public struct DescribeDomainsInput: Swift.Equatable {
    /// The names of the domains you want to include in the response.
    public var domainNames: [Swift.String]?

    public init (
        domainNames: [Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

extension DescribeDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainsOutputResponse(domainStatusList: \(Swift.String(describing: domainStatusList)))"}
}

extension DescribeDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatusList = output.domainStatusList
        } else {
            self.domainStatusList = nil
        }
    }
}

/// The result of a DescribeDomains request. Contains the status of the domains specified in the request or all domains owned by the account.
public struct DescribeDomainsOutputResponse: Swift.Equatable {
    /// A list that contains the status of each requested domain.
    /// This member is required.
    public var domainStatusList: [CloudSearchClientTypes.DomainStatus]?

    public init (
        domainStatusList: [CloudSearchClientTypes.DomainStatus]? = nil
    )
    {
        self.domainStatusList = domainStatusList
    }
}

struct DescribeDomainsOutputResponseBody: Swift.Equatable {
    public let domainStatusList: [CloudSearchClientTypes.DomainStatus]?
}

extension DescribeDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatusList = "DomainStatusList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDomainsResult"))
        if containerValues.contains(.domainStatusList) {
            struct KeyVal0{struct member{}}
            let domainStatusListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .domainStatusList)
            if let domainStatusListWrappedContainer = domainStatusListWrappedContainer {
                let domainStatusListContainer = try domainStatusListWrappedContainer.decodeIfPresent([CloudSearchClientTypes.DomainStatus].self, forKey: .member)
                var domainStatusListBuffer:[CloudSearchClientTypes.DomainStatus]? = nil
                if let domainStatusListContainer = domainStatusListContainer {
                    domainStatusListBuffer = [CloudSearchClientTypes.DomainStatus]()
                    for structureContainer0 in domainStatusListContainer {
                        domainStatusListBuffer?.append(structureContainer0)
                    }
                }
                domainStatusList = domainStatusListBuffer
            } else {
                domainStatusList = []
            }
        } else {
            domainStatusList = nil
        }
    }
}

public struct DescribeExpressionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExpressionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExpressionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExpressionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExpressionsOutputError>
}

extension DescribeExpressionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeExpressionsInput(deployed: \(Swift.String(describing: deployed)), domainName: \(Swift.String(describing: domainName)), expressionNames: \(Swift.String(describing: expressionNames)))"}
}

extension DescribeExpressionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expressionNames = expressionNames {
            var expressionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExpressionNames"))
            for (index0, standardname0) in expressionNames.enumerated() {
                try expressionNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeExpressions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeExpressionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExpressionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExpressionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExpressionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExpressionsOutputError>
}

public struct DescribeExpressionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExpressionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExpressionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExpressionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExpressionsOutputError>
}

public struct DescribeExpressionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExpressionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeExpressionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeExpressionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExpressionsOutputError>
}

public struct DescribeExpressionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExpressionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeExpressionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeExpressionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExpressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExpressionsOutputError>
}

/// Container for the parameters to the [DescribeDomains] operation. Specifies the name of the domain you want to describe. To restrict the response to particular expressions, specify the names of the expressions you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeExpressionsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// Limits the [DescribeExpressions] response to the specified expressions. If not specified, all expressions are shown.
    public var expressionNames: [Swift.String]?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        expressionNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.expressionNames = expressionNames
    }
}

extension DescribeExpressionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeExpressionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExpressionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExpressionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeExpressionsOutputResponse(expressions: \(Swift.String(describing: expressions)))"}
}

extension DescribeExpressionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExpressionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expressions = output.expressions
        } else {
            self.expressions = nil
        }
    }
}

/// The result of a DescribeExpressions request. Contains the expressions configured for the domain specified in the request.
public struct DescribeExpressionsOutputResponse: Swift.Equatable {
    /// The expressions configured for the domain.
    /// This member is required.
    public var expressions: [CloudSearchClientTypes.ExpressionStatus]?

    public init (
        expressions: [CloudSearchClientTypes.ExpressionStatus]? = nil
    )
    {
        self.expressions = expressions
    }
}

struct DescribeExpressionsOutputResponseBody: Swift.Equatable {
    public let expressions: [CloudSearchClientTypes.ExpressionStatus]?
}

extension DescribeExpressionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expressions = "Expressions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeExpressionsResult"))
        if containerValues.contains(.expressions) {
            struct KeyVal0{struct member{}}
            let expressionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .expressions)
            if let expressionsWrappedContainer = expressionsWrappedContainer {
                let expressionsContainer = try expressionsWrappedContainer.decodeIfPresent([CloudSearchClientTypes.ExpressionStatus].self, forKey: .member)
                var expressionsBuffer:[CloudSearchClientTypes.ExpressionStatus]? = nil
                if let expressionsContainer = expressionsContainer {
                    expressionsBuffer = [CloudSearchClientTypes.ExpressionStatus]()
                    for structureContainer0 in expressionsContainer {
                        expressionsBuffer?.append(structureContainer0)
                    }
                }
                expressions = expressionsBuffer
            } else {
                expressions = []
            }
        } else {
            expressions = nil
        }
    }
}

public struct DescribeIndexFieldsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexFieldsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIndexFieldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIndexFieldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexFieldsOutputError>
}

extension DescribeIndexFieldsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIndexFieldsInput(deployed: \(Swift.String(describing: deployed)), domainName: \(Swift.String(describing: domainName)), fieldNames: \(Swift.String(describing: fieldNames)))"}
}

extension DescribeIndexFieldsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let fieldNames = fieldNames {
            var fieldNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FieldNames"))
            for (index0, dynamicfieldname0) in fieldNames.enumerated() {
                try fieldNamesContainer.encode(dynamicfieldname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeIndexFields", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeIndexFieldsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexFieldsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIndexFieldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIndexFieldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexFieldsOutputError>
}

public struct DescribeIndexFieldsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexFieldsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIndexFieldsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIndexFieldsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexFieldsOutputError>
}

public struct DescribeIndexFieldsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexFieldsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeIndexFieldsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeIndexFieldsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexFieldsOutputError>
}

public struct DescribeIndexFieldsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIndexFieldsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeIndexFieldsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeIndexFieldsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIndexFieldsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIndexFieldsOutputError>
}

/// Container for the parameters to the [DescribeIndexFields] operation. Specifies the name of the domain you want to describe. To restrict the response to particular index fields, specify the names of the index fields you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeIndexFieldsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
    public var fieldNames: [Swift.String]?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        fieldNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.fieldNames = fieldNames
    }
}

extension DescribeIndexFieldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeIndexFieldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIndexFieldsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIndexFieldsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIndexFieldsOutputResponse(indexFields: \(Swift.String(describing: indexFields)))"}
}

extension DescribeIndexFieldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIndexFieldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexFields = output.indexFields
        } else {
            self.indexFields = nil
        }
    }
}

/// The result of a DescribeIndexFields request. Contains the index fields configured for the domain specified in the request.
public struct DescribeIndexFieldsOutputResponse: Swift.Equatable {
    /// The index fields configured for the domain.
    /// This member is required.
    public var indexFields: [CloudSearchClientTypes.IndexFieldStatus]?

    public init (
        indexFields: [CloudSearchClientTypes.IndexFieldStatus]? = nil
    )
    {
        self.indexFields = indexFields
    }
}

struct DescribeIndexFieldsOutputResponseBody: Swift.Equatable {
    public let indexFields: [CloudSearchClientTypes.IndexFieldStatus]?
}

extension DescribeIndexFieldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexFields = "IndexFields"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeIndexFieldsResult"))
        if containerValues.contains(.indexFields) {
            struct KeyVal0{struct member{}}
            let indexFieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .indexFields)
            if let indexFieldsWrappedContainer = indexFieldsWrappedContainer {
                let indexFieldsContainer = try indexFieldsWrappedContainer.decodeIfPresent([CloudSearchClientTypes.IndexFieldStatus].self, forKey: .member)
                var indexFieldsBuffer:[CloudSearchClientTypes.IndexFieldStatus]? = nil
                if let indexFieldsContainer = indexFieldsContainer {
                    indexFieldsBuffer = [CloudSearchClientTypes.IndexFieldStatus]()
                    for structureContainer0 in indexFieldsContainer {
                        indexFieldsBuffer?.append(structureContainer0)
                    }
                }
                indexFields = indexFieldsBuffer
            } else {
                indexFields = []
            }
        } else {
            indexFields = nil
        }
    }
}

public struct DescribeScalingParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScalingParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeScalingParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeScalingParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScalingParametersOutputError>
}

extension DescribeScalingParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeScalingParametersInput(domainName: \(Swift.String(describing: domainName)))"}
}

extension DescribeScalingParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeScalingParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeScalingParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScalingParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeScalingParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeScalingParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScalingParametersOutputError>
}

public struct DescribeScalingParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScalingParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeScalingParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeScalingParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScalingParametersOutputError>
}

public struct DescribeScalingParametersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScalingParametersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeScalingParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeScalingParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScalingParametersOutputError>
}

public struct DescribeScalingParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeScalingParametersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeScalingParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeScalingParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeScalingParametersOutputError>
}

/// Container for the parameters to the [DescribeScalingParameters] operation. Specifies the name of the domain you want to describe.
public struct DescribeScalingParametersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension DescribeScalingParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeScalingParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScalingParametersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScalingParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeScalingParametersOutputResponse(scalingParameters: \(Swift.String(describing: scalingParameters)))"}
}

extension DescribeScalingParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeScalingParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scalingParameters = output.scalingParameters
        } else {
            self.scalingParameters = nil
        }
    }
}

/// The result of a DescribeScalingParameters request. Contains the scaling parameters configured for the domain specified in the request.
public struct DescribeScalingParametersOutputResponse: Swift.Equatable {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init (
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

struct DescribeScalingParametersOutputResponseBody: Swift.Equatable {
    public let scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?
}

extension DescribeScalingParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scalingParameters = "ScalingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeScalingParametersResult"))
        let scalingParametersDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ScalingParametersStatus.self, forKey: .scalingParameters)
        scalingParameters = scalingParametersDecoded
    }
}

public struct DescribeServiceAccessPoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceAccessPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceAccessPoliciesOutputError>
}

extension DescribeServiceAccessPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceAccessPoliciesInput(deployed: \(Swift.String(describing: deployed)), domainName: \(Swift.String(describing: domainName)))"}
}

extension DescribeServiceAccessPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeServiceAccessPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeServiceAccessPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceAccessPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceAccessPoliciesOutputError>
}

public struct DescribeServiceAccessPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceAccessPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceAccessPoliciesOutputError>
}

public struct DescribeServiceAccessPoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceAccessPoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeServiceAccessPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServiceAccessPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceAccessPoliciesOutputError>
}

public struct DescribeServiceAccessPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceAccessPoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeServiceAccessPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServiceAccessPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceAccessPoliciesOutputError>
}

/// Container for the parameters to the [DescribeServiceAccessPolicies] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeServiceAccessPoliciesInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeServiceAccessPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeServiceAccessPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceAccessPoliciesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceAccessPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceAccessPoliciesOutputResponse(accessPolicies: \(Swift.String(describing: accessPolicies)))"}
}

extension DescribeServiceAccessPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServiceAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicies = output.accessPolicies
        } else {
            self.accessPolicies = nil
        }
    }
}

/// The result of a DescribeServiceAccessPolicies request.
public struct DescribeServiceAccessPoliciesOutputResponse: Swift.Equatable {
    /// The access rules configured for the domain specified in the request.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init (
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

struct DescribeServiceAccessPoliciesOutputResponseBody: Swift.Equatable {
    public let accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?
}

extension DescribeServiceAccessPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeServiceAccessPoliciesResult"))
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AccessPoliciesStatus.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
    }
}

public struct DescribeSuggestersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSuggestersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSuggestersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSuggestersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSuggestersOutputError>
}

extension DescribeSuggestersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSuggestersInput(deployed: \(Swift.String(describing: deployed)), domainName: \(Swift.String(describing: domainName)), suggesterNames: \(Swift.String(describing: suggesterNames)))"}
}

extension DescribeSuggestersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggesterNames = suggesterNames {
            var suggesterNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SuggesterNames"))
            for (index0, standardname0) in suggesterNames.enumerated() {
                try suggesterNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeSuggesters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeSuggestersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSuggestersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSuggestersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSuggestersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSuggestersOutputError>
}

public struct DescribeSuggestersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSuggestersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSuggestersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSuggestersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSuggestersOutputError>
}

public struct DescribeSuggestersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSuggestersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSuggestersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSuggestersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSuggestersOutputError>
}

public struct DescribeSuggestersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSuggestersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSuggestersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSuggestersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSuggestersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSuggestersOutputError>
}

/// Container for the parameters to the [DescribeSuggester] operation. Specifies the name of the domain you want to describe. To restrict the response to particular suggesters, specify the names of the suggesters you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeSuggestersInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// The suggesters you want to describe.
    public var suggesterNames: [Swift.String]?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        suggesterNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.suggesterNames = suggesterNames
    }
}

extension DescribeSuggestersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSuggestersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSuggestersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSuggestersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSuggestersOutputResponse(suggesters: \(Swift.String(describing: suggesters)))"}
}

extension DescribeSuggestersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSuggestersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suggesters = output.suggesters
        } else {
            self.suggesters = nil
        }
    }
}

/// The result of a DescribeSuggesters request.
public struct DescribeSuggestersOutputResponse: Swift.Equatable {
    /// The suggesters configured for the domain specified in the request.
    /// This member is required.
    public var suggesters: [CloudSearchClientTypes.SuggesterStatus]?

    public init (
        suggesters: [CloudSearchClientTypes.SuggesterStatus]? = nil
    )
    {
        self.suggesters = suggesters
    }
}

struct DescribeSuggestersOutputResponseBody: Swift.Equatable {
    public let suggesters: [CloudSearchClientTypes.SuggesterStatus]?
}

extension DescribeSuggestersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suggesters = "Suggesters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeSuggestersResult"))
        if containerValues.contains(.suggesters) {
            struct KeyVal0{struct member{}}
            let suggestersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .suggesters)
            if let suggestersWrappedContainer = suggestersWrappedContainer {
                let suggestersContainer = try suggestersWrappedContainer.decodeIfPresent([CloudSearchClientTypes.SuggesterStatus].self, forKey: .member)
                var suggestersBuffer:[CloudSearchClientTypes.SuggesterStatus]? = nil
                if let suggestersContainer = suggestersContainer {
                    suggestersBuffer = [CloudSearchClientTypes.SuggesterStatus]()
                    for structureContainer0 in suggestersContainer {
                        suggestersBuffer?.append(structureContainer0)
                    }
                }
                suggesters = suggestersBuffer
            } else {
                suggesters = []
            }
        } else {
            suggesters = nil
        }
    }
}

extension DisabledOperationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisabledOperationException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension DisabledOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DisabledOperationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted an operation which is not enabled.
public struct DisabledOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct DisabledOperationExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension DisabledOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.DocumentSuggesterOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fuzzyMatching = "FuzzyMatching"
        case sortExpression = "SortExpression"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fuzzyMatching = fuzzyMatching {
            try container.encode(fuzzyMatching, forKey: ClientRuntime.Key("FuzzyMatching"))
        }
        if let sortExpression = sortExpression {
            try container.encode(sortExpression, forKey: ClientRuntime.Key("SortExpression"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let fuzzyMatchingDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.SuggesterFuzzyMatching.self, forKey: .fuzzyMatching)
        fuzzyMatching = fuzzyMatchingDecoded
        let sortExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortExpression)
        sortExpression = sortExpressionDecoded
    }
}

extension CloudSearchClientTypes.DocumentSuggesterOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentSuggesterOptions(fuzzyMatching: \(Swift.String(describing: fuzzyMatching)), sortExpression: \(Swift.String(describing: sortExpression)), sourceField: \(Swift.String(describing: sourceField)))"}
}

extension CloudSearchClientTypes {
    /// Options for a search suggester.
    public struct DocumentSuggesterOptions: Swift.Equatable {
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none.
        public var fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching?
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        public var sortExpression: Swift.String?
        /// The name of the index field you want to use for suggestions.
        /// This member is required.
        public var sourceField: Swift.String?

        public init (
            fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching? = nil,
            sortExpression: Swift.String? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.fuzzyMatching = fuzzyMatching
            self.sortExpression = sortExpression
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes.DomainEndpointOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforceHTTPS = "EnforceHTTPS"
        case tLSSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enforceHTTPS = enforceHTTPS {
            try container.encode(enforceHTTPS, forKey: ClientRuntime.Key("EnforceHTTPS"))
        }
        if let tLSSecurityPolicy = tLSSecurityPolicy {
            try container.encode(tLSSecurityPolicy, forKey: ClientRuntime.Key("TLSSecurityPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceHTTPSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceHTTPS)
        enforceHTTPS = enforceHTTPSDecoded
        let tLSSecurityPolicyDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.TLSSecurityPolicy.self, forKey: .tLSSecurityPolicy)
        tLSSecurityPolicy = tLSSecurityPolicyDecoded
    }
}

extension CloudSearchClientTypes.DomainEndpointOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainEndpointOptions(enforceHTTPS: \(Swift.String(describing: enforceHTTPS)), tLSSecurityPolicy: \(Swift.String(describing: tLSSecurityPolicy)))"}
}

extension CloudSearchClientTypes {
    /// The domain's endpoint options.
    public struct DomainEndpointOptions: Swift.Equatable {
        /// Whether the domain is HTTPS only enabled.
        public var enforceHTTPS: Swift.Bool?
        /// The minimum required TLS version
        public var tLSSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy?

        public init (
            enforceHTTPS: Swift.Bool? = nil,
            tLSSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy? = nil
        )
        {
            self.enforceHTTPS = enforceHTTPS
            self.tLSSecurityPolicy = tLSSecurityPolicy
        }
    }

}

extension CloudSearchClientTypes.DomainEndpointOptionsStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainEndpointOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.DomainEndpointOptionsStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainEndpointOptionsStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The configuration and status of the domain's endpoint options.
    public struct DomainEndpointOptionsStatus: Swift.Equatable {
        /// The domain endpoint options configured for the domain.
        /// This member is required.
        public var options: CloudSearchClientTypes.DomainEndpointOptions?
        /// The status of the configured domain endpoint options.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.DomainEndpointOptions? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.DomainStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case created = "Created"
        case deleted = "Deleted"
        case docService = "DocService"
        case domainId = "DomainId"
        case domainName = "DomainName"
        case limits = "Limits"
        case processing = "Processing"
        case requiresIndexDocuments = "RequiresIndexDocuments"
        case searchInstanceCount = "SearchInstanceCount"
        case searchInstanceType = "SearchInstanceType"
        case searchPartitionCount = "SearchPartitionCount"
        case searchService = "SearchService"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let created = created {
            try container.encode(created, forKey: ClientRuntime.Key("Created"))
        }
        if let deleted = deleted {
            try container.encode(deleted, forKey: ClientRuntime.Key("Deleted"))
        }
        if let docService = docService {
            try container.encode(docService, forKey: ClientRuntime.Key("DocService"))
        }
        if let domainId = domainId {
            try container.encode(domainId, forKey: ClientRuntime.Key("DomainId"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let limits = limits {
            try container.encode(limits, forKey: ClientRuntime.Key("Limits"))
        }
        if let processing = processing {
            try container.encode(processing, forKey: ClientRuntime.Key("Processing"))
        }
        if let requiresIndexDocuments = requiresIndexDocuments {
            try container.encode(requiresIndexDocuments, forKey: ClientRuntime.Key("RequiresIndexDocuments"))
        }
        if searchInstanceCount != 0 {
            try container.encode(searchInstanceCount, forKey: ClientRuntime.Key("SearchInstanceCount"))
        }
        if let searchInstanceType = searchInstanceType {
            try container.encode(searchInstanceType, forKey: ClientRuntime.Key("SearchInstanceType"))
        }
        if searchPartitionCount != 0 {
            try container.encode(searchPartitionCount, forKey: ClientRuntime.Key("SearchPartitionCount"))
        }
        if let searchService = searchService {
            try container.encode(searchService, forKey: ClientRuntime.Key("SearchService"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .created)
        created = createdDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let docServiceDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ServiceEndpoint.self, forKey: .docService)
        docService = docServiceDecoded
        let searchServiceDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ServiceEndpoint.self, forKey: .searchService)
        searchService = searchServiceDecoded
        let requiresIndexDocumentsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requiresIndexDocuments)
        requiresIndexDocuments = requiresIndexDocumentsDecoded
        let processingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .processing)
        processing = processingDecoded
        let searchInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchInstanceType)
        searchInstanceType = searchInstanceTypeDecoded
        let searchPartitionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .searchPartitionCount)
        searchPartitionCount = searchPartitionCountDecoded
        let searchInstanceCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .searchInstanceCount)
        searchInstanceCount = searchInstanceCountDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Limits.self, forKey: .limits)
        limits = limitsDecoded
    }
}

extension CloudSearchClientTypes.DomainStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainStatus(aRN: \(Swift.String(describing: aRN)), created: \(Swift.String(describing: created)), deleted: \(Swift.String(describing: deleted)), docService: \(Swift.String(describing: docService)), domainId: \(Swift.String(describing: domainId)), domainName: \(Swift.String(describing: domainName)), limits: \(Swift.String(describing: limits)), processing: \(Swift.String(describing: processing)), requiresIndexDocuments: \(Swift.String(describing: requiresIndexDocuments)), searchInstanceCount: \(Swift.String(describing: searchInstanceCount)), searchInstanceType: \(Swift.String(describing: searchInstanceType)), searchPartitionCount: \(Swift.String(describing: searchPartitionCount)), searchService: \(Swift.String(describing: searchService)))"}
}

extension CloudSearchClientTypes {
    /// The current status of the search domain.
    public struct DomainStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the search domain. See [Identifiers for IAM Entities](http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html) in Using AWS Identity and Access Management for more information.
        public var aRN: Swift.String?
        /// True if the search domain is created. It can take several minutes to initialize a domain when [CreateDomain] is called. Newly created search domains are returned from [DescribeDomains] with a false value for Created until domain creation is complete.
        public var created: Swift.Bool?
        /// True if the search domain has been deleted. The system must clean up resources dedicated to the search domain when [DeleteDomain] is called. Newly deleted search domains are returned from [DescribeDomains] with a true value for IsDeleted for several minutes until resource cleanup is complete.
        public var deleted: Swift.Bool?
        /// The service endpoint for updating documents in a search domain.
        public var docService: CloudSearchClientTypes.ServiceEndpoint?
        /// An internally generated unique identifier for a domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        /// This member is required.
        public var domainName: Swift.String?
        public var limits: CloudSearchClientTypes.Limits?
        /// True if processing is being done to activate the current domain configuration.
        public var processing: Swift.Bool?
        /// True if [IndexDocuments] needs to be called to activate the current domain configuration.
        /// This member is required.
        public var requiresIndexDocuments: Swift.Bool?
        /// The number of search instances that are available to process search requests.
        public var searchInstanceCount: Swift.Int
        /// The instance type that is being used to process search requests.
        public var searchInstanceType: Swift.String?
        /// The number of partitions across which the search index is spread.
        public var searchPartitionCount: Swift.Int
        /// The service endpoint for requesting search results from a search domain.
        public var searchService: CloudSearchClientTypes.ServiceEndpoint?

        public init (
            aRN: Swift.String? = nil,
            created: Swift.Bool? = nil,
            deleted: Swift.Bool? = nil,
            docService: CloudSearchClientTypes.ServiceEndpoint? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            limits: CloudSearchClientTypes.Limits? = nil,
            processing: Swift.Bool? = nil,
            requiresIndexDocuments: Swift.Bool? = nil,
            searchInstanceCount: Swift.Int = 0,
            searchInstanceType: Swift.String? = nil,
            searchPartitionCount: Swift.Int = 0,
            searchService: CloudSearchClientTypes.ServiceEndpoint? = nil
        )
        {
            self.aRN = aRN
            self.created = created
            self.deleted = deleted
            self.docService = docService
            self.domainId = domainId
            self.domainName = domainName
            self.limits = limits
            self.processing = processing
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchInstanceCount = searchInstanceCount
            self.searchInstanceType = searchInstanceType
            self.searchPartitionCount = searchPartitionCount
            self.searchService = searchService
        }
    }

}

extension CloudSearchClientTypes.DoubleArrayOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes.DoubleArrayOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DoubleArrayOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sourceFields: \(Swift.String(describing: sourceFields)))"}
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
    public struct DoubleArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.DoubleOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes.DoubleOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DoubleOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sortEnabled: \(Swift.String(describing: sortEnabled)), sourceField: \(Swift.String(describing: sourceField)))"}
}

extension CloudSearchClientTypes {
    /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
    public struct DoubleOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes.Expression: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expressionName = "ExpressionName"
        case expressionValue = "ExpressionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: ClientRuntime.Key("ExpressionName"))
        }
        if let expressionValue = expressionValue {
            try container.encode(expressionValue, forKey: ClientRuntime.Key("ExpressionValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expressionName)
        expressionName = expressionNameDecoded
        let expressionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expressionValue)
        expressionValue = expressionValueDecoded
    }
}

extension CloudSearchClientTypes.Expression: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Expression(expressionName: \(Swift.String(describing: expressionName)), expressionValue: \(Swift.String(describing: expressionValue)))"}
}

extension CloudSearchClientTypes {
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    public struct Expression: Swift.Equatable {
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var expressionName: Swift.String?
        /// The expression to evaluate for sorting while processing a search request. The Expression syntax is based on JavaScript expressions. For more information, see [Configuring Expressions](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-expressions.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var expressionValue: Swift.String?

        public init (
            expressionName: Swift.String? = nil,
            expressionValue: Swift.String? = nil
        )
        {
            self.expressionName = expressionName
            self.expressionValue = expressionValue
        }
    }

}

extension CloudSearchClientTypes.ExpressionStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Expression.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.ExpressionStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpressionStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The value of an Expression and its current status.
    public struct ExpressionStatus: Swift.Equatable {
        /// The expression that is evaluated for sorting while processing a search request.
        /// This member is required.
        public var options: CloudSearchClientTypes.Expression?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.Expression? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

public struct IndexDocumentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IndexDocumentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IndexDocumentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IndexDocumentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IndexDocumentsOutputError>
}

extension IndexDocumentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexDocumentsInput(domainName: \(Swift.String(describing: domainName)))"}
}

extension IndexDocumentsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("IndexDocuments", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct IndexDocumentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IndexDocumentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IndexDocumentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IndexDocumentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IndexDocumentsOutputError>
}

public struct IndexDocumentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IndexDocumentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IndexDocumentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IndexDocumentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IndexDocumentsOutputError>
}

public struct IndexDocumentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IndexDocumentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: IndexDocumentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = IndexDocumentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IndexDocumentsOutputError>
}

public struct IndexDocumentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IndexDocumentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: IndexDocumentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = IndexDocumentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<IndexDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IndexDocumentsOutputError>
}

/// Container for the parameters to the [IndexDocuments] operation. Specifies the name of the domain you want to re-index.
public struct IndexDocumentsInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension IndexDocumentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension IndexDocumentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IndexDocumentsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IndexDocumentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexDocumentsOutputResponse(fieldNames: \(Swift.String(describing: fieldNames)))"}
}

extension IndexDocumentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IndexDocumentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fieldNames = output.fieldNames
        } else {
            self.fieldNames = nil
        }
    }
}

/// The result of an IndexDocuments request. Contains the status of the indexing operation, including the fields being indexed.
public struct IndexDocumentsOutputResponse: Swift.Equatable {
    /// The names of the fields that are currently being indexed.
    public var fieldNames: [Swift.String]?

    public init (
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

struct IndexDocumentsOutputResponseBody: Swift.Equatable {
    public let fieldNames: [Swift.String]?
}

extension IndexDocumentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldNames = "FieldNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("IndexDocumentsResult"))
        if containerValues.contains(.fieldNames) {
            struct KeyVal0{struct member{}}
            let fieldNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fieldNames)
            if let fieldNamesWrappedContainer = fieldNamesWrappedContainer {
                let fieldNamesContainer = try fieldNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldNamesBuffer:[Swift.String]? = nil
                if let fieldNamesContainer = fieldNamesContainer {
                    fieldNamesBuffer = [Swift.String]()
                    for stringContainer0 in fieldNamesContainer {
                        fieldNamesBuffer?.append(stringContainer0)
                    }
                }
                fieldNames = fieldNamesBuffer
            } else {
                fieldNames = []
            }
        } else {
            fieldNames = nil
        }
    }
}

extension CloudSearchClientTypes.IndexField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateArrayOptions = "DateArrayOptions"
        case dateOptions = "DateOptions"
        case doubleArrayOptions = "DoubleArrayOptions"
        case doubleOptions = "DoubleOptions"
        case indexFieldName = "IndexFieldName"
        case indexFieldType = "IndexFieldType"
        case intArrayOptions = "IntArrayOptions"
        case intOptions = "IntOptions"
        case latLonOptions = "LatLonOptions"
        case literalArrayOptions = "LiteralArrayOptions"
        case literalOptions = "LiteralOptions"
        case textArrayOptions = "TextArrayOptions"
        case textOptions = "TextOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dateArrayOptions = dateArrayOptions {
            try container.encode(dateArrayOptions, forKey: ClientRuntime.Key("DateArrayOptions"))
        }
        if let dateOptions = dateOptions {
            try container.encode(dateOptions, forKey: ClientRuntime.Key("DateOptions"))
        }
        if let doubleArrayOptions = doubleArrayOptions {
            try container.encode(doubleArrayOptions, forKey: ClientRuntime.Key("DoubleArrayOptions"))
        }
        if let doubleOptions = doubleOptions {
            try container.encode(doubleOptions, forKey: ClientRuntime.Key("DoubleOptions"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: ClientRuntime.Key("IndexFieldName"))
        }
        if let indexFieldType = indexFieldType {
            try container.encode(indexFieldType, forKey: ClientRuntime.Key("IndexFieldType"))
        }
        if let intArrayOptions = intArrayOptions {
            try container.encode(intArrayOptions, forKey: ClientRuntime.Key("IntArrayOptions"))
        }
        if let intOptions = intOptions {
            try container.encode(intOptions, forKey: ClientRuntime.Key("IntOptions"))
        }
        if let latLonOptions = latLonOptions {
            try container.encode(latLonOptions, forKey: ClientRuntime.Key("LatLonOptions"))
        }
        if let literalArrayOptions = literalArrayOptions {
            try container.encode(literalArrayOptions, forKey: ClientRuntime.Key("LiteralArrayOptions"))
        }
        if let literalOptions = literalOptions {
            try container.encode(literalOptions, forKey: ClientRuntime.Key("LiteralOptions"))
        }
        if let textArrayOptions = textArrayOptions {
            try container.encode(textArrayOptions, forKey: ClientRuntime.Key("TextArrayOptions"))
        }
        if let textOptions = textOptions {
            try container.encode(textOptions, forKey: ClientRuntime.Key("TextOptions"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
        let indexFieldTypeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexFieldType.self, forKey: .indexFieldType)
        indexFieldType = indexFieldTypeDecoded
        let intOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IntOptions.self, forKey: .intOptions)
        intOptions = intOptionsDecoded
        let doubleOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DoubleOptions.self, forKey: .doubleOptions)
        doubleOptions = doubleOptionsDecoded
        let literalOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.LiteralOptions.self, forKey: .literalOptions)
        literalOptions = literalOptionsDecoded
        let textOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.TextOptions.self, forKey: .textOptions)
        textOptions = textOptionsDecoded
        let dateOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DateOptions.self, forKey: .dateOptions)
        dateOptions = dateOptionsDecoded
        let latLonOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.LatLonOptions.self, forKey: .latLonOptions)
        latLonOptions = latLonOptionsDecoded
        let intArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IntArrayOptions.self, forKey: .intArrayOptions)
        intArrayOptions = intArrayOptionsDecoded
        let doubleArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DoubleArrayOptions.self, forKey: .doubleArrayOptions)
        doubleArrayOptions = doubleArrayOptionsDecoded
        let literalArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.LiteralArrayOptions.self, forKey: .literalArrayOptions)
        literalArrayOptions = literalArrayOptionsDecoded
        let textArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.TextArrayOptions.self, forKey: .textArrayOptions)
        textArrayOptions = textArrayOptionsDecoded
        let dateArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DateArrayOptions.self, forKey: .dateArrayOptions)
        dateArrayOptions = dateArrayOptionsDecoded
    }
}

extension CloudSearchClientTypes.IndexField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexField(dateArrayOptions: \(Swift.String(describing: dateArrayOptions)), dateOptions: \(Swift.String(describing: dateOptions)), doubleArrayOptions: \(Swift.String(describing: doubleArrayOptions)), doubleOptions: \(Swift.String(describing: doubleOptions)), indexFieldName: \(Swift.String(describing: indexFieldName)), indexFieldType: \(Swift.String(describing: indexFieldType)), intArrayOptions: \(Swift.String(describing: intArrayOptions)), intOptions: \(Swift.String(describing: intOptions)), latLonOptions: \(Swift.String(describing: latLonOptions)), literalArrayOptions: \(Swift.String(describing: literalArrayOptions)), literalOptions: \(Swift.String(describing: literalOptions)), textArrayOptions: \(Swift.String(describing: textArrayOptions)), textOptions: \(Swift.String(describing: textOptions)))"}
}

extension CloudSearchClientTypes {
    /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
    public struct IndexField: Swift.Equatable {
        /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
        public var dateArrayOptions: CloudSearchClientTypes.DateArrayOptions?
        /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
        public var dateOptions: CloudSearchClientTypes.DateOptions?
        /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
        public var doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions?
        /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
        public var doubleOptions: CloudSearchClientTypes.DoubleOptions?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        /// This member is required.
        public var indexFieldName: Swift.String?
        /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var indexFieldType: CloudSearchClientTypes.IndexFieldType?
        /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
        public var intArrayOptions: CloudSearchClientTypes.IntArrayOptions?
        /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
        public var intOptions: CloudSearchClientTypes.IntOptions?
        /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
        public var latLonOptions: CloudSearchClientTypes.LatLonOptions?
        /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
        public var literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions?
        /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
        public var literalOptions: CloudSearchClientTypes.LiteralOptions?
        /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
        public var textArrayOptions: CloudSearchClientTypes.TextArrayOptions?
        /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
        public var textOptions: CloudSearchClientTypes.TextOptions?

        public init (
            dateArrayOptions: CloudSearchClientTypes.DateArrayOptions? = nil,
            dateOptions: CloudSearchClientTypes.DateOptions? = nil,
            doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions? = nil,
            doubleOptions: CloudSearchClientTypes.DoubleOptions? = nil,
            indexFieldName: Swift.String? = nil,
            indexFieldType: CloudSearchClientTypes.IndexFieldType? = nil,
            intArrayOptions: CloudSearchClientTypes.IntArrayOptions? = nil,
            intOptions: CloudSearchClientTypes.IntOptions? = nil,
            latLonOptions: CloudSearchClientTypes.LatLonOptions? = nil,
            literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions? = nil,
            literalOptions: CloudSearchClientTypes.LiteralOptions? = nil,
            textArrayOptions: CloudSearchClientTypes.TextArrayOptions? = nil,
            textOptions: CloudSearchClientTypes.TextOptions? = nil
        )
        {
            self.dateArrayOptions = dateArrayOptions
            self.dateOptions = dateOptions
            self.doubleArrayOptions = doubleArrayOptions
            self.doubleOptions = doubleOptions
            self.indexFieldName = indexFieldName
            self.indexFieldType = indexFieldType
            self.intArrayOptions = intArrayOptions
            self.intOptions = intOptions
            self.latLonOptions = latLonOptions
            self.literalArrayOptions = literalArrayOptions
            self.literalOptions = literalOptions
            self.textArrayOptions = textArrayOptions
            self.textOptions = textOptions
        }
    }

}

extension CloudSearchClientTypes.IndexFieldStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexField.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.IndexFieldStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexFieldStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The value of an IndexField and its current status.
    public struct IndexFieldStatus: Swift.Equatable {
        /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
        /// This member is required.
        public var options: CloudSearchClientTypes.IndexField?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.IndexField? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
    public enum IndexFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case dateArray
        case double
        case doubleArray
        case int
        case intArray
        case latlon
        case literal
        case literalArray
        case text
        case textArray
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexFieldType] {
            return [
                .date,
                .dateArray,
                .double,
                .doubleArray,
                .int,
                .intArray,
                .latlon,
                .literal,
                .literalArray,
                .text,
                .textArray,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "date"
            case .dateArray: return "date-array"
            case .double: return "double"
            case .doubleArray: return "double-array"
            case .int: return "int"
            case .intArray: return "int-array"
            case .latlon: return "latlon"
            case .literal: return "literal"
            case .literalArray: return "literal-array"
            case .text: return "text"
            case .textArray: return "text-array"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IndexFieldType(rawValue: rawValue) ?? IndexFieldType.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.IntArrayOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes.IntArrayOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntArrayOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sourceFields: \(Swift.String(describing: sourceFields)))"}
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
    public struct IntArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.IntOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes.IntOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sortEnabled: \(Swift.String(describing: sortEnabled)), sourceField: \(Swift.String(describing: sourceField)))"}
}

extension CloudSearchClientTypes {
    /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
    public struct IntOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension InternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InternalExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error occurred while processing the request. If this problem persists, report an issue from the [Service Health Dashboard](http://status.aws.amazon.com/).
public struct InternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTypeException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTypeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it specified an invalid type definition.
public struct InvalidTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidTypeExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InvalidTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.LatLonOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes.LatLonOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LatLonOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sortEnabled: \(Swift.String(describing: sortEnabled)), sourceField: \(Swift.String(describing: sourceField)))"}
}

extension CloudSearchClientTypes {
    /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
    public struct LatLonOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because a resource limit has already been met.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.Limits: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumPartitionCount = "MaximumPartitionCount"
        case maximumReplicationCount = "MaximumReplicationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if maximumPartitionCount != 0 {
            try container.encode(maximumPartitionCount, forKey: ClientRuntime.Key("MaximumPartitionCount"))
        }
        if maximumReplicationCount != 0 {
            try container.encode(maximumReplicationCount, forKey: ClientRuntime.Key("MaximumReplicationCount"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumReplicationCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maximumReplicationCount)
        maximumReplicationCount = maximumReplicationCountDecoded
        let maximumPartitionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maximumPartitionCount)
        maximumPartitionCount = maximumPartitionCountDecoded
    }
}

extension CloudSearchClientTypes.Limits: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Limits(maximumPartitionCount: \(Swift.String(describing: maximumPartitionCount)), maximumReplicationCount: \(Swift.String(describing: maximumReplicationCount)))"}
}

extension CloudSearchClientTypes {
    public struct Limits: Swift.Equatable {
        /// This member is required.
        public var maximumPartitionCount: Swift.Int
        /// This member is required.
        public var maximumReplicationCount: Swift.Int

        public init (
            maximumPartitionCount: Swift.Int = 0,
            maximumReplicationCount: Swift.Int = 0
        )
        {
            self.maximumPartitionCount = maximumPartitionCount
            self.maximumReplicationCount = maximumReplicationCount
        }
    }

}

public struct ListDomainNamesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainNamesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainNamesOutputError>
}

extension ListDomainNamesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainNamesInput()"}
}

extension ListDomainNamesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListDomainNames", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListDomainNamesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainNamesOutputError>
}

public struct ListDomainNamesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainNamesOutputError>
}

public struct ListDomainNamesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainNamesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDomainNamesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDomainNamesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainNamesOutputError>
}

public struct ListDomainNamesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainNamesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDomainNamesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDomainNamesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainNamesOutputError>
}

public struct ListDomainNamesInput: Swift.Equatable {

    public init() {}
}

extension ListDomainNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDomainNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainNamesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainNamesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainNamesOutputResponse(domainNames: \(Swift.String(describing: domainNames)))"}
}

extension ListDomainNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainNames = output.domainNames
        } else {
            self.domainNames = nil
        }
    }
}

/// The result of a ListDomainNames request. Contains a list of the domains owned by an account.
public struct ListDomainNamesOutputResponse: Swift.Equatable {
    /// The names of the search domains owned by an account.
    public var domainNames: [Swift.String:Swift.String]?

    public init (
        domainNames: [Swift.String:Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

struct ListDomainNamesOutputResponseBody: Swift.Equatable {
    public let domainNames: [Swift.String:Swift.String]?
}

extension ListDomainNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNames = "DomainNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListDomainNamesResult"))
        if containerValues.contains(.domainNames) {
            struct KeyVal0{struct key{}; struct value{}}
            let domainNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .domainNames)
            if let domainNamesWrappedContainer = domainNamesWrappedContainer {
                let domainNamesContainer = try domainNamesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var domainNamesBuffer: [Swift.String:Swift.String]? = nil
                if let domainNamesContainer = domainNamesContainer {
                    domainNamesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in domainNamesContainer {
                        domainNamesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                domainNames = domainNamesBuffer
            } else {
                domainNames = [:]
            }
        } else {
            domainNames = nil
        }
    }
}

extension CloudSearchClientTypes.LiteralArrayOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes.LiteralArrayOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LiteralArrayOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sourceFields: \(Swift.String(describing: sourceFields)))"}
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
    public struct LiteralArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.LiteralOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes.LiteralOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LiteralOptions(defaultValue: \(Swift.String(describing: defaultValue)), facetEnabled: \(Swift.String(describing: facetEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), searchEnabled: \(Swift.String(describing: searchEnabled)), sortEnabled: \(Swift.String(describing: sortEnabled)), sourceField: \(Swift.String(describing: sourceField)))"}
}

extension CloudSearchClientTypes {
    /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
    public struct LiteralOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// The state of processing a change to an option. One of:
    ///
    /// * RequiresIndexDocuments: The option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
    ///
    /// * Processing: The option's latest value is in the process of being activated.
    ///
    /// * Active: The option's latest value is fully deployed.
    ///
    /// * FailedToValidate: The option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
    public enum OptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failedtovalidate
        case processing
        case requiresindexdocuments
        case sdkUnknown(Swift.String)

        public static var allCases: [OptionState] {
            return [
                .active,
                .failedtovalidate,
                .processing,
                .requiresindexdocuments,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failedtovalidate: return "FailedToValidate"
            case .processing: return "Processing"
            case .requiresindexdocuments: return "RequiresIndexDocuments"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptionState(rawValue: rawValue) ?? OptionState.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.OptionStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case pendingDeletion = "PendingDeletion"
        case state = "State"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let creationDate = creationDate {
            try container.encode(ClientRuntime.TimestampWrapper(creationDate, format: .dateTime), forKey: ClientRuntime.Key("creationDate"))
        }
        if let pendingDeletion = pendingDeletion {
            try container.encode(pendingDeletion, forKey: ClientRuntime.Key("PendingDeletion"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let updateDate = updateDate {
            try container.encode(ClientRuntime.TimestampWrapper(updateDate, format: .dateTime), forKey: ClientRuntime.Key("updateDate"))
        }
        if updateVersion != 0 {
            try container.encode(updateVersion, forKey: ClientRuntime.Key("UpdateVersion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        var creationDateBuffer:ClientRuntime.Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
        let updateDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDate)
        var updateDateBuffer:ClientRuntime.Date? = nil
        if let updateDateDecoded = updateDateDecoded {
            updateDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(updateDateDecoded, format: .dateTime)
        }
        updateDate = updateDateBuffer
        let updateVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionState.self, forKey: .state)
        state = stateDecoded
        let pendingDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pendingDeletion)
        pendingDeletion = pendingDeletionDecoded
    }
}

extension CloudSearchClientTypes.OptionStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionStatus(creationDate: \(Swift.String(describing: creationDate)), pendingDeletion: \(Swift.String(describing: pendingDeletion)), state: \(Swift.String(describing: state)), updateDate: \(Swift.String(describing: updateDate)), updateVersion: \(Swift.String(describing: updateVersion)))"}
}

extension CloudSearchClientTypes {
    /// The status of domain configuration option.
    public struct OptionStatus: Swift.Equatable {
        /// A timestamp for when this option was created.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// Indicates that the option will be deleted once processing is complete.
        public var pendingDeletion: Swift.Bool?
        /// The state of processing a change to an option. Possible values:
        ///
        /// * RequiresIndexDocuments: the option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
        ///
        /// * Processing: the option's latest value is in the process of being activated.
        ///
        /// * Active: the option's latest value is completely deployed.
        ///
        /// * FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
        /// This member is required.
        public var state: CloudSearchClientTypes.OptionState?
        /// A timestamp for when this option was last updated.
        /// This member is required.
        public var updateDate: ClientRuntime.Date?
        /// A unique integer that indicates when this option was last updated.
        public var updateVersion: Swift.Int

        public init (
            creationDate: ClientRuntime.Date? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: CloudSearchClientTypes.OptionState? = nil,
            updateDate: ClientRuntime.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension CloudSearchClientTypes {
    /// The instance type (such as search.m1.small) on which an index partition is hosted.
    public enum PartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case search2xlarge
        case searchLarge
        case searchM1Large
        case searchM1Small
        case searchM22xlarge
        case searchM2Xlarge
        case searchM32xlarge
        case searchM3Large
        case searchM3Medium
        case searchM3Xlarge
        case searchMedium
        case searchPreviousgeneration2xlarge
        case searchPreviousgenerationLarge
        case searchPreviousgenerationSmall
        case searchPreviousgenerationXlarge
        case searchSmall
        case searchXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [PartitionInstanceType] {
            return [
                .search2xlarge,
                .searchLarge,
                .searchM1Large,
                .searchM1Small,
                .searchM22xlarge,
                .searchM2Xlarge,
                .searchM32xlarge,
                .searchM3Large,
                .searchM3Medium,
                .searchM3Xlarge,
                .searchMedium,
                .searchPreviousgeneration2xlarge,
                .searchPreviousgenerationLarge,
                .searchPreviousgenerationSmall,
                .searchPreviousgenerationXlarge,
                .searchSmall,
                .searchXlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .search2xlarge: return "search.2xlarge"
            case .searchLarge: return "search.large"
            case .searchM1Large: return "search.m1.large"
            case .searchM1Small: return "search.m1.small"
            case .searchM22xlarge: return "search.m2.2xlarge"
            case .searchM2Xlarge: return "search.m2.xlarge"
            case .searchM32xlarge: return "search.m3.2xlarge"
            case .searchM3Large: return "search.m3.large"
            case .searchM3Medium: return "search.m3.medium"
            case .searchM3Xlarge: return "search.m3.xlarge"
            case .searchMedium: return "search.medium"
            case .searchPreviousgeneration2xlarge: return "search.previousgeneration.2xlarge"
            case .searchPreviousgenerationLarge: return "search.previousgeneration.large"
            case .searchPreviousgenerationSmall: return "search.previousgeneration.small"
            case .searchPreviousgenerationXlarge: return "search.previousgeneration.xlarge"
            case .searchSmall: return "search.small"
            case .searchXlarge: return "search.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartitionInstanceType(rawValue: rawValue) ?? PartitionInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to reference a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.ScalingParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredInstanceType = "DesiredInstanceType"
        case desiredPartitionCount = "DesiredPartitionCount"
        case desiredReplicationCount = "DesiredReplicationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let desiredInstanceType = desiredInstanceType {
            try container.encode(desiredInstanceType, forKey: ClientRuntime.Key("DesiredInstanceType"))
        }
        if desiredPartitionCount != 0 {
            try container.encode(desiredPartitionCount, forKey: ClientRuntime.Key("DesiredPartitionCount"))
        }
        if desiredReplicationCount != 0 {
            try container.encode(desiredReplicationCount, forKey: ClientRuntime.Key("DesiredReplicationCount"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredInstanceTypeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.PartitionInstanceType.self, forKey: .desiredInstanceType)
        desiredInstanceType = desiredInstanceTypeDecoded
        let desiredReplicationCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .desiredReplicationCount)
        desiredReplicationCount = desiredReplicationCountDecoded
        let desiredPartitionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .desiredPartitionCount)
        desiredPartitionCount = desiredPartitionCountDecoded
    }
}

extension CloudSearchClientTypes.ScalingParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScalingParameters(desiredInstanceType: \(Swift.String(describing: desiredInstanceType)), desiredPartitionCount: \(Swift.String(describing: desiredPartitionCount)), desiredReplicationCount: \(Swift.String(describing: desiredReplicationCount)))"}
}

extension CloudSearchClientTypes {
    /// The desired instance type and desired number of replicas of each index partition.
    public struct ScalingParameters: Swift.Equatable {
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        public var desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType?
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        public var desiredPartitionCount: Swift.Int
        /// The number of replicas you want to preconfigure for each index partition.
        public var desiredReplicationCount: Swift.Int

        public init (
            desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType? = nil,
            desiredPartitionCount: Swift.Int = 0,
            desiredReplicationCount: Swift.Int = 0
        )
        {
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
            self.desiredReplicationCount = desiredReplicationCount
        }
    }

}

extension CloudSearchClientTypes.ScalingParametersStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ScalingParameters.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.ScalingParametersStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScalingParametersStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The status and configuration of a search domain's scaling parameters.
    public struct ScalingParametersStatus: Swift.Equatable {
        /// The desired instance type and desired number of replicas of each index partition.
        /// This member is required.
        public var options: CloudSearchClientTypes.ScalingParameters?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.ScalingParameters? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.ServiceEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension CloudSearchClientTypes.ServiceEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceEndpoint(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension CloudSearchClientTypes {
    /// The endpoint to which service requests can be submitted.
    public struct ServiceEndpoint: Swift.Equatable {
        /// The endpoint to which service requests can be submitted. For example, search-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com or doc-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com.
        public var endpoint: Swift.String?

        public init (
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension CloudSearchClientTypes.Suggester: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentSuggesterOptions = "DocumentSuggesterOptions"
        case suggesterName = "SuggesterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let documentSuggesterOptions = documentSuggesterOptions {
            try container.encode(documentSuggesterOptions, forKey: ClientRuntime.Key("DocumentSuggesterOptions"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: ClientRuntime.Key("SuggesterName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suggesterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suggesterName)
        suggesterName = suggesterNameDecoded
        let documentSuggesterOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DocumentSuggesterOptions.self, forKey: .documentSuggesterOptions)
        documentSuggesterOptions = documentSuggesterOptionsDecoded
    }
}

extension CloudSearchClientTypes.Suggester: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Suggester(documentSuggesterOptions: \(Swift.String(describing: documentSuggesterOptions)), suggesterName: \(Swift.String(describing: suggesterName)))"}
}

extension CloudSearchClientTypes {
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    public struct Suggester: Swift.Equatable {
        /// Options for a search suggester.
        /// This member is required.
        public var documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var suggesterName: Swift.String?

        public init (
            documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions? = nil,
            suggesterName: Swift.String? = nil
        )
        {
            self.documentSuggesterOptions = documentSuggesterOptions
            self.suggesterName = suggesterName
        }
    }

}

extension CloudSearchClientTypes {
    public enum SuggesterFuzzyMatching: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggesterFuzzyMatching] {
            return [
                .high,
                .low,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SuggesterFuzzyMatching(rawValue: rawValue) ?? SuggesterFuzzyMatching.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.SuggesterStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Suggester.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes.SuggesterStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggesterStatus(options: \(Swift.String(describing: options)), status: \(Swift.String(describing: status)))"}
}

extension CloudSearchClientTypes {
    /// The value of a Suggester and its current status.
    public struct SuggesterStatus: Swift.Equatable {
        /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
        /// This member is required.
        public var options: CloudSearchClientTypes.Suggester?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.Suggester? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    /// The minimum required TLS version.
    public enum TLSSecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyMinTls10201907
        case policyMinTls12201907
        case sdkUnknown(Swift.String)

        public static var allCases: [TLSSecurityPolicy] {
            return [
                .policyMinTls10201907,
                .policyMinTls12201907,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyMinTls10201907: return "Policy-Min-TLS-1-0-2019-07"
            case .policyMinTls12201907: return "Policy-Min-TLS-1-2-2019-07"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TLSSecurityPolicy(rawValue: rawValue) ?? TLSSecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.TextArrayOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: ClientRuntime.Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let highlightEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .highlightEnabled)
        highlightEnabled = highlightEnabledDecoded
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension CloudSearchClientTypes.TextArrayOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextArrayOptions(analysisScheme: \(Swift.String(describing: analysisScheme)), defaultValue: \(Swift.String(describing: defaultValue)), highlightEnabled: \(Swift.String(describing: highlightEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), sourceFields: \(Swift.String(describing: sourceFields)))"}
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
    public struct TextArrayOptions: Swift.Equatable {
        /// The name of an analysis scheme for a text-array field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.TextOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: ClientRuntime.Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
        let highlightEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .highlightEnabled)
        highlightEnabled = highlightEnabledDecoded
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension CloudSearchClientTypes.TextOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextOptions(analysisScheme: \(Swift.String(describing: analysisScheme)), defaultValue: \(Swift.String(describing: defaultValue)), highlightEnabled: \(Swift.String(describing: highlightEnabled)), returnEnabled: \(Swift.String(describing: returnEnabled)), sortEnabled: \(Swift.String(describing: sortEnabled)), sourceField: \(Swift.String(describing: sourceField)))"}
}

extension CloudSearchClientTypes {
    /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
    public struct TextOptions: Swift.Equatable {
        /// The name of an analysis scheme for a text field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

public struct UpdateAvailabilityOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAvailabilityOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAvailabilityOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAvailabilityOptionsOutputError>
}

extension UpdateAvailabilityOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAvailabilityOptionsInput(domainName: \(Swift.String(describing: domainName)), multiAZ: \(Swift.String(describing: multiAZ)))"}
}

extension UpdateAvailabilityOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        try container.encode("UpdateAvailabilityOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct UpdateAvailabilityOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAvailabilityOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAvailabilityOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAvailabilityOptionsOutputError>
}

public struct UpdateAvailabilityOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAvailabilityOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAvailabilityOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAvailabilityOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAvailabilityOptionsOutputError>
}

public struct UpdateAvailabilityOptionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAvailabilityOptionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAvailabilityOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAvailabilityOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAvailabilityOptionsOutputError>
}

public struct UpdateAvailabilityOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAvailabilityOptionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAvailabilityOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAvailabilityOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAvailabilityOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAvailabilityOptionsOutputError>
}

/// Container for the parameters to the [UpdateAvailabilityOptions] operation. Specifies the name of the domain you want to update and the Multi-AZ availability option.
public struct UpdateAvailabilityOptionsInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false.
    /// This member is required.
    public var multiAZ: Swift.Bool?

    public init (
        domainName: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.multiAZ = multiAZ
    }
}

extension UpdateAvailabilityOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAvailabilityOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAvailabilityOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAvailabilityOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAvailabilityOptionsOutputResponse(availabilityOptions: \(Swift.String(describing: availabilityOptions)))"}
}

extension UpdateAvailabilityOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAvailabilityOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityOptions = output.availabilityOptions
        } else {
            self.availabilityOptions = nil
        }
    }
}

/// The result of a UpdateAvailabilityOptions request. Contains the status of the domain's availability options.
public struct UpdateAvailabilityOptionsOutputResponse: Swift.Equatable {
    /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init (
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

struct UpdateAvailabilityOptionsOutputResponseBody: Swift.Equatable {
    public let availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?
}

extension UpdateAvailabilityOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityOptions = "AvailabilityOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateAvailabilityOptionsResult"))
        let availabilityOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AvailabilityOptionsStatus.self, forKey: .availabilityOptions)
        availabilityOptions = availabilityOptionsDecoded
    }
}

public struct UpdateDomainEndpointOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainEndpointOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainEndpointOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainEndpointOptionsOutputError>
}

extension UpdateDomainEndpointOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainEndpointOptionsInput(domainEndpointOptions: \(Swift.String(describing: domainEndpointOptions)), domainName: \(Swift.String(describing: domainName)))"}
}

extension UpdateDomainEndpointOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainEndpointOptions = domainEndpointOptions {
            try container.encode(domainEndpointOptions, forKey: ClientRuntime.Key("DomainEndpointOptions"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("UpdateDomainEndpointOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct UpdateDomainEndpointOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainEndpointOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainEndpointOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainEndpointOptionsOutputError>
}

public struct UpdateDomainEndpointOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainEndpointOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainEndpointOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainEndpointOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainEndpointOptionsOutputError>
}

public struct UpdateDomainEndpointOptionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainEndpointOptionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDomainEndpointOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDomainEndpointOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainEndpointOptionsOutputError>
}

public struct UpdateDomainEndpointOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainEndpointOptionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDomainEndpointOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDomainEndpointOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainEndpointOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainEndpointOptionsOutputError>
}

/// Container for the parameters to the [UpdateDomainEndpointOptions] operation. Specifies the name of the domain you want to update and the domain endpoint options.
public struct UpdateDomainEndpointOptionsInput: Swift.Equatable {
    /// Whether to require that all requests to the domain arrive over HTTPS. We recommend Policy-Min-TLS-1-2-2019-07 for TLSSecurityPolicy. For compatibility with older clients, the default is Policy-Min-TLS-1-0-2019-07.
    /// This member is required.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
    }
}

extension UpdateDomainEndpointOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateDomainEndpointOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainEndpointOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainEndpointOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainEndpointOptionsOutputResponse(domainEndpointOptions: \(Swift.String(describing: domainEndpointOptions)))"}
}

extension UpdateDomainEndpointOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDomainEndpointOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainEndpointOptions = output.domainEndpointOptions
        } else {
            self.domainEndpointOptions = nil
        }
    }
}

/// The result of a UpdateDomainEndpointOptions request. Contains the configuration and status of the domain's endpoint options.
public struct UpdateDomainEndpointOptionsOutputResponse: Swift.Equatable {
    /// The newly-configured domain endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init (
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

struct UpdateDomainEndpointOptionsOutputResponseBody: Swift.Equatable {
    public let domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?
}

extension UpdateDomainEndpointOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateDomainEndpointOptionsResult"))
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainEndpointOptionsStatus.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
    }
}

public struct UpdateScalingParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateScalingParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateScalingParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateScalingParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateScalingParametersOutputError>
}

extension UpdateScalingParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateScalingParametersInput(domainName: \(Swift.String(describing: domainName)), scalingParameters: \(Swift.String(describing: scalingParameters)))"}
}

extension UpdateScalingParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let scalingParameters = scalingParameters {
            try container.encode(scalingParameters, forKey: ClientRuntime.Key("ScalingParameters"))
        }
        try container.encode("UpdateScalingParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct UpdateScalingParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateScalingParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateScalingParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateScalingParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateScalingParametersOutputError>
}

public struct UpdateScalingParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateScalingParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateScalingParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateScalingParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateScalingParametersOutputError>
}

public struct UpdateScalingParametersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateScalingParametersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateScalingParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateScalingParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateScalingParametersOutputError>
}

public struct UpdateScalingParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateScalingParametersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateScalingParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateScalingParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateScalingParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateScalingParametersOutputError>
}

/// Container for the parameters to the [UpdateScalingParameters] operation. Specifies the name of the domain you want to update and the scaling parameters you want to configure.
public struct UpdateScalingParametersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The desired instance type and desired number of replicas of each index partition.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParameters?

    public init (
        domainName: Swift.String? = nil,
        scalingParameters: CloudSearchClientTypes.ScalingParameters? = nil
    )
    {
        self.domainName = domainName
        self.scalingParameters = scalingParameters
    }
}

extension UpdateScalingParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateScalingParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateScalingParametersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScalingParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateScalingParametersOutputResponse(scalingParameters: \(Swift.String(describing: scalingParameters)))"}
}

extension UpdateScalingParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateScalingParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scalingParameters = output.scalingParameters
        } else {
            self.scalingParameters = nil
        }
    }
}

/// The result of a UpdateScalingParameters request. Contains the status of the newly-configured scaling parameters.
public struct UpdateScalingParametersOutputResponse: Swift.Equatable {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init (
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

struct UpdateScalingParametersOutputResponseBody: Swift.Equatable {
    public let scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?
}

extension UpdateScalingParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scalingParameters = "ScalingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateScalingParametersResult"))
        let scalingParametersDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ScalingParametersStatus.self, forKey: .scalingParameters)
        scalingParameters = scalingParametersDecoded
    }
}

public struct UpdateServiceAccessPoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceAccessPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceAccessPoliciesOutputError>
}

extension UpdateServiceAccessPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceAccessPoliciesInput(accessPolicies: \(Swift.String(describing: accessPolicies)), domainName: \(Swift.String(describing: domainName)))"}
}

extension UpdateServiceAccessPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessPolicies = accessPolicies {
            try container.encode(accessPolicies, forKey: ClientRuntime.Key("AccessPolicies"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("UpdateServiceAccessPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct UpdateServiceAccessPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceAccessPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceAccessPoliciesOutputError>
}

public struct UpdateServiceAccessPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceAccessPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceAccessPoliciesOutputError>
}

public struct UpdateServiceAccessPoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceAccessPoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceAccessPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceAccessPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceAccessPoliciesOutputError>
}

public struct UpdateServiceAccessPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceAccessPoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceAccessPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceAccessPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceAccessPoliciesOutputError>
}

/// Container for the parameters to the [UpdateServiceAccessPolicies] operation. Specifies the name of the domain you want to update and the access rules you want to configure.
public struct UpdateServiceAccessPoliciesInput: Swift.Equatable {
    /// The access rules you want to configure. These rules replace any existing rules.
    /// This member is required.
    public var accessPolicies: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        accessPolicies: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.domainName = domainName
    }
}

extension UpdateServiceAccessPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateServiceAccessPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceAccessPoliciesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceAccessPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceAccessPoliciesOutputResponse(accessPolicies: \(Swift.String(describing: accessPolicies)))"}
}

extension UpdateServiceAccessPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicies = output.accessPolicies
        } else {
            self.accessPolicies = nil
        }
    }
}

/// The result of an UpdateServiceAccessPolicies request. Contains the new access policies.
public struct UpdateServiceAccessPoliciesOutputResponse: Swift.Equatable {
    /// The access rules configured for the domain.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init (
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

struct UpdateServiceAccessPoliciesOutputResponseBody: Swift.Equatable {
    public let accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?
}

extension UpdateServiceAccessPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateServiceAccessPoliciesResult"))
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AccessPoliciesStatus.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ValidationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it has invalid parameters.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
