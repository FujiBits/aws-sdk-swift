// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct CreateContainerRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContainerRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContainerRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInputBodyMiddleware: Middleware {
    public let id: String = "CreateContainerRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerRecipeOutputError>
}

extension CreateContainerRecipeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let containerType = containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let dockerfileTemplateUri = dockerfileTemplateUri {
            try encodeContainer.encode(dockerfileTemplateUri, forKey: .dockerfileTemplateUri)
        }
        if let imageOsVersionOverride = imageOsVersionOverride {
            try encodeContainer.encode(imageOsVersionOverride, forKey: .imageOsVersionOverride)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platformOverride = platformOverride {
            try encodeContainer.encode(platformOverride.rawValue, forKey: .platformOverride)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}
