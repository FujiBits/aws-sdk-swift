// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IotEventsClientTypes.AcknowledgeFlow: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension IotEventsClientTypes.AcknowledgeFlow: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcknowledgeFlow(enabled: \(Swift.String(describing: enabled)))"}
}

extension IotEventsClientTypes {
    /// <p>Specifies whether to get notified for alarm state changes.</p>
    public struct AcknowledgeFlow: Swift.Equatable {
        /// <p>The value must be <code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, you
        ///       receive a notification when the alarm state changes. You must choose to acknowledge the
        ///       notification before the alarm state can return to <code>NORMAL</code>. If <code>FALSE</code>,
        ///       you won't receive notifications. The alarm automatically changes to the <code>NORMAL</code>
        ///       state when the input property value returns to the specified range.</p>
        public let enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension IotEventsClientTypes.Action: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clearTimer
        case dynamoDB
        case dynamoDBv2
        case firehose
        case iotEvents
        case iotSiteWise
        case iotTopicPublish
        case lambda
        case resetTimer
        case setTimer
        case setVariable
        case sns
        case sqs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clearTimer = clearTimer {
            try encodeContainer.encode(clearTimer, forKey: .clearTimer)
        }
        if let dynamoDB = dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let iotEvents = iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let iotTopicPublish = iotTopicPublish {
            try encodeContainer.encode(iotTopicPublish, forKey: .iotTopicPublish)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let resetTimer = resetTimer {
            try encodeContainer.encode(resetTimer, forKey: .resetTimer)
        }
        if let setTimer = setTimer {
            try encodeContainer.encode(setTimer, forKey: .setTimer)
        }
        if let setVariable = setVariable {
            try encodeContainer.encode(setVariable, forKey: .setVariable)
        }
        if let sns = sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let setVariableDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SetVariableAction.self, forKey: .setVariable)
        setVariable = setVariableDecoded
        let snsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SNSTopicPublishAction.self, forKey: .sns)
        sns = snsDecoded
        let iotTopicPublishDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotTopicPublishAction.self, forKey: .iotTopicPublish)
        iotTopicPublish = iotTopicPublishDecoded
        let setTimerDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SetTimerAction.self, forKey: .setTimer)
        setTimer = setTimerDecoded
        let clearTimerDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.ClearTimerAction.self, forKey: .clearTimer)
        clearTimer = clearTimerDecoded
        let resetTimerDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.ResetTimerAction.self, forKey: .resetTimer)
        resetTimer = resetTimerDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let dynamoDBDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
    }
}

extension IotEventsClientTypes.Action: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Action(clearTimer: \(Swift.String(describing: clearTimer)), dynamoDB: \(Swift.String(describing: dynamoDB)), dynamoDBv2: \(Swift.String(describing: dynamoDBv2)), firehose: \(Swift.String(describing: firehose)), iotEvents: \(Swift.String(describing: iotEvents)), iotSiteWise: \(Swift.String(describing: iotSiteWise)), iotTopicPublish: \(Swift.String(describing: iotTopicPublish)), lambda: \(Swift.String(describing: lambda)), resetTimer: \(Swift.String(describing: resetTimer)), setTimer: \(Swift.String(describing: setTimer)), setVariable: \(Swift.String(describing: setVariable)), sns: \(Swift.String(describing: sns)), sqs: \(Swift.String(describing: sqs)))"}
}

extension IotEventsClientTypes {
    /// <p>An action to be performed when the <code>condition</code> is TRUE.</p>
    public struct Action: Swift.Equatable {
        /// <p>Information needed to clear the timer.</p>
        public let clearTimer: IotEventsClientTypes.ClearTimerAction?
        /// <p>Writes to the DynamoDB table that you created. The default action payload contains all
        ///       attribute-value pairs that have the information about the detector model instance and the
        ///       event that triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. One column of the
        ///       DynamoDB table receives all attribute-value pairs in the payload that you specify. For more
        ///       information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html">Actions</a> in
        ///         <i>AWS IoT Events Developer Guide</i>.</p>
        public let dynamoDB: IotEventsClientTypes.DynamoDBAction?
        /// <p>Writes to the DynamoDB table that you created. The default action payload contains all
        ///       attribute-value pairs that have the information about the detector model instance and the
        ///       event that triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. A separate column of
        ///       the DynamoDB table receives one attribute-value pair in the payload that you specify. For more
        ///       information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html">Actions</a> in
        ///         <i>AWS IoT Events Developer Guide</i>.</p>
        public let dynamoDBv2: IotEventsClientTypes.DynamoDBv2Action?
        /// <p>Sends information about the detector model instance and the event that triggered the
        ///       action to an Amazon Kinesis Data Firehose delivery stream.</p>
        public let firehose: IotEventsClientTypes.FirehoseAction?
        /// <p>Sends AWS IoT Events input, which passes information about the detector model instance and the
        ///       event that triggered the action.</p>
        public let iotEvents: IotEventsClientTypes.IotEventsAction?
        /// <p>Sends information about the detector model instance and the event that triggered the
        ///       action to an asset property in AWS IoT SiteWise .</p>
        public let iotSiteWise: IotEventsClientTypes.IotSiteWiseAction?
        /// <p>Publishes an MQTT message with the given topic to the AWS IoT message broker.</p>
        public let iotTopicPublish: IotEventsClientTypes.IotTopicPublishAction?
        /// <p>Calls a Lambda function, passing in information about the detector model instance and the
        ///       event that triggered the action.</p>
        public let lambda: IotEventsClientTypes.LambdaAction?
        /// <p>Information needed to reset the timer.</p>
        public let resetTimer: IotEventsClientTypes.ResetTimerAction?
        /// <p>Information needed to set the timer.</p>
        public let setTimer: IotEventsClientTypes.SetTimerAction?
        /// <p>Sets a variable to a specified value.</p>
        public let setVariable: IotEventsClientTypes.SetVariableAction?
        /// <p>Sends an Amazon SNS message.</p>
        public let sns: IotEventsClientTypes.SNSTopicPublishAction?
        /// <p>Sends information about the detector model instance and the event that triggered the
        ///       action to an Amazon SQS queue.</p>
        public let sqs: IotEventsClientTypes.SqsAction?

        public init (
            clearTimer: IotEventsClientTypes.ClearTimerAction? = nil,
            dynamoDB: IotEventsClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IotEventsClientTypes.DynamoDBv2Action? = nil,
            firehose: IotEventsClientTypes.FirehoseAction? = nil,
            iotEvents: IotEventsClientTypes.IotEventsAction? = nil,
            iotSiteWise: IotEventsClientTypes.IotSiteWiseAction? = nil,
            iotTopicPublish: IotEventsClientTypes.IotTopicPublishAction? = nil,
            lambda: IotEventsClientTypes.LambdaAction? = nil,
            resetTimer: IotEventsClientTypes.ResetTimerAction? = nil,
            setTimer: IotEventsClientTypes.SetTimerAction? = nil,
            setVariable: IotEventsClientTypes.SetVariableAction? = nil,
            sns: IotEventsClientTypes.SNSTopicPublishAction? = nil,
            sqs: IotEventsClientTypes.SqsAction? = nil
        )
        {
            self.clearTimer = clearTimer
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.resetTimer = resetTimer
            self.setTimer = setTimer
            self.setVariable = setVariable
            self.sns = sns
            self.sqs = sqs
        }
    }

}

extension IotEventsClientTypes.AlarmAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamoDB
        case dynamoDBv2
        case firehose
        case iotEvents
        case iotSiteWise
        case iotTopicPublish
        case lambda
        case sns
        case sqs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamoDB = dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let iotEvents = iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let iotTopicPublish = iotTopicPublish {
            try encodeContainer.encode(iotTopicPublish, forKey: .iotTopicPublish)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let sns = sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SNSTopicPublishAction.self, forKey: .sns)
        sns = snsDecoded
        let iotTopicPublishDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotTopicPublishAction.self, forKey: .iotTopicPublish)
        iotTopicPublish = iotTopicPublishDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let dynamoDBDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
    }
}

extension IotEventsClientTypes.AlarmAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmAction(dynamoDB: \(Swift.String(describing: dynamoDB)), dynamoDBv2: \(Swift.String(describing: dynamoDBv2)), firehose: \(Swift.String(describing: firehose)), iotEvents: \(Swift.String(describing: iotEvents)), iotSiteWise: \(Swift.String(describing: iotSiteWise)), iotTopicPublish: \(Swift.String(describing: iotTopicPublish)), lambda: \(Swift.String(describing: lambda)), sns: \(Swift.String(describing: sns)), sqs: \(Swift.String(describing: sqs)))"}
}

extension IotEventsClientTypes {
    /// <p>Specifies one of the following actions to receive notifications when the alarm state
    ///       changes.</p>
    public struct AlarmAction: Swift.Equatable {
        /// <p>Defines an action to write to the Amazon DynamoDB table that you created. The standard action
        ///       payload contains all the information about the detector model instance and the event that
        ///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. One column of the
        ///       DynamoDB table receives all attribute-value pairs in the payload that you specify.</p>
        ///          <p>You must use expressions for all parameters in <code>DynamoDBAction</code>. The expressions
        ///       accept literals, operators, functions, references, and substitution templates.</p>
        ///          <p class="title">
        ///             <b>Examples</b>
        ///          </p>
        ///          <ul>
        ///             <li>
        ///                <p>For literal values, the expressions must contain single quotes. For example, the value
        ///           for the <code>hashKeyType</code> parameter can be <code>'STRING'</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>For references, you must specify either variables or input values. For example, the
        ///           value for the <code>hashKeyField</code> parameter can be
        ///             <code>$input.GreenhouseInput.name</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
        ///           in single quotes. A substitution template can also contain a combination of literals,
        ///           operators, functions, references, and substitution templates.</p>
        ///                <p>In the following example, the value for the <code>hashKeyValue</code> parameter uses a
        ///           substitution template. </p>
        ///                <p>
        ///                   <code>'${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
        ///           also contain a combination of literals, operators, functions, references, and substitution
        ///           templates.</p>
        ///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
        ///           string concatenation. </p>
        ///                <p>
        ///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///          <p>For more information,
        ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
        ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
        ///          <p>If the defined payload type is a string, <code>DynamoDBAction</code> writes non-JSON data to
        ///       the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text.
        ///       The value for the <code>payloadField</code> parameter is
        ///         <code><payload-field>_raw</code>.</p>
        public let dynamoDB: IotEventsClientTypes.DynamoDBAction?
        /// <p>Defines an action to write to the Amazon DynamoDB table that you created. The default action
        ///       payload contains all the information about the detector model instance and the event that
        ///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. A separate column of
        ///       the DynamoDB table receives one attribute-value pair in the payload that you specify.</p>
        ///          <p>You must use expressions for all parameters in <code>DynamoDBv2Action</code>. The expressions
        ///       accept literals, operators, functions, references, and substitution templates.</p>
        ///          <p class="title">
        ///             <b>Examples</b>
        ///          </p>
        ///          <ul>
        ///             <li>
        ///                <p>For literal values, the expressions must contain single quotes. For example, the value
        ///           for the <code>tableName</code> parameter can be
        ///           <code>'GreenhouseTemperatureTable'</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>For references, you must specify either variables or input values. For example, the
        ///           value for the <code>tableName</code> parameter can be
        ///           <code>$variable.ddbtableName</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
        ///           in single quotes. A substitution template can also contain a combination of literals,
        ///           operators, functions, references, and substitution templates.</p>
        ///                <p>In the following example, the value for the <code>contentExpression</code> parameter
        ///           in <code>Payload</code> uses a substitution template. </p>
        ///                <p>
        ///                   <code>'{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\":
        ///             \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
        ///           also contain a combination of literals, operators, functions, references, and substitution
        ///           templates.</p>
        ///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
        ///           string concatenation. </p>
        ///                <p>
        ///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///          <p>For more information,
        ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
        ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
        ///          <p>The value for the <code>type</code> parameter in <code>Payload</code> must be
        ///         <code>JSON</code>.</p>
        public let dynamoDBv2: IotEventsClientTypes.DynamoDBv2Action?
        /// <p>Sends information about the detector model instance and the event that triggered the
        ///       action to an Amazon Kinesis Data Firehose delivery stream.</p>
        public let firehose: IotEventsClientTypes.FirehoseAction?
        /// <p>Sends an AWS IoT Events input, passing in information about the detector model instance and the
        ///       event that triggered the action.</p>
        public let iotEvents: IotEventsClientTypes.IotEventsAction?
        /// <p>Sends information about the detector model instance and the event that triggered the
        ///       action to a specified asset property in AWS IoT SiteWise.</p>
        ///          <p>You must use expressions for all parameters in <code>IotSiteWiseAction</code>. The
        ///       expressions accept literals, operators, functions, references, and substitutions
        ///       templates.</p>
        ///          <p class="title">
        ///             <b>Examples</b>
        ///          </p>
        ///          <ul>
        ///             <li>
        ///                <p>For literal values, the expressions must contain single quotes. For example, the value
        ///           for the <code>propertyAlias</code> parameter can be
        ///             <code>'/company/windfarm/3/turbine/7/temperature'</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>For references, you must specify either variables or input values. For example, the
        ///           value for the <code>assetId</code> parameter can be
        ///             <code>$input.TurbineInput.assetId1</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
        ///           in single quotes. A substitution template can also contain a combination of literals,
        ///           operators, functions, references, and substitution templates.</p>
        ///                <p>In the following example, the value for the <code>propertyAlias</code> parameter uses
        ///           a substitution template. </p>
        ///                <p>
        ///                   <code>'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/
        ///             ${$input.TemperatureInput.sensorData.turbineID}/temperature'</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///          <p>You must specify either <code>propertyAlias</code> or both <code>assetId</code> and
        ///         <code>propertyId</code> to identify the target asset property in AWS IoT SiteWise.</p>
        ///          <p>For more information,
        ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
        ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
        public let iotSiteWise: IotEventsClientTypes.IotSiteWiseAction?
        /// <p>Information required to publish the MQTT message through the AWS IoT message broker.</p>
        public let iotTopicPublish: IotEventsClientTypes.IotTopicPublishAction?
        /// <p>Calls a Lambda function, passing in information about the detector model instance and the
        ///       event that triggered the action.</p>
        public let lambda: IotEventsClientTypes.LambdaAction?
        /// <p>Information required to publish the Amazon SNS message.</p>
        public let sns: IotEventsClientTypes.SNSTopicPublishAction?
        /// <p>Sends information about the detector model instance and the event that triggered the
        ///       action to an Amazon SQS queue.</p>
        public let sqs: IotEventsClientTypes.SqsAction?

        public init (
            dynamoDB: IotEventsClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IotEventsClientTypes.DynamoDBv2Action? = nil,
            firehose: IotEventsClientTypes.FirehoseAction? = nil,
            iotEvents: IotEventsClientTypes.IotEventsAction? = nil,
            iotSiteWise: IotEventsClientTypes.IotSiteWiseAction? = nil,
            iotTopicPublish: IotEventsClientTypes.IotTopicPublishAction? = nil,
            lambda: IotEventsClientTypes.LambdaAction? = nil,
            sns: IotEventsClientTypes.SNSTopicPublishAction? = nil,
            sqs: IotEventsClientTypes.SqsAction? = nil
        )
        {
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.sns = sns
            self.sqs = sqs
        }
    }

}

extension IotEventsClientTypes.AlarmCapabilities: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeFlow
        case initializationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeFlow = acknowledgeFlow {
            try encodeContainer.encode(acknowledgeFlow, forKey: .acknowledgeFlow)
        }
        if let initializationConfiguration = initializationConfiguration {
            try encodeContainer.encode(initializationConfiguration, forKey: .initializationConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initializationConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InitializationConfiguration.self, forKey: .initializationConfiguration)
        initializationConfiguration = initializationConfigurationDecoded
        let acknowledgeFlowDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AcknowledgeFlow.self, forKey: .acknowledgeFlow)
        acknowledgeFlow = acknowledgeFlowDecoded
    }
}

extension IotEventsClientTypes.AlarmCapabilities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmCapabilities(acknowledgeFlow: \(Swift.String(describing: acknowledgeFlow)), initializationConfiguration: \(Swift.String(describing: initializationConfiguration)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public struct AlarmCapabilities: Swift.Equatable {
        /// <p>Specifies whether to get notified for alarm state changes.</p>
        public let acknowledgeFlow: IotEventsClientTypes.AcknowledgeFlow?
        /// <p>Specifies the default alarm state.
        /// The configuration applies to all alarms that were created based on this alarm model.</p>
        public let initializationConfiguration: IotEventsClientTypes.InitializationConfiguration?

        public init (
            acknowledgeFlow: IotEventsClientTypes.AcknowledgeFlow? = nil,
            initializationConfiguration: IotEventsClientTypes.InitializationConfiguration? = nil
        )
        {
            self.acknowledgeFlow = acknowledgeFlow
            self.initializationConfiguration = initializationConfiguration
        }
    }

}

extension IotEventsClientTypes.AlarmEventActions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmActions = alarmActions {
            var alarmActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alarmActions)
            for alarmactions0 in alarmActions {
                try alarmActionsContainer.encode(alarmactions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmActionsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.AlarmAction?].self, forKey: .alarmActions)
        var alarmActionsDecoded0:[IotEventsClientTypes.AlarmAction]? = nil
        if let alarmActionsContainer = alarmActionsContainer {
            alarmActionsDecoded0 = [IotEventsClientTypes.AlarmAction]()
            for structure0 in alarmActionsContainer {
                if let structure0 = structure0 {
                    alarmActionsDecoded0?.append(structure0)
                }
            }
        }
        alarmActions = alarmActionsDecoded0
    }
}

extension IotEventsClientTypes.AlarmEventActions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmEventActions(alarmActions: \(Swift.String(describing: alarmActions)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains information about one or more alarm actions.</p>
    public struct AlarmEventActions: Swift.Equatable {
        /// <p>Specifies one or more supported actions to receive notifications when the alarm state
        ///       changes.</p>
        public let alarmActions: [IotEventsClientTypes.AlarmAction]?

        public init (
            alarmActions: [IotEventsClientTypes.AlarmAction]? = nil
        )
        {
            self.alarmActions = alarmActions
        }
    }

}

extension IotEventsClientTypes.AlarmModelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelDescription
        case alarmModelName
        case creationTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelDescription = alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
    }
}

extension IotEventsClientTypes.AlarmModelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmModelSummary(alarmModelDescription: \(Swift.String(describing: alarmModelDescription)), alarmModelName: \(Swift.String(describing: alarmModelName)), creationTime: \(Swift.String(describing: creationTime)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains a summary of an alarm model.</p>
    public struct AlarmModelSummary: Swift.Equatable {
        /// <p>The description of the alarm model.</p>
        public let alarmModelDescription: Swift.String?
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The time the alarm model was created, in the Unix epoch format.</p>
        public let creationTime: ClientRuntime.Date?

        public init (
            alarmModelDescription: Swift.String? = nil,
            alarmModelName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil
        )
        {
            self.alarmModelDescription = alarmModelDescription
            self.alarmModelName = alarmModelName
            self.creationTime = creationTime
        }
    }

}

extension IotEventsClientTypes {
    public enum AlarmModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case failed
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmModelVersionStatus] {
            return [
                .activating,
                .active,
                .failed,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlarmModelVersionStatus(rawValue: rawValue) ?? AlarmModelVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsClientTypes.AlarmModelVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelArn
        case alarmModelName
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case roleArn
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelArn = alarmModelArn {
            try encodeContainer.encode(alarmModelArn, forKey: .alarmModelArn)
        }
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension IotEventsClientTypes.AlarmModelVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmModelVersionSummary(alarmModelArn: \(Swift.String(describing: alarmModelArn)), alarmModelName: \(Swift.String(describing: alarmModelName)), alarmModelVersion: \(Swift.String(describing: alarmModelVersion)), creationTime: \(Swift.String(describing: creationTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains a summary of an alarm model version.</p>
    public struct AlarmModelVersionSummary: Swift.Equatable {
        /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        public let alarmModelArn: Swift.String?
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The version of the alarm model.</p>
        public let alarmModelVersion: Swift.String?
        /// <p>The time the alarm model was created, in the Unix epoch format.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        public let roleArn: Swift.String?
        /// <p>The status of the alarm model. The status can be one of the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
        ///         Activating an alarm model can take up to a few minutes.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
        /// 	  Check your alarm model information and update the alarm model.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
        ///         and try again.</p>
        ///             </li>
        ///          </ul>
        public let status: IotEventsClientTypes.AlarmModelVersionStatus?
        /// <p>
        ///       Contains information about the status of the alarm model version.
        ///     </p>
        public let statusMessage: Swift.String?

        public init (
            alarmModelArn: Swift.String? = nil,
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IotEventsClientTypes.AlarmModelVersionStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.alarmModelArn = alarmModelArn
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension IotEventsClientTypes.AlarmNotification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationActions = notificationActions {
            var notificationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationActions)
            for notificationactions0 in notificationActions {
                try notificationActionsContainer.encode(notificationactions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationActionsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.NotificationAction?].self, forKey: .notificationActions)
        var notificationActionsDecoded0:[IotEventsClientTypes.NotificationAction]? = nil
        if let notificationActionsContainer = notificationActionsContainer {
            notificationActionsDecoded0 = [IotEventsClientTypes.NotificationAction]()
            for structure0 in notificationActionsContainer {
                if let structure0 = structure0 {
                    notificationActionsDecoded0?.append(structure0)
                }
            }
        }
        notificationActions = notificationActionsDecoded0
    }
}

extension IotEventsClientTypes.AlarmNotification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmNotification(notificationActions: \(Swift.String(describing: notificationActions)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains information about one or more notification actions.</p>
    public struct AlarmNotification: Swift.Equatable {
        /// <p>Contains the notification settings of an alarm model.
        /// The settings apply to all alarms that were created based on this alarm model.</p>
        public let notificationActions: [IotEventsClientTypes.NotificationAction]?

        public init (
            notificationActions: [IotEventsClientTypes.NotificationAction]? = nil
        )
        {
            self.notificationActions = notificationActions
        }
    }

}

extension IotEventsClientTypes.AlarmRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleRule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleRule = simpleRule {
            try encodeContainer.encode(simpleRule, forKey: .simpleRule)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleRuleDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SimpleRule.self, forKey: .simpleRule)
        simpleRule = simpleRuleDecoded
    }
}

extension IotEventsClientTypes.AlarmRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmRule(simpleRule: \(Swift.String(describing: simpleRule)))"}
}

extension IotEventsClientTypes {
    /// <p>Defines when your alarm is invoked.</p>
    public struct AlarmRule: Swift.Equatable {
        /// <p>A rule that compares an input property value to a threshold value with a comparison operator.</p>
        public let simpleRule: IotEventsClientTypes.SimpleRule?

        public init (
            simpleRule: IotEventsClientTypes.SimpleRule? = nil
        )
        {
            self.simpleRule = simpleRule
        }
    }

}

extension IotEventsClientTypes.AnalysisResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case level
        case locations
        case message
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let locations = locations {
            var locationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .locations)
            for analysisresultlocations0 in locations {
                try locationsContainer.encode(analysisresultlocations0)
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let levelDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AnalysisResultLevel.self, forKey: .level)
        level = levelDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let locationsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.AnalysisResultLocation?].self, forKey: .locations)
        var locationsDecoded0:[IotEventsClientTypes.AnalysisResultLocation]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [IotEventsClientTypes.AnalysisResultLocation]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

extension IotEventsClientTypes.AnalysisResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalysisResult(level: \(Swift.String(describing: level)), locations: \(Swift.String(describing: locations)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains the result of the analysis.</p>
    public struct AnalysisResult: Swift.Equatable {
        /// <p>The severity level of the analysis result. Based on the severity level, analysis results
        ///       fall into three general categories:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>INFO</code> - An information result tells you about a significant field in your
        ///           detector model. This type of result usually doesn't require immediate action.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>WARNING</code> - A warning result draws special attention to fields that might cause issues for your detector model.
        ///           We recommend that you review warnings and take necessary actions
        ///           before you use your detector model in production environments. Otherwise, the detector
        ///           model might not work as expected.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ERROR</code> - An error result notifies you about a problem found in your
        ///           detector model. You must fix all errors before you can publish your detector model.</p>
        ///             </li>
        ///          </ul>
        public let level: IotEventsClientTypes.AnalysisResultLevel?
        /// <p>Contains one or more locations that you can use to locate the fields in your detector
        ///       model that the analysis result references.</p>
        public let locations: [IotEventsClientTypes.AnalysisResultLocation]?
        /// <p>Contains additional information about the analysis result.</p>
        public let message: Swift.String?
        /// <p>The type of the analysis result. Analyses fall into the following types based on the
        ///       validators used to generate the analysis result:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>supported-actions</code> - You must specify AWS IoT Events supported actions that work
        ///           with other AWS services in a supported AWS Region.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>service-limits</code> - Resources or API operations can't exceed service
        ///           quotas (also known as limits). Update your detector model or request a quota
        ///           increase.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>structure</code> - The detector model must follow a structure that AWS IoT Events
        ///           supports. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>expression-syntax</code> - Your expression must follow the required
        ///           syntax.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>data-type</code> - Data types referenced in the detector model must be
        ///           compatible.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>referenced-data</code> - You must define the data referenced in your detector
        ///           model before you can use the data.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>referenced-resource</code> - Resources that the detector model uses must be
        ///           available.</p>
        ///             </li>
        ///          </ul>
        ///          <p>For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-analyze-api.html">Running detector model
        ///         analyses</a> in the <i>AWS IoT Events Developer Guide</i>.</p>
        public let type: Swift.String?

        public init (
            level: IotEventsClientTypes.AnalysisResultLevel? = nil,
            locations: [IotEventsClientTypes.AnalysisResultLocation]? = nil,
            message: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.level = level
            self.locations = locations
            self.message = message
            self.type = type
        }
    }

}

extension IotEventsClientTypes {
    public enum AnalysisResultLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisResultLevel] {
            return [
                .error,
                .info,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisResultLevel(rawValue: rawValue) ?? AnalysisResultLevel.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsClientTypes.AnalysisResultLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension IotEventsClientTypes.AnalysisResultLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalysisResultLocation(path: \(Swift.String(describing: path)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains information that you can use to locate the field in your detector model that the
    ///       analysis result references.</p>
    public struct AnalysisResultLocation: Swift.Equatable {
        /// <p>A <a href="https://github.com/json-path/JsonPath">JsonPath</a> expression that
        ///       identifies the error field in your detector model.</p>
        public let path: Swift.String?

        public init (
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension IotEventsClientTypes {
    public enum AnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisStatus] {
            return [
                .complete,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisStatus(rawValue: rawValue) ?? AnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsClientTypes.AssetPropertyTimestamp: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension IotEventsClientTypes.AssetPropertyTimestamp: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetPropertyTimestamp(offsetInNanos: \(Swift.String(describing: offsetInNanos)), timeInSeconds: \(Swift.String(describing: timeInSeconds)))"}
}

extension IotEventsClientTypes {
    /// <p>A structure that contains timestamp information. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html">TimeInNanos</a> in the <i>AWS IoT SiteWise API Reference</i>.</p>
    ///          <p>You must use expressions for all parameters in <code>AssetPropertyTimestamp</code>. The
    ///       expressions accept literals, operators, functions, references, and substitution
    ///       templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>timeInSeconds</code> parameter can be <code>'1586400675'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>offsetInNanos</code> parameter can be
    ///           <code>$variable.time</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates.</p>
    ///                <p>In the following example, the value for the <code>timeInSeconds</code> parameter uses
    ///           a substitution template.</p>
    ///                <p>
    ///                   <code>'${$input.TemperatureInput.sensorData.timestamp / 1000}'</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    public struct AssetPropertyTimestamp: Swift.Equatable {
        /// <p>The nanosecond offset converted from <code>timeInSeconds</code>. The valid range is
        ///       between 0-999999999.</p>
        public let offsetInNanos: Swift.String?
        /// <p>The timestamp, in seconds, in the Unix epoch format. The valid range is between
        ///       1-31556889864403199.</p>
        public let timeInSeconds: Swift.String?

        public init (
            offsetInNanos: Swift.String? = nil,
            timeInSeconds: Swift.String? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IotEventsClientTypes.AssetPropertyValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = quality {
            try encodeContainer.encode(quality, forKey: .quality)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AssetPropertyVariant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AssetPropertyTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension IotEventsClientTypes.AssetPropertyValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetPropertyValue(quality: \(Swift.String(describing: quality)), timestamp: \(Swift.String(describing: timestamp)), value: \(Swift.String(describing: value)))"}
}

extension IotEventsClientTypes {
    /// <p>A structure that contains value information. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html">AssetPropertyValue</a> in the <i>AWS IoT SiteWise API Reference</i>.</p>
    ///          <p>You must use expressions for all parameters in <code>AssetPropertyValue</code>. The
    ///       expressions accept literals, operators, functions, references, and substitution
    ///       templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>quality</code> parameter can be <code>'GOOD'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>quality</code> parameter can be
    ///             <code>$input.TemperatureInput.sensorData.quality</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    public struct AssetPropertyValue: Swift.Equatable {
        /// <p>The quality of the asset property value. The value must be <code>'GOOD'</code>,
        ///         <code>'BAD'</code>, or <code>'UNCERTAIN'</code>.</p>
        public let quality: Swift.String?
        /// <p>The timestamp associated with the asset property value. The default is the current event
        ///       time.</p>
        public let timestamp: IotEventsClientTypes.AssetPropertyTimestamp?
        /// <p>The value to send to an asset property.</p>
        public let value: IotEventsClientTypes.AssetPropertyVariant?

        public init (
            quality: Swift.String? = nil,
            timestamp: IotEventsClientTypes.AssetPropertyTimestamp? = nil,
            value: IotEventsClientTypes.AssetPropertyVariant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IotEventsClientTypes.AssetPropertyVariant: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
    }
}

extension IotEventsClientTypes.AssetPropertyVariant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetPropertyVariant(booleanValue: \(Swift.String(describing: booleanValue)), doubleValue: \(Swift.String(describing: doubleValue)), integerValue: \(Swift.String(describing: integerValue)), stringValue: \(Swift.String(describing: stringValue)))"}
}

extension IotEventsClientTypes {
    /// <p>A structure that contains an asset property value. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html">Variant</a>
    ///       in the <i>AWS IoT SiteWise API Reference</i>.</p>
    ///          <p>You must use expressions for all parameters in <code>AssetPropertyVariant</code>. The
    ///       expressions accept literals, operators, functions, references, and substitution
    ///       templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>integerValue</code> parameter can be <code>'100'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or parameters. For example, the
    ///           value for the <code>booleanValue</code> parameter can be
    ///           <code>$variable.offline</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates. </p>
    ///                <p>In the following example, the value for the <code>doubleValue</code> parameter uses a
    ///           substitution template. </p>
    ///                <p>
    ///                   <code>'${$input.TemperatureInput.sensorData.temperature * 6 / 5 + 32}'</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    ///          <p>You must specify one of the following value types, depending on the <code>dataType</code>
    ///       of the specified asset property. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetProperty.html">AssetProperty</a> in the
    ///         <i>AWS IoT SiteWise API Reference</i>.</p>
    public struct AssetPropertyVariant: Swift.Equatable {
        /// <p>The asset property value is a Boolean value that must be <code>'TRUE'</code> or
        ///         <code>'FALSE'</code>. You must use an expression, and the evaluated result should be a
        ///       Boolean value.</p>
        public let booleanValue: Swift.String?
        /// <p>The asset property value is a double. You must use an expression, and the evaluated result
        ///       should be a double.</p>
        public let doubleValue: Swift.String?
        /// <p>The asset property value is an integer. You must use an expression, and the evaluated
        ///       result should be an integer.</p>
        public let integerValue: Swift.String?
        /// <p>The asset property value is a string. You must use an expression, and the evaluated result
        ///       should be a string.</p>
        public let stringValue: Swift.String?

        public init (
            booleanValue: Swift.String? = nil,
            doubleValue: Swift.String? = nil,
            integerValue: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }
    }

}

extension IotEventsClientTypes.Attribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jsonPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
    }
}

extension IotEventsClientTypes.Attribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attribute(jsonPath: \(Swift.String(describing: jsonPath)))"}
}

extension IotEventsClientTypes {
    /// <p>The attributes from the JSON payload that are made available by the input. Inputs are
    ///       derived from messages sent to the AWS IoT Events system using <code>BatchPutMessage</code>. Each such
    ///       message contains a JSON payload. Those attributes (and their paired values) specified here are
    ///       available for use in the <code>condition</code> expressions used by detectors. </p>
    public struct Attribute: Swift.Equatable {
        /// <p>An expression that specifies an attribute-value pair in a JSON structure. Use this to
        ///       specify an attribute from the JSON payload that is made available by the input. Inputs are
        ///       derived from messages sent to AWS IoT Events (<code>BatchPutMessage</code>). Each such message contains
        ///       a JSON payload. The attribute (and its paired value) specified here are available for use in
        ///       the <code>condition</code> expressions used by detectors. </p>
        ///          <p>Syntax: <code><field-name>.<field-name>...</code>
        ///          </p>
        public let jsonPath: Swift.String?

        public init (
            jsonPath: Swift.String? = nil
        )
        {
            self.jsonPath = jsonPath
        }
    }

}

extension IotEventsClientTypes.ClearTimerAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timerName = timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timerName)
        timerName = timerNameDecoded
    }
}

extension IotEventsClientTypes.ClearTimerAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClearTimerAction(timerName: \(Swift.String(describing: timerName)))"}
}

extension IotEventsClientTypes {
    /// <p>Information needed to clear the timer.</p>
    public struct ClearTimerAction: Swift.Equatable {
        /// <p>The name of the timer to clear.</p>
        public let timerName: Swift.String?

        public init (
            timerName: Swift.String? = nil
        )
        {
            self.timerName = timerName
        }
    }

}

extension IotEventsClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greater
        case greaterOrEqual
        case less
        case lessOrEqual
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greater,
                .greaterOrEqual,
                .less,
                .lessOrEqual,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greater: return "GREATER"
            case .greaterOrEqual: return "GREATER_OR_EQUAL"
            case .less: return "LESS"
            case .lessOrEqual: return "LESS_OR_EQUAL"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

public struct CreateAlarmModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAlarmModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAlarmModelOutputError>
}

extension CreateAlarmModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAlarmModelInput(alarmCapabilities: \(Swift.String(describing: alarmCapabilities)), alarmEventActions: \(Swift.String(describing: alarmEventActions)), alarmModelDescription: \(Swift.String(describing: alarmModelDescription)), alarmModelName: \(Swift.String(describing: alarmModelName)), alarmNotification: \(Swift.String(describing: alarmNotification)), alarmRule: \(Swift.String(describing: alarmRule)), key: \(Swift.String(describing: key)), roleArn: \(Swift.String(describing: roleArn)), severity: \(Swift.String(describing: severity)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAlarmModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmModelName
        case alarmNotification
        case alarmRule
        case key
        case roleArn
        case severity
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmCapabilities = alarmCapabilities {
            try encodeContainer.encode(alarmCapabilities, forKey: .alarmCapabilities)
        }
        if let alarmEventActions = alarmEventActions {
            try encodeContainer.encode(alarmEventActions, forKey: .alarmEventActions)
        }
        if let alarmModelDescription = alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmNotification = alarmNotification {
            try encodeContainer.encode(alarmNotification, forKey: .alarmNotification)
        }
        if let alarmRule = alarmRule {
            try encodeContainer.encode(alarmRule, forKey: .alarmRule)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateAlarmModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAlarmModelOutputError>
}

public struct CreateAlarmModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAlarmModelOutputError>
}

public struct CreateAlarmModelInput: Swift.Equatable {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public let alarmCapabilities: IotEventsClientTypes.AlarmCapabilities?
    /// <p>Contains information about one or more alarm actions.</p>
    public let alarmEventActions: IotEventsClientTypes.AlarmEventActions?
    /// <p>A description that tells you what the alarm model detects.</p>
    public let alarmModelDescription: Swift.String?
    /// <p>A unique name that helps you identify the alarm model. You can't change this name after
    ///       you create the alarm model.</p>
    public let alarmModelName: Swift.String?
    /// <p>Contains information about one or more notification actions.</p>
    public let alarmNotification: IotEventsClientTypes.AlarmNotification?
    /// <p>Defines when your alarm is invoked.</p>
    public let alarmRule: IotEventsClientTypes.AlarmRule?
    /// <p>An input attribute used as a key to create an alarm.
    /// AWS IoT Events routes <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html">inputs</a>
    /// associated with this key to the alarm.</p>
    public let key: Swift.String?
    /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let roleArn: Swift.String?
    /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
    public let severity: Swift.Int?
    /// <p>A list of key-value pairs that contain metadata for the alarm model. The tags help you
    ///       manage the alarm model. For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/tagging-iotevents.html">Tagging your AWS IoT Events
    ///         resources</a> in the <i>AWS IoT Events Developer Guide</i>.</p>
    ///          <p>You can create up to 50 tags for one alarm model.</p>
    public let tags: [IotEventsClientTypes.Tag]?

    public init (
        alarmCapabilities: IotEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IotEventsClientTypes.AlarmEventActions? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmNotification: IotEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IotEventsClientTypes.AlarmRule? = nil,
        key: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil,
        tags: [IotEventsClientTypes.Tag]? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.key = key
        self.roleArn = roleArn
        self.severity = severity
        self.tags = tags
    }
}

struct CreateAlarmModelInputBody: Swift.Equatable {
    public let alarmModelName: Swift.String?
    public let alarmModelDescription: Swift.String?
    public let roleArn: Swift.String?
    public let tags: [IotEventsClientTypes.Tag]?
    public let key: Swift.String?
    public let severity: Swift.Int?
    public let alarmRule: IotEventsClientTypes.AlarmRule?
    public let alarmNotification: IotEventsClientTypes.AlarmNotification?
    public let alarmEventActions: IotEventsClientTypes.AlarmEventActions?
    public let alarmCapabilities: IotEventsClientTypes.AlarmCapabilities?
}

extension CreateAlarmModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmModelName
        case alarmNotification
        case alarmRule
        case key
        case roleArn
        case severity
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension CreateAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAlarmModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAlarmModelOutputResponse(alarmModelArn: \(Swift.String(describing: alarmModelArn)), alarmModelVersion: \(Swift.String(describing: alarmModelVersion)), creationTime: \(Swift.String(describing: creationTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), status: \(Swift.String(describing: status)))"}
}

extension CreateAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelVersion = output.alarmModelVersion
            self.creationTime = output.creationTime
            self.lastUpdateTime = output.lastUpdateTime
            self.status = output.status
        } else {
            self.alarmModelArn = nil
            self.alarmModelVersion = nil
            self.creationTime = nil
            self.lastUpdateTime = nil
            self.status = nil
        }
    }
}

public struct CreateAlarmModelOutputResponse: Swift.Equatable {
    /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let alarmModelArn: Swift.String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: Swift.String?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: ClientRuntime.Date?
    /// <p>The status of the alarm model. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
    ///         Activating an alarm model can take up to a few minutes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
    /// 	  Check your alarm model information and update the alarm model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
    ///         and try again.</p>
    ///             </li>
    ///          </ul>
    public let status: IotEventsClientTypes.AlarmModelVersionStatus?

    public init (
        alarmModelArn: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        status: IotEventsClientTypes.AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

struct CreateAlarmModelOutputResponseBody: Swift.Equatable {
    public let creationTime: ClientRuntime.Date?
    public let alarmModelArn: Swift.String?
    public let alarmModelVersion: Swift.String?
    public let lastUpdateTime: ClientRuntime.Date?
    public let status: IotEventsClientTypes.AlarmModelVersionStatus?
}

extension CreateAlarmModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelArn
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateDetectorModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDetectorModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDetectorModelOutputError>
}

extension CreateDetectorModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDetectorModelInput(detectorModelDefinition: \(Swift.String(describing: detectorModelDefinition)), detectorModelDescription: \(Swift.String(describing: detectorModelDescription)), detectorModelName: \(Swift.String(describing: detectorModelName)), evaluationMethod: \(Swift.String(describing: evaluationMethod)), key: \(Swift.String(describing: key)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDetectorModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case detectorModelName
        case evaluationMethod
        case key
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateDetectorModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDetectorModelOutputError>
}

public struct CreateDetectorModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDetectorModelOutputError>
}

public struct CreateDetectorModelInput: Swift.Equatable {
    /// <p>Information that defines how the detectors operate.</p>
    public let detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition?
    /// <p>A brief description of the detector model.</p>
    public let detectorModelDescription: Swift.String?
    /// <p>The name of the detector model.</p>
    public let detectorModelName: Swift.String?
    /// <p>Information about the order in which events are evaluated and how actions are executed.
    ///     </p>
    public let evaluationMethod: IotEventsClientTypes.EvaluationMethod?
    /// <p>The input attribute key used to identify a device or system to create a detector (an
    ///       instance of the detector model) and then to route each input received to the appropriate
    ///       detector (instance). This parameter uses a JSON-path expression in the message payload of each
    ///       input to specify the attribute-value pair that is used to identify the device associated with
    ///       the input.</p>
    public let key: Swift.String?
    /// <p>The ARN of the role that grants permission to AWS IoT Events to perform its operations.</p>
    public let roleArn: Swift.String?
    /// <p>Metadata that can be used to manage the detector model.</p>
    public let tags: [IotEventsClientTypes.Tag]?

    public init (
        detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition? = nil,
        detectorModelDescription: Swift.String? = nil,
        detectorModelName: Swift.String? = nil,
        evaluationMethod: IotEventsClientTypes.EvaluationMethod? = nil,
        key: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IotEventsClientTypes.Tag]? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.key = key
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDetectorModelInputBody: Swift.Equatable {
    public let detectorModelName: Swift.String?
    public let detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition?
    public let detectorModelDescription: Swift.String?
    public let key: Swift.String?
    public let roleArn: Swift.String?
    public let tags: [IotEventsClientTypes.Tag]?
    public let evaluationMethod: IotEventsClientTypes.EvaluationMethod?
}

extension CreateDetectorModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case detectorModelName
        case evaluationMethod
        case key
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension CreateDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDetectorModelOutputResponse(detectorModelConfiguration: \(Swift.String(describing: detectorModelConfiguration)))"}
}

extension CreateDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelConfiguration = output.detectorModelConfiguration
        } else {
            self.detectorModelConfiguration = nil
        }
    }
}

public struct CreateDetectorModelOutputResponse: Swift.Equatable {
    /// <p>Information about how the detector model is configured.</p>
    public let detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration?

    public init (
        detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

struct CreateDetectorModelOutputResponseBody: Swift.Equatable {
    public let detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration?
}

extension CreateDetectorModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

public struct CreateInputInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInputOutputError>
}

extension CreateInputInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInputInput(inputDefinition: \(Swift.String(describing: inputDefinition)), inputDescription: \(Swift.String(describing: inputDescription)), inputName: \(Swift.String(describing: inputName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateInputInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
        case inputName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDefinition = inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateInputInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInputOutputError>
}

public struct CreateInputInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInputOutputError>
}

public struct CreateInputInput: Swift.Equatable {
    /// <p>The definition of the input.</p>
    public let inputDefinition: IotEventsClientTypes.InputDefinition?
    /// <p>A brief description of the input.</p>
    public let inputDescription: Swift.String?
    /// <p>The name you want to give to the input.</p>
    public let inputName: Swift.String?
    /// <p>Metadata that can be used to manage the input.</p>
    public let tags: [IotEventsClientTypes.Tag]?

    public init (
        inputDefinition: IotEventsClientTypes.InputDefinition? = nil,
        inputDescription: Swift.String? = nil,
        inputName: Swift.String? = nil,
        tags: [IotEventsClientTypes.Tag]? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
        self.tags = tags
    }
}

struct CreateInputInputBody: Swift.Equatable {
    public let inputName: Swift.String?
    public let inputDescription: Swift.String?
    public let inputDefinition: IotEventsClientTypes.InputDefinition?
    public let tags: [IotEventsClientTypes.Tag]?
}

extension CreateInputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
        case inputName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInputOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInputOutputResponse(inputConfiguration: \(Swift.String(describing: inputConfiguration)))"}
}

extension CreateInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateInputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputConfiguration = output.inputConfiguration
        } else {
            self.inputConfiguration = nil
        }
    }
}

public struct CreateInputOutputResponse: Swift.Equatable {
    /// <p>Information about the configuration of the input.</p>
    public let inputConfiguration: IotEventsClientTypes.InputConfiguration?

    public init (
        inputConfiguration: IotEventsClientTypes.InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

struct CreateInputOutputResponseBody: Swift.Equatable {
    public let inputConfiguration: IotEventsClientTypes.InputConfiguration?
}

extension CreateInputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
    }
}

extension DeleteAlarmModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAlarmModelInput(alarmModelName: \(Swift.String(describing: alarmModelName)))"}
}

extension DeleteAlarmModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAlarmModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlarmModelOutputError>
}

public struct DeleteAlarmModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlarmModelOutputError>
}

public struct DeleteAlarmModelInput: Swift.Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
    }
}

struct DeleteAlarmModelInputBody: Swift.Equatable {
}

extension DeleteAlarmModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlarmModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAlarmModelOutputResponse()"}
}

extension DeleteAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlarmModelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAlarmModelOutputResponseBody: Swift.Equatable {
}

extension DeleteAlarmModelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDetectorModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDetectorModelInput(detectorModelName: \(Swift.String(describing: detectorModelName)))"}
}

extension DeleteDetectorModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDetectorModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorModelOutputError>
}

public struct DeleteDetectorModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorModelOutputError>
}

public struct DeleteDetectorModelInput: Swift.Equatable {
    /// <p>The name of the detector model to be deleted.</p>
    public let detectorModelName: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
    }
}

struct DeleteDetectorModelInputBody: Swift.Equatable {
}

extension DeleteDetectorModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDetectorModelOutputResponse()"}
}

extension DeleteDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorModelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDetectorModelOutputResponseBody: Swift.Equatable {
}

extension DeleteDetectorModelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInputInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInputInput(inputName: \(Swift.String(describing: inputName)))"}
}

extension DeleteInputInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteInputInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInputOutputError>
}

public struct DeleteInputInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInputOutputError>
}

public struct DeleteInputInput: Swift.Equatable {
    /// <p>The name of the input to delete.</p>
    public let inputName: Swift.String?

    public init (
        inputName: Swift.String? = nil
    )
    {
        self.inputName = inputName
    }
}

struct DeleteInputInputBody: Swift.Equatable {
}

extension DeleteInputInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInputOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInputOutputResponse()"}
}

extension DeleteInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInputOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteInputOutputResponseBody: Swift.Equatable {
}

extension DeleteInputOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlarmModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlarmModelInput(alarmModelName: \(Swift.String(describing: alarmModelName)), alarmModelVersion: \(Swift.String(describing: alarmModelVersion)))"}
}

extension DescribeAlarmModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAlarmModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlarmModelOutputError>
}

public struct DescribeAlarmModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let alarmModelVersion = input.operationInput.alarmModelVersion {
            let alarmModelVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(alarmModelVersion).urlPercentEncoding())
            input.builder.withQueryItem(alarmModelVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlarmModelOutputError>
}

public struct DescribeAlarmModelInput: Swift.Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: Swift.String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
    }
}

struct DescribeAlarmModelInputBody: Swift.Equatable {
}

extension DescribeAlarmModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlarmModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlarmModelOutputResponse(alarmCapabilities: \(Swift.String(describing: alarmCapabilities)), alarmEventActions: \(Swift.String(describing: alarmEventActions)), alarmModelArn: \(Swift.String(describing: alarmModelArn)), alarmModelDescription: \(Swift.String(describing: alarmModelDescription)), alarmModelName: \(Swift.String(describing: alarmModelName)), alarmModelVersion: \(Swift.String(describing: alarmModelVersion)), alarmNotification: \(Swift.String(describing: alarmNotification)), alarmRule: \(Swift.String(describing: alarmRule)), creationTime: \(Swift.String(describing: creationTime)), key: \(Swift.String(describing: key)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), roleArn: \(Swift.String(describing: roleArn)), severity: \(Swift.String(describing: severity)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension DescribeAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmCapabilities = output.alarmCapabilities
            self.alarmEventActions = output.alarmEventActions
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelDescription = output.alarmModelDescription
            self.alarmModelName = output.alarmModelName
            self.alarmModelVersion = output.alarmModelVersion
            self.alarmNotification = output.alarmNotification
            self.alarmRule = output.alarmRule
            self.creationTime = output.creationTime
            self.key = output.key
            self.lastUpdateTime = output.lastUpdateTime
            self.roleArn = output.roleArn
            self.severity = output.severity
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.alarmCapabilities = nil
            self.alarmEventActions = nil
            self.alarmModelArn = nil
            self.alarmModelDescription = nil
            self.alarmModelName = nil
            self.alarmModelVersion = nil
            self.alarmNotification = nil
            self.alarmRule = nil
            self.creationTime = nil
            self.key = nil
            self.lastUpdateTime = nil
            self.roleArn = nil
            self.severity = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeAlarmModelOutputResponse: Swift.Equatable {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public let alarmCapabilities: IotEventsClientTypes.AlarmCapabilities?
    /// <p>Contains information about one or more alarm actions.</p>
    public let alarmEventActions: IotEventsClientTypes.AlarmEventActions?
    /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let alarmModelArn: Swift.String?
    /// <p>The description of the alarm model.</p>
    public let alarmModelDescription: Swift.String?
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: Swift.String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: Swift.String?
    /// <p>Contains information about one or more notification actions.</p>
    public let alarmNotification: IotEventsClientTypes.AlarmNotification?
    /// <p>Defines when your alarm is invoked.</p>
    public let alarmRule: IotEventsClientTypes.AlarmRule?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>An input attribute used as a key to create an alarm.
    /// AWS IoT Events routes <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html">inputs</a>
    /// associated with this key to the alarm.</p>
    public let key: Swift.String?
    /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: ClientRuntime.Date?
    /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let roleArn: Swift.String?
    /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
    public let severity: Swift.Int?
    /// <p>The status of the alarm model. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
    ///         Activating an alarm model can take up to a few minutes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
    /// 	  Check your alarm model information and update the alarm model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
    ///         and try again.</p>
    ///             </li>
    ///          </ul>
    public let status: IotEventsClientTypes.AlarmModelVersionStatus?
    /// <p>
    ///       Contains information about the status of the alarm model.
    ///     </p>
    public let statusMessage: Swift.String?

    public init (
        alarmCapabilities: IotEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IotEventsClientTypes.AlarmEventActions? = nil,
        alarmModelArn: Swift.String? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        alarmNotification: IotEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IotEventsClientTypes.AlarmRule? = nil,
        creationTime: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil,
        status: IotEventsClientTypes.AlarmModelVersionStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelArn = alarmModelArn
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.creationTime = creationTime
        self.key = key
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.severity = severity
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribeAlarmModelOutputResponseBody: Swift.Equatable {
    public let creationTime: ClientRuntime.Date?
    public let alarmModelArn: Swift.String?
    public let alarmModelVersion: Swift.String?
    public let lastUpdateTime: ClientRuntime.Date?
    public let status: IotEventsClientTypes.AlarmModelVersionStatus?
    public let statusMessage: Swift.String?
    public let alarmModelName: Swift.String?
    public let alarmModelDescription: Swift.String?
    public let roleArn: Swift.String?
    public let key: Swift.String?
    public let severity: Swift.Int?
    public let alarmRule: IotEventsClientTypes.AlarmRule?
    public let alarmNotification: IotEventsClientTypes.AlarmNotification?
    public let alarmEventActions: IotEventsClientTypes.AlarmEventActions?
    public let alarmCapabilities: IotEventsClientTypes.AlarmCapabilities?
}

extension DescribeAlarmModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelArn
        case alarmModelDescription
        case alarmModelName
        case alarmModelVersion
        case alarmNotification
        case alarmRule
        case creationTime
        case key
        case lastUpdateTime
        case roleArn
        case severity
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension DescribeDetectorModelAnalysisInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorModelAnalysisInput(analysisId: \(Swift.String(describing: analysisId)))"}
}

extension DescribeDetectorModelAnalysisInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDetectorModelAnalysisInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorModelAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorModelAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorModelAnalysisOutputError>
}

public struct DescribeDetectorModelAnalysisInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorModelAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorModelAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorModelAnalysisOutputError>
}

public struct DescribeDetectorModelAnalysisInput: Swift.Equatable {
    /// <p>The ID of the analysis result that you want to retrieve.</p>
    public let analysisId: Swift.String?

    public init (
        analysisId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

struct DescribeDetectorModelAnalysisInputBody: Swift.Equatable {
}

extension DescribeDetectorModelAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDetectorModelAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorModelAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorModelAnalysisOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorModelAnalysisOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorModelAnalysisOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension DescribeDetectorModelAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDetectorModelAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DescribeDetectorModelAnalysisOutputResponse: Swift.Equatable {
    /// <p>The status of the analysis activity. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RUNNING</code> - AWS IoT Events is analyzing your detector model. This process can take
    ///           several minutes to complete.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETE</code> - AWS IoT Events finished analyzing your detector model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - AWS IoT Events couldn't analyze your detector model. Try again
    ///           later.</p>
    ///             </li>
    ///          </ul>
    public let status: IotEventsClientTypes.AnalysisStatus?

    public init (
        status: IotEventsClientTypes.AnalysisStatus? = nil
    )
    {
        self.status = status
    }
}

struct DescribeDetectorModelAnalysisOutputResponseBody: Swift.Equatable {
    public let status: IotEventsClientTypes.AnalysisStatus?
}

extension DescribeDetectorModelAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AnalysisStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDetectorModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorModelInput(detectorModelName: \(Swift.String(describing: detectorModelName)), detectorModelVersion: \(Swift.String(describing: detectorModelVersion)))"}
}

extension DescribeDetectorModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDetectorModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorModelOutputError>
}

public struct DescribeDetectorModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let detectorModelVersion = input.operationInput.detectorModelVersion {
            let detectorModelVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(detectorModelVersion).urlPercentEncoding())
            input.builder.withQueryItem(detectorModelVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorModelOutputError>
}

public struct DescribeDetectorModelInput: Swift.Equatable {
    /// <p>The name of the detector model.</p>
    public let detectorModelName: Swift.String?
    /// <p>The version of the detector model.</p>
    public let detectorModelVersion: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil,
        detectorModelVersion: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
    }
}

struct DescribeDetectorModelInputBody: Swift.Equatable {
}

extension DescribeDetectorModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorModelOutputResponse(detectorModel: \(Swift.String(describing: detectorModel)))"}
}

extension DescribeDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModel = output.detectorModel
        } else {
            self.detectorModel = nil
        }
    }
}

public struct DescribeDetectorModelOutputResponse: Swift.Equatable {
    /// <p>Information about the detector model.</p>
    public let detectorModel: IotEventsClientTypes.DetectorModel?

    public init (
        detectorModel: IotEventsClientTypes.DetectorModel? = nil
    )
    {
        self.detectorModel = detectorModel
    }
}

struct DescribeDetectorModelOutputResponseBody: Swift.Equatable {
    public let detectorModel: IotEventsClientTypes.DetectorModel?
}

extension DescribeDetectorModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModel.self, forKey: .detectorModel)
        detectorModel = detectorModelDecoded
    }
}

extension DescribeInputInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInputInput(inputName: \(Swift.String(describing: inputName)))"}
}

extension DescribeInputInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeInputInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInputOutputError>
}

public struct DescribeInputInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInputOutputError>
}

public struct DescribeInputInput: Swift.Equatable {
    /// <p>The name of the input.</p>
    public let inputName: Swift.String?

    public init (
        inputName: Swift.String? = nil
    )
    {
        self.inputName = inputName
    }
}

struct DescribeInputInputBody: Swift.Equatable {
}

extension DescribeInputInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInputOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInputOutputResponse(input: \(Swift.String(describing: input)))"}
}

extension DescribeInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.input = output.input
        } else {
            self.input = nil
        }
    }
}

public struct DescribeInputOutputResponse: Swift.Equatable {
    /// <p>Information about the input.</p>
    public let input: IotEventsClientTypes.Input?

    public init (
        input: IotEventsClientTypes.Input? = nil
    )
    {
        self.input = input
    }
}

struct DescribeInputOutputResponseBody: Swift.Equatable {
    public let input: IotEventsClientTypes.Input?
}

extension DescribeInputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Input.self, forKey: .input)
        input = inputDecoded
    }
}

extension DescribeLoggingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingOptionsInput()"}
}

extension DescribeLoggingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeLoggingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInput: Swift.Equatable {

    public init() {}
}

struct DescribeLoggingOptionsInputBody: Swift.Equatable {
}

extension DescribeLoggingOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingOptionsOutputResponse(loggingOptions: \(Swift.String(describing: loggingOptions)))"}
}

extension DescribeLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Swift.Equatable {
    /// <p>The current settings of the AWS IoT Events logging options.</p>
    public let loggingOptions: IotEventsClientTypes.LoggingOptions?

    public init (
        loggingOptions: IotEventsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Swift.Equatable {
    public let loggingOptions: IotEventsClientTypes.LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension IotEventsClientTypes.DetectorDebugOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelName
        case keyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
    }
}

extension IotEventsClientTypes.DetectorDebugOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorDebugOption(detectorModelName: \(Swift.String(describing: detectorModelName)), keyValue: \(Swift.String(describing: keyValue)))"}
}

extension IotEventsClientTypes {
    /// <p>The detector model and the specific detectors (instances) for which the logging level is
    ///       given.</p>
    public struct DetectorDebugOption: Swift.Equatable {
        /// <p>The name of the detector model.</p>
        public let detectorModelName: Swift.String?
        /// <p>The value of the input attribute key used to create the detector (the instance of the
        ///       detector model).</p>
        public let keyValue: Swift.String?

        public init (
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
        }
    }

}

extension IotEventsClientTypes.DetectorModel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelConfiguration
        case detectorModelDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelConfiguration = detectorModelConfiguration {
            try encodeContainer.encode(detectorModelConfiguration, forKey: .detectorModelConfiguration)
        }
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

extension IotEventsClientTypes.DetectorModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorModel(detectorModelConfiguration: \(Swift.String(describing: detectorModelConfiguration)), detectorModelDefinition: \(Swift.String(describing: detectorModelDefinition)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about the detector model.</p>
    public struct DetectorModel: Swift.Equatable {
        /// <p>Information about how the detector is configured.</p>
        public let detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration?
        /// <p>Information that defines how a detector operates.</p>
        public let detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition?

        public init (
            detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration? = nil,
            detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition? = nil
        )
        {
            self.detectorModelConfiguration = detectorModelConfiguration
            self.detectorModelDefinition = detectorModelDefinition
        }
    }

}

extension IotEventsClientTypes.DetectorModelConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelArn
        case detectorModelDescription
        case detectorModelName
        case detectorModelVersion
        case evaluationMethod
        case key
        case lastUpdateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelArn = detectorModelArn {
            try encodeContainer.encode(detectorModelArn, forKey: .detectorModelArn)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let detectorModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelArn)
        detectorModelArn = detectorModelArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension IotEventsClientTypes.DetectorModelConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorModelConfiguration(creationTime: \(Swift.String(describing: creationTime)), detectorModelArn: \(Swift.String(describing: detectorModelArn)), detectorModelDescription: \(Swift.String(describing: detectorModelDescription)), detectorModelName: \(Swift.String(describing: detectorModelName)), detectorModelVersion: \(Swift.String(describing: detectorModelVersion)), evaluationMethod: \(Swift.String(describing: evaluationMethod)), key: \(Swift.String(describing: key)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about how the detector model is configured.</p>
    public struct DetectorModelConfiguration: Swift.Equatable {
        /// <p>The time the detector model was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The ARN of the detector model.</p>
        public let detectorModelArn: Swift.String?
        /// <p>A brief description of the detector model.</p>
        public let detectorModelDescription: Swift.String?
        /// <p>The name of the detector model.</p>
        public let detectorModelName: Swift.String?
        /// <p>The version of the detector model.</p>
        public let detectorModelVersion: Swift.String?
        /// <p>Information about the order in which events are evaluated and how actions are executed.
        ///     </p>
        public let evaluationMethod: IotEventsClientTypes.EvaluationMethod?
        /// <p>The value used to identify a detector instance. When a device or system sends input, a new
        ///       detector instance with a unique key value is created. AWS IoT Events can continue to route input to its
        ///       corresponding detector instance based on this identifying information. </p>
        ///          <p>This parameter uses a JSON-path expression to select the attribute-value pair in the
        ///       message payload that is used for identification. To route the message to the correct detector
        ///       instance, the device must send a message payload that contains the same
        ///       attribute-value.</p>
        public let key: Swift.String?
        /// <p>The time the detector model was last updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The ARN of the role that grants permission to AWS IoT Events to perform its operations.</p>
        public let roleArn: Swift.String?
        /// <p>The status of the detector model.</p>
        public let status: IotEventsClientTypes.DetectorModelVersionStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelArn: Swift.String? = nil,
            detectorModelDescription: Swift.String? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            evaluationMethod: IotEventsClientTypes.EvaluationMethod? = nil,
            key: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IotEventsClientTypes.DetectorModelVersionStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.key = key
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension IotEventsClientTypes.DetectorModelDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialStateName
        case states
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialStateName = initialStateName {
            try encodeContainer.encode(initialStateName, forKey: .initialStateName)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for states0 in states {
                try statesContainer.encode(states0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.State?].self, forKey: .states)
        var statesDecoded0:[IotEventsClientTypes.State]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [IotEventsClientTypes.State]()
            for structure0 in statesContainer {
                if let structure0 = structure0 {
                    statesDecoded0?.append(structure0)
                }
            }
        }
        states = statesDecoded0
        let initialStateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialStateName)
        initialStateName = initialStateNameDecoded
    }
}

extension IotEventsClientTypes.DetectorModelDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorModelDefinition(initialStateName: \(Swift.String(describing: initialStateName)), states: \(Swift.String(describing: states)))"}
}

extension IotEventsClientTypes {
    /// <p>Information that defines how a detector operates.</p>
    public struct DetectorModelDefinition: Swift.Equatable {
        /// <p>The state that is entered at the creation of each detector (instance).</p>
        public let initialStateName: Swift.String?
        /// <p>Information about the states of the detector.</p>
        public let states: [IotEventsClientTypes.State]?

        public init (
            initialStateName: Swift.String? = nil,
            states: [IotEventsClientTypes.State]? = nil
        )
        {
            self.initialStateName = initialStateName
            self.states = states
        }
    }

}

extension IotEventsClientTypes.DetectorModelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelDescription
        case detectorModelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension IotEventsClientTypes.DetectorModelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorModelSummary(creationTime: \(Swift.String(describing: creationTime)), detectorModelDescription: \(Swift.String(describing: detectorModelDescription)), detectorModelName: \(Swift.String(describing: detectorModelName)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about the detector model.</p>
    public struct DetectorModelSummary: Swift.Equatable {
        /// <p>The time the detector model was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>A brief description of the detector model.</p>
        public let detectorModelDescription: Swift.String?
        /// <p>The name of the detector model.</p>
        public let detectorModelName: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelDescription: Swift.String? = nil,
            detectorModelName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
        }
    }

}

extension IotEventsClientTypes {
    public enum DetectorModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deprecated
        case draft
        case failed
        case inactive
        case paused
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorModelVersionStatus] {
            return [
                .activating,
                .active,
                .deprecated,
                .draft,
                .failed,
                .inactive,
                .paused,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deprecated: return "DEPRECATED"
            case .draft: return "DRAFT"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .paused: return "PAUSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorModelVersionStatus(rawValue: rawValue) ?? DetectorModelVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsClientTypes.DetectorModelVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelArn
        case detectorModelName
        case detectorModelVersion
        case evaluationMethod
        case lastUpdateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelArn = detectorModelArn {
            try encodeContainer.encode(detectorModelArn, forKey: .detectorModelArn)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let detectorModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelArn)
        detectorModelArn = detectorModelArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension IotEventsClientTypes.DetectorModelVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorModelVersionSummary(creationTime: \(Swift.String(describing: creationTime)), detectorModelArn: \(Swift.String(describing: detectorModelArn)), detectorModelName: \(Swift.String(describing: detectorModelName)), detectorModelVersion: \(Swift.String(describing: detectorModelVersion)), evaluationMethod: \(Swift.String(describing: evaluationMethod)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about the detector model version.</p>
    public struct DetectorModelVersionSummary: Swift.Equatable {
        /// <p>The time the detector model version was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The ARN of the detector model version.</p>
        public let detectorModelArn: Swift.String?
        /// <p>The name of the detector model.</p>
        public let detectorModelName: Swift.String?
        /// <p>The ID of the detector model version.</p>
        public let detectorModelVersion: Swift.String?
        /// <p>Information about the order in which events are evaluated and how actions are executed.
        ///     </p>
        public let evaluationMethod: IotEventsClientTypes.EvaluationMethod?
        /// <p>The last time the detector model version was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The ARN of the role that grants the detector model permission to perform its tasks.</p>
        public let roleArn: Swift.String?
        /// <p>The status of the detector model version.</p>
        public let status: IotEventsClientTypes.DetectorModelVersionStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelArn: Swift.String? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            evaluationMethod: IotEventsClientTypes.EvaluationMethod? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IotEventsClientTypes.DetectorModelVersionStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension IotEventsClientTypes.DynamoDBAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashKeyField
        case hashKeyType
        case hashKeyValue
        case operation
        case payload
        case payloadField
        case rangeKeyField
        case rangeKeyType
        case rangeKeyValue
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashKeyField = hashKeyField {
            try encodeContainer.encode(hashKeyField, forKey: .hashKeyField)
        }
        if let hashKeyType = hashKeyType {
            try encodeContainer.encode(hashKeyType, forKey: .hashKeyType)
        }
        if let hashKeyValue = hashKeyValue {
            try encodeContainer.encode(hashKeyValue, forKey: .hashKeyValue)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let payloadField = payloadField {
            try encodeContainer.encode(payloadField, forKey: .payloadField)
        }
        if let rangeKeyField = rangeKeyField {
            try encodeContainer.encode(rangeKeyField, forKey: .rangeKeyField)
        }
        if let rangeKeyType = rangeKeyType {
            try encodeContainer.encode(rangeKeyType, forKey: .rangeKeyType)
        }
        if let rangeKeyValue = rangeKeyValue {
            try encodeContainer.encode(rangeKeyValue, forKey: .rangeKeyValue)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hashKeyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyType)
        hashKeyType = hashKeyTypeDecoded
        let hashKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyField)
        hashKeyField = hashKeyFieldDecoded
        let hashKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyValue)
        hashKeyValue = hashKeyValueDecoded
        let rangeKeyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyType)
        rangeKeyType = rangeKeyTypeDecoded
        let rangeKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyField)
        rangeKeyField = rangeKeyFieldDecoded
        let rangeKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyValue)
        rangeKeyValue = rangeKeyValueDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let payloadFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadField)
        payloadField = payloadFieldDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.DynamoDBAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynamoDBAction(hashKeyField: \(Swift.String(describing: hashKeyField)), hashKeyType: \(Swift.String(describing: hashKeyType)), hashKeyValue: \(Swift.String(describing: hashKeyValue)), operation: \(Swift.String(describing: operation)), payload: \(Swift.String(describing: payload)), payloadField: \(Swift.String(describing: payloadField)), rangeKeyField: \(Swift.String(describing: rangeKeyField)), rangeKeyType: \(Swift.String(describing: rangeKeyType)), rangeKeyValue: \(Swift.String(describing: rangeKeyValue)), tableName: \(Swift.String(describing: tableName)))"}
}

extension IotEventsClientTypes {
    /// <p>Defines an action to write to the Amazon DynamoDB table that you created. The standard action
    ///       payload contains all the information about the detector model instance and the event that
    ///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. One column of the
    ///       DynamoDB table receives all attribute-value pairs in the payload that you specify.</p>
    ///          <p>You must use expressions for all parameters in <code>DynamoDBAction</code>. The expressions
    ///       accept literals, operators, functions, references, and substitution templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>hashKeyType</code> parameter can be <code>'STRING'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>hashKeyField</code> parameter can be
    ///             <code>$input.GreenhouseInput.name</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates.</p>
    ///                <p>In the following example, the value for the <code>hashKeyValue</code> parameter uses a
    ///           substitution template. </p>
    ///                <p>
    ///                   <code>'${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
    ///           also contain a combination of literals, operators, functions, references, and substitution
    ///           templates.</p>
    ///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
    ///           string concatenation. </p>
    ///                <p>
    ///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    ///          <p>If the defined payload type is a string, <code>DynamoDBAction</code> writes non-JSON data to
    ///       the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text.
    ///       The value for the <code>payloadField</code> parameter is
    ///         <code><payload-field>_raw</code>.</p>
    public struct DynamoDBAction: Swift.Equatable {
        /// <p>The name of the hash key (also called the partition key). The <code>hashKeyField</code>
        ///       value must match the partition key of the target DynamoDB table.</p>
        public let hashKeyField: Swift.String?
        /// <p>The data type for the hash key (also called the partition key). You can specify the
        ///       following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>'STRING'</code> - The hash key is a string.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>'NUMBER'</code> - The hash key is a number.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If you don't specify <code>hashKeyType</code>, the default value is
        ///       <code>'STRING'</code>.</p>
        public let hashKeyType: Swift.String?
        /// <p>The value of the hash key (also called the partition key).</p>
        public let hashKeyValue: Swift.String?
        /// <p>The type of operation to perform. You can specify the following values: </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>'INSERT'</code> - Insert data as a new item into the DynamoDB table. This item uses
        ///           the specified hash key as a partition key. If you specified a range key, the item uses the
        ///           range key as a sort key.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>'UPDATE'</code> - Update an existing item of the DynamoDB table with new data. This
        ///           item's partition key must match the specified hash key. If you specified a range key, the
        ///           range key must match the item's sort key.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>'DELETE'</code> - Delete an existing item of the DynamoDB table. This item's
        ///           partition key must match the specified hash key. If you specified a range key, the range
        ///           key must match the item's sort key.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If you don't specify this parameter, AWS IoT Events triggers the <code>'INSERT'</code>
        ///       operation.</p>
        public let operation: Swift.String?
        /// <p>Information needed to configure the payload.</p>
        ///          <p>By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload
        ///       contains all attribute-value pairs that have the information about the detector model instance
        ///       and the event triggered the action. To configure the action payload, you can use
        ///         <code>contentExpression</code>.</p>
        public let payload: IotEventsClientTypes.Payload?
        /// <p>The name of the DynamoDB column that receives the action payload.</p>
        ///          <p>If you don't specify this parameter, the name of the DynamoDB column is
        ///       <code>payload</code>.</p>
        public let payloadField: Swift.String?
        /// <p>The name of the range key (also called the sort key). The <code>rangeKeyField</code> value
        ///       must match the sort key of the target DynamoDB table. </p>
        public let rangeKeyField: Swift.String?
        /// <p>The data type for the range key (also called the sort key), You can specify the following
        ///       values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>'STRING'</code> - The range key is a string.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>'NUMBER'</code> - The range key is number.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If you don't specify <code>rangeKeyField</code>, the default value is
        ///         <code>'STRING'</code>.</p>
        public let rangeKeyType: Swift.String?
        /// <p>The value of the range key (also called the sort key).</p>
        public let rangeKeyValue: Swift.String?
        /// <p>The name of the DynamoDB table. The <code>tableName</code> value must match the table name of
        ///       the target DynamoDB table. </p>
        public let tableName: Swift.String?

        public init (
            hashKeyField: Swift.String? = nil,
            hashKeyType: Swift.String? = nil,
            hashKeyValue: Swift.String? = nil,
            operation: Swift.String? = nil,
            payload: IotEventsClientTypes.Payload? = nil,
            payloadField: Swift.String? = nil,
            rangeKeyField: Swift.String? = nil,
            rangeKeyType: Swift.String? = nil,
            rangeKeyValue: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payload = payload
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.tableName = tableName
        }
    }

}

extension IotEventsClientTypes.DynamoDBv2Action: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.DynamoDBv2Action: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynamoDBv2Action(payload: \(Swift.String(describing: payload)), tableName: \(Swift.String(describing: tableName)))"}
}

extension IotEventsClientTypes {
    /// <p>Defines an action to write to the Amazon DynamoDB table that you created. The default action
    ///       payload contains all the information about the detector model instance and the event that
    ///       triggered the action. You can customize the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html">payload</a>. A separate column of
    ///       the DynamoDB table receives one attribute-value pair in the payload that you specify.</p>
    ///          <p>You must use expressions for all parameters in <code>DynamoDBv2Action</code>. The expressions
    ///       accept literals, operators, functions, references, and substitution templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>tableName</code> parameter can be
    ///           <code>'GreenhouseTemperatureTable'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>tableName</code> parameter can be
    ///           <code>$variable.ddbtableName</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates.</p>
    ///                <p>In the following example, the value for the <code>contentExpression</code> parameter
    ///           in <code>Payload</code> uses a substitution template. </p>
    ///                <p>
    ///                   <code>'{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\":
    ///             \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For a string concatenation, you must use <code>+</code>. A string concatenation can
    ///           also contain a combination of literals, operators, functions, references, and substitution
    ///           templates.</p>
    ///                <p>In the following example, the value for the <code>tableName</code> parameter uses a
    ///           string concatenation. </p>
    ///                <p>
    ///                   <code>'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    ///          <p>The value for the <code>type</code> parameter in <code>Payload</code> must be
    ///         <code>JSON</code>.</p>
    public struct DynamoDBv2Action: Swift.Equatable {
        /// <p>Information needed to configure the payload.</p>
        ///          <p>By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload
        ///       contains all attribute-value pairs that have the information about the detector model instance
        ///       and the event triggered the action. To configure the action payload, you can use
        ///         <code>contentExpression</code>.</p>
        public let payload: IotEventsClientTypes.Payload?
        /// <p>The name of the DynamoDB table.</p>
        public let tableName: Swift.String?

        public init (
            payload: IotEventsClientTypes.Payload? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.payload = payload
            self.tableName = tableName
        }
    }

}

extension IotEventsClientTypes.EmailConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case from
        case recipients
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let from = from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let recipients = recipients {
            try encodeContainer.encode(recipients, forKey: .recipients)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
        let contentDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.EmailContent.self, forKey: .content)
        content = contentDecoded
        let recipientsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.EmailRecipients.self, forKey: .recipients)
        recipients = recipientsDecoded
    }
}

extension IotEventsClientTypes.EmailConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailConfiguration(content: \(Swift.String(describing: content)), from: \(Swift.String(describing: from)), recipients: \(Swift.String(describing: recipients)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains the configuration information of email notifications.</p>
    public struct EmailConfiguration: Swift.Equatable {
        /// <p>Contains the subject and message of an email.</p>
        public let content: IotEventsClientTypes.EmailContent?
        /// <p>The email address that sends emails.</p>
        ///          <important>
        ///             <p>If you use the AWS IoT Events managed AWS Lambda function to manage your emails, you must <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify
        ///           the email address that sends emails in Amazon SES</a>.</p>
        ///          </important>
        public let from: Swift.String?
        /// <p>Contains the information of one or more recipients who receive the emails.</p>
        ///          <important>
        ///             <p>You must <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html">add the users that receive emails to your AWS SSO store</a>.</p>
        ///          </important>
        public let recipients: IotEventsClientTypes.EmailRecipients?

        public init (
            content: IotEventsClientTypes.EmailContent? = nil,
            from: Swift.String? = nil,
            recipients: IotEventsClientTypes.EmailRecipients? = nil
        )
        {
            self.content = content
            self.from = from
            self.recipients = recipients
        }
    }

}

extension IotEventsClientTypes.EmailContent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMessage
        case subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMessage = additionalMessage {
            try encodeContainer.encode(additionalMessage, forKey: .additionalMessage)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let additionalMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMessage)
        additionalMessage = additionalMessageDecoded
    }
}

extension IotEventsClientTypes.EmailContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailContent(additionalMessage: \(Swift.String(describing: additionalMessage)), subject: \(Swift.String(describing: subject)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains the subject and message of an email.</p>
    public struct EmailContent: Swift.Equatable {
        /// <p>The message that you want to send. The message can be up to 200 characters.</p>
        public let additionalMessage: Swift.String?
        /// <p>The subject of the email.</p>
        public let subject: Swift.String?

        public init (
            additionalMessage: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.additionalMessage = additionalMessage
            self.subject = subject
        }
    }

}

extension IotEventsClientTypes.EmailRecipients: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case to
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let to = to {
            var toContainer = encodeContainer.nestedUnkeyedContainer(forKey: .to)
            for recipientdetails0 in to {
                try toContainer.encode(recipientdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let toContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.RecipientDetail?].self, forKey: .to)
        var toDecoded0:[IotEventsClientTypes.RecipientDetail]? = nil
        if let toContainer = toContainer {
            toDecoded0 = [IotEventsClientTypes.RecipientDetail]()
            for structure0 in toContainer {
                if let structure0 = structure0 {
                    toDecoded0?.append(structure0)
                }
            }
        }
        to = toDecoded0
    }
}

extension IotEventsClientTypes.EmailRecipients: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailRecipients(to: \(Swift.String(describing: to)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains the information of one or more recipients who receive the emails.</p>
    ///          <important>
    ///             <p>You must <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html">add the users that receive emails to your AWS SSO store</a>.</p>
    ///          </important>
    public struct EmailRecipients: Swift.Equatable {
        /// <p>Specifies one or more recipients who receive the email.</p>
        public let to: [IotEventsClientTypes.RecipientDetail]?

        public init (
            to: [IotEventsClientTypes.RecipientDetail]? = nil
        )
        {
            self.to = to
        }
    }

}

extension IotEventsClientTypes {
    public enum EvaluationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case batch
        case serial
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationMethod] {
            return [
                .batch,
                .serial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .batch: return "BATCH"
            case .serial: return "SERIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationMethod(rawValue: rawValue) ?? EvaluationMethod.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case condition
        case eventName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actions0 in actions {
                try actionsContainer.encode(actions0)
            }
        }
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[IotEventsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IotEventsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension IotEventsClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(actions: \(Swift.String(describing: actions)), condition: \(Swift.String(describing: condition)), eventName: \(Swift.String(describing: eventName)))"}
}

extension IotEventsClientTypes {
    /// <p>Specifies the <code>actions</code> to be performed when the <code>condition</code>
    ///       evaluates to TRUE.</p>
    public struct Event: Swift.Equatable {
        /// <p>The actions to be performed.</p>
        public let actions: [IotEventsClientTypes.Action]?
        /// <p>Optional. The Boolean expression that, when TRUE, causes the <code>actions</code> to be
        ///       performed. If not present, the actions are performed (=TRUE). If the expression result is not
        ///       a Boolean value, the actions are not performed (=FALSE).</p>
        public let condition: Swift.String?
        /// <p>The name of the event.</p>
        public let eventName: Swift.String?

        public init (
            actions: [IotEventsClientTypes.Action]? = nil,
            condition: Swift.String? = nil,
            eventName: Swift.String? = nil
        )
        {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
        }
    }

}

extension IotEventsClientTypes.FirehoseAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamName
        case payload
        case separator
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamName = deliveryStreamName {
            try encodeContainer.encode(deliveryStreamName, forKey: .deliveryStreamName)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let separator = separator {
            try encodeContainer.encode(separator, forKey: .separator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamName)
        deliveryStreamName = deliveryStreamNameDecoded
        let separatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .separator)
        separator = separatorDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.FirehoseAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FirehoseAction(deliveryStreamName: \(Swift.String(describing: deliveryStreamName)), payload: \(Swift.String(describing: payload)), separator: \(Swift.String(describing: separator)))"}
}

extension IotEventsClientTypes {
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to an Amazon Kinesis Data Firehose delivery stream.</p>
    public struct FirehoseAction: Swift.Equatable {
        /// <p>The name of the Kinesis Data Firehose delivery stream where the data is written.</p>
        public let deliveryStreamName: Swift.String?
        /// <p>You can configure the action payload when you send a message to an Amazon Kinesis Data Firehose delivery
        ///       stream.</p>
        public let payload: IotEventsClientTypes.Payload?
        /// <p>A character separator that is used to separate records written to the Kinesis Data
        ///       Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows
        ///       newline), ',' (comma).</p>
        public let separator: Swift.String?

        public init (
            deliveryStreamName: Swift.String? = nil,
            payload: IotEventsClientTypes.Payload? = nil,
            separator: Swift.String? = nil
        )
        {
            self.deliveryStreamName = deliveryStreamName
            self.payload = payload
            self.separator = separator
        }
    }

}

extension GetDetectorModelAnalysisResultsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDetectorModelAnalysisResultsInput(analysisId: \(Swift.String(describing: analysisId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDetectorModelAnalysisResultsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDetectorModelAnalysisResultsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorModelAnalysisResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorModelAnalysisResultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorModelAnalysisResultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorModelAnalysisResultsOutputError>
}

public struct GetDetectorModelAnalysisResultsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorModelAnalysisResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorModelAnalysisResultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorModelAnalysisResultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorModelAnalysisResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorModelAnalysisResultsOutputError>
}

public struct GetDetectorModelAnalysisResultsInput: Swift.Equatable {
    /// <p>The ID of the analysis result that you want to retrieve.</p>
    public let analysisId: Swift.String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDetectorModelAnalysisResultsInputBody: Swift.Equatable {
}

extension GetDetectorModelAnalysisResultsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDetectorModelAnalysisResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorModelAnalysisResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorModelAnalysisResultsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorModelAnalysisResultsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDetectorModelAnalysisResultsOutputResponse(analysisResults: \(Swift.String(describing: analysisResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDetectorModelAnalysisResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDetectorModelAnalysisResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisResults = output.analysisResults
            self.nextToken = output.nextToken
        } else {
            self.analysisResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetDetectorModelAnalysisResultsOutputResponse: Swift.Equatable {
    /// <p>Contains information about one or more analysis results.</p>
    public let analysisResults: [IotEventsClientTypes.AnalysisResult]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        analysisResults: [IotEventsClientTypes.AnalysisResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisResults = analysisResults
        self.nextToken = nextToken
    }
}

struct GetDetectorModelAnalysisResultsOutputResponseBody: Swift.Equatable {
    public let analysisResults: [IotEventsClientTypes.AnalysisResult]?
    public let nextToken: Swift.String?
}

extension GetDetectorModelAnalysisResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisResultsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.AnalysisResult?].self, forKey: .analysisResults)
        var analysisResultsDecoded0:[IotEventsClientTypes.AnalysisResult]? = nil
        if let analysisResultsContainer = analysisResultsContainer {
            analysisResultsDecoded0 = [IotEventsClientTypes.AnalysisResult]()
            for structure0 in analysisResultsContainer {
                if let structure0 = structure0 {
                    analysisResultsDecoded0?.append(structure0)
                }
            }
        }
        analysisResults = analysisResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IotEventsClientTypes.InitializationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledOnInitialization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledOnInitialization = disabledOnInitialization {
            try encodeContainer.encode(disabledOnInitialization, forKey: .disabledOnInitialization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledOnInitializationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabledOnInitialization)
        disabledOnInitialization = disabledOnInitializationDecoded
    }
}

extension IotEventsClientTypes.InitializationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitializationConfiguration(disabledOnInitialization: \(Swift.String(describing: disabledOnInitialization)))"}
}

extension IotEventsClientTypes {
    /// <p>Specifies the default alarm state.
    /// The configuration applies to all alarms that were created based on this alarm model.</p>
    public struct InitializationConfiguration: Swift.Equatable {
        /// <p>The value must be <code>TRUE</code> or <code>FALSE</code>. If <code>FALSE</code>, all
        ///       alarm instances created based on the alarm model are activated. The default value is
        ///         <code>TRUE</code>.</p>
        public let disabledOnInitialization: Swift.Bool?

        public init (
            disabledOnInitialization: Swift.Bool? = nil
        )
        {
            self.disabledOnInitialization = disabledOnInitialization
        }
    }

}

extension IotEventsClientTypes.Input: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
        case inputDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputConfiguration = inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let inputDefinition = inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
    }
}

extension IotEventsClientTypes.Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Input(inputConfiguration: \(Swift.String(describing: inputConfiguration)), inputDefinition: \(Swift.String(describing: inputDefinition)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about the input.</p>
    public struct Input: Swift.Equatable {
        /// <p>Information about the configuration of an input.</p>
        public let inputConfiguration: IotEventsClientTypes.InputConfiguration?
        /// <p>The definition of the input.</p>
        public let inputDefinition: IotEventsClientTypes.InputDefinition?

        public init (
            inputConfiguration: IotEventsClientTypes.InputConfiguration? = nil,
            inputDefinition: IotEventsClientTypes.InputDefinition? = nil
        )
        {
            self.inputConfiguration = inputConfiguration
            self.inputDefinition = inputDefinition
        }
    }

}

extension IotEventsClientTypes.InputConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case inputArn
        case inputDescription
        case inputName
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let inputArn = inputArn {
            try encodeContainer.encode(inputArn, forKey: .inputArn)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputArn)
        inputArn = inputArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IotEventsClientTypes.InputConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputConfiguration(creationTime: \(Swift.String(describing: creationTime)), inputArn: \(Swift.String(describing: inputArn)), inputDescription: \(Swift.String(describing: inputDescription)), inputName: \(Swift.String(describing: inputName)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), status: \(Swift.String(describing: status)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about the configuration of an input.</p>
    public struct InputConfiguration: Swift.Equatable {
        /// <p>The time the input was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The ARN of the input.</p>
        public let inputArn: Swift.String?
        /// <p>A brief description of the input.</p>
        public let inputDescription: Swift.String?
        /// <p>The name of the input.</p>
        public let inputName: Swift.String?
        /// <p>The last time the input was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The status of the input.</p>
        public let status: IotEventsClientTypes.InputStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            inputArn: Swift.String? = nil,
            inputDescription: Swift.String? = nil,
            inputName: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: IotEventsClientTypes.InputStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

extension IotEventsClientTypes.InputDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributes0 in attributes {
                try attributesContainer.encode(attributes0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[IotEventsClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [IotEventsClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension IotEventsClientTypes.InputDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputDefinition(attributes: \(Swift.String(describing: attributes)))"}
}

extension IotEventsClientTypes {
    /// <p>The definition of the input.</p>
    public struct InputDefinition: Swift.Equatable {
        /// <p>The attributes from the JSON payload that are made available by the input. Inputs are
        ///       derived from messages sent to the AWS IoT Events system using <code>BatchPutMessage</code>. Each such
        ///       message contains a JSON payload, and those attributes (and their paired values) specified here
        ///       are available for use in the <code>condition</code> expressions used by detectors that monitor
        ///       this input. </p>
        public let attributes: [IotEventsClientTypes.Attribute]?

        public init (
            attributes: [IotEventsClientTypes.Attribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension IotEventsClientTypes.InputIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotEventsInputIdentifier
        case iotSiteWiseInputIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotEventsInputIdentifier = iotEventsInputIdentifier {
            try encodeContainer.encode(iotEventsInputIdentifier, forKey: .iotEventsInputIdentifier)
        }
        if let iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifier {
            try encodeContainer.encode(iotSiteWiseInputIdentifier, forKey: .iotSiteWiseInputIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotEventsInputIdentifierDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotEventsInputIdentifier.self, forKey: .iotEventsInputIdentifier)
        iotEventsInputIdentifier = iotEventsInputIdentifierDecoded
        let iotSiteWiseInputIdentifierDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotSiteWiseInputIdentifier.self, forKey: .iotSiteWiseInputIdentifier)
        iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifierDecoded
    }
}

extension IotEventsClientTypes.InputIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputIdentifier(iotEventsInputIdentifier: \(Swift.String(describing: iotEventsInputIdentifier)), iotSiteWiseInputIdentifier: \(Swift.String(describing: iotSiteWiseInputIdentifier)))"}
}

extension IotEventsClientTypes {
    /// <p>
    ///       The identifer of the input.
    ///     </p>
    public struct InputIdentifier: Swift.Equatable {
        /// <p>
        ///       The identifier of the input routed to AWS IoT Events.
        ///     </p>
        public let iotEventsInputIdentifier: IotEventsClientTypes.IotEventsInputIdentifier?
        /// <p>
        ///       The identifer of the input routed from AWS IoT SiteWise.
        ///     </p>
        public let iotSiteWiseInputIdentifier: IotEventsClientTypes.IotSiteWiseInputIdentifier?

        public init (
            iotEventsInputIdentifier: IotEventsClientTypes.IotEventsInputIdentifier? = nil,
            iotSiteWiseInputIdentifier: IotEventsClientTypes.IotSiteWiseInputIdentifier? = nil
        )
        {
            self.iotEventsInputIdentifier = iotEventsInputIdentifier
            self.iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifier
        }
    }

}

extension IotEventsClientTypes {
    public enum InputStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [InputStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputStatus(rawValue: rawValue) ?? InputStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsClientTypes.InputSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case inputArn
        case inputDescription
        case inputName
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let inputArn = inputArn {
            try encodeContainer.encode(inputArn, forKey: .inputArn)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputArn)
        inputArn = inputArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IotEventsClientTypes.InputSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputSummary(creationTime: \(Swift.String(describing: creationTime)), inputArn: \(Swift.String(describing: inputArn)), inputDescription: \(Swift.String(describing: inputDescription)), inputName: \(Swift.String(describing: inputName)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), status: \(Swift.String(describing: status)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about the input.</p>
    public struct InputSummary: Swift.Equatable {
        /// <p>The time the input was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The ARN of the input.</p>
        public let inputArn: Swift.String?
        /// <p>A brief description of the input.</p>
        public let inputDescription: Swift.String?
        /// <p>The name of the input.</p>
        public let inputName: Swift.String?
        /// <p>The last time the input was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The status of the input.</p>
        public let status: IotEventsClientTypes.InputStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            inputArn: Swift.String? = nil,
            inputDescription: Swift.String? = nil,
            inputName: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: IotEventsClientTypes.InputStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was invalid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsClientTypes.IotEventsAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputName
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.IotEventsAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IotEventsAction(inputName: \(Swift.String(describing: inputName)), payload: \(Swift.String(describing: payload)))"}
}

extension IotEventsClientTypes {
    /// <p>Sends an AWS IoT Events input, passing in information about the detector model instance and the
    ///       event that triggered the action.</p>
    public struct IotEventsAction: Swift.Equatable {
        /// <p>The name of the AWS IoT Events input where the data is sent.</p>
        public let inputName: Swift.String?
        /// <p>You can configure the action payload when you send a message to an AWS IoT Events input.</p>
        public let payload: IotEventsClientTypes.Payload?

        public init (
            inputName: Swift.String? = nil,
            payload: IotEventsClientTypes.Payload? = nil
        )
        {
            self.inputName = inputName
            self.payload = payload
        }
    }

}

extension IotEventsClientTypes.IotEventsInputIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
    }
}

extension IotEventsClientTypes.IotEventsInputIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IotEventsInputIdentifier(inputName: \(Swift.String(describing: inputName)))"}
}

extension IotEventsClientTypes {
    /// <p>
    ///       The identifier of the input routed to AWS IoT Events.
    ///     </p>
    public struct IotEventsInputIdentifier: Swift.Equatable {
        /// <p>
        ///       The name of the input routed to AWS IoT Events.
        ///     </p>
        public let inputName: Swift.String?

        public init (
            inputName: Swift.String? = nil
        )
        {
            self.inputName = inputName
        }
    }

}

extension IotEventsClientTypes.IotSiteWiseAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValue = propertyValue {
            try encodeContainer.encode(propertyValue, forKey: .propertyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValueDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AssetPropertyValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension IotEventsClientTypes.IotSiteWiseAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IotSiteWiseAction(assetId: \(Swift.String(describing: assetId)), entryId: \(Swift.String(describing: entryId)), propertyAlias: \(Swift.String(describing: propertyAlias)), propertyId: \(Swift.String(describing: propertyId)), propertyValue: \(Swift.String(describing: propertyValue)))"}
}

extension IotEventsClientTypes {
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to a specified asset property in AWS IoT SiteWise.</p>
    ///          <p>You must use expressions for all parameters in <code>IotSiteWiseAction</code>. The
    ///       expressions accept literals, operators, functions, references, and substitutions
    ///       templates.</p>
    ///          <p class="title">
    ///             <b>Examples</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>For literal values, the expressions must contain single quotes. For example, the value
    ///           for the <code>propertyAlias</code> parameter can be
    ///             <code>'/company/windfarm/3/turbine/7/temperature'</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For references, you must specify either variables or input values. For example, the
    ///           value for the <code>assetId</code> parameter can be
    ///             <code>$input.TurbineInput.assetId1</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For a substitution template, you must use <code>${}</code>, and the template must be
    ///           in single quotes. A substitution template can also contain a combination of literals,
    ///           operators, functions, references, and substitution templates.</p>
    ///                <p>In the following example, the value for the <code>propertyAlias</code> parameter uses
    ///           a substitution template. </p>
    ///                <p>
    ///                   <code>'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/
    ///             ${$input.TemperatureInput.sensorData.turbineID}/temperature'</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>You must specify either <code>propertyAlias</code> or both <code>assetId</code> and
    ///         <code>propertyId</code> to identify the target asset property in AWS IoT SiteWise.</p>
    ///          <p>For more information,
    ///         see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html">Expressions</a>
    ///         in the <i>AWS IoT Events Developer Guide</i>.</p>
    public struct IotSiteWiseAction: Swift.Equatable {
        /// <p>The ID of the asset that has the specified property.</p>
        public let assetId: Swift.String?
        /// <p>A unique identifier for this entry. You can use the entry ID to track which data entry
        ///       causes an error in case of failure. The default is a new unique identifier.</p>
        public let entryId: Swift.String?
        /// <p>The alias of the asset property.</p>
        public let propertyAlias: Swift.String?
        /// <p>The ID of the asset property.</p>
        public let propertyId: Swift.String?
        /// <p>The value to send to the asset property. This value contains timestamp, quality, and value
        ///       (TQV) information. </p>
        public let propertyValue: IotEventsClientTypes.AssetPropertyValue?

        public init (
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValue: IotEventsClientTypes.AssetPropertyValue? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValue = propertyValue
        }
    }

}

extension IotEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelId
        case propertyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
    }
}

extension IotEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IotSiteWiseAssetModelPropertyIdentifier(assetModelId: \(Swift.String(describing: assetModelId)), propertyId: \(Swift.String(describing: propertyId)))"}
}

extension IotEventsClientTypes {
    /// <p>
    ///       The asset model property identifer of the input routed from AWS IoT SiteWise.
    ///     </p>
    public struct IotSiteWiseAssetModelPropertyIdentifier: Swift.Equatable {
        /// <p>
        ///       The ID of the AWS IoT SiteWise asset model.
        ///     </p>
        public let assetModelId: Swift.String?
        /// <p>
        ///       The ID of the AWS IoT SiteWise asset property.
        ///     </p>
        public let propertyId: Swift.String?

        public init (
            assetModelId: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.assetModelId = assetModelId
            self.propertyId = propertyId
        }
    }

}

extension IotEventsClientTypes.IotSiteWiseInputIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotSiteWiseAssetModelPropertyIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifier {
            try encodeContainer.encode(iotSiteWiseAssetModelPropertyIdentifier, forKey: .iotSiteWiseAssetModelPropertyIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotSiteWiseAssetModelPropertyIdentifierDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier.self, forKey: .iotSiteWiseAssetModelPropertyIdentifier)
        iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifierDecoded
    }
}

extension IotEventsClientTypes.IotSiteWiseInputIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IotSiteWiseInputIdentifier(iotSiteWiseAssetModelPropertyIdentifier: \(Swift.String(describing: iotSiteWiseAssetModelPropertyIdentifier)))"}
}

extension IotEventsClientTypes {
    /// <p>
    ///       The identifer of the input routed from AWS IoT SiteWise.
    ///     </p>
    public struct IotSiteWiseInputIdentifier: Swift.Equatable {
        /// <p>
        ///       The identifier of the AWS IoT SiteWise asset model property.
        ///     </p>
        public let iotSiteWiseAssetModelPropertyIdentifier: IotEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier?

        public init (
            iotSiteWiseAssetModelPropertyIdentifier: IotEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier? = nil
        )
        {
            self.iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifier
        }
    }

}

extension IotEventsClientTypes.IotTopicPublishAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mqttTopic
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mqttTopic = mqttTopic {
            try encodeContainer.encode(mqttTopic, forKey: .mqttTopic)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mqttTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mqttTopic)
        mqttTopic = mqttTopicDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.IotTopicPublishAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IotTopicPublishAction(mqttTopic: \(Swift.String(describing: mqttTopic)), payload: \(Swift.String(describing: payload)))"}
}

extension IotEventsClientTypes {
    /// <p>Information required to publish the MQTT message through the AWS IoT message broker.</p>
    public struct IotTopicPublishAction: Swift.Equatable {
        /// <p>The MQTT topic of the message. You can use a string expression that includes variables
        ///         (<code>$variable.<variable-name></code>) and input values
        ///         (<code>$input.<input-name>.<path-to-datum></code>) as the topic string.</p>
        public let mqttTopic: Swift.String?
        /// <p>You can configure the action payload when you publish a message to an AWS IoT Core
        ///       topic.</p>
        public let payload: IotEventsClientTypes.Payload?

        public init (
            mqttTopic: Swift.String? = nil,
            payload: IotEventsClientTypes.Payload? = nil
        )
        {
            self.mqttTopic = mqttTopic
            self.payload = payload
        }
    }

}

extension IotEventsClientTypes.LambdaAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.LambdaAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaAction(functionArn: \(Swift.String(describing: functionArn)), payload: \(Swift.String(describing: payload)))"}
}

extension IotEventsClientTypes {
    /// <p>Calls a Lambda function, passing in information about the detector model instance and the
    ///       event that triggered the action.</p>
    public struct LambdaAction: Swift.Equatable {
        /// <p>The ARN of the Lambda function that is executed.</p>
        public let functionArn: Swift.String?
        /// <p>You can configure the action payload when you send a message to a Lambda function.</p>
        public let payload: IotEventsClientTypes.Payload?

        public init (
            functionArn: Swift.String? = nil,
            payload: IotEventsClientTypes.Payload? = nil
        )
        {
            self.functionArn = functionArn
            self.payload = payload
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit was exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmModelVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmModelVersionsInput(alarmModelName: \(Swift.String(describing: alarmModelName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmModelVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAlarmModelVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmModelVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmModelVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmModelVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmModelVersionsOutputError>
}

public struct ListAlarmModelVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmModelVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmModelVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmModelVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmModelVersionsOutputError>
}

public struct ListAlarmModelVersionsInput: Swift.Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: Swift.String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmModelVersionsInputBody: Swift.Equatable {
}

extension ListAlarmModelVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAlarmModelVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmModelVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmModelVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmModelVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmModelVersionsOutputResponse(alarmModelVersionSummaries: \(Swift.String(describing: alarmModelVersionSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmModelVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAlarmModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelVersionSummaries = output.alarmModelVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmModelVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmModelVersionsOutputResponse: Swift.Equatable {
    /// <p>A list that summarizes each alarm model version.</p>
    public let alarmModelVersionSummaries: [IotEventsClientTypes.AlarmModelVersionSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        alarmModelVersionSummaries: [IotEventsClientTypes.AlarmModelVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelVersionSummaries = alarmModelVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmModelVersionsOutputResponseBody: Swift.Equatable {
    public let alarmModelVersionSummaries: [IotEventsClientTypes.AlarmModelVersionSummary]?
    public let nextToken: Swift.String?
}

extension ListAlarmModelVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelVersionSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelVersionSummariesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.AlarmModelVersionSummary?].self, forKey: .alarmModelVersionSummaries)
        var alarmModelVersionSummariesDecoded0:[IotEventsClientTypes.AlarmModelVersionSummary]? = nil
        if let alarmModelVersionSummariesContainer = alarmModelVersionSummariesContainer {
            alarmModelVersionSummariesDecoded0 = [IotEventsClientTypes.AlarmModelVersionSummary]()
            for structure0 in alarmModelVersionSummariesContainer {
                if let structure0 = structure0 {
                    alarmModelVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmModelVersionSummaries = alarmModelVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAlarmModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmModelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmModelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAlarmModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmModelsOutputError>
}

public struct ListAlarmModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmModelsOutputError>
}

public struct ListAlarmModelsInput: Swift.Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmModelsInputBody: Swift.Equatable {
}

extension ListAlarmModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAlarmModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmModelsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmModelsOutputResponse(alarmModelSummaries: \(Swift.String(describing: alarmModelSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAlarmModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelSummaries = output.alarmModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmModelsOutputResponse: Swift.Equatable {
    /// <p>A list that summarizes each alarm model.</p>
    public let alarmModelSummaries: [IotEventsClientTypes.AlarmModelSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        alarmModelSummaries: [IotEventsClientTypes.AlarmModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelSummaries = alarmModelSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmModelsOutputResponseBody: Swift.Equatable {
    public let alarmModelSummaries: [IotEventsClientTypes.AlarmModelSummary]?
    public let nextToken: Swift.String?
}

extension ListAlarmModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelSummariesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.AlarmModelSummary?].self, forKey: .alarmModelSummaries)
        var alarmModelSummariesDecoded0:[IotEventsClientTypes.AlarmModelSummary]? = nil
        if let alarmModelSummariesContainer = alarmModelSummariesContainer {
            alarmModelSummariesDecoded0 = [IotEventsClientTypes.AlarmModelSummary]()
            for structure0 in alarmModelSummariesContainer {
                if let structure0 = structure0 {
                    alarmModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmModelSummaries = alarmModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorModelVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDetectorModelVersionsInput(detectorModelName: \(Swift.String(describing: detectorModelName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDetectorModelVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDetectorModelVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDetectorModelVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDetectorModelVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDetectorModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDetectorModelVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDetectorModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDetectorModelVersionsOutputError>
}

public struct ListDetectorModelVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDetectorModelVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDetectorModelVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDetectorModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDetectorModelVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDetectorModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDetectorModelVersionsOutputError>
}

public struct ListDetectorModelVersionsInput: Swift.Equatable {
    /// <p>The name of the detector model whose versions are returned.</p>
    public let detectorModelName: Swift.String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorModelVersionsInputBody: Swift.Equatable {
}

extension ListDetectorModelVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorModelVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorModelVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorModelVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorModelVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDetectorModelVersionsOutputResponse(detectorModelVersionSummaries: \(Swift.String(describing: detectorModelVersionSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDetectorModelVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDetectorModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelVersionSummaries = output.detectorModelVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorModelVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorModelVersionsOutputResponse: Swift.Equatable {
    /// <p>Summary information about the detector model versions.</p>
    public let detectorModelVersionSummaries: [IotEventsClientTypes.DetectorModelVersionSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        detectorModelVersionSummaries: [IotEventsClientTypes.DetectorModelVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelVersionSummaries = detectorModelVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorModelVersionsOutputResponseBody: Swift.Equatable {
    public let detectorModelVersionSummaries: [IotEventsClientTypes.DetectorModelVersionSummary]?
    public let nextToken: Swift.String?
}

extension ListDetectorModelVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelVersionSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelVersionSummariesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.DetectorModelVersionSummary?].self, forKey: .detectorModelVersionSummaries)
        var detectorModelVersionSummariesDecoded0:[IotEventsClientTypes.DetectorModelVersionSummary]? = nil
        if let detectorModelVersionSummariesContainer = detectorModelVersionSummariesContainer {
            detectorModelVersionSummariesDecoded0 = [IotEventsClientTypes.DetectorModelVersionSummary]()
            for structure0 in detectorModelVersionSummariesContainer {
                if let structure0 = structure0 {
                    detectorModelVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorModelVersionSummaries = detectorModelVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDetectorModelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDetectorModelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDetectorModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDetectorModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDetectorModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDetectorModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDetectorModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDetectorModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDetectorModelsOutputError>
}

public struct ListDetectorModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDetectorModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDetectorModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDetectorModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDetectorModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDetectorModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDetectorModelsOutputError>
}

public struct ListDetectorModelsInput: Swift.Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorModelsInputBody: Swift.Equatable {
}

extension ListDetectorModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorModelsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDetectorModelsOutputResponse(detectorModelSummaries: \(Swift.String(describing: detectorModelSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDetectorModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDetectorModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelSummaries = output.detectorModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorModelsOutputResponse: Swift.Equatable {
    /// <p>Summary information about the detector models.</p>
    public let detectorModelSummaries: [IotEventsClientTypes.DetectorModelSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        detectorModelSummaries: [IotEventsClientTypes.DetectorModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelSummaries = detectorModelSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorModelsOutputResponseBody: Swift.Equatable {
    public let detectorModelSummaries: [IotEventsClientTypes.DetectorModelSummary]?
    public let nextToken: Swift.String?
}

extension ListDetectorModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelSummariesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.DetectorModelSummary?].self, forKey: .detectorModelSummaries)
        var detectorModelSummariesDecoded0:[IotEventsClientTypes.DetectorModelSummary]? = nil
        if let detectorModelSummariesContainer = detectorModelSummariesContainer {
            detectorModelSummariesDecoded0 = [IotEventsClientTypes.DetectorModelSummary]()
            for structure0 in detectorModelSummariesContainer {
                if let structure0 = structure0 {
                    detectorModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorModelSummaries = detectorModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInputRoutingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInputRoutingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInputRoutingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInputRoutingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInputRoutingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInputRoutingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInputRoutingsOutputError>
}

extension ListInputRoutingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInputRoutingsInput(inputIdentifier: \(Swift.String(describing: inputIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInputRoutingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputIdentifier
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputIdentifier = inputIdentifier {
            try encodeContainer.encode(inputIdentifier, forKey: .inputIdentifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInputRoutingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInputRoutingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInputRoutingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInputRoutingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInputRoutingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInputRoutingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInputRoutingsOutputError>
}

public struct ListInputRoutingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInputRoutingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInputRoutingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInputRoutingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInputRoutingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInputRoutingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInputRoutingsOutputError>
}

public struct ListInputRoutingsInput: Swift.Equatable {
    /// <p>
    ///       The identifer of the routed input.
    ///     </p>
    public let inputIdentifier: IotEventsClientTypes.InputIdentifier?
    /// <p>
    ///       The maximum number of results to be returned per request.
    ///     </p>
    public let maxResults: Swift.Int?
    /// <p>
    ///       The token that you can use to return the next set of results.
    ///     </p>
    public let nextToken: Swift.String?

    public init (
        inputIdentifier: IotEventsClientTypes.InputIdentifier? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inputIdentifier = inputIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInputRoutingsInputBody: Swift.Equatable {
    public let inputIdentifier: IotEventsClientTypes.InputIdentifier?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListInputRoutingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputIdentifier
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdentifierDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputIdentifier.self, forKey: .inputIdentifier)
        inputIdentifier = inputIdentifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInputRoutingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInputRoutingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInputRoutingsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInputRoutingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInputRoutingsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), routedResources: \(Swift.String(describing: routedResources)))"}
}

extension ListInputRoutingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInputRoutingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routedResources = output.routedResources
        } else {
            self.nextToken = nil
            self.routedResources = nil
        }
    }
}

public struct ListInputRoutingsOutputResponse: Swift.Equatable {
    /// <p>
    ///       The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.
    ///     </p>
    public let nextToken: Swift.String?
    /// <p>
    ///       Summary information about the routed resources.
    ///     </p>
    public let routedResources: [IotEventsClientTypes.RoutedResource]?

    public init (
        nextToken: Swift.String? = nil,
        routedResources: [IotEventsClientTypes.RoutedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.routedResources = routedResources
    }
}

struct ListInputRoutingsOutputResponseBody: Swift.Equatable {
    public let routedResources: [IotEventsClientTypes.RoutedResource]?
    public let nextToken: Swift.String?
}

extension ListInputRoutingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case routedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routedResourcesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.RoutedResource?].self, forKey: .routedResources)
        var routedResourcesDecoded0:[IotEventsClientTypes.RoutedResource]? = nil
        if let routedResourcesContainer = routedResourcesContainer {
            routedResourcesDecoded0 = [IotEventsClientTypes.RoutedResource]()
            for structure0 in routedResourcesContainer {
                if let structure0 = structure0 {
                    routedResourcesDecoded0?.append(structure0)
                }
            }
        }
        routedResources = routedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInputsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInputsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInputsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListInputsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInputsOutputError>
}

public struct ListInputsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInputsOutputError>
}

public struct ListInputsInput: Swift.Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInputsInputBody: Swift.Equatable {
}

extension ListInputsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInputsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInputsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInputsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInputsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInputsOutputResponse(inputSummaries: \(Swift.String(describing: inputSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInputsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInputsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputSummaries = output.inputSummaries
            self.nextToken = output.nextToken
        } else {
            self.inputSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListInputsOutputResponse: Swift.Equatable {
    /// <p>Summary information about the inputs.</p>
    public let inputSummaries: [IotEventsClientTypes.InputSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        inputSummaries: [IotEventsClientTypes.InputSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inputSummaries = inputSummaries
        self.nextToken = nextToken
    }
}

struct ListInputsOutputResponseBody: Swift.Equatable {
    public let inputSummaries: [IotEventsClientTypes.InputSummary]?
    public let nextToken: Swift.String?
}

extension ListInputsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSummariesContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.InputSummary?].self, forKey: .inputSummaries)
        var inputSummariesDecoded0:[IotEventsClientTypes.InputSummary]? = nil
        if let inputSummariesContainer = inputSummariesContainer {
            inputSummariesDecoded0 = [IotEventsClientTypes.InputSummary]()
            for structure0 in inputSummariesContainer {
                if let structure0 = structure0 {
                    inputSummariesDecoded0?.append(structure0)
                }
            }
        }
        inputSummaries = inputSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The list of tags assigned to the resource.</p>
    public let tags: [IotEventsClientTypes.Tag]?

    public init (
        tags: [IotEventsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [IotEventsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IotEventsClientTypes {
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .debug,
                .error,
                .info,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsClientTypes.LoggingOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorDebugOptions
        case enabled
        case level
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorDebugOptions = detectorDebugOptions {
            var detectorDebugOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectorDebugOptions)
            for detectordebugoptions0 in detectorDebugOptions {
                try detectorDebugOptionsContainer.encode(detectordebugoptions0)
            }
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let levelDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.LoggingLevel.self, forKey: .level)
        level = levelDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let detectorDebugOptionsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.DetectorDebugOption?].self, forKey: .detectorDebugOptions)
        var detectorDebugOptionsDecoded0:[IotEventsClientTypes.DetectorDebugOption]? = nil
        if let detectorDebugOptionsContainer = detectorDebugOptionsContainer {
            detectorDebugOptionsDecoded0 = [IotEventsClientTypes.DetectorDebugOption]()
            for structure0 in detectorDebugOptionsContainer {
                if let structure0 = structure0 {
                    detectorDebugOptionsDecoded0?.append(structure0)
                }
            }
        }
        detectorDebugOptions = detectorDebugOptionsDecoded0
    }
}

extension IotEventsClientTypes.LoggingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingOptions(detectorDebugOptions: \(Swift.String(describing: detectorDebugOptions)), enabled: \(Swift.String(describing: enabled)), level: \(Swift.String(describing: level)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IotEventsClientTypes {
    /// <p>The values of the AWS IoT Events logging options.</p>
    public struct LoggingOptions: Swift.Equatable {
        /// <p>Information that identifies those detector models and their detectors (instances) for
        ///       which the logging level is given.</p>
        public let detectorDebugOptions: [IotEventsClientTypes.DetectorDebugOption]?
        /// <p>If TRUE, logging is enabled for AWS IoT Events.</p>
        public let enabled: Swift.Bool
        /// <p>The logging level.</p>
        public let level: IotEventsClientTypes.LoggingLevel?
        /// <p>The ARN of the role that grants permission to AWS IoT Events to perform logging.</p>
        public let roleArn: Swift.String?

        public init (
            detectorDebugOptions: [IotEventsClientTypes.DetectorDebugOption]? = nil,
            enabled: Swift.Bool = false,
            level: IotEventsClientTypes.LoggingLevel? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.detectorDebugOptions = detectorDebugOptions
            self.enabled = enabled
            self.level = level
            self.roleArn = roleArn
        }
    }

}

extension IotEventsClientTypes.NotificationAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case emailConfigurations
        case smsConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let emailConfigurations = emailConfigurations {
            var emailConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emailConfigurations)
            for emailconfigurations0 in emailConfigurations {
                try emailConfigurationsContainer.encode(emailconfigurations0)
            }
        }
        if let smsConfigurations = smsConfigurations {
            var smsConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smsConfigurations)
            for smsconfigurations0 in smsConfigurations {
                try smsConfigurationsContainer.encode(smsconfigurations0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.NotificationTargetActions.self, forKey: .action)
        action = actionDecoded
        let smsConfigurationsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.SMSConfiguration?].self, forKey: .smsConfigurations)
        var smsConfigurationsDecoded0:[IotEventsClientTypes.SMSConfiguration]? = nil
        if let smsConfigurationsContainer = smsConfigurationsContainer {
            smsConfigurationsDecoded0 = [IotEventsClientTypes.SMSConfiguration]()
            for structure0 in smsConfigurationsContainer {
                if let structure0 = structure0 {
                    smsConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        smsConfigurations = smsConfigurationsDecoded0
        let emailConfigurationsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.EmailConfiguration?].self, forKey: .emailConfigurations)
        var emailConfigurationsDecoded0:[IotEventsClientTypes.EmailConfiguration]? = nil
        if let emailConfigurationsContainer = emailConfigurationsContainer {
            emailConfigurationsDecoded0 = [IotEventsClientTypes.EmailConfiguration]()
            for structure0 in emailConfigurationsContainer {
                if let structure0 = structure0 {
                    emailConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        emailConfigurations = emailConfigurationsDecoded0
    }
}

extension IotEventsClientTypes.NotificationAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationAction(action: \(Swift.String(describing: action)), emailConfigurations: \(Swift.String(describing: emailConfigurations)), smsConfigurations: \(Swift.String(describing: smsConfigurations)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains the notification settings of an alarm model.
    /// The settings apply to all alarms that were created based on this alarm model.</p>
    public struct NotificationAction: Swift.Equatable {
        /// <p>Specifies an AWS Lambda function to manage alarm notifications.
        /// You can create one or use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">AWS Lambda function provided by AWS IoT Events</a>.</p>
        public let action: IotEventsClientTypes.NotificationTargetActions?
        /// <p>Contains the configuration information of email notifications.</p>
        public let emailConfigurations: [IotEventsClientTypes.EmailConfiguration]?
        /// <p>Contains the configuration information of SMS notifications.</p>
        public let smsConfigurations: [IotEventsClientTypes.SMSConfiguration]?

        public init (
            action: IotEventsClientTypes.NotificationTargetActions? = nil,
            emailConfigurations: [IotEventsClientTypes.EmailConfiguration]? = nil,
            smsConfigurations: [IotEventsClientTypes.SMSConfiguration]? = nil
        )
        {
            self.action = action
            self.emailConfigurations = emailConfigurations
            self.smsConfigurations = smsConfigurations
        }
    }

}

extension IotEventsClientTypes.NotificationTargetActions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaAction = lambdaAction {
            try encodeContainer.encode(lambdaAction, forKey: .lambdaAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaActionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.LambdaAction.self, forKey: .lambdaAction)
        lambdaAction = lambdaActionDecoded
    }
}

extension IotEventsClientTypes.NotificationTargetActions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationTargetActions(lambdaAction: \(Swift.String(describing: lambdaAction)))"}
}

extension IotEventsClientTypes {
    /// <p>Specifies an AWS Lambda function to manage alarm notifications.
    /// You can create one or use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">AWS Lambda function provided by AWS IoT Events</a>.</p>
    public struct NotificationTargetActions: Swift.Equatable {
        /// <p>Calls a Lambda function, passing in information about the detector model instance and the
        ///       event that triggered the action.</p>
        public let lambdaAction: IotEventsClientTypes.LambdaAction?

        public init (
            lambdaAction: IotEventsClientTypes.LambdaAction? = nil
        )
        {
            self.lambdaAction = lambdaAction
        }
    }

}

extension IotEventsClientTypes.OnEnterLifecycle: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for events0 in events {
                try eventsContainer.encode(events0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IotEventsClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IotEventsClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IotEventsClientTypes.OnEnterLifecycle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OnEnterLifecycle(events: \(Swift.String(describing: events)))"}
}

extension IotEventsClientTypes {
    /// <p>When entering this state, perform these <code>actions</code> if the <code>condition</code>
    ///       is TRUE.</p>
    public struct OnEnterLifecycle: Swift.Equatable {
        /// <p>Specifies the actions that are performed when the state is entered and the
        ///         <code>condition</code> is <code>TRUE</code>.</p>
        public let events: [IotEventsClientTypes.Event]?

        public init (
            events: [IotEventsClientTypes.Event]? = nil
        )
        {
            self.events = events
        }
    }

}

extension IotEventsClientTypes.OnExitLifecycle: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for events0 in events {
                try eventsContainer.encode(events0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IotEventsClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IotEventsClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IotEventsClientTypes.OnExitLifecycle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OnExitLifecycle(events: \(Swift.String(describing: events)))"}
}

extension IotEventsClientTypes {
    /// <p>When exiting this state, perform these <code>actions</code> if the specified
    ///         <code>condition</code> is <code>TRUE</code>.</p>
    public struct OnExitLifecycle: Swift.Equatable {
        /// <p>Specifies the <code>actions</code> that are performed when the state is exited and the
        ///         <code>condition</code> is <code>TRUE</code>.</p>
        public let events: [IotEventsClientTypes.Event]?

        public init (
            events: [IotEventsClientTypes.Event]? = nil
        )
        {
            self.events = events
        }
    }

}

extension IotEventsClientTypes.OnInputLifecycle: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case transitionEvents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for events0 in events {
                try eventsContainer.encode(events0)
            }
        }
        if let transitionEvents = transitionEvents {
            var transitionEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transitionEvents)
            for transitionevents0 in transitionEvents {
                try transitionEventsContainer.encode(transitionevents0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IotEventsClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IotEventsClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let transitionEventsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.TransitionEvent?].self, forKey: .transitionEvents)
        var transitionEventsDecoded0:[IotEventsClientTypes.TransitionEvent]? = nil
        if let transitionEventsContainer = transitionEventsContainer {
            transitionEventsDecoded0 = [IotEventsClientTypes.TransitionEvent]()
            for structure0 in transitionEventsContainer {
                if let structure0 = structure0 {
                    transitionEventsDecoded0?.append(structure0)
                }
            }
        }
        transitionEvents = transitionEventsDecoded0
    }
}

extension IotEventsClientTypes.OnInputLifecycle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OnInputLifecycle(events: \(Swift.String(describing: events)), transitionEvents: \(Swift.String(describing: transitionEvents)))"}
}

extension IotEventsClientTypes {
    /// <p>Specifies the actions performed when the <code>condition</code> evaluates to TRUE.</p>
    public struct OnInputLifecycle: Swift.Equatable {
        /// <p>Specifies the actions performed when the <code>condition</code> evaluates to TRUE.</p>
        public let events: [IotEventsClientTypes.Event]?
        /// <p>Specifies the actions performed, and the next state entered, when a <code>condition</code>
        ///       evaluates to TRUE.</p>
        public let transitionEvents: [IotEventsClientTypes.TransitionEvent]?

        public init (
            events: [IotEventsClientTypes.Event]? = nil,
            transitionEvents: [IotEventsClientTypes.TransitionEvent]? = nil
        )
        {
            self.events = events
            self.transitionEvents = transitionEvents
        }
    }

}

extension IotEventsClientTypes.Payload: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentExpression
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentExpression = contentExpression {
            try encodeContainer.encode(contentExpression, forKey: .contentExpression)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentExpression)
        contentExpression = contentExpressionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.PayloadType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IotEventsClientTypes.Payload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Payload(contentExpression: \(Swift.String(describing: contentExpression)), type: \(Swift.String(describing: type)))"}
}

extension IotEventsClientTypes {
    /// <p>Information needed to configure the payload.</p>
    ///          <p>By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload
    ///       contains all attribute-value pairs that have the information about the detector model instance
    ///       and the event triggered the action. To configure the action payload, you can use
    ///         <code>contentExpression</code>.</p>
    public struct Payload: Swift.Equatable {
        /// <p>The content of the payload. You can use a string expression that includes quoted strings
        ///         (<code>'<string>'</code>), variables (<code>$variable.<variable-name></code>),
        ///       input values (<code>$input.<input-name>.<path-to-datum></code>), string
        ///       concatenations, and quoted strings that contain <code>${}</code> as the content. The
        ///       recommended maximum size of a content expression is 1 KB.</p>
        public let contentExpression: Swift.String?
        /// <p>The value of the payload type can be either <code>STRING</code> or
        ///       <code>JSON</code>.</p>
        public let type: IotEventsClientTypes.PayloadType?

        public init (
            contentExpression: Swift.String? = nil,
            type: IotEventsClientTypes.PayloadType? = nil
        )
        {
            self.contentExpression = contentExpression
            self.type = type
        }
    }

}

extension IotEventsClientTypes {
    public enum PayloadType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [PayloadType] {
            return [
                .json,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PayloadType(rawValue: rawValue) ?? PayloadType.sdkUnknown(rawValue)
        }
    }
}

public struct PutLoggingOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

extension PutLoggingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLoggingOptionsInput(loggingOptions: \(Swift.String(describing: loggingOptions)))"}
}

extension PutLoggingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

public struct PutLoggingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// <p>The new values of the AWS IoT Events logging options.</p>
    public let loggingOptions: IotEventsClientTypes.LoggingOptions?

    public init (
        loggingOptions: IotEventsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    public let loggingOptions: IotEventsClientTypes.LoggingOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLoggingOptionsOutputResponse()"}
}

extension PutLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutLoggingOptionsOutputResponseBody: Swift.Equatable {
}

extension PutLoggingOptionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotEventsClientTypes.RecipientDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssoIdentity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssoIdentity = ssoIdentity {
            try encodeContainer.encode(ssoIdentity, forKey: .ssoIdentity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssoIdentityDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.SSOIdentity.self, forKey: .ssoIdentity)
        ssoIdentity = ssoIdentityDecoded
    }
}

extension IotEventsClientTypes.RecipientDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecipientDetail(ssoIdentity: \(Swift.String(describing: ssoIdentity)))"}
}

extension IotEventsClientTypes {
    /// <p>The information that identifies the recipient.</p>
    public struct RecipientDetail: Swift.Equatable {
        /// <p>The AWS Single Sign-On (AWS SSO) authentication information.</p>
        public let ssoIdentity: IotEventsClientTypes.SSOIdentity?

        public init (
            ssoIdentity: IotEventsClientTypes.SSOIdentity? = nil
        )
        {
            self.ssoIdentity = ssoIdentity
        }
    }

}

extension IotEventsClientTypes.ResetTimerAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timerName = timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timerName)
        timerName = timerNameDecoded
    }
}

extension IotEventsClientTypes.ResetTimerAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetTimerAction(timerName: \(Swift.String(describing: timerName)))"}
}

extension IotEventsClientTypes {
    /// <p>Information required to reset the timer. The timer is reset to the previously evaluated
    ///       result of the duration. The duration expression isn't reevaluated when you reset the
    ///       timer.</p>
    public struct ResetTimerAction: Swift.Equatable {
        /// <p>The name of the timer to reset.</p>
        public let timerName: Swift.String?

        public init (
            timerName: Swift.String? = nil
        )
        {
            self.timerName = timerName
        }
    }

}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)), resourceArn: \(Swift.String(describing: resourceArn)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?
    /// <p>The ARN of the resource.</p>
    public var resourceArn: Swift.String?
    /// <p>The ID of the resource.</p>
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsClientTypes.RoutedResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IotEventsClientTypes.RoutedResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoutedResource(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension IotEventsClientTypes {
    /// <p>
    ///       Contains information about the routed resource.
    ///     </p>
    public struct RoutedResource: Swift.Equatable {
        /// <p>
        ///       The ARN of the routed resource. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.
        ///     </p>
        public let arn: Swift.String?
        /// <p>
        ///       The name of the routed resource.
        ///     </p>
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension IotEventsClientTypes.SMSConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMessage
        case recipients
        case senderId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMessage = additionalMessage {
            try encodeContainer.encode(additionalMessage, forKey: .additionalMessage)
        }
        if let recipients = recipients {
            var recipientsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipients)
            for recipientdetails0 in recipients {
                try recipientsContainer.encode(recipientdetails0)
            }
        }
        if let senderId = senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let additionalMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMessage)
        additionalMessage = additionalMessageDecoded
        let recipientsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.RecipientDetail?].self, forKey: .recipients)
        var recipientsDecoded0:[IotEventsClientTypes.RecipientDetail]? = nil
        if let recipientsContainer = recipientsContainer {
            recipientsDecoded0 = [IotEventsClientTypes.RecipientDetail]()
            for structure0 in recipientsContainer {
                if let structure0 = structure0 {
                    recipientsDecoded0?.append(structure0)
                }
            }
        }
        recipients = recipientsDecoded0
    }
}

extension IotEventsClientTypes.SMSConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SMSConfiguration(additionalMessage: \(Swift.String(describing: additionalMessage)), recipients: \(Swift.String(describing: recipients)), senderId: \(Swift.String(describing: senderId)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains the configuration information of SMS notifications.</p>
    public struct SMSConfiguration: Swift.Equatable {
        /// <p>The message that you want to send. The message can be up to 200 characters.</p>
        public let additionalMessage: Swift.String?
        /// <p>Specifies one or more recipients who receive the message.</p>
        ///          <important>
        ///             <p>You must <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html">add the users that receive SMS messages to your AWS SSO store</a>.</p>
        ///          </important>
        public let recipients: [IotEventsClientTypes.RecipientDetail]?
        /// <p>The sender ID.</p>
        public let senderId: Swift.String?

        public init (
            additionalMessage: Swift.String? = nil,
            recipients: [IotEventsClientTypes.RecipientDetail]? = nil,
            senderId: Swift.String? = nil
        )
        {
            self.additionalMessage = additionalMessage
            self.recipients = recipients
            self.senderId = senderId
        }
    }

}

extension IotEventsClientTypes.SNSTopicPublishAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.SNSTopicPublishAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSTopicPublishAction(payload: \(Swift.String(describing: payload)), targetArn: \(Swift.String(describing: targetArn)))"}
}

extension IotEventsClientTypes {
    /// <p>Information required to publish the Amazon SNS message.</p>
    public struct SNSTopicPublishAction: Swift.Equatable {
        /// <p>You can configure the action payload when you send a message as an Amazon SNS push
        ///       notification.</p>
        public let payload: IotEventsClientTypes.Payload?
        /// <p>The ARN of the Amazon SNS target where the message is sent.</p>
        public let targetArn: Swift.String?

        public init (
            payload: IotEventsClientTypes.Payload? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.payload = payload
            self.targetArn = targetArn
        }
    }

}

extension IotEventsClientTypes.SSOIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension IotEventsClientTypes.SSOIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SSOIdentity(identityStoreId: \(Swift.String(describing: identityStoreId)), userId: \(Swift.String(describing: userId)))"}
}

extension IotEventsClientTypes {
    /// <p>Contains information about your identity source in AWS Single Sign-On. For more information, see
    ///       the <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html">AWS Single Sign-On
    ///         User Guide</a>.</p>
    public struct SSOIdentity: Swift.Equatable {
        /// <p>The ID of the AWS SSO identity store.</p>
        public let identityStoreId: Swift.String?
        /// <p>The user ID.</p>
        public let userId: Swift.String?

        public init (
            identityStoreId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.userId = userId
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is currently unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsClientTypes.SetTimerAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationExpression
        case seconds
        case timerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationExpression = durationExpression {
            try encodeContainer.encode(durationExpression, forKey: .durationExpression)
        }
        if let seconds = seconds {
            try encodeContainer.encode(seconds, forKey: .seconds)
        }
        if let timerName = timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timerName)
        timerName = timerNameDecoded
        let secondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seconds)
        seconds = secondsDecoded
        let durationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .durationExpression)
        durationExpression = durationExpressionDecoded
    }
}

extension IotEventsClientTypes.SetTimerAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetTimerAction(durationExpression: \(Swift.String(describing: durationExpression)), seconds: \(Swift.String(describing: seconds)), timerName: \(Swift.String(describing: timerName)))"}
}

extension IotEventsClientTypes {
    /// <p>Information needed to set the timer.</p>
    public struct SetTimerAction: Swift.Equatable {
        /// <p>The duration of the timer, in seconds. You can use a string expression that includes
        ///       numbers, variables (<code>$variable.<variable-name></code>), and input values
        ///         (<code>$input.<input-name>.<path-to-datum></code>) as the duration. The range of
        ///       the duration is 1-31622400 seconds. To ensure accuracy, the minimum duration is 60 seconds.
        ///       The evaluated result of the duration is rounded down to the nearest whole number. </p>
        public let durationExpression: Swift.String?
        /// <p>The number of seconds until the timer expires. The minimum value is 60 seconds to ensure
        ///       accuracy. The maximum value is 31622400 seconds. </p>
        @available(*, deprecated, message: "seconds is deprecated. You can use durationExpression for SetTimerAction. The value of seconds can be used as a string expression for durationExpression.")
        public let seconds: Swift.Int?
        /// <p>The name of the timer.</p>
        public let timerName: Swift.String?

        public init (
            durationExpression: Swift.String? = nil,
            seconds: Swift.Int? = nil,
            timerName: Swift.String? = nil
        )
        {
            self.durationExpression = durationExpression
            self.seconds = seconds
            self.timerName = timerName
        }
    }

}

extension IotEventsClientTypes.SetVariableAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
        case variableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let variableName = variableName {
            try encodeContainer.encode(variableName, forKey: .variableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableName)
        variableName = variableNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotEventsClientTypes.SetVariableAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetVariableAction(value: \(Swift.String(describing: value)), variableName: \(Swift.String(describing: variableName)))"}
}

extension IotEventsClientTypes {
    /// <p>Information about the variable and its new value.</p>
    public struct SetVariableAction: Swift.Equatable {
        /// <p>The new value of the variable.</p>
        public let value: Swift.String?
        /// <p>The name of the variable.</p>
        public let variableName: Swift.String?

        public init (
            value: Swift.String? = nil,
            variableName: Swift.String? = nil
        )
        {
            self.value = value
            self.variableName = variableName
        }
    }

}

extension IotEventsClientTypes.SimpleRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator
        case inputProperty
        case threshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let inputProperty = inputProperty {
            try encodeContainer.encode(inputProperty, forKey: .inputProperty)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPropertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputProperty)
        inputProperty = inputPropertyDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension IotEventsClientTypes.SimpleRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimpleRule(comparisonOperator: \(Swift.String(describing: comparisonOperator)), inputProperty: \(Swift.String(describing: inputProperty)), threshold: \(Swift.String(describing: threshold)))"}
}

extension IotEventsClientTypes {
    /// <p>A rule that compares an input property value to a threshold value with a comparison operator.</p>
    public struct SimpleRule: Swift.Equatable {
        /// <p>The comparison operator.</p>
        public let comparisonOperator: IotEventsClientTypes.ComparisonOperator?
        /// <p>The value on the left side of the comparison operator. You can specify an AWS IoT Events input
        ///       attribute as an input property.</p>
        public let inputProperty: Swift.String?
        /// <p>The value on the right side of the comparison operator. You can enter a number or specify
        ///       an AWS IoT Events input attribute.</p>
        public let threshold: Swift.String?

        public init (
            comparisonOperator: IotEventsClientTypes.ComparisonOperator? = nil,
            inputProperty: Swift.String? = nil,
            threshold: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.inputProperty = inputProperty
            self.threshold = threshold
        }
    }

}

extension IotEventsClientTypes.SqsAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case queueUrl
        case useBase64
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let queueUrl = queueUrl {
            try encodeContainer.encode(queueUrl, forKey: .queueUrl)
        }
        if let useBase64 = useBase64 {
            try encodeContainer.encode(useBase64, forKey: .useBase64)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueUrl)
        queueUrl = queueUrlDecoded
        let useBase64Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBase64)
        useBase64 = useBase64Decoded
        let payloadDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IotEventsClientTypes.SqsAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqsAction(payload: \(Swift.String(describing: payload)), queueUrl: \(Swift.String(describing: queueUrl)), useBase64: \(Swift.String(describing: useBase64)))"}
}

extension IotEventsClientTypes {
    /// <p>Sends information about the detector model instance and the event that triggered the
    ///       action to an Amazon SQS queue.</p>
    public struct SqsAction: Swift.Equatable {
        /// <p>You can configure the action payload when you send a message to an Amazon SQS
        ///       queue.</p>
        public let payload: IotEventsClientTypes.Payload?
        /// <p>The URL of the SQS queue where the data is written.</p>
        public let queueUrl: Swift.String?
        /// <p>Set this to TRUE if you want the data to be base-64 encoded before it is written to the
        ///       queue. Otherwise, set this to FALSE.</p>
        public let useBase64: Swift.Bool?

        public init (
            payload: IotEventsClientTypes.Payload? = nil,
            queueUrl: Swift.String? = nil,
            useBase64: Swift.Bool? = nil
        )
        {
            self.payload = payload
            self.queueUrl = queueUrl
            self.useBase64 = useBase64
        }
    }

}

public struct StartDetectorModelAnalysisInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDetectorModelAnalysisInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDetectorModelAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDetectorModelAnalysisOutputError>
}

extension StartDetectorModelAnalysisInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDetectorModelAnalysisInput(detectorModelDefinition: \(Swift.String(describing: detectorModelDefinition)))"}
}

extension StartDetectorModelAnalysisInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
    }
}

public struct StartDetectorModelAnalysisInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDetectorModelAnalysisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDetectorModelAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDetectorModelAnalysisOutputError>
}

public struct StartDetectorModelAnalysisInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDetectorModelAnalysisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDetectorModelAnalysisInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDetectorModelAnalysisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDetectorModelAnalysisInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDetectorModelAnalysisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDetectorModelAnalysisOutputError>
}

public struct StartDetectorModelAnalysisInput: Swift.Equatable {
    /// <p>Information that defines how a detector operates.</p>
    public let detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition?

    public init (
        detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
    }
}

struct StartDetectorModelAnalysisInputBody: Swift.Equatable {
    public let detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition?
}

extension StartDetectorModelAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
    }
}

extension StartDetectorModelAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDetectorModelAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDetectorModelAnalysisOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDetectorModelAnalysisOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDetectorModelAnalysisOutputResponse(analysisId: \(Swift.String(describing: analysisId)))"}
}

extension StartDetectorModelAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDetectorModelAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
        } else {
            self.analysisId = nil
        }
    }
}

public struct StartDetectorModelAnalysisOutputResponse: Swift.Equatable {
    /// <p>The ID that you can use to retrieve the analysis result.</p>
    public let analysisId: Swift.String?

    public init (
        analysisId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

struct StartDetectorModelAnalysisOutputResponseBody: Swift.Equatable {
    public let analysisId: Swift.String?
}

extension StartDetectorModelAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
    }
}

extension IotEventsClientTypes.State: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onEnter
        case onExit
        case onInput
        case stateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onEnter = onEnter {
            try encodeContainer.encode(onEnter, forKey: .onEnter)
        }
        if let onExit = onExit {
            try encodeContainer.encode(onExit, forKey: .onExit)
        }
        if let onInput = onInput {
            try encodeContainer.encode(onInput, forKey: .onInput)
        }
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let onInputDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.OnInputLifecycle.self, forKey: .onInput)
        onInput = onInputDecoded
        let onEnterDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.OnEnterLifecycle.self, forKey: .onEnter)
        onEnter = onEnterDecoded
        let onExitDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.OnExitLifecycle.self, forKey: .onExit)
        onExit = onExitDecoded
    }
}

extension IotEventsClientTypes.State: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "State(onEnter: \(Swift.String(describing: onEnter)), onExit: \(Swift.String(describing: onExit)), onInput: \(Swift.String(describing: onInput)), stateName: \(Swift.String(describing: stateName)))"}
}

extension IotEventsClientTypes {
    /// <p>Information that defines a state of a detector.</p>
    public struct State: Swift.Equatable {
        /// <p>When entering this state, perform these <code>actions</code> if the <code>condition</code>
        ///       is TRUE.</p>
        public let onEnter: IotEventsClientTypes.OnEnterLifecycle?
        /// <p>When exiting this state, perform these <code>actions</code> if the specified
        ///         <code>condition</code> is <code>TRUE</code>.</p>
        public let onExit: IotEventsClientTypes.OnExitLifecycle?
        /// <p>When an input is received and the <code>condition</code> is TRUE, perform the specified
        ///         <code>actions</code>.</p>
        public let onInput: IotEventsClientTypes.OnInputLifecycle?
        /// <p>The name of the state.</p>
        public let stateName: Swift.String?

        public init (
            onEnter: IotEventsClientTypes.OnEnterLifecycle? = nil,
            onExit: IotEventsClientTypes.OnExitLifecycle? = nil,
            onInput: IotEventsClientTypes.OnInputLifecycle? = nil,
            stateName: Swift.String? = nil
        )
        {
            self.onEnter = onEnter
            self.onExit = onExit
            self.onInput = onInput
            self.stateName = stateName
        }
    }

}

extension IotEventsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotEventsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension IotEventsClientTypes {
    /// <p>Metadata that can be used to manage the resource.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The tag's key.</p>
        public let key: Swift.String?
        /// <p>The tag's value.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: Swift.String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [IotEventsClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IotEventsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [IotEventsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be completed due to throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsClientTypes.TransitionEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case condition
        case eventName
        case nextState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actions0 in actions {
                try actionsContainer.encode(actions0)
            }
        }
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let nextState = nextState {
            try encodeContainer.encode(nextState, forKey: .nextState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IotEventsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[IotEventsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IotEventsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextState)
        nextState = nextStateDecoded
    }
}

extension IotEventsClientTypes.TransitionEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitionEvent(actions: \(Swift.String(describing: actions)), condition: \(Swift.String(describing: condition)), eventName: \(Swift.String(describing: eventName)), nextState: \(Swift.String(describing: nextState)))"}
}

extension IotEventsClientTypes {
    /// <p>Specifies the actions performed and the next state entered when a <code>condition</code>
    ///       evaluates to TRUE.</p>
    public struct TransitionEvent: Swift.Equatable {
        /// <p>The actions to be performed.</p>
        public let actions: [IotEventsClientTypes.Action]?
        /// <p>Required. A Boolean expression that when TRUE causes the actions to be performed and the
        ///         <code>nextState</code> to be entered.</p>
        public let condition: Swift.String?
        /// <p>The name of the transition event.</p>
        public let eventName: Swift.String?
        /// <p>The next state to enter.</p>
        public let nextState: Swift.String?

        public init (
            actions: [IotEventsClientTypes.Action]? = nil,
            condition: Swift.String? = nil,
            eventName: Swift.String? = nil,
            nextState: Swift.String? = nil
        )
        {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
            self.nextState = nextState
        }
    }

}

extension UnsupportedOperationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperationException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation is not supported.</p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: Swift.String?
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAlarmModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAlarmModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAlarmModelOutputError>
}

extension UpdateAlarmModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAlarmModelInput(alarmCapabilities: \(Swift.String(describing: alarmCapabilities)), alarmEventActions: \(Swift.String(describing: alarmEventActions)), alarmModelDescription: \(Swift.String(describing: alarmModelDescription)), alarmModelName: \(Swift.String(describing: alarmModelName)), alarmNotification: \(Swift.String(describing: alarmNotification)), alarmRule: \(Swift.String(describing: alarmRule)), roleArn: \(Swift.String(describing: roleArn)), severity: \(Swift.String(describing: severity)))"}
}

extension UpdateAlarmModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmNotification
        case alarmRule
        case roleArn
        case severity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmCapabilities = alarmCapabilities {
            try encodeContainer.encode(alarmCapabilities, forKey: .alarmCapabilities)
        }
        if let alarmEventActions = alarmEventActions {
            try encodeContainer.encode(alarmEventActions, forKey: .alarmEventActions)
        }
        if let alarmModelDescription = alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmNotification = alarmNotification {
            try encodeContainer.encode(alarmNotification, forKey: .alarmNotification)
        }
        if let alarmRule = alarmRule {
            try encodeContainer.encode(alarmRule, forKey: .alarmRule)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }
}

public struct UpdateAlarmModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAlarmModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAlarmModelOutputError>
}

public struct UpdateAlarmModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAlarmModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAlarmModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAlarmModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAlarmModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAlarmModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAlarmModelOutputError>
}

public struct UpdateAlarmModelInput: Swift.Equatable {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public let alarmCapabilities: IotEventsClientTypes.AlarmCapabilities?
    /// <p>Contains information about one or more alarm actions.</p>
    public let alarmEventActions: IotEventsClientTypes.AlarmEventActions?
    /// <p>The description of the alarm model.</p>
    public let alarmModelDescription: Swift.String?
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: Swift.String?
    /// <p>Contains information about one or more notification actions.</p>
    public let alarmNotification: IotEventsClientTypes.AlarmNotification?
    /// <p>Defines when your alarm is invoked.</p>
    public let alarmRule: IotEventsClientTypes.AlarmRule?
    /// <p>The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let roleArn: Swift.String?
    /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
    public let severity: Swift.Int?

    public init (
        alarmCapabilities: IotEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IotEventsClientTypes.AlarmEventActions? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmNotification: IotEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IotEventsClientTypes.AlarmRule? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.roleArn = roleArn
        self.severity = severity
    }
}

struct UpdateAlarmModelInputBody: Swift.Equatable {
    public let alarmModelDescription: Swift.String?
    public let roleArn: Swift.String?
    public let severity: Swift.Int?
    public let alarmRule: IotEventsClientTypes.AlarmRule?
    public let alarmNotification: IotEventsClientTypes.AlarmNotification?
    public let alarmEventActions: IotEventsClientTypes.AlarmEventActions?
    public let alarmCapabilities: IotEventsClientTypes.AlarmCapabilities?
}

extension UpdateAlarmModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmNotification
        case alarmRule
        case roleArn
        case severity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension UpdateAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAlarmModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAlarmModelOutputResponse(alarmModelArn: \(Swift.String(describing: alarmModelArn)), alarmModelVersion: \(Swift.String(describing: alarmModelVersion)), creationTime: \(Swift.String(describing: creationTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), status: \(Swift.String(describing: status)))"}
}

extension UpdateAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelVersion = output.alarmModelVersion
            self.creationTime = output.creationTime
            self.lastUpdateTime = output.lastUpdateTime
            self.status = output.status
        } else {
            self.alarmModelArn = nil
            self.alarmModelVersion = nil
            self.creationTime = nil
            self.lastUpdateTime = nil
            self.status = nil
        }
    }
}

public struct UpdateAlarmModelOutputResponse: Swift.Equatable {
    /// <p>The ARN of the alarm model. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    public let alarmModelArn: Swift.String?
    /// <p>The version of the alarm model.</p>
    public let alarmModelVersion: Swift.String?
    /// <p>The time the alarm model was created, in the Unix epoch format.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The time the alarm model was last updated, in the Unix epoch format.</p>
    public let lastUpdateTime: ClientRuntime.Date?
    /// <p>The status of the alarm model. The status can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The alarm model is active and it's ready to evaluate data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATING</code> - AWS IoT Events is activating your alarm model.
    ///         Activating an alarm model can take up to a few minutes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code> - The alarm model is inactive, so it isn't ready to evaluate data.
    /// 	  Check your alarm model information and update the alarm model.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - You couldn't create or update the alarm model. Check your alarm model information
    ///         and try again.</p>
    ///             </li>
    ///          </ul>
    public let status: IotEventsClientTypes.AlarmModelVersionStatus?

    public init (
        alarmModelArn: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        status: IotEventsClientTypes.AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

struct UpdateAlarmModelOutputResponseBody: Swift.Equatable {
    public let creationTime: ClientRuntime.Date?
    public let alarmModelArn: Swift.String?
    public let alarmModelVersion: Swift.String?
    public let lastUpdateTime: ClientRuntime.Date?
    public let status: IotEventsClientTypes.AlarmModelVersionStatus?
}

extension UpdateAlarmModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelArn
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateDetectorModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorModelOutputError>
}

extension UpdateDetectorModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorModelInput(detectorModelDefinition: \(Swift.String(describing: detectorModelDefinition)), detectorModelDescription: \(Swift.String(describing: detectorModelDescription)), detectorModelName: \(Swift.String(describing: detectorModelName)), evaluationMethod: \(Swift.String(describing: evaluationMethod)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension UpdateDetectorModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case evaluationMethod
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
        if let detectorModelDescription = detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let evaluationMethod = evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateDetectorModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorModelOutputError>
}

public struct UpdateDetectorModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorModelOutputError>
}

public struct UpdateDetectorModelInput: Swift.Equatable {
    /// <p>Information that defines how a detector operates.</p>
    public let detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition?
    /// <p>A brief description of the detector model.</p>
    public let detectorModelDescription: Swift.String?
    /// <p>The name of the detector model that is updated.</p>
    public let detectorModelName: Swift.String?
    /// <p>Information about the order in which events are evaluated and how actions are executed.
    ///     </p>
    public let evaluationMethod: IotEventsClientTypes.EvaluationMethod?
    /// <p>The ARN of the role that grants permission to AWS IoT Events to perform its operations.</p>
    public let roleArn: Swift.String?

    public init (
        detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition? = nil,
        detectorModelDescription: Swift.String? = nil,
        detectorModelName: Swift.String? = nil,
        evaluationMethod: IotEventsClientTypes.EvaluationMethod? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.roleArn = roleArn
    }
}

struct UpdateDetectorModelInputBody: Swift.Equatable {
    public let detectorModelDefinition: IotEventsClientTypes.DetectorModelDefinition?
    public let detectorModelDescription: Swift.String?
    public let roleArn: Swift.String?
    public let evaluationMethod: IotEventsClientTypes.EvaluationMethod?
}

extension UpdateDetectorModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case evaluationMethod
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension UpdateDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorModelOutputResponse(detectorModelConfiguration: \(Swift.String(describing: detectorModelConfiguration)))"}
}

extension UpdateDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelConfiguration = output.detectorModelConfiguration
        } else {
            self.detectorModelConfiguration = nil
        }
    }
}

public struct UpdateDetectorModelOutputResponse: Swift.Equatable {
    /// <p>Information about how the detector model is configured.</p>
    public let detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration?

    public init (
        detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

struct UpdateDetectorModelOutputResponseBody: Swift.Equatable {
    public let detectorModelConfiguration: IotEventsClientTypes.DetectorModelConfiguration?
}

extension UpdateDetectorModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

public struct UpdateInputInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInputOutputError>
}

extension UpdateInputInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInputInput(inputDefinition: \(Swift.String(describing: inputDefinition)), inputDescription: \(Swift.String(describing: inputDescription)), inputName: \(Swift.String(describing: inputName)))"}
}

extension UpdateInputInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDefinition = inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
        if let inputDescription = inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
    }
}

public struct UpdateInputInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInputOutputError>
}

public struct UpdateInputInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInputOutputError>
}

public struct UpdateInputInput: Swift.Equatable {
    /// <p>The definition of the input.</p>
    public let inputDefinition: IotEventsClientTypes.InputDefinition?
    /// <p>A brief description of the input.</p>
    public let inputDescription: Swift.String?
    /// <p>The name of the input you want to update.</p>
    public let inputName: Swift.String?

    public init (
        inputDefinition: IotEventsClientTypes.InputDefinition? = nil,
        inputDescription: Swift.String? = nil,
        inputName: Swift.String? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
    }
}

struct UpdateInputInputBody: Swift.Equatable {
    public let inputDescription: Swift.String?
    public let inputDefinition: IotEventsClientTypes.InputDefinition?
}

extension UpdateInputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
    }
}

extension UpdateInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInputOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInputOutputResponse(inputConfiguration: \(Swift.String(describing: inputConfiguration)))"}
}

extension UpdateInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateInputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputConfiguration = output.inputConfiguration
        } else {
            self.inputConfiguration = nil
        }
    }
}

public struct UpdateInputOutputResponse: Swift.Equatable {
    /// <p>Information about the configuration of the input.</p>
    public let inputConfiguration: IotEventsClientTypes.InputConfiguration?

    public init (
        inputConfiguration: IotEventsClientTypes.InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

struct UpdateInputOutputResponseBody: Swift.Equatable {
    public let inputConfiguration: IotEventsClientTypes.InputConfiguration?
}

extension UpdateInputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsClientTypes.InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
    }
}
