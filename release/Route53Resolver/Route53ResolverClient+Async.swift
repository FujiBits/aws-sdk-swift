// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension Route53ResolverClient {
    /// <p>Associates a <a>FirewallRuleGroup</a> with a VPC, to provide DNS filtering for the VPC. </p>
    func associateFirewallRuleGroup(input: AssociateFirewallRuleGroupInput) async throws -> AssociateFirewallRuleGroupOutputResponse
    {
        typealias associateFirewallRuleGroupContinuation = CheckedContinuation<AssociateFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateFirewallRuleGroupContinuation) in
            associateFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds IP addresses to an inbound or an outbound Resolver endpoint. If you want to add more than one IP address,
    /// 			submit one <code>AssociateResolverEndpointIpAddress</code> request for each IP address.</p>
    /// 		       <p>To remove an IP address from an endpoint, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverEndpointIpAddress.html">DisassociateResolverEndpointIpAddress</a>.
    /// 		</p>
    func associateResolverEndpointIpAddress(input: AssociateResolverEndpointIpAddressInput) async throws -> AssociateResolverEndpointIpAddressOutputResponse
    {
        typealias associateResolverEndpointIpAddressContinuation = CheckedContinuation<AssociateResolverEndpointIpAddressOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateResolverEndpointIpAddressContinuation) in
            associateResolverEndpointIpAddress(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Associates an Amazon VPC with a specified query logging configuration. Route 53 Resolver logs DNS queries that originate in all of the Amazon VPCs
    /// 			that are associated with a specified query logging configuration. To associate more than one VPC with a configuration, submit one <code>AssociateResolverQueryLogConfig</code>
    /// 			request for each VPC.</p>
    /// 		
    /// 		       <note>
    ///             <p>The VPCs that you associate with a query logging configuration must be in the same Region as the configuration.</p>
    ///          </note>
    /// 		
    /// 		       <p>To remove a VPC from a query logging configuration, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.
    /// 			</p>
    func associateResolverQueryLogConfig(input: AssociateResolverQueryLogConfigInput) async throws -> AssociateResolverQueryLogConfigOutputResponse
    {
        typealias associateResolverQueryLogConfigContinuation = CheckedContinuation<AssociateResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateResolverQueryLogConfigContinuation) in
            associateResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Associates a Resolver rule with a VPC. When you associate a rule with a VPC, Resolver forwards all DNS queries
    /// 			for the domain name that is specified in the rule and that originate in the VPC. The queries are forwarded to the
    /// 			IP addresses for the DNS resolvers that are specified in the rule. For more information about rules, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>. </p>
    func associateResolverRule(input: AssociateResolverRuleInput) async throws -> AssociateResolverRuleOutputResponse
    {
        typealias associateResolverRuleContinuation = CheckedContinuation<AssociateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateResolverRuleContinuation) in
            associateResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an empty firewall domain list for use in DNS Firewall rules. You can populate the domains for the new list with a file, using <a>ImportFirewallDomains</a>, or with domain strings, using <a>UpdateFirewallDomains</a>. </p>
    func createFirewallDomainList(input: CreateFirewallDomainListInput) async throws -> CreateFirewallDomainListOutputResponse
    {
        typealias createFirewallDomainListContinuation = CheckedContinuation<CreateFirewallDomainListOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFirewallDomainListContinuation) in
            createFirewallDomainList(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.</p>
    func createFirewallRule(input: CreateFirewallRuleInput) async throws -> CreateFirewallRuleOutputResponse
    {
        typealias createFirewallRuleContinuation = CheckedContinuation<CreateFirewallRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFirewallRuleContinuation) in
            createFirewallRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an empty DNS Firewall rule group for filtering DNS network traffic in a VPC. You can add rules to the new rule group
    ///            by calling <a>CreateFirewallRule</a>. </p>
    func createFirewallRuleGroup(input: CreateFirewallRuleGroupInput) async throws -> CreateFirewallRuleGroupOutputResponse
    {
        typealias createFirewallRuleGroupContinuation = CheckedContinuation<CreateFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFirewallRuleGroupContinuation) in
            createFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a Resolver endpoint. There are two types of Resolver endpoints, inbound and outbound:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>An <i>inbound Resolver endpoint</i> forwards DNS queries to the DNS service for a VPC
    /// 				from your network.</p>
    ///             </li>
    ///             <li>
    ///                <p>An <i>outbound Resolver endpoint</i> forwards DNS queries from the DNS service for a VPC
    /// 				to your network.</p>
    ///             </li>
    ///          </ul>
    func createResolverEndpoint(input: CreateResolverEndpointInput) async throws -> CreateResolverEndpointOutputResponse
    {
        typealias createResolverEndpointContinuation = CheckedContinuation<CreateResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResolverEndpointContinuation) in
            createResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs that originate in your VPCs.
    /// 			Resolver can log queries only for VPCs that are in the same Region as the query logging configuration.</p>
    /// 		
    /// 		       <p>To specify which VPCs you want to log queries for, you use <code>AssociateResolverQueryLogConfig</code>. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html">AssociateResolverQueryLogConfig</a>. </p>
    /// 		
    /// 		       <p>You can optionally use AWS Resource Access Manager (AWS RAM) to share a query logging configuration with other AWS accounts. The other accounts
    /// 			can then associate VPCs with the configuration. The query logs that Resolver creates for a configuration include all DNS queries that originate in all
    /// 			VPCs that are associated with the configuration.</p>
    func createResolverQueryLogConfig(input: CreateResolverQueryLogConfigInput) async throws -> CreateResolverQueryLogConfigOutputResponse
    {
        typealias createResolverQueryLogConfigContinuation = CheckedContinuation<CreateResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResolverQueryLogConfigContinuation) in
            createResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>For DNS queries that originate in your VPCs, specifies which Resolver endpoint the queries pass through,
    /// 			one domain name that you want to forward to your network, and the IP addresses of the DNS resolvers in your network.</p>
    func createResolverRule(input: CreateResolverRuleInput) async throws -> CreateResolverRuleOutputResponse
    {
        typealias createResolverRuleContinuation = CheckedContinuation<CreateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResolverRuleContinuation) in
            createResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified domain list. </p>
    func deleteFirewallDomainList(input: DeleteFirewallDomainListInput) async throws -> DeleteFirewallDomainListOutputResponse
    {
        typealias deleteFirewallDomainListContinuation = CheckedContinuation<DeleteFirewallDomainListOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFirewallDomainListContinuation) in
            deleteFirewallDomainList(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified firewall rule.</p>
    func deleteFirewallRule(input: DeleteFirewallRuleInput) async throws -> DeleteFirewallRuleOutputResponse
    {
        typealias deleteFirewallRuleContinuation = CheckedContinuation<DeleteFirewallRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFirewallRuleContinuation) in
            deleteFirewallRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified firewall rule group. </p>
    func deleteFirewallRuleGroup(input: DeleteFirewallRuleGroupInput) async throws -> DeleteFirewallRuleGroupOutputResponse
    {
        typealias deleteFirewallRuleGroupContinuation = CheckedContinuation<DeleteFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFirewallRuleGroupContinuation) in
            deleteFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a Resolver endpoint. The effect of deleting a Resolver endpoint depends on whether it's an inbound or an outbound
    /// 			Resolver endpoint:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Inbound</b>: DNS queries from your network are no longer routed
    /// 				to the DNS service for the specified VPC.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Outbound</b>: DNS queries from a VPC are no longer routed to your network.</p>
    ///             </li>
    ///          </ul>
    func deleteResolverEndpoint(input: DeleteResolverEndpointInput) async throws -> DeleteResolverEndpointOutputResponse
    {
        typealias deleteResolverEndpointContinuation = CheckedContinuation<DeleteResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResolverEndpointContinuation) in
            deleteResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for all of the Amazon VPCs that are
    /// 			associated with the configuration. This also applies if the query logging configuration is shared with other AWS accounts, and
    /// 			the other accounts have associated VPCs with the shared configuration.</p>
    /// 		
    /// 		       <p>Before you can delete a query logging configuration, you must first disassociate all VPCs from the configuration. See
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.</p>
    /// 			
    /// 		       <p>If you used Resource Access Manager (RAM) to share a query logging configuration with other accounts, you must stop sharing
    /// 			the configuration before you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
    /// 			that they associated with the configuration, but that's not necessary. If you stop sharing the configuration, those VPCs are automatically
    /// 			disassociated from the configuration.</p>
    func deleteResolverQueryLogConfig(input: DeleteResolverQueryLogConfigInput) async throws -> DeleteResolverQueryLogConfigOutputResponse
    {
        typealias deleteResolverQueryLogConfigContinuation = CheckedContinuation<DeleteResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResolverQueryLogConfigContinuation) in
            deleteResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a Resolver rule. Before you can delete a Resolver rule, you must disassociate it from all the VPCs that you
    /// 			associated the Resolver rule with. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html">DisassociateResolverRule</a>.</p>
    func deleteResolverRule(input: DeleteResolverRuleInput) async throws -> DeleteResolverRuleOutputResponse
    {
        typealias deleteResolverRuleContinuation = CheckedContinuation<DeleteResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResolverRuleContinuation) in
            deleteResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Disassociates a <a>FirewallRuleGroup</a> from a VPC, to remove DNS filtering from the VPC. </p>
    func disassociateFirewallRuleGroup(input: DisassociateFirewallRuleGroupInput) async throws -> DisassociateFirewallRuleGroupOutputResponse
    {
        typealias disassociateFirewallRuleGroupContinuation = CheckedContinuation<DisassociateFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateFirewallRuleGroupContinuation) in
            disassociateFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes IP addresses from an inbound or an outbound Resolver endpoint. If you want to remove more than one IP address,
    /// 			submit one <code>DisassociateResolverEndpointIpAddress</code> request for each IP address.</p>
    /// 		       <p>To add an IP address to an endpoint, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverEndpointIpAddress.html">AssociateResolverEndpointIpAddress</a>.
    /// 		</p>
    func disassociateResolverEndpointIpAddress(input: DisassociateResolverEndpointIpAddressInput) async throws -> DisassociateResolverEndpointIpAddressOutputResponse
    {
        typealias disassociateResolverEndpointIpAddressContinuation = CheckedContinuation<DisassociateResolverEndpointIpAddressOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateResolverEndpointIpAddressContinuation) in
            disassociateResolverEndpointIpAddress(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Disassociates a VPC from a query logging configuration.</p>
    /// 		
    /// 		       <note>
    /// 			         <p>Before you can delete a query logging configuration, you must first disassociate all VPCs
    /// 				from the configuration. If you used AWS Resource Access Manager (AWS RAM) to share a
    /// 				query logging configuration with other accounts, VPCs can be disassociated from the
    /// 				configuration in the following ways:</p>
    /// 			         <ul>
    ///                <li>
    ///                   <p>The accounts that you shared the configuration with can disassociate VPCs from the configuration.</p>
    ///                </li>
    ///                <li>
    ///                   <p>You can stop sharing the configuration.</p>
    ///                </li>
    ///             </ul>
    /// 		       </note>
    func disassociateResolverQueryLogConfig(input: DisassociateResolverQueryLogConfigInput) async throws -> DisassociateResolverQueryLogConfigOutputResponse
    {
        typealias disassociateResolverQueryLogConfigContinuation = CheckedContinuation<DisassociateResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateResolverQueryLogConfigContinuation) in
            disassociateResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes the association between a specified Resolver rule and a specified VPC.</p>
    /// 		       <important>
    /// 			         <p>If you disassociate a Resolver rule from a VPC, Resolver stops forwarding DNS queries for the
    /// 				domain name that you specified in the Resolver rule. </p>
    /// 		       </important>
    func disassociateResolverRule(input: DisassociateResolverRuleInput) async throws -> DisassociateResolverRuleOutputResponse
    {
        typealias disassociateResolverRuleContinuation = CheckedContinuation<DisassociateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateResolverRuleContinuation) in
            disassociateResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the configuration of the firewall behavior provided by DNS Firewall for a
    /// 			single VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
    func getFirewallConfig(input: GetFirewallConfigInput) async throws -> GetFirewallConfigOutputResponse
    {
        typealias getFirewallConfigContinuation = CheckedContinuation<GetFirewallConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallConfigContinuation) in
            getFirewallConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the specified firewall domain list.</p>
    func getFirewallDomainList(input: GetFirewallDomainListInput) async throws -> GetFirewallDomainListOutputResponse
    {
        typealias getFirewallDomainListContinuation = CheckedContinuation<GetFirewallDomainListOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallDomainListContinuation) in
            getFirewallDomainList(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the specified firewall rule group. </p>
    func getFirewallRuleGroup(input: GetFirewallRuleGroupInput) async throws -> GetFirewallRuleGroupOutputResponse
    {
        typealias getFirewallRuleGroupContinuation = CheckedContinuation<GetFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallRuleGroupContinuation) in
            getFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves a firewall rule group association, which enables DNS filtering for a VPC with one rule group. A VPC can have more than one firewall rule group association, and a rule group can be associated with more than one VPC.</p>
    func getFirewallRuleGroupAssociation(input: GetFirewallRuleGroupAssociationInput) async throws -> GetFirewallRuleGroupAssociationOutputResponse
    {
        typealias getFirewallRuleGroupAssociationContinuation = CheckedContinuation<GetFirewallRuleGroupAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallRuleGroupAssociationContinuation) in
            getFirewallRuleGroupAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the AWS Identity and Access Management (AWS IAM) policy for sharing the
    /// 			specified rule group. You can use the policy to share the rule group using AWS Resource
    /// 			Access Manager (AWS RAM). </p>
    func getFirewallRuleGroupPolicy(input: GetFirewallRuleGroupPolicyInput) async throws -> GetFirewallRuleGroupPolicyOutputResponse
    {
        typealias getFirewallRuleGroupPolicyContinuation = CheckedContinuation<GetFirewallRuleGroupPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallRuleGroupPolicyContinuation) in
            getFirewallRuleGroupPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets DNSSEC validation information for a specified resource.</p>
    func getResolverDnssecConfig(input: GetResolverDnssecConfigInput) async throws -> GetResolverDnssecConfigOutputResponse
    {
        typealias getResolverDnssecConfigContinuation = CheckedContinuation<GetResolverDnssecConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverDnssecConfigContinuation) in
            getResolverDnssecConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a specified Resolver endpoint, such as whether it's an inbound or an outbound Resolver endpoint, and the
    /// 			current status of the endpoint.</p>
    func getResolverEndpoint(input: GetResolverEndpointInput) async throws -> GetResolverEndpointOutputResponse
    {
        typealias getResolverEndpointContinuation = CheckedContinuation<GetResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverEndpointContinuation) in
            getResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a specified Resolver query logging configuration, such as the number of VPCs that the configuration
    /// 			is logging queries for and the location that logs are sent to. </p>
    func getResolverQueryLogConfig(input: GetResolverQueryLogConfigInput) async throws -> GetResolverQueryLogConfigOutputResponse
    {
        typealias getResolverQueryLogConfigContinuation = CheckedContinuation<GetResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverQueryLogConfigContinuation) in
            getResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a specified association between a Resolver query logging configuration and an Amazon VPC. When you associate a VPC
    /// 			with a query logging configuration, Resolver logs DNS queries that originate in that VPC.</p>
    func getResolverQueryLogConfigAssociation(input: GetResolverQueryLogConfigAssociationInput) async throws -> GetResolverQueryLogConfigAssociationOutputResponse
    {
        typealias getResolverQueryLogConfigAssociationContinuation = CheckedContinuation<GetResolverQueryLogConfigAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverQueryLogConfigAssociationContinuation) in
            getResolverQueryLogConfigAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a query logging policy. A query logging policy specifies the Resolver query logging
    /// 			operations and resources that you want to allow another AWS account to be able to use.</p>
    func getResolverQueryLogConfigPolicy(input: GetResolverQueryLogConfigPolicyInput) async throws -> GetResolverQueryLogConfigPolicyOutputResponse
    {
        typealias getResolverQueryLogConfigPolicyContinuation = CheckedContinuation<GetResolverQueryLogConfigPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverQueryLogConfigPolicyContinuation) in
            getResolverQueryLogConfigPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a specified Resolver rule, such as the domain name that the rule forwards DNS queries for and the ID of the
    /// 			outbound Resolver endpoint that the rule is associated with.</p>
    func getResolverRule(input: GetResolverRuleInput) async throws -> GetResolverRuleOutputResponse
    {
        typealias getResolverRuleContinuation = CheckedContinuation<GetResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverRuleContinuation) in
            getResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about an association between a specified Resolver rule and a VPC. You associate a Resolver rule and a VPC using
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>. </p>
    func getResolverRuleAssociation(input: GetResolverRuleAssociationInput) async throws -> GetResolverRuleAssociationOutputResponse
    {
        typealias getResolverRuleAssociationContinuation = CheckedContinuation<GetResolverRuleAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverRuleAssociationContinuation) in
            getResolverRuleAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about the Resolver rule policy for a specified rule. A Resolver rule policy includes the rule that you want to share
    /// 			with another account, the account that you want to share the rule with, and the Resolver operations that you want to allow the account to use. </p>
    func getResolverRulePolicy(input: GetResolverRulePolicyInput) async throws -> GetResolverRulePolicyOutputResponse
    {
        typealias getResolverRulePolicyContinuation = CheckedContinuation<GetResolverRulePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverRulePolicyContinuation) in
            getResolverRulePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Imports domain names from a file into a domain list, for use in a DNS firewall rule group. </p>
    ///          <p>Each domain specification in your domain list must satisfy the following
    /// 	requirements: </p>
    ///          <ul>
    ///             <li>
    ///       	        <p>It can optionally start with <code>*</code> (asterisk).</p>
    ///       	     </li>
    ///             <li>
    ///       	        <p>With the exception of the optional starting asterisk, it must only contain
    ///       	   the following characters: <code>A-Z</code>, <code>a-z</code>,
    ///       	   <code>0-9</code>, <code>-</code> (hyphen).</p>
    ///       	     </li>
    ///             <li>
    ///       	        <p>It must be from 1-255 characters in length. </p>
    ///       	     </li>
    ///          </ul>
    func importFirewallDomains(input: ImportFirewallDomainsInput) async throws -> ImportFirewallDomainsOutputResponse
    {
        typealias importFirewallDomainsContinuation = CheckedContinuation<ImportFirewallDomainsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: importFirewallDomainsContinuation) in
            importFirewallDomains(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the firewall configurations that you have defined. DNS Firewall uses the configurations to manage firewall behavior for your VPCs. </p>
    ///          <p>A single call might return only a partial list of the configurations. For information, see <code>MaxResults</code>. </p>
    func listFirewallConfigs(input: ListFirewallConfigsInput) async throws -> ListFirewallConfigsOutputResponse
    {
        typealias listFirewallConfigsContinuation = CheckedContinuation<ListFirewallConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallConfigsContinuation) in
            listFirewallConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the firewall domain lists that you have defined. For each firewall domain list, you can retrieve the domains that are defined for a list by calling <a>ListFirewallDomains</a>. </p>
    ///          <p>A single call to this list operation might return only a partial list of the domain lists. For information, see <code>MaxResults</code>. </p>
    func listFirewallDomainLists(input: ListFirewallDomainListsInput) async throws -> ListFirewallDomainListsOutputResponse
    {
        typealias listFirewallDomainListsContinuation = CheckedContinuation<ListFirewallDomainListsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallDomainListsContinuation) in
            listFirewallDomainLists(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the domains that you have defined for the specified firewall domain list.  </p>
    ///          <p>A single call might return only a partial list of the domains. For information, see <code>MaxResults</code>. </p>
    func listFirewallDomains(input: ListFirewallDomainsInput) async throws -> ListFirewallDomainsOutputResponse
    {
        typealias listFirewallDomainsContinuation = CheckedContinuation<ListFirewallDomainsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallDomainsContinuation) in
            listFirewallDomains(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the firewall rule group associations that you have defined. Each association enables DNS filtering for a VPC with one rule group. </p>
    ///          <p>A single call might return only a partial list of the associations. For information, see <code>MaxResults</code>. </p>
    func listFirewallRuleGroupAssociations(input: ListFirewallRuleGroupAssociationsInput) async throws -> ListFirewallRuleGroupAssociationsOutputResponse
    {
        typealias listFirewallRuleGroupAssociationsContinuation = CheckedContinuation<ListFirewallRuleGroupAssociationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallRuleGroupAssociationsContinuation) in
            listFirewallRuleGroupAssociations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the minimal high-level information for the rule groups that you have defined.  </p>
    ///          <p>A single call might return only a partial list of the rule groups. For information, see <code>MaxResults</code>. </p>
    func listFirewallRuleGroups(input: ListFirewallRuleGroupsInput) async throws -> ListFirewallRuleGroupsOutputResponse
    {
        typealias listFirewallRuleGroupsContinuation = CheckedContinuation<ListFirewallRuleGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallRuleGroupsContinuation) in
            listFirewallRuleGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the firewall rules that you have defined for the specified firewall rule group. DNS Firewall uses the rules in a rule group to filter DNS network traffic for a VPC. </p>
    ///          <p>A single call might return only a partial list of the rules. For information, see <code>MaxResults</code>. </p>
    func listFirewallRules(input: ListFirewallRulesInput) async throws -> ListFirewallRulesOutputResponse
    {
        typealias listFirewallRulesContinuation = CheckedContinuation<ListFirewallRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallRulesContinuation) in
            listFirewallRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the configurations for DNSSEC validation that are associated with the current AWS account.</p>
    func listResolverDnssecConfigs(input: ListResolverDnssecConfigsInput) async throws -> ListResolverDnssecConfigsOutputResponse
    {
        typealias listResolverDnssecConfigsContinuation = CheckedContinuation<ListResolverDnssecConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverDnssecConfigsContinuation) in
            listResolverDnssecConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets the IP addresses for a specified Resolver endpoint.</p>
    func listResolverEndpointIpAddresses(input: ListResolverEndpointIpAddressesInput) async throws -> ListResolverEndpointIpAddressesOutputResponse
    {
        typealias listResolverEndpointIpAddressesContinuation = CheckedContinuation<ListResolverEndpointIpAddressesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverEndpointIpAddressesContinuation) in
            listResolverEndpointIpAddresses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists all the Resolver endpoints that were created using the current AWS account.</p>
    func listResolverEndpoints(input: ListResolverEndpointsInput) async throws -> ListResolverEndpointsOutputResponse
    {
        typealias listResolverEndpointsContinuation = CheckedContinuation<ListResolverEndpointsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverEndpointsContinuation) in
            listResolverEndpoints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists information about associations between Amazon VPCs and query logging configurations.</p>
    func listResolverQueryLogConfigAssociations(input: ListResolverQueryLogConfigAssociationsInput) async throws -> ListResolverQueryLogConfigAssociationsOutputResponse
    {
        typealias listResolverQueryLogConfigAssociationsContinuation = CheckedContinuation<ListResolverQueryLogConfigAssociationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverQueryLogConfigAssociationsContinuation) in
            listResolverQueryLogConfigAssociations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists information about the specified query logging configurations. Each configuration defines where you want Resolver to save
    /// 			DNS query logs and specifies the VPCs that you want to log queries for.</p>
    func listResolverQueryLogConfigs(input: ListResolverQueryLogConfigsInput) async throws -> ListResolverQueryLogConfigsOutputResponse
    {
        typealias listResolverQueryLogConfigsContinuation = CheckedContinuation<ListResolverQueryLogConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverQueryLogConfigsContinuation) in
            listResolverQueryLogConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the associations that were created between Resolver rules and VPCs using the current AWS account.</p>
    func listResolverRuleAssociations(input: ListResolverRuleAssociationsInput) async throws -> ListResolverRuleAssociationsOutputResponse
    {
        typealias listResolverRuleAssociationsContinuation = CheckedContinuation<ListResolverRuleAssociationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverRuleAssociationsContinuation) in
            listResolverRuleAssociations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the Resolver rules that were created using the current AWS account.</p>
    func listResolverRules(input: ListResolverRulesInput) async throws -> ListResolverRulesOutputResponse
    {
        typealias listResolverRulesContinuation = CheckedContinuation<ListResolverRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverRulesContinuation) in
            listResolverRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the tags that you associated with the specified resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Attaches an AWS Identity and Access Management (AWS IAM) policy for sharing the rule
    /// 			group. You can use the policy to share the rule group using AWS Resource Access Manager
    /// 			(AWS RAM). </p>
    func putFirewallRuleGroupPolicy(input: PutFirewallRuleGroupPolicyInput) async throws -> PutFirewallRuleGroupPolicyOutputResponse
    {
        typealias putFirewallRuleGroupPolicyContinuation = CheckedContinuation<PutFirewallRuleGroupPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putFirewallRuleGroupPolicyContinuation) in
            putFirewallRuleGroupPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Specifies an AWS account that you want to share a query logging configuration with, the query logging configuration that you want to share,
    /// 			and the operations that you want the account to be able to perform on the configuration.</p>
    func putResolverQueryLogConfigPolicy(input: PutResolverQueryLogConfigPolicyInput) async throws -> PutResolverQueryLogConfigPolicyOutputResponse
    {
        typealias putResolverQueryLogConfigPolicyContinuation = CheckedContinuation<PutResolverQueryLogConfigPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResolverQueryLogConfigPolicyContinuation) in
            putResolverQueryLogConfigPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Specifies an AWS rule that you want to share with another account, the account that you want to share the rule with,
    /// 			and the operations that you want the account to be able to perform on the rule.</p>
    func putResolverRulePolicy(input: PutResolverRulePolicyInput) async throws -> PutResolverRulePolicyOutputResponse
    {
        typealias putResolverRulePolicyContinuation = CheckedContinuation<PutResolverRulePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResolverRulePolicyContinuation) in
            putResolverRulePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds one or more tags to a specified resource.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes one or more tags from a specified resource.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the configuration of the firewall behavior provided by DNS Firewall for a single
    /// 			VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
    func updateFirewallConfig(input: UpdateFirewallConfigInput) async throws -> UpdateFirewallConfigOutputResponse
    {
        typealias updateFirewallConfigContinuation = CheckedContinuation<UpdateFirewallConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallConfigContinuation) in
            updateFirewallConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the firewall domain list from an array of domain specifications. </p>
    func updateFirewallDomains(input: UpdateFirewallDomainsInput) async throws -> UpdateFirewallDomainsOutputResponse
    {
        typealias updateFirewallDomainsContinuation = CheckedContinuation<UpdateFirewallDomainsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallDomainsContinuation) in
            updateFirewallDomains(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the specified firewall rule. </p>
    func updateFirewallRule(input: UpdateFirewallRuleInput) async throws -> UpdateFirewallRuleOutputResponse
    {
        typealias updateFirewallRuleContinuation = CheckedContinuation<UpdateFirewallRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallRuleContinuation) in
            updateFirewallRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Changes the association of a <a>FirewallRuleGroup</a> with a VPC. The association enables DNS filtering for the VPC. </p>
    func updateFirewallRuleGroupAssociation(input: UpdateFirewallRuleGroupAssociationInput) async throws -> UpdateFirewallRuleGroupAssociationOutputResponse
    {
        typealias updateFirewallRuleGroupAssociationContinuation = CheckedContinuation<UpdateFirewallRuleGroupAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallRuleGroupAssociationContinuation) in
            updateFirewallRuleGroupAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an existing DNSSEC validation configuration. If there is no existing DNSSEC validation configuration, one is created.</p>
    func updateResolverDnssecConfig(input: UpdateResolverDnssecConfigInput) async throws -> UpdateResolverDnssecConfigOutputResponse
    {
        typealias updateResolverDnssecConfigContinuation = CheckedContinuation<UpdateResolverDnssecConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResolverDnssecConfigContinuation) in
            updateResolverDnssecConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the name of an inbound or an outbound Resolver endpoint.  </p>
    func updateResolverEndpoint(input: UpdateResolverEndpointInput) async throws -> UpdateResolverEndpointOutputResponse
    {
        typealias updateResolverEndpointContinuation = CheckedContinuation<UpdateResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResolverEndpointContinuation) in
            updateResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates settings for a specified Resolver rule. <code>ResolverRuleId</code> is required, and all other parameters are optional.
    /// 			If you don't specify a parameter, it retains its current value.</p>
    func updateResolverRule(input: UpdateResolverRuleInput) async throws -> UpdateResolverRuleOutputResponse
    {
        typealias updateResolverRuleContinuation = CheckedContinuation<UpdateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResolverRuleContinuation) in
            updateResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
