// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension Route53ResolverClient {
    /// Associates a FirewallRuleGroup with a VPC, to provide DNS filtering for the VPC.
    func associateFirewallRuleGroup(input: AssociateFirewallRuleGroupInput) async throws -> AssociateFirewallRuleGroupOutputResponse
    {
        typealias associateFirewallRuleGroupContinuation = CheckedContinuation<AssociateFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateFirewallRuleGroupContinuation) in
            associateFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds IP addresses to an inbound or an outbound Resolver endpoint. If you want to add more than one IP address,
    /// 			submit one AssociateResolverEndpointIpAddress request for each IP address.
    /// 		       To remove an IP address from an endpoint, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverEndpointIpAddress.html">DisassociateResolverEndpointIpAddress.
    /// 		
    func associateResolverEndpointIpAddress(input: AssociateResolverEndpointIpAddressInput) async throws -> AssociateResolverEndpointIpAddressOutputResponse
    {
        typealias associateResolverEndpointIpAddressContinuation = CheckedContinuation<AssociateResolverEndpointIpAddressOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateResolverEndpointIpAddressContinuation) in
            associateResolverEndpointIpAddress(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Associates an Amazon VPC with a specified query logging configuration. Route 53 Resolver logs DNS queries that originate in all of the Amazon VPCs
    /// 			that are associated with a specified query logging configuration. To associate more than one VPC with a configuration, submit one AssociateResolverQueryLogConfig
    /// 			request for each VPC.
    /// 		
    /// 		
    ///             The VPCs that you associate with a query logging configuration must be in the same Region as the configuration.
    ///
    /// 		
    /// 		       To remove a VPC from a query logging configuration, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig.
    /// 			
    func associateResolverQueryLogConfig(input: AssociateResolverQueryLogConfigInput) async throws -> AssociateResolverQueryLogConfigOutputResponse
    {
        typealias associateResolverQueryLogConfigContinuation = CheckedContinuation<AssociateResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateResolverQueryLogConfigContinuation) in
            associateResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Associates a Resolver rule with a VPC. When you associate a rule with a VPC, Resolver forwards all DNS queries
    /// 			for the domain name that is specified in the rule and that originate in the VPC. The queries are forwarded to the
    /// 			IP addresses for the DNS resolvers that are specified in the rule. For more information about rules, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule.
    func associateResolverRule(input: AssociateResolverRuleInput) async throws -> AssociateResolverRuleOutputResponse
    {
        typealias associateResolverRuleContinuation = CheckedContinuation<AssociateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateResolverRuleContinuation) in
            associateResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an empty firewall domain list for use in DNS Firewall rules. You can populate the domains for the new list with a file, using ImportFirewallDomains, or with domain strings, using UpdateFirewallDomains.
    func createFirewallDomainList(input: CreateFirewallDomainListInput) async throws -> CreateFirewallDomainListOutputResponse
    {
        typealias createFirewallDomainListContinuation = CheckedContinuation<CreateFirewallDomainListOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFirewallDomainListContinuation) in
            createFirewallDomainList(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.
    func createFirewallRule(input: CreateFirewallRuleInput) async throws -> CreateFirewallRuleOutputResponse
    {
        typealias createFirewallRuleContinuation = CheckedContinuation<CreateFirewallRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFirewallRuleContinuation) in
            createFirewallRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an empty DNS Firewall rule group for filtering DNS network traffic in a VPC. You can add rules to the new rule group
    ///            by calling CreateFirewallRule.
    func createFirewallRuleGroup(input: CreateFirewallRuleGroupInput) async throws -> CreateFirewallRuleGroupOutputResponse
    {
        typealias createFirewallRuleGroupContinuation = CheckedContinuation<CreateFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFirewallRuleGroupContinuation) in
            createFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a Resolver endpoint. There are two types of Resolver endpoints, inbound and outbound:
    /// 		
    ///
    ///                An inbound Resolver endpoint forwards DNS queries to the DNS service for a VPC
    /// 				from your network.
    ///
    ///
    ///                An outbound Resolver endpoint forwards DNS queries from the DNS service for a VPC
    /// 				to your network.
    ///
    ///
    func createResolverEndpoint(input: CreateResolverEndpointInput) async throws -> CreateResolverEndpointOutputResponse
    {
        typealias createResolverEndpointContinuation = CheckedContinuation<CreateResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResolverEndpointContinuation) in
            createResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs that originate in your VPCs.
    /// 			Resolver can log queries only for VPCs that are in the same Region as the query logging configuration.
    /// 		
    /// 		       To specify which VPCs you want to log queries for, you use AssociateResolverQueryLogConfig. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html">AssociateResolverQueryLogConfig.
    /// 		
    /// 		       You can optionally use AWS Resource Access Manager (AWS RAM) to share a query logging configuration with other AWS accounts. The other accounts
    /// 			can then associate VPCs with the configuration. The query logs that Resolver creates for a configuration include all DNS queries that originate in all
    /// 			VPCs that are associated with the configuration.
    func createResolverQueryLogConfig(input: CreateResolverQueryLogConfigInput) async throws -> CreateResolverQueryLogConfigOutputResponse
    {
        typealias createResolverQueryLogConfigContinuation = CheckedContinuation<CreateResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResolverQueryLogConfigContinuation) in
            createResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// For DNS queries that originate in your VPCs, specifies which Resolver endpoint the queries pass through,
    /// 			one domain name that you want to forward to your network, and the IP addresses of the DNS resolvers in your network.
    func createResolverRule(input: CreateResolverRuleInput) async throws -> CreateResolverRuleOutputResponse
    {
        typealias createResolverRuleContinuation = CheckedContinuation<CreateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResolverRuleContinuation) in
            createResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified domain list.
    func deleteFirewallDomainList(input: DeleteFirewallDomainListInput) async throws -> DeleteFirewallDomainListOutputResponse
    {
        typealias deleteFirewallDomainListContinuation = CheckedContinuation<DeleteFirewallDomainListOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFirewallDomainListContinuation) in
            deleteFirewallDomainList(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified firewall rule.
    func deleteFirewallRule(input: DeleteFirewallRuleInput) async throws -> DeleteFirewallRuleOutputResponse
    {
        typealias deleteFirewallRuleContinuation = CheckedContinuation<DeleteFirewallRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFirewallRuleContinuation) in
            deleteFirewallRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified firewall rule group.
    func deleteFirewallRuleGroup(input: DeleteFirewallRuleGroupInput) async throws -> DeleteFirewallRuleGroupOutputResponse
    {
        typealias deleteFirewallRuleGroupContinuation = CheckedContinuation<DeleteFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFirewallRuleGroupContinuation) in
            deleteFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a Resolver endpoint. The effect of deleting a Resolver endpoint depends on whether it's an inbound or an outbound
    /// 			Resolver endpoint:
    /// 		
    ///
    ///
    ///                   Inbound: DNS queries from your network are no longer routed
    /// 				to the DNS service for the specified VPC.
    ///
    ///
    ///
    ///                   Outbound: DNS queries from a VPC are no longer routed to your network.
    ///
    ///
    func deleteResolverEndpoint(input: DeleteResolverEndpointInput) async throws -> DeleteResolverEndpointOutputResponse
    {
        typealias deleteResolverEndpointContinuation = CheckedContinuation<DeleteResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResolverEndpointContinuation) in
            deleteResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for all of the Amazon VPCs that are
    /// 			associated with the configuration. This also applies if the query logging configuration is shared with other AWS accounts, and
    /// 			the other accounts have associated VPCs with the shared configuration.
    /// 		
    /// 		       Before you can delete a query logging configuration, you must first disassociate all VPCs from the configuration. See
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig.
    /// 			
    /// 		       If you used Resource Access Manager (RAM) to share a query logging configuration with other accounts, you must stop sharing
    /// 			the configuration before you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
    /// 			that they associated with the configuration, but that's not necessary. If you stop sharing the configuration, those VPCs are automatically
    /// 			disassociated from the configuration.
    func deleteResolverQueryLogConfig(input: DeleteResolverQueryLogConfigInput) async throws -> DeleteResolverQueryLogConfigOutputResponse
    {
        typealias deleteResolverQueryLogConfigContinuation = CheckedContinuation<DeleteResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResolverQueryLogConfigContinuation) in
            deleteResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a Resolver rule. Before you can delete a Resolver rule, you must disassociate it from all the VPCs that you
    /// 			associated the Resolver rule with. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html">DisassociateResolverRule.
    func deleteResolverRule(input: DeleteResolverRuleInput) async throws -> DeleteResolverRuleOutputResponse
    {
        typealias deleteResolverRuleContinuation = CheckedContinuation<DeleteResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResolverRuleContinuation) in
            deleteResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Disassociates a FirewallRuleGroup from a VPC, to remove DNS filtering from the VPC.
    func disassociateFirewallRuleGroup(input: DisassociateFirewallRuleGroupInput) async throws -> DisassociateFirewallRuleGroupOutputResponse
    {
        typealias disassociateFirewallRuleGroupContinuation = CheckedContinuation<DisassociateFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateFirewallRuleGroupContinuation) in
            disassociateFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes IP addresses from an inbound or an outbound Resolver endpoint. If you want to remove more than one IP address,
    /// 			submit one DisassociateResolverEndpointIpAddress request for each IP address.
    /// 		       To add an IP address to an endpoint, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverEndpointIpAddress.html">AssociateResolverEndpointIpAddress.
    /// 		
    func disassociateResolverEndpointIpAddress(input: DisassociateResolverEndpointIpAddressInput) async throws -> DisassociateResolverEndpointIpAddressOutputResponse
    {
        typealias disassociateResolverEndpointIpAddressContinuation = CheckedContinuation<DisassociateResolverEndpointIpAddressOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateResolverEndpointIpAddressContinuation) in
            disassociateResolverEndpointIpAddress(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Disassociates a VPC from a query logging configuration.
    /// 		
    /// 		
    /// 			         Before you can delete a query logging configuration, you must first disassociate all VPCs
    /// 				from the configuration. If you used AWS Resource Access Manager (AWS RAM) to share a
    /// 				query logging configuration with other accounts, VPCs can be disassociated from the
    /// 				configuration in the following ways:
    /// 			
    ///
    ///                   The accounts that you shared the configuration with can disassociate VPCs from the configuration.
    ///
    ///
    ///                   You can stop sharing the configuration.
    ///
    ///
    /// 		
    func disassociateResolverQueryLogConfig(input: DisassociateResolverQueryLogConfigInput) async throws -> DisassociateResolverQueryLogConfigOutputResponse
    {
        typealias disassociateResolverQueryLogConfigContinuation = CheckedContinuation<DisassociateResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateResolverQueryLogConfigContinuation) in
            disassociateResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes the association between a specified Resolver rule and a specified VPC.
    /// 		
    /// 			         If you disassociate a Resolver rule from a VPC, Resolver stops forwarding DNS queries for the
    /// 				domain name that you specified in the Resolver rule.
    /// 		
    func disassociateResolverRule(input: DisassociateResolverRuleInput) async throws -> DisassociateResolverRuleOutputResponse
    {
        typealias disassociateResolverRuleContinuation = CheckedContinuation<DisassociateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateResolverRuleContinuation) in
            disassociateResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the configuration of the firewall behavior provided by DNS Firewall for a
    /// 			single VPC from Amazon Virtual Private Cloud (Amazon VPC).
    func getFirewallConfig(input: GetFirewallConfigInput) async throws -> GetFirewallConfigOutputResponse
    {
        typealias getFirewallConfigContinuation = CheckedContinuation<GetFirewallConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallConfigContinuation) in
            getFirewallConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the specified firewall domain list.
    func getFirewallDomainList(input: GetFirewallDomainListInput) async throws -> GetFirewallDomainListOutputResponse
    {
        typealias getFirewallDomainListContinuation = CheckedContinuation<GetFirewallDomainListOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallDomainListContinuation) in
            getFirewallDomainList(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the specified firewall rule group.
    func getFirewallRuleGroup(input: GetFirewallRuleGroupInput) async throws -> GetFirewallRuleGroupOutputResponse
    {
        typealias getFirewallRuleGroupContinuation = CheckedContinuation<GetFirewallRuleGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallRuleGroupContinuation) in
            getFirewallRuleGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a firewall rule group association, which enables DNS filtering for a VPC with one rule group. A VPC can have more than one firewall rule group association, and a rule group can be associated with more than one VPC.
    func getFirewallRuleGroupAssociation(input: GetFirewallRuleGroupAssociationInput) async throws -> GetFirewallRuleGroupAssociationOutputResponse
    {
        typealias getFirewallRuleGroupAssociationContinuation = CheckedContinuation<GetFirewallRuleGroupAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallRuleGroupAssociationContinuation) in
            getFirewallRuleGroupAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the AWS Identity and Access Management (AWS IAM) policy for sharing the
    /// 			specified rule group. You can use the policy to share the rule group using AWS Resource
    /// 			Access Manager (AWS RAM).
    func getFirewallRuleGroupPolicy(input: GetFirewallRuleGroupPolicyInput) async throws -> GetFirewallRuleGroupPolicyOutputResponse
    {
        typealias getFirewallRuleGroupPolicyContinuation = CheckedContinuation<GetFirewallRuleGroupPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFirewallRuleGroupPolicyContinuation) in
            getFirewallRuleGroupPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets DNSSEC validation information for a specified resource.
    func getResolverDnssecConfig(input: GetResolverDnssecConfigInput) async throws -> GetResolverDnssecConfigOutputResponse
    {
        typealias getResolverDnssecConfigContinuation = CheckedContinuation<GetResolverDnssecConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverDnssecConfigContinuation) in
            getResolverDnssecConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a specified Resolver endpoint, such as whether it's an inbound or an outbound Resolver endpoint, and the
    /// 			current status of the endpoint.
    func getResolverEndpoint(input: GetResolverEndpointInput) async throws -> GetResolverEndpointOutputResponse
    {
        typealias getResolverEndpointContinuation = CheckedContinuation<GetResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverEndpointContinuation) in
            getResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a specified Resolver query logging configuration, such as the number of VPCs that the configuration
    /// 			is logging queries for and the location that logs are sent to.
    func getResolverQueryLogConfig(input: GetResolverQueryLogConfigInput) async throws -> GetResolverQueryLogConfigOutputResponse
    {
        typealias getResolverQueryLogConfigContinuation = CheckedContinuation<GetResolverQueryLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverQueryLogConfigContinuation) in
            getResolverQueryLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a specified association between a Resolver query logging configuration and an Amazon VPC. When you associate a VPC
    /// 			with a query logging configuration, Resolver logs DNS queries that originate in that VPC.
    func getResolverQueryLogConfigAssociation(input: GetResolverQueryLogConfigAssociationInput) async throws -> GetResolverQueryLogConfigAssociationOutputResponse
    {
        typealias getResolverQueryLogConfigAssociationContinuation = CheckedContinuation<GetResolverQueryLogConfigAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverQueryLogConfigAssociationContinuation) in
            getResolverQueryLogConfigAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a query logging policy. A query logging policy specifies the Resolver query logging
    /// 			operations and resources that you want to allow another AWS account to be able to use.
    func getResolverQueryLogConfigPolicy(input: GetResolverQueryLogConfigPolicyInput) async throws -> GetResolverQueryLogConfigPolicyOutputResponse
    {
        typealias getResolverQueryLogConfigPolicyContinuation = CheckedContinuation<GetResolverQueryLogConfigPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverQueryLogConfigPolicyContinuation) in
            getResolverQueryLogConfigPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a specified Resolver rule, such as the domain name that the rule forwards DNS queries for and the ID of the
    /// 			outbound Resolver endpoint that the rule is associated with.
    func getResolverRule(input: GetResolverRuleInput) async throws -> GetResolverRuleOutputResponse
    {
        typealias getResolverRuleContinuation = CheckedContinuation<GetResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverRuleContinuation) in
            getResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about an association between a specified Resolver rule and a VPC. You associate a Resolver rule and a VPC using
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule.
    func getResolverRuleAssociation(input: GetResolverRuleAssociationInput) async throws -> GetResolverRuleAssociationOutputResponse
    {
        typealias getResolverRuleAssociationContinuation = CheckedContinuation<GetResolverRuleAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverRuleAssociationContinuation) in
            getResolverRuleAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about the Resolver rule policy for a specified rule. A Resolver rule policy includes the rule that you want to share
    /// 			with another account, the account that you want to share the rule with, and the Resolver operations that you want to allow the account to use.
    func getResolverRulePolicy(input: GetResolverRulePolicyInput) async throws -> GetResolverRulePolicyOutputResponse
    {
        typealias getResolverRulePolicyContinuation = CheckedContinuation<GetResolverRulePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getResolverRulePolicyContinuation) in
            getResolverRulePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Imports domain names from a file into a domain list, for use in a DNS firewall rule group.
    ///          Each domain specification in your domain list must satisfy the following
    /// 	requirements:
    ///
    ///
    ///       	        It can optionally start with * (asterisk).
    ///       	
    ///
    ///       	        With the exception of the optional starting asterisk, it must only contain
    ///       	   the following characters: A-Z, a-z,
    ///       	   0-9, - (hyphen).
    ///       	
    ///
    ///       	        It must be from 1-255 characters in length.
    ///       	
    ///
    func importFirewallDomains(input: ImportFirewallDomainsInput) async throws -> ImportFirewallDomainsOutputResponse
    {
        typealias importFirewallDomainsContinuation = CheckedContinuation<ImportFirewallDomainsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: importFirewallDomainsContinuation) in
            importFirewallDomains(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the firewall configurations that you have defined. DNS Firewall uses the configurations to manage firewall behavior for your VPCs.
    ///          A single call might return only a partial list of the configurations. For information, see MaxResults.
    func listFirewallConfigs(input: ListFirewallConfigsInput) async throws -> ListFirewallConfigsOutputResponse
    {
        typealias listFirewallConfigsContinuation = CheckedContinuation<ListFirewallConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallConfigsContinuation) in
            listFirewallConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the firewall domain lists that you have defined. For each firewall domain list, you can retrieve the domains that are defined for a list by calling ListFirewallDomains.
    ///          A single call to this list operation might return only a partial list of the domain lists. For information, see MaxResults.
    func listFirewallDomainLists(input: ListFirewallDomainListsInput) async throws -> ListFirewallDomainListsOutputResponse
    {
        typealias listFirewallDomainListsContinuation = CheckedContinuation<ListFirewallDomainListsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallDomainListsContinuation) in
            listFirewallDomainLists(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the domains that you have defined for the specified firewall domain list.
    ///          A single call might return only a partial list of the domains. For information, see MaxResults.
    func listFirewallDomains(input: ListFirewallDomainsInput) async throws -> ListFirewallDomainsOutputResponse
    {
        typealias listFirewallDomainsContinuation = CheckedContinuation<ListFirewallDomainsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallDomainsContinuation) in
            listFirewallDomains(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the firewall rule group associations that you have defined. Each association enables DNS filtering for a VPC with one rule group.
    ///          A single call might return only a partial list of the associations. For information, see MaxResults.
    func listFirewallRuleGroupAssociations(input: ListFirewallRuleGroupAssociationsInput) async throws -> ListFirewallRuleGroupAssociationsOutputResponse
    {
        typealias listFirewallRuleGroupAssociationsContinuation = CheckedContinuation<ListFirewallRuleGroupAssociationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallRuleGroupAssociationsContinuation) in
            listFirewallRuleGroupAssociations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the minimal high-level information for the rule groups that you have defined.
    ///          A single call might return only a partial list of the rule groups. For information, see MaxResults.
    func listFirewallRuleGroups(input: ListFirewallRuleGroupsInput) async throws -> ListFirewallRuleGroupsOutputResponse
    {
        typealias listFirewallRuleGroupsContinuation = CheckedContinuation<ListFirewallRuleGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallRuleGroupsContinuation) in
            listFirewallRuleGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the firewall rules that you have defined for the specified firewall rule group. DNS Firewall uses the rules in a rule group to filter DNS network traffic for a VPC.
    ///          A single call might return only a partial list of the rules. For information, see MaxResults.
    func listFirewallRules(input: ListFirewallRulesInput) async throws -> ListFirewallRulesOutputResponse
    {
        typealias listFirewallRulesContinuation = CheckedContinuation<ListFirewallRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFirewallRulesContinuation) in
            listFirewallRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the configurations for DNSSEC validation that are associated with the current AWS account.
    func listResolverDnssecConfigs(input: ListResolverDnssecConfigsInput) async throws -> ListResolverDnssecConfigsOutputResponse
    {
        typealias listResolverDnssecConfigsContinuation = CheckedContinuation<ListResolverDnssecConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverDnssecConfigsContinuation) in
            listResolverDnssecConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets the IP addresses for a specified Resolver endpoint.
    func listResolverEndpointIpAddresses(input: ListResolverEndpointIpAddressesInput) async throws -> ListResolverEndpointIpAddressesOutputResponse
    {
        typealias listResolverEndpointIpAddressesContinuation = CheckedContinuation<ListResolverEndpointIpAddressesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverEndpointIpAddressesContinuation) in
            listResolverEndpointIpAddresses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists all the Resolver endpoints that were created using the current AWS account.
    func listResolverEndpoints(input: ListResolverEndpointsInput) async throws -> ListResolverEndpointsOutputResponse
    {
        typealias listResolverEndpointsContinuation = CheckedContinuation<ListResolverEndpointsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverEndpointsContinuation) in
            listResolverEndpoints(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists information about associations between Amazon VPCs and query logging configurations.
    func listResolverQueryLogConfigAssociations(input: ListResolverQueryLogConfigAssociationsInput) async throws -> ListResolverQueryLogConfigAssociationsOutputResponse
    {
        typealias listResolverQueryLogConfigAssociationsContinuation = CheckedContinuation<ListResolverQueryLogConfigAssociationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverQueryLogConfigAssociationsContinuation) in
            listResolverQueryLogConfigAssociations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists information about the specified query logging configurations. Each configuration defines where you want Resolver to save
    /// 			DNS query logs and specifies the VPCs that you want to log queries for.
    func listResolverQueryLogConfigs(input: ListResolverQueryLogConfigsInput) async throws -> ListResolverQueryLogConfigsOutputResponse
    {
        typealias listResolverQueryLogConfigsContinuation = CheckedContinuation<ListResolverQueryLogConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverQueryLogConfigsContinuation) in
            listResolverQueryLogConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the associations that were created between Resolver rules and VPCs using the current AWS account.
    func listResolverRuleAssociations(input: ListResolverRuleAssociationsInput) async throws -> ListResolverRuleAssociationsOutputResponse
    {
        typealias listResolverRuleAssociationsContinuation = CheckedContinuation<ListResolverRuleAssociationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverRuleAssociationsContinuation) in
            listResolverRuleAssociations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the Resolver rules that were created using the current AWS account.
    func listResolverRules(input: ListResolverRulesInput) async throws -> ListResolverRulesOutputResponse
    {
        typealias listResolverRulesContinuation = CheckedContinuation<ListResolverRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listResolverRulesContinuation) in
            listResolverRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the tags that you associated with the specified resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Attaches an AWS Identity and Access Management (AWS IAM) policy for sharing the rule
    /// 			group. You can use the policy to share the rule group using AWS Resource Access Manager
    /// 			(AWS RAM).
    func putFirewallRuleGroupPolicy(input: PutFirewallRuleGroupPolicyInput) async throws -> PutFirewallRuleGroupPolicyOutputResponse
    {
        typealias putFirewallRuleGroupPolicyContinuation = CheckedContinuation<PutFirewallRuleGroupPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putFirewallRuleGroupPolicyContinuation) in
            putFirewallRuleGroupPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Specifies an AWS account that you want to share a query logging configuration with, the query logging configuration that you want to share,
    /// 			and the operations that you want the account to be able to perform on the configuration.
    func putResolverQueryLogConfigPolicy(input: PutResolverQueryLogConfigPolicyInput) async throws -> PutResolverQueryLogConfigPolicyOutputResponse
    {
        typealias putResolverQueryLogConfigPolicyContinuation = CheckedContinuation<PutResolverQueryLogConfigPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResolverQueryLogConfigPolicyContinuation) in
            putResolverQueryLogConfigPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Specifies an AWS rule that you want to share with another account, the account that you want to share the rule with,
    /// 			and the operations that you want the account to be able to perform on the rule.
    func putResolverRulePolicy(input: PutResolverRulePolicyInput) async throws -> PutResolverRulePolicyOutputResponse
    {
        typealias putResolverRulePolicyContinuation = CheckedContinuation<PutResolverRulePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResolverRulePolicyContinuation) in
            putResolverRulePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds one or more tags to a specified resource.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes one or more tags from a specified resource.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the configuration of the firewall behavior provided by DNS Firewall for a single
    /// 			VPC from Amazon Virtual Private Cloud (Amazon VPC).
    func updateFirewallConfig(input: UpdateFirewallConfigInput) async throws -> UpdateFirewallConfigOutputResponse
    {
        typealias updateFirewallConfigContinuation = CheckedContinuation<UpdateFirewallConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallConfigContinuation) in
            updateFirewallConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the firewall domain list from an array of domain specifications.
    func updateFirewallDomains(input: UpdateFirewallDomainsInput) async throws -> UpdateFirewallDomainsOutputResponse
    {
        typealias updateFirewallDomainsContinuation = CheckedContinuation<UpdateFirewallDomainsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallDomainsContinuation) in
            updateFirewallDomains(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the specified firewall rule.
    func updateFirewallRule(input: UpdateFirewallRuleInput) async throws -> UpdateFirewallRuleOutputResponse
    {
        typealias updateFirewallRuleContinuation = CheckedContinuation<UpdateFirewallRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallRuleContinuation) in
            updateFirewallRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Changes the association of a FirewallRuleGroup with a VPC. The association enables DNS filtering for the VPC.
    func updateFirewallRuleGroupAssociation(input: UpdateFirewallRuleGroupAssociationInput) async throws -> UpdateFirewallRuleGroupAssociationOutputResponse
    {
        typealias updateFirewallRuleGroupAssociationContinuation = CheckedContinuation<UpdateFirewallRuleGroupAssociationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFirewallRuleGroupAssociationContinuation) in
            updateFirewallRuleGroupAssociation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an existing DNSSEC validation configuration. If there is no existing DNSSEC validation configuration, one is created.
    func updateResolverDnssecConfig(input: UpdateResolverDnssecConfigInput) async throws -> UpdateResolverDnssecConfigOutputResponse
    {
        typealias updateResolverDnssecConfigContinuation = CheckedContinuation<UpdateResolverDnssecConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResolverDnssecConfigContinuation) in
            updateResolverDnssecConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the name of an inbound or an outbound Resolver endpoint.
    func updateResolverEndpoint(input: UpdateResolverEndpointInput) async throws -> UpdateResolverEndpointOutputResponse
    {
        typealias updateResolverEndpointContinuation = CheckedContinuation<UpdateResolverEndpointOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResolverEndpointContinuation) in
            updateResolverEndpoint(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates settings for a specified Resolver rule. ResolverRuleId is required, and all other parameters are optional.
    /// 			If you don't specify a parameter, it retains its current value.
    func updateResolverRule(input: UpdateResolverRuleInput) async throws -> UpdateResolverRuleOutputResponse
    {
        typealias updateResolverRuleContinuation = CheckedContinuation<UpdateResolverRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResolverRuleContinuation) in
            updateResolverRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
