// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension InternalFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailure(message: \(Swift.String(describing: message)))"}
}

extension InternalFailure {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///  An internal failure occurred.
public struct InternalFailure: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct InvokeEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.data(bodydata)
            input.builder.withBody(bodybody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeEndpointOutputError>
}

extension InvokeEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeEndpointInput(accept: \(Swift.String(describing: accept)), body: \(Swift.String(describing: body)), contentType: \(Swift.String(describing: contentType)), customAttributes: \(Swift.String(describing: customAttributes)), endpointName: \(Swift.String(describing: endpointName)), inferenceId: \(Swift.String(describing: inferenceId)), targetContainerHostname: \(Swift.String(describing: targetContainerHostname)), targetModel: \(Swift.String(describing: targetModel)), targetVariant: \(Swift.String(describing: targetVariant)))"}
}

extension InvokeEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct InvokeEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accept = input.operationInput.accept {
            input.builder.withHeader(name: "Accept", value: Swift.String(accept))
        }
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: Swift.String(contentType))
        }
        if let customAttributes = input.operationInput.customAttributes {
            input.builder.withHeader(name: "X-Amzn-SageMaker-Custom-Attributes", value: Swift.String(customAttributes))
        }
        if let inferenceId = input.operationInput.inferenceId {
            input.builder.withHeader(name: "X-Amzn-SageMaker-Inference-Id", value: Swift.String(inferenceId))
        }
        if let targetContainerHostname = input.operationInput.targetContainerHostname {
            input.builder.withHeader(name: "X-Amzn-SageMaker-Target-Container-Hostname", value: Swift.String(targetContainerHostname))
        }
        if let targetModel = input.operationInput.targetModel {
            input.builder.withHeader(name: "X-Amzn-SageMaker-Target-Model", value: Swift.String(targetModel))
        }
        if let targetVariant = input.operationInput.targetVariant {
            input.builder.withHeader(name: "X-Amzn-SageMaker-Target-Variant", value: Swift.String(targetVariant))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeEndpointOutputError>
}

public struct InvokeEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeEndpointOutputError>
}

public struct InvokeEndpointInput: Swift.Equatable {
    /// The desired MIME type of the inference in the response.
    public let accept: Swift.String?
    /// Provides input data, in the format specified in the ContentType
    ///             request header. Amazon SageMaker passes all of the data in the body to the model.
    ///         For information about the format of the request body, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html">Common Data
    ///                 Formats-Inference.
    /// This member is required.
    public let body: ClientRuntime.Data?
    /// The MIME type of the input data in the request body.
    public let contentType: Swift.String?
    /// Provides additional information about a request for an inference submitted to a model
    ///             hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
    ///             forwarded verbatim. You could use this value, for example, to provide an ID that you can
    ///             use to track a request or to provide other metadata that a service endpoint was
    ///             programmed to process. The value must consist of no more than 1024 visible US-ASCII
    ///             characters as specified in <a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">Section 3.3.6. Field Value
    ///                 Components of the Hypertext Transfer Protocol (HTTP/1.1).
    ///         The code in your model is responsible for setting or updating any custom attributes in
    ///             the response. If your code does not set this value in the response, an empty value is
    ///             returned. For example, if a custom attribute represents the trace ID, your model can
    ///             prepend the custom attribute with Trace ID: in your post-processing
    ///             function.
    ///
    ///         This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python
    ///             SDK.
    public let customAttributes: Swift.String?
    /// The name of the endpoint that you specified when you created the endpoint using the
    ///                 <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateEndpoint.html">CreateEndpoint API.
    /// This member is required.
    public let endpointName: Swift.String?
    /// If you provide a value, it is added to the captured data when you enable data capture
    ///             on the endpoint. For information about data capture, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-data-capture.html">Capture
    ///             Data.
    public let inferenceId: Swift.String?
    /// If the endpoint hosts multiple containers and is configured to use direct invocation,
    ///             this parameter specifies the host name of the container to invoke.
    public let targetContainerHostname: Swift.String?
    /// The model to request for inference when invoking a multi-model endpoint.
    public let targetModel: Swift.String?
    /// Specify the production variant to send the inference request to when invoking an
    ///             endpoint that is running two or more variants. Note that this parameter overrides the
    ///             default behavior for the endpoint, which is to distribute the invocation traffic based
    ///             on the variant weights.
    ///         For information about how to use variant targeting to perform a/b testing, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-ab-testing.html">Test models in
    ///                 production
    ///
    public let targetVariant: Swift.String?

    public init (
        accept: Swift.String? = nil,
        body: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        customAttributes: Swift.String? = nil,
        endpointName: Swift.String? = nil,
        inferenceId: Swift.String? = nil,
        targetContainerHostname: Swift.String? = nil,
        targetModel: Swift.String? = nil,
        targetVariant: Swift.String? = nil
    )
    {
        self.accept = accept
        self.body = body
        self.contentType = contentType
        self.customAttributes = customAttributes
        self.endpointName = endpointName
        self.inferenceId = inferenceId
        self.targetContainerHostname = targetContainerHostname
        self.targetModel = targetModel
        self.targetVariant = targetVariant
    }
}

struct InvokeEndpointInputBody: Swift.Equatable {
    public let body: ClientRuntime.Data?
}

extension InvokeEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension InvokeEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ModelError" : self = .modelError(try ModelError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalFailure(InternalFailure)
    case modelError(ModelError)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeEndpointOutputResponse(body: \(Swift.String(describing: body)), contentType: \(Swift.String(describing: contentType)), customAttributes: \(Swift.String(describing: customAttributes)), invokedProductionVariant: \(Swift.String(describing: invokedProductionVariant)))"}
}

extension InvokeEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let customAttributesHeaderValue = httpResponse.headers.value(for: "X-Amzn-SageMaker-Custom-Attributes") {
            self.customAttributes = customAttributesHeaderValue
        } else {
            self.customAttributes = nil
        }
        if let invokedProductionVariantHeaderValue = httpResponse.headers.value(for: "x-Amzn-Invoked-Production-Variant") {
            self.invokedProductionVariant = invokedProductionVariantHeaderValue
        } else {
            self.invokedProductionVariant = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.body = data
        } else {
            self.body = nil
        }
    }
}

public struct InvokeEndpointOutputResponse: Swift.Equatable {
    /// Includes the inference provided by the model.
    ///         For information about the format of the response body, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html">Common Data
    ///                 Formats-Inference.
    /// This member is required.
    public let body: ClientRuntime.Data?
    /// The MIME type of the inference returned in the response body.
    public let contentType: Swift.String?
    /// Provides additional information in the response about the inference returned by a
    ///             model hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
    ///             forwarded verbatim. You could use this value, for example, to return an ID received in
    ///             the CustomAttributes header of a request or other metadata that a service
    ///             endpoint was programmed to produce. The value must consist of no more than 1024 visible
    ///             US-ASCII characters as specified in <a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">Section 3.3.6. Field Value
    ///                 Components of the Hypertext Transfer Protocol (HTTP/1.1). If the customer
    ///             wants the custom attribute returned, the model must set the custom attribute to be
    ///             included on the way back.
    ///         The code in your model is responsible for setting or updating any custom attributes in
    ///             the response. If your code does not set this value in the response, an empty value is
    ///             returned. For example, if a custom attribute represents the trace ID, your model can
    ///             prepend the custom attribute with Trace ID: in your post-processing
    ///             function.
    ///         This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python
    ///             SDK.
    public let customAttributes: Swift.String?
    /// Identifies the production variant that was invoked.
    public let invokedProductionVariant: Swift.String?

    public init (
        body: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        customAttributes: Swift.String? = nil,
        invokedProductionVariant: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
        self.customAttributes = customAttributes
        self.invokedProductionVariant = invokedProductionVariant
    }
}

struct InvokeEndpointOutputResponseBody: Swift.Equatable {
    public let body: ClientRuntime.Data?
}

extension InvokeEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ModelError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelError(logStreamArn: \(Swift.String(describing: logStreamArn)), message: \(Swift.String(describing: message)), originalMessage: \(Swift.String(describing: originalMessage)), originalStatusCode: \(Swift.String(describing: originalStatusCode)))"}
}

extension ModelError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModelErrorBody = try responseDecoder.decode(responseBody: data)
            self.logStreamArn = output.logStreamArn
            self.message = output.message
            self.originalMessage = output.originalMessage
            self.originalStatusCode = output.originalStatusCode
        } else {
            self.logStreamArn = nil
            self.message = nil
            self.originalMessage = nil
            self.originalStatusCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///  Model (owned by the customer in the container) returned 4xx or 5xx error code.
///
public struct ModelError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///  The Amazon Resource Name (ARN) of the log stream.
    public var logStreamArn: Swift.String?
    public var message: Swift.String?
    ///  Original message.
    public var originalMessage: Swift.String?
    ///  Original status code.
    public var originalStatusCode: Swift.Int?

    public init (
        logStreamArn: Swift.String? = nil,
        message: Swift.String? = nil,
        originalMessage: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil
    )
    {
        self.logStreamArn = logStreamArn
        self.message = message
        self.originalMessage = originalMessage
        self.originalStatusCode = originalStatusCode
    }
}

struct ModelErrorBody: Swift.Equatable {
    public let message: Swift.String?
    public let originalStatusCode: Swift.Int?
    public let originalMessage: Swift.String?
    public let logStreamArn: Swift.String?
}

extension ModelErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logStreamArn = "LogStreamArn"
        case message = "Message"
        case originalMessage = "OriginalMessage"
        case originalStatusCode = "OriginalStatusCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let originalStatusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originalStatusCode)
        originalStatusCode = originalStatusCodeDecoded
        let originalMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalMessage)
        originalMessage = originalMessageDecoded
        let logStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamArn)
        logStreamArn = logStreamArnDecoded
    }
}

extension ServiceUnavailable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailable(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailable {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///  The service is unavailable. Try your call again.
public struct ServiceUnavailable: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationError(message: \(Swift.String(describing: message)))"}
}

extension ValidationError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///  Inspect your request and try again.
public struct ValidationError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
