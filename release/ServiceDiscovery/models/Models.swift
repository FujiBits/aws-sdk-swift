// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct CreateHttpNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHttpNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHttpNamespaceOutputError>
}

extension CreateHttpNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHttpNamespaceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateHttpNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateHttpNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHttpNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHttpNamespaceOutputError>
}

public struct CreateHttpNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHttpNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHttpNamespaceOutputError>
}

public struct CreateHttpNamespaceInput: Swift.Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreateHttpNamespace</code> requests to
    ///    be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string
    ///    (for example, a date/time stamp).</p>
    public var creatorRequestId: Swift.String?
    /// <p>A description for the namespace.</p>
    public let description: Swift.String?
    /// <p>The name that you want to assign to this namespace.</p>
    public let name: Swift.String?
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateHttpNamespaceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension CreateHttpNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateHttpNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHttpNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHttpNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHttpNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHttpNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension CreateHttpNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHttpNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreateHttpNamespaceOutputResponse: Swift.Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreateHttpNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension CreateHttpNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreatePrivateDnsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePrivateDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePrivateDnsNamespaceOutputError>
}

extension CreatePrivateDnsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePrivateDnsNamespaceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), vpc: \(Swift.String(describing: vpc)))"}
}

extension CreatePrivateDnsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpc = vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }
}

public struct CreatePrivateDnsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePrivateDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePrivateDnsNamespaceOutputError>
}

public struct CreatePrivateDnsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePrivateDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePrivateDnsNamespaceOutputError>
}

public struct CreatePrivateDnsNamespaceInput: Swift.Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreatePrivateDnsNamespace</code>
    ///    requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
    ///    unique string (for example, a date/timestamp).</p>
    public var creatorRequestId: Swift.String?
    /// <p>A description for the namespace.</p>
    public let description: Swift.String?
    /// <p>The name that you want to assign to this namespace. When you create a private DNS namespace, AWS Cloud Map
    ///    automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.</p>
    public let name: Swift.String?
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    /// <p>The ID of the Amazon VPC that you want to associate the namespace with.</p>
    public let vpc: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        vpc: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
        self.vpc = vpc
    }
}

struct CreatePrivateDnsNamespaceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let vpc: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension CreatePrivateDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePrivateDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePrivateDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePrivateDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePrivateDnsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePrivateDnsNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension CreatePrivateDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePrivateDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePrivateDnsNamespaceOutputResponse: Swift.Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePrivateDnsNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension CreatePrivateDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreatePublicDnsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicDnsNamespaceOutputError>
}

extension CreatePublicDnsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicDnsNamespaceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePublicDnsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePublicDnsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicDnsNamespaceOutputError>
}

public struct CreatePublicDnsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicDnsNamespaceOutputError>
}

public struct CreatePublicDnsNamespaceInput: Swift.Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreatePublicDnsNamespace</code>
    ///    requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
    ///    unique string (for example, a date/timestamp).</p>
    public var creatorRequestId: Swift.String?
    /// <p>A description for the namespace.</p>
    public let description: Swift.String?
    /// <p>The name that you want to assign to this namespace.</p>
    public let name: Swift.String?
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreatePublicDnsNamespaceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension CreatePublicDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePublicDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublicDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicDnsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicDnsNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension CreatePublicDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePublicDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePublicDnsNamespaceOutputResponse: Swift.Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePublicDnsNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension CreatePublicDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)), healthCheckCustomConfig: \(Swift.String(describing: healthCheckCustomConfig)), name: \(Swift.String(describing: name)), namespaceId: \(Swift.String(describing: namespaceId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInput: Swift.Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreateService</code> requests to be
    ///    retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string (for
    ///    example, a date/timestamp).</p>
    public var creatorRequestId: Swift.String?
    /// <p>A description for the service.</p>
    public let description: Swift.String?
    /// <p>A complex type that contains information about the Amazon Route 53 records that you want AWS Cloud Map to create when you
    ///    register an instance. </p>
    public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
    /// <p>
    ///             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
    ///    Route 53 health check. If you specify settings for a health check, AWS Cloud Map associates the health check with all the
    ///    Route 53 DNS records that you specify in <code>DnsConfig</code>.</p>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    ///          <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/cloud-map/pricing/">AWS Cloud Map Pricing</a>.</p>
    public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
    /// <p>A complex type that contains information about an optional custom health check.</p>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    ///          <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration from an existing
    ///    service.</p>
    public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
    /// <p>The name that you want to assign to the service.</p>
    ///          <p>If you want AWS Cloud Map to create an <code>SRV</code> record when you register an instance and you're using a
    ///    system that requires a specific <code>SRV</code> format, such as <a href="http://www.haproxy.org/">HAProxy</a>, specify the following for <code>Name</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Start the name with an underscore (_), such as <code>_exampleservice</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>End the name with <i>._protocol</i>, such as <code>._tcp</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>When you register an instance, AWS Cloud Map creates an <code>SRV</code> record and assigns a name to the record by
    ///    concatenating the service name and the namespace name (for example,</p>
    ///          <p>
    ///             <code>_exampleservice._tcp.example.com</code>).</p>
    ///          <note>
    ///             <p>For services that are accessible by DNS queries, you can't create multiple services with names that differ only
    ///     by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished.
    ///     However, if you use a namespace that's only accessible by API calls, then you can create services that with names
    ///     that differ only by case.</p>
    ///          </note>
    public let name: Swift.String?
    /// <p>The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it
    ///    can be specified either here or in the <code>DnsConfig</code> object.</p>
    public let namespaceId: Swift.String?
    /// <p>The tags to add to the service. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    /// <p>If present, specifies that the service instances are only discoverable using the <code>DiscoverInstances</code>
    ///    API operation. No DNS records is registered for the service instances. The only valid value is
    ///    <code>HTTP</code>.</p>
    public let type: ServiceDiscoveryClientTypes.ServiceTypeOption?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
        healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
        healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
        name: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        type: ServiceDiscoveryClientTypes.ServiceTypeOption? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
        self.healthCheckCustomConfig = healthCheckCustomConfig
        self.name = name
        self.namespaceId = namespaceId
        self.tags = tags
        self.type = type
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let namespaceId: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
    public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
    public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    public let type: ServiceDiscoveryClientTypes.ServiceTypeOption?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceTypeOption.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAlreadyExists" : self = .serviceAlreadyExists(try ServiceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceAlreadyExists(ServiceAlreadyExists)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// <p>A complex type that contains information about the new service.</p>
    public let service: ServiceDiscoveryClientTypes.Service?

    public init (
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    public let service: ServiceDiscoveryClientTypes.Service?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension CustomHealthNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomHealthNotFound(message: \(Swift.String(describing: message)))"}
}

extension CustomHealthNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CustomHealthNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The health check for the instance that's specified by <code>ServiceId</code> and <code>InstanceId</code> isn't a
///    custom health check. </p>
public struct CustomHealthNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomHealthNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CustomHealthNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum CustomHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomHealthStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomHealthStatus(rawValue: rawValue) ?? CustomHealthStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNamespaceOutputError>
}

extension DeleteNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNamespaceInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInput: Swift.Equatable {
    /// <p>The ID of the namespace that you want to delete.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DeleteNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension DeleteNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeleteNamespaceOutputResponse: Swift.Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeleteNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension DeleteNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DeleteServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

extension DeleteServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInput: Swift.Equatable {
    /// <p>The ID of the service that you want to delete.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceOutputResponse()"}
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

extension DeregisterInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterInstanceInput(instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension DeregisterInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct DeregisterInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInput: Swift.Equatable {
    /// <p>The value that you specified for <code>Id</code> in the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request.</p>
    public let instanceId: Swift.String?
    /// <p>The ID of the service that the instance is associated with.</p>
    public let serviceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct DeregisterInstanceInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
}

extension DeregisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterInstanceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension DeregisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeregisterInstanceOutputResponse: Swift.Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. For more information, see
    ///     <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeregisterInstanceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension DeregisterInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DiscoverInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DiscoverInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DiscoverInstancesOutputError>
}

extension DiscoverInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DiscoverInstancesInput(healthStatus: \(Swift.String(describing: healthStatus)), maxResults: \(Swift.String(describing: maxResults)), namespaceName: \(Swift.String(describing: namespaceName)), optionalParameters: \(Swift.String(describing: optionalParameters)), queryParameters: \(Swift.String(describing: queryParameters)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension DiscoverInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let optionalParameters = optionalParameters {
            var optionalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .optionalParameters)
            for (dictKey0, attributes0) in optionalParameters {
                try optionalParametersContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .queryParameters)
            for (dictKey0, attributes0) in queryParameters {
                try queryParametersContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct DiscoverInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DiscoverInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DiscoverInstancesOutputError>
}

public struct DiscoverInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DiscoverInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DiscoverInstancesOutputError>
}

public struct DiscoverInstancesInput: Swift.Equatable {
    /// <p>The health status of the instances that you want to discover. This parameter is ignored for services that don't
    ///    have a health check configured, and
    ///    all
    ///    instances are returned.</p>
    ///          <dl>
    ///             <dt>HEALTHY</dt>
    ///             <dd>
    ///                <p>Returns healthy instances.</p>
    ///             </dd>
    ///             <dt>UNHEALTHY</dt>
    ///             <dd>
    ///                <p>Returns unhealthy instances.</p>
    ///             </dd>
    ///             <dt>ALL</dt>
    ///             <dd>
    ///                <p>Returns all instances.</p>
    ///             </dd>
    ///             <dt>HEALTHY_OR_ELSE_ALL</dt>
    ///             <dd>
    ///                <p>Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances.
    ///       This is also called failing open.</p>
    ///             </dd>
    ///          </dl>
    public let healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter?
    /// <p>The maximum number of instances that you want AWS Cloud Map to return in the response to a
    ///     <code>DiscoverInstances</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up
    ///    to 100 instances.</p>
    public let maxResults: Swift.Int?
    /// <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
    ///     <code>Properties</code> member of the namespace.</p>
    public let namespaceName: Swift.String?
    /// <p>Opportunistic filters to scope the results based on custom attributes. If there are instances that match both
    ///    the filters specified in both the <code>QueryParameters</code> parameter and this parameter, all of these instances
    ///    are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the
    ///     <code>QueryParameters</code> parameter are returned.</p>
    public let optionalParameters: [Swift.String:Swift.String]?
    /// <p>Filters to scope the results based on custom attributes for the instance (for example, <code>{version=v1,
    ///     az=1a}</code>). Only instances that match all the specified key-value pairs are returned.</p>
    public let queryParameters: [Swift.String:Swift.String]?
    /// <p>The name of the service that you specified when you registered the instance.</p>
    public let serviceName: Swift.String?

    public init (
        healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter? = nil,
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        optionalParameters: [Swift.String:Swift.String]? = nil,
        queryParameters: [Swift.String:Swift.String]? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.healthStatus = healthStatus
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.optionalParameters = optionalParameters
        self.queryParameters = queryParameters
        self.serviceName = serviceName
    }
}

struct DiscoverInstancesInputBody: Swift.Equatable {
    public let namespaceName: Swift.String?
    public let serviceName: Swift.String?
    public let maxResults: Swift.Int?
    public let queryParameters: [Swift.String:Swift.String]?
    public let optionalParameters: [Swift.String:Swift.String]?
    public let healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter?
}

extension DiscoverInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .queryParameters)
        var queryParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in queryParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    queryParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let optionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .optionalParameters)
        var optionalParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let optionalParametersContainer = optionalParametersContainer {
            optionalParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in optionalParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    optionalParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        optionalParameters = optionalParametersDecoded0
        let healthStatusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthStatusFilter.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
    }
}

extension DiscoverInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceeded" : self = .requestLimitExceeded(try RequestLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DiscoverInstancesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case requestLimitExceeded(RequestLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DiscoverInstancesOutputResponse(instances: \(Swift.String(describing: instances)))"}
}

extension DiscoverInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DiscoverInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

public struct DiscoverInstancesOutputResponse: Swift.Equatable {
    /// <p>A complex type that contains one <code>HttpInstanceSummary</code> for each registered instance.</p>
    public let instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]?

    public init (
        instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]? = nil
    )
    {
        self.instances = instances
    }
}

struct DiscoverInstancesOutputResponseBody: Swift.Equatable {
    public let instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]?
}

extension DiscoverInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.HttpInstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[ServiceDiscoveryClientTypes.HttpInstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [ServiceDiscoveryClientTypes.HttpInstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.DnsConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsRecords = "DnsRecords"
        case namespaceId = "NamespaceId"
        case routingPolicy = "RoutingPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let routingPolicy = routingPolicy {
            try encodeContainer.encode(routingPolicy.rawValue, forKey: .routingPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let routingPolicyDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.RoutingPolicy.self, forKey: .routingPolicy)
        routingPolicy = routingPolicyDecoded
        let dnsRecordsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[ServiceDiscoveryClientTypes.DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [ServiceDiscoveryClientTypes.DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.DnsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsConfig(dnsRecords: \(Swift.String(describing: dnsRecords)), namespaceId: \(Swift.String(describing: namespaceId)), routingPolicy: \(Swift.String(describing: routingPolicy)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about the Amazon Route 53 DNS records that you want AWS Cloud Map to create when
    ///    you register an instance.</p>
    public struct DnsConfig: Swift.Equatable {
        /// <p>An array that contains one <code>DnsRecord</code> object for each Route 53 DNS record that you want AWS Cloud Map to
        ///    create when you register an instance.</p>
        public let dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?
        /// <p>The ID of the namespace to use for DNS configuration.</p>
        @available(*, deprecated, message: "Top level attribute in request should be used to reference namespace-id")
        public let namespaceId: Swift.String?
        /// <p>The routing policy that you want to apply to all Route 53 DNS records that AWS Cloud Map creates when you register an
        ///    instance and specify this service.</p>
        ///          <note>
        ///             <p>If you want to use this service to register instances that create alias records, specify <code>WEIGHTED</code>
        ///     for the routing policy.</p>
        ///          </note>
        ///          <p>You can specify the following values:</p>
        ///          <dl>
        ///             <dt>MULTIVALUE</dt>
        ///             <dd>
        ///                <p>If you define a health check for the service and the health check is healthy, Route 53 returns the applicable
        ///       value for up to eight instances.</p>
        ///                <p>For example, suppose that the service includes configurations for one <code>A</code> record and a health
        ///       check. You use the service to register 10 instances. Route 53 responds to DNS queries with IP addresses for up to
        ///       eight healthy instances. If fewer than eight instances are healthy, Route 53 responds to every DNS query with the IP
        ///       addresses for all of the healthy instances.</p>
        ///                <p>If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
        ///       the values for up to eight instances.</p>
        ///                <p>For more information about the multivalue routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-multivalue">Multivalue Answer
        ///        Routing</a> in the <i>Route 53 Developer Guide</i>.</p>
        ///             </dd>
        ///             <dt>WEIGHTED</dt>
        ///             <dd>
        ///                <p>Route 53 returns the applicable value from one randomly selected instance from among the instances that you
        ///       registered using the same service. Currently, all records have the same weight, so you can't route more or less
        ///       traffic to any instances.</p>
        ///                <p>For example, suppose that the service includes configurations for one <code>A</code> record and a health
        ///       check. You use the service to register 10 instances. Route 53 responds to DNS queries with the IP address for one
        ///       randomly selected instance from among the healthy instances. If no instances are healthy, Route 53 responds to DNS
        ///       queries as if all of the instances were healthy.</p>
        ///                <p>If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
        ///       the applicable value for one randomly selected instance.</p>
        ///                <p>For more information about the weighted routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted">Weighted Routing</a> in the
        ///        <i>Route 53 Developer Guide</i>.</p>
        ///             </dd>
        ///          </dl>
        public let routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy?

        public init (
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil,
            namespaceId: Swift.String? = nil,
            routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy? = nil
        )
        {
            self.dnsRecords = dnsRecords
            self.namespaceId = namespaceId
            self.routingPolicy = routingPolicy
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsConfigChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsRecords = "DnsRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsRecordsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[ServiceDiscoveryClientTypes.DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [ServiceDiscoveryClientTypes.DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.DnsConfigChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsConfigChange(dnsRecords: \(Swift.String(describing: dnsRecords)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about changes to the Route 53 DNS records that AWS Cloud Map creates when you
    ///    register an instance.</p>
    public struct DnsConfigChange: Swift.Equatable {
        /// <p>An array that contains one <code>DnsRecord</code> object for each Route 53 record that you want AWS Cloud Map to
        ///    create when you register an instance.</p>
        public let dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?

        public init (
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil
        )
        {
            self.dnsRecords = dnsRecords
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostedZoneId = "HostedZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.DnsProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsProperties(hostedZoneId: \(Swift.String(describing: hostedZoneId)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains the ID for the Route 53 hosted zone that AWS Cloud Map creates when you create a
    ///    namespace.</p>
    public struct DnsProperties: Swift.Equatable {
        /// <p>The ID for the Route 53 hosted zone that AWS Cloud Map creates when you create a namespace.</p>
        public let hostedZoneId: Swift.String?

        public init (
            hostedZoneId: Swift.String? = nil
        )
        {
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsRecord: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tTL = "TTL"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.RecordType.self, forKey: .type)
        type = typeDecoded
        let tTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension ServiceDiscoveryClientTypes.DnsRecord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsRecord(tTL: \(Swift.String(describing: tTL)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about the Route 53 DNS records that you want AWS Cloud Map to create when you
    ///    register an instance.</p>
    public struct DnsRecord: Swift.Equatable {
        /// <p>The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record.</p>
        ///          <note>
        ///             <p>Alias records don't include a TTL because Route 53 uses the TTL for the AWS resource that an alias record routes
        ///     traffic to. If you include the <code>AWS_ALIAS_DNS_NAME</code> attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request, the
        ///      <code>TTL</code> value is ignored. Always specify a TTL for the service; you can use a service to register
        ///     instances that create either alias or non-alias records.</p>
        ///          </note>
        public let tTL: Swift.Int?
        /// <p>The type of the resource, which indicates the type of value that Route 53 returns in response to DNS queries. You
        ///    can specify values for <code>Type</code> in the following combinations:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>
        ///                      <code>A</code>
        ///                   </b>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>
        ///                      <code>AAAA</code>
        ///                   </b>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>
        ///                      <code>A</code>
        ///                   </b> and <b>
        ///                      <code>AAAA</code>
        ///                   </b>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>
        ///                      <code>SRV</code>
        ///                   </b>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>
        ///                      <code>CNAME</code>
        ///                   </b>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///          <p>If you want AWS Cloud Map to create a Route 53 alias record when you register an instance, specify <code>A</code> or
        ///     <code>AAAA</code> for <code>Type</code>.</p>
        ///          <p>You specify other settings, such as the IP address for <code>A</code> and <code>AAAA</code> records, when you
        ///    register an instance. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a>.</p>
        ///          <p>The following values are supported:</p>
        ///          <dl>
        ///             <dt>A</dt>
        ///             <dd>
        ///                <p>Route 53 returns the IP address of the resource in IPv4 format, such as 192.0.2.44.</p>
        ///             </dd>
        ///             <dt>AAAA</dt>
        ///             <dd>
        ///                <p>Route 53 returns the IP address of the resource in IPv6 format, such as
        ///       2001:0db8:85a3:0000:0000:abcd:0001:2345.</p>
        ///             </dd>
        ///             <dt>CNAME</dt>
        ///             <dd>
        ///                <p>Route 53 returns the domain name of the resource, such as www.example.com. Note the following:</p>
        ///                <ul>
        ///                   <li>
        ///                      <p>You specify the domain name that you want to route traffic to when you register an instance. For more
        ///         information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html#cloudmap-RegisterInstance-request-Attributes">Attributes</a> in the topic <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a>.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>You must specify <code>WEIGHTED</code> for the value of <code>RoutingPolicy</code>.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>You can't specify both <code>CNAME</code> for <code>Type</code> and settings for
        ///          <code>HealthCheckConfig</code>. If you do, the request will fail with an <code>InvalidInput</code>
        ///         error.</p>
        ///                   </li>
        ///                </ul>
        ///             </dd>
        ///             <dt>SRV</dt>
        ///             <dd>
        ///                <p>Route 53 returns the value for an <code>SRV</code> record. The value for an <code>SRV</code> record uses the
        ///       following values:</p>
        ///                <p>
        ///                   <code>priority weight port service-hostname</code>
        ///                </p>
        ///                <p>Note the following about the values:</p>
        ///                <ul>
        ///                   <li>
        ///                      <p>The values of <code>priority</code> and <code>weight</code> are both set to <code>1</code> and can't be
        ///         changed. </p>
        ///                   </li>
        ///                   <li>
        ///                      <p>The value of <code>port</code> comes from the value that you specify for the <code>AWS_INSTANCE_PORT</code>
        ///         attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request. </p>
        ///                   </li>
        ///                   <li>
        ///                      <p>The value of <code>service-hostname</code> is a concatenation of the following values:</p>
        ///                      <ul>
        ///                         <li>
        ///                            <p>The value that you specify for <code>InstanceId</code> when you register an instance.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>The name of the service.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>The name of the namespace. </p>
        ///                         </li>
        ///                      </ul>
        ///                      <p>For example, if the value of <code>InstanceId</code> is <code>test</code>, the name of the service is
        ///          <code>backend</code>, and the name of the namespace is <code>example.com</code>, the value of
        ///          <code>service-hostname</code> is the following:</p>
        ///                      <p>
        ///                         <code>test.backend.example.com</code>
        ///                      </p>
        ///                   </li>
        ///                </ul>
        ///                <p>If you specify settings for an <code>SRV</code> record, note the following:</p>
        ///                <ul>
        ///                   <li>
        ///                      <p>If you specify values for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both in the
        ///          <code>RegisterInstance</code> request, AWS Cloud Map automatically creates <code>A</code> and/or <code>AAAA</code>
        ///         records that have the same name as the value of <code>service-hostname</code> in the <code>SRV</code> record.
        ///         You can ignore these records.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>If you're using a system that requires a specific <code>SRV</code> format, such as HAProxy, see the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html#cloudmap-CreateService-request-Name">Name</a> element in the documentation about <code>CreateService</code> for information about how to
        ///         specify the correct name format.</p>
        ///                   </li>
        ///                </ul>
        ///             </dd>
        ///          </dl>
        public let type: ServiceDiscoveryClientTypes.RecordType?

        public init (
            tTL: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.RecordType? = nil
        )
        {
            self.tTL = tTL
            self.type = type
        }
    }

}

extension DuplicateRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateRequest(duplicateOperationId: \(Swift.String(describing: duplicateOperationId)), message: \(Swift.String(describing: message)))"}
}

extension DuplicateRequest: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateRequestBody = try responseDecoder.decode(responseBody: data)
            self.duplicateOperationId = output.duplicateOperationId
            self.message = output.message
        } else {
            self.duplicateOperationId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation is already in progress.</p>
public struct DuplicateRequest: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The ID of the operation that's already in progress.</p>
    public var duplicateOperationId: Swift.String?
    public var message: Swift.String?

    public init (
        duplicateOperationId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.duplicateOperationId = duplicateOperationId
        self.message = message
    }
}

struct DuplicateRequestBody: Swift.Equatable {
    public let message: Swift.String?
    public let duplicateOperationId: Swift.String?
}

extension DuplicateRequestBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duplicateOperationId = "DuplicateOperationId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let duplicateOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duplicateOperationId)
        duplicateOperationId = duplicateOperationIdDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum FilterCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case eq
        case `in`
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterCondition] {
            return [
                .between,
                .eq,
                .in,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .eq: return "EQ"
            case .in: return "IN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterCondition(rawValue: rawValue) ?? FilterCondition.sdkUnknown(rawValue)
        }
    }
}

public struct GetInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceOutputError>
}

extension GetInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstanceInput(instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension GetInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct GetInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceOutputError>
}

public struct GetInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceOutputError>
}

public struct GetInstanceInput: Swift.Equatable {
    /// <p>The ID of the instance that you want to get information about.</p>
    public let instanceId: Swift.String?
    /// <p>The ID of the service that the instance is associated with.</p>
    public let serviceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct GetInstanceInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
}

extension GetInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension GetInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstanceOutputError: Swift.Error, Swift.Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstanceOutputResponse(instance: \(Swift.String(describing: instance)))"}
}

extension GetInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instance = output.instance
        } else {
            self.instance = nil
        }
    }
}

public struct GetInstanceOutputResponse: Swift.Equatable {
    /// <p>A complex type that contains information about a specified instance.</p>
    public let instance: ServiceDiscoveryClientTypes.Instance?

    public init (
        instance: ServiceDiscoveryClientTypes.Instance? = nil
    )
    {
        self.instance = instance
    }
}

struct GetInstanceOutputResponseBody: Swift.Equatable {
    public let instance: ServiceDiscoveryClientTypes.Instance?
}

extension GetInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance = "Instance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Instance.self, forKey: .instance)
        instance = instanceDecoded
    }
}

public struct GetInstancesHealthStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstancesHealthStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstancesHealthStatusOutputError>
}

extension GetInstancesHealthStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstancesHealthStatusInput(instances: \(Swift.String(describing: instances)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension GetInstancesHealthStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for instanceidlist0 in instances {
                try instancesContainer.encode(instanceidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct GetInstancesHealthStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstancesHealthStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstancesHealthStatusOutputError>
}

public struct GetInstancesHealthStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstancesHealthStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstancesHealthStatusOutputError>
}

public struct GetInstancesHealthStatusInput: Swift.Equatable {
    /// <p>An array that contains the IDs of all the instances that you want to get the health status for.</p>
    ///          <p>If you omit <code>Instances</code>, AWS Cloud Map returns the health status for all the instances that are
    ///    associated with the specified service.</p>
    ///          <note>
    ///             <p>To get the IDs for the instances that you've registered by using a specified service, submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html">ListInstances</a> request.</p>
    ///          </note>
    public let instances: [Swift.String]?
    /// <p>The maximum number of instances that you want AWS Cloud Map to return in the response to a
    ///     <code>GetInstancesHealthStatus</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map
    ///    returns up to 100 instances.</p>
    public let maxResults: Swift.Int?
    /// <p>For the first <code>GetInstancesHealthStatus</code> request, omit this value.</p>
    ///          <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
    ///     <code>NextToken</code> from the previous response in the next request.</p>
    public let nextToken: Swift.String?
    /// <p>The ID of the service that the instance is associated with.</p>
    public let serviceId: Swift.String?

    public init (
        instances: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instances = instances
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct GetInstancesHealthStatusInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instances: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension GetInstancesHealthStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instancesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instances)
        var instancesDecoded0:[Swift.String]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [Swift.String]()
            for string0 in instancesContainer {
                if let string0 = string0 {
                    instancesDecoded0?.append(string0)
                }
            }
        }
        instances = instancesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInstancesHealthStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstancesHealthStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstancesHealthStatusOutputError: Swift.Error, Swift.Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstancesHealthStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstancesHealthStatusOutputResponse(nextToken: \(Swift.String(describing: nextToken)), status: \(Swift.String(describing: status)))"}
}

extension GetInstancesHealthStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInstancesHealthStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.status = output.status
        } else {
            self.nextToken = nil
            self.status = nil
        }
    }
}

public struct GetInstancesHealthStatusOutputResponse: Swift.Equatable {
    /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
    ///     <code>NextToken</code> from the previous response in the next request.</p>
    public let nextToken: Swift.String?
    /// <p>A complex type that contains the IDs and the health status of the instances that you specified in the
    ///     <code>GetInstancesHealthStatus</code> request.</p>
    public let status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]?

    public init (
        nextToken: Swift.String? = nil,
        status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
    }
}

struct GetInstancesHealthStatusOutputResponseBody: Swift.Equatable {
    public let status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]?
    public let nextToken: Swift.String?
}

extension GetInstancesHealthStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusContainer = try containerValues.decodeIfPresent([Swift.String: ServiceDiscoveryClientTypes.HealthStatus?].self, forKey: .status)
        var statusDecoded0: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]? = nil
        if let statusContainer = statusContainer {
            statusDecoded0 = [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]()
            for (key0, healthstatus0) in statusContainer {
                if let healthstatus0 = healthstatus0 {
                    statusDecoded0?[key0] = healthstatus0
                }
            }
        }
        status = statusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNamespaceOutputError>
}

extension GetNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNamespaceInput(id: \(Swift.String(describing: id)))"}
}

extension GetNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNamespaceOutputError>
}

public struct GetNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNamespaceOutputError>
}

public struct GetNamespaceInput: Swift.Equatable {
    /// <p>The ID of the namespace that you want to get information about.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetNamespaceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension GetNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNamespaceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNamespaceOutputResponse(namespace: \(Swift.String(describing: namespace)))"}
}

extension GetNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct GetNamespaceOutputResponse: Swift.Equatable {
    /// <p>A complex type that contains information about the specified namespace.</p>
    public let namespace: ServiceDiscoveryClientTypes.Namespace?

    public init (
        namespace: ServiceDiscoveryClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct GetNamespaceOutputResponseBody: Swift.Equatable {
    public let namespace: ServiceDiscoveryClientTypes.Namespace?
}

extension GetNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace = "Namespace"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

public struct GetOperationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOperationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOperationOutputError>
}

extension GetOperationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOperationInput(operationId: \(Swift.String(describing: operationId)))"}
}

extension GetOperationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

public struct GetOperationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOperationOutputError>
}

public struct GetOperationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOperationOutputError>
}

public struct GetOperationInput: Swift.Equatable {
    /// <p>The ID of the operation that you want to get more information about.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationInputBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension GetOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotFound" : self = .operationNotFound(try OperationNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOperationOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationNotFound(OperationNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOperationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOperationOutputResponse(operation: \(Swift.String(describing: operation)))"}
}

extension GetOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operation = output.operation
        } else {
            self.operation = nil
        }
    }
}

public struct GetOperationOutputResponse: Swift.Equatable {
    /// <p>A complex type that contains information about the operation.</p>
    public let operation: ServiceDiscoveryClientTypes.Operation?

    public init (
        operation: ServiceDiscoveryClientTypes.Operation? = nil
    )
    {
        self.operation = operation
    }
}

struct GetOperationOutputResponseBody: Swift.Equatable {
    public let operation: ServiceDiscoveryClientTypes.Operation?
}

extension GetOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

public struct GetServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

extension GetServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceInput(id: \(Swift.String(describing: id)))"}
}

extension GetServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInput: Swift.Equatable {
    /// <p>The ID of the service that you want to get settings for.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension GetServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension GetServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct GetServiceOutputResponse: Swift.Equatable {
    /// <p>A complex type that contains information about the service.</p>
    public let service: ServiceDiscoveryClientTypes.Service?

    public init (
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct GetServiceOutputResponseBody: Swift.Equatable {
    public let service: ServiceDiscoveryClientTypes.Service?
}

extension GetServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureThreshold = "FailureThreshold"
        case resourcePath = "ResourcePath"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
        if let resourcePath = resourcePath {
            try encodeContainer.encode(resourcePath, forKey: .resourcePath)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckType.self, forKey: .type)
        type = typeDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HealthCheckConfig(failureThreshold: \(Swift.String(describing: failureThreshold)), resourcePath: \(Swift.String(describing: resourcePath)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>
    ///             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
    ///    health check. If you specify settings for a health check, AWS Cloud Map associates the health check with the records
    ///    that you specify in <code>DnsConfig</code>.</p>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    ///          <p>Health checks are basic Route 53 health checks that monitor an AWS endpoint. For information about pricing for
    ///    health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
    ///          <p>Note the following about configuring health checks.</p>
    ///          <dl>
    ///             <dt>A and AAAA records</dt>
    ///             <dd>
    ///                <p>If <code>DnsConfig</code> includes configurations for both <code>A</code> and <code>AAAA</code> records,
    ///       AWS Cloud Map creates a health check that uses the IPv4 address to check the health of the resource. If the endpoint
    ///       tthat's specified by the IPv4 address is unhealthy, Route 53 considers both the <code>A</code> and <code>AAAA</code>
    ///       records to be unhealthy. </p>
    ///             </dd>
    ///             <dt>CNAME records</dt>
    ///             <dd>
    ///                <p>You can't specify settings for <code>HealthCheckConfig</code> when the <code>DNSConfig</code> includes
    ///        <code>CNAME</code> for the value of <code>Type</code>. If you do, the <code>CreateService</code> request will
    ///       fail with an <code>InvalidInput</code> error.</p>
    ///             </dd>
    ///             <dt>Request interval</dt>
    ///             <dd>
    ///                <p>A Route 53 health checker in each health-checking AWS Region sends a health check request to an endpoint every
    ///       30 seconds. On average, your endpoint receives a health check request about every two seconds. However, health
    ///       checkers don't coordinate with one another. Therefore, you might sometimes see several requests in one second
    ///       that's followed by a few seconds with no health checks at all.</p>
    ///             </dd>
    ///             <dt>Health checking regions</dt>
    ///             <dd>
    ///                <p>Health checkers perform checks from all Route 53 health-checking Regions. For a list of the current Regions, see
    ///        <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions">Regions</a>.</p>
    ///             </dd>
    ///             <dt>Alias records</dt>
    ///             <dd>
    ///                <p>When you register an instance, if you include the <code>AWS_ALIAS_DNS_NAME</code> attribute, AWS Cloud Map
    ///       creates a Route 53 alias record. Note the following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Route 53 automatically sets <code>EvaluateTargetHealth</code> to true for alias records. When
    ///          <code>EvaluateTargetHealth</code> is true, the alias record inherits the health of the referenced AWS
    ///         resource. such as an ELB load balancer. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-EvaluateTargetHealth">EvaluateTargetHealth</a>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you include <code>HealthCheckConfig</code> and then use the service to register an instance that creates
    ///         an alias record, Route 53 doesn't create the health check.</p>
    ///                   </li>
    ///                </ul>
    ///             </dd>
    ///             <dt>Charges for health checks</dt>
    ///             <dd>
    ///                <p>Health checks are basic Route 53 health checks that monitor an AWS endpoint. For information about pricing for
    ///       health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
    ///             </dd>
    ///          </dl>
    public struct HealthCheckConfig: Swift.Equatable {
        /// <p>The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current
        ///    status of the endpoint from unhealthy to healthy or the other way around. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53
        ///     Determines Whether an Endpoint Is Healthy</a> in the <i>Route 53 Developer Guide</i>.</p>
        public let failureThreshold: Swift.Int?
        /// <p>The path that you want Route 53 to request when performing health checks. The path can be any value that your
        ///    endpoint returns an HTTP status code of a 2xx or 3xx format for when the endpoint is healthy. An example file is
        ///     <code>/docs/route53-health-check.html</code>. Route 53 automatically adds the DNS name for the service. If you don't
        ///    specify a value for <code>ResourcePath</code>, the default value is <code>/</code>.</p>
        ///          <p>If you specify <code>TCP</code> for <code>Type</code>, you must <i>not</i> specify a value for
        ///     <code>ResourcePath</code>.</p>
        public let resourcePath: Swift.String?
        /// <p>The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is
        ///    healthy.</p>
        ///          <important>
        ///             <p>You can't change the value of <code>Type</code> after you create a health check.</p>
        ///          </important>
        ///          <p>You can create the following types of health checks:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>HTTP</b>: Route 53 tries to establish a TCP connection. If successful, Route 53 submits
        ///      an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>HTTPS</b>: Route 53 tries to establish a TCP connection. If successful, Route 53
        ///      submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.</p>
        ///                <important>
        ///                   <p>If you specify HTTPS for the value of <code>Type</code>, the endpoint must support TLS v1.0 or later.</p>
        ///                </important>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>TCP</b>: Route 53 tries to establish a TCP connection.</p>
        ///                <p>If you specify <code>TCP</code> for <code>Type</code>, don't specify a value for
        ///      <code>ResourcePath</code>.</p>
        ///             </li>
        ///          </ul>
        ///          <p>For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53 Determines Whether
        ///     an Endpoint Is Healthy</a> in the <i>Route 53 Developer Guide</i>.</p>
        public let type: ServiceDiscoveryClientTypes.HealthCheckType?

        public init (
            failureThreshold: Swift.Int? = nil,
            resourcePath: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.HealthCheckType? = nil
        )
        {
            self.failureThreshold = failureThreshold
            self.resourcePath = resourcePath
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes.HealthCheckCustomConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureThreshold = "FailureThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckCustomConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HealthCheckCustomConfig(failureThreshold: \(Swift.String(describing: failureThreshold)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about an optional custom health check. A custom health check, which
    ///    requires that you use a third-party health checker to evaluate the health of your resources, is useful in the
    ///    following circumstances:</p>
    ///          <ul>
    ///             <li>
    ///                <p>You can't use a health check that's defined by <code>HealthCheckConfig</code> because the resource isn't
    ///      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
    ///      (To check the health of resources in a VPC, the health checker must also be in the VPC.)</p>
    ///             </li>
    ///             <li>
    ///                <p>You want to use a third-party health checker regardless of where your resources are located.</p>
    ///             </li>
    ///          </ul>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    ///          <p>To change the status of a custom health check, submit an <code>UpdateInstanceCustomHealthStatus</code> request.
    ///    AWS Cloud Map doesn't monitor the status of the resource, it just keeps a record of the status specified in the most recent
    ///     <code>UpdateInstanceCustomHealthStatus</code> request.</p>
    ///          <p>Here's how custom health checks work:</p>
    ///          <ol>
    ///             <li>
    ///                <p>You create a service.</p>
    ///             </li>
    ///             <li>
    ///                <p>You register an instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>You configure a third-party health checker to monitor the resource that's associated with the new instance. </p>
    ///                <note>
    ///                   <p>AWS Cloud Map doesn't check the health of the resource directly. </p>
    ///                </note>
    ///             </li>
    ///             <li>
    ///                <p>The third-party health-checker determines that the resource is unhealthy and notifies your application.</p>
    ///             </li>
    ///             <li>
    ///                <p>Your application submits an <code>UpdateInstanceCustomHealthStatus</code> request.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS Cloud Map waits for 30 seconds.</p>
    ///             </li>
    ///             <li>
    ///                <p>If another <code>UpdateInstanceCustomHealthStatus</code> request doesn't arrive during that time to change the
    ///      status back to healthy, AWS Cloud Map stops routing traffic to the resource.</p>
    ///             </li>
    ///          </ol>
    public struct HealthCheckCustomConfig: Swift.Equatable {
        /// <important>
        ///             <p>This parameter is no longer supported and is always set to 1. AWS Cloud Map waits for approximately 30 seconds after
        ///     receiving an <code>UpdateInstanceCustomHealthStatus</code> request before changing the status of the service
        ///     instance.</p>
        ///          </important>
        ///          <p>The number of 30-second intervals that you want AWS Cloud Map to wait after receiving an
        ///     <code>UpdateInstanceCustomHealthStatus</code> request before it changes the health status of a service
        ///    instance.</p>
        ///          <p>Sending a second or subsequent <code>UpdateInstanceCustomHealthStatus</code> request with the same value before
        ///    30 seconds has passed doesn't accelerate the change. AWS Cloud Map still waits <code>30</code> seconds after the first
        ///    request to make the change.</p>
        @available(*, deprecated, message: "Configurable FailureThreshold of HealthCheckCustomConfig is deprecated.  It will always have value 1.")
        public let failureThreshold: Swift.Int?

        public init (
            failureThreshold: Swift.Int? = nil
        )
        {
            self.failureThreshold = failureThreshold
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum HealthCheckType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckType] {
            return [
                .http,
                .https,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckType(rawValue: rawValue) ?? HealthCheckType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum HealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatus] {
            return [
                .healthy,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatus(rawValue: rawValue) ?? HealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum HealthStatusFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case healthy
        case healthyOrElseAll
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatusFilter] {
            return [
                .all,
                .healthy,
                .healthyOrElseAll,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .healthy: return "HEALTHY"
            case .healthyOrElseAll: return "HEALTHY_OR_ELSE_ALL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatusFilter(rawValue: rawValue) ?? HealthStatusFilter.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.HttpInstanceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case healthStatus = "HealthStatus"
        case instanceId = "InstanceId"
        case namespaceName = "NamespaceName"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.HttpInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpInstanceSummary(attributes: \(Swift.String(describing: attributes)), healthStatus: \(Swift.String(describing: healthStatus)), instanceId: \(Swift.String(describing: instanceId)), namespaceName: \(Swift.String(describing: namespaceName)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>In a response to a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a> request, <code>HttpInstanceSummary</code> contains information about one instance that
    ///    matches the values that you specified in the request.</p>
    public struct HttpInstanceSummary: Swift.Equatable {
        /// <p>If you included any attributes when you registered the instance, the values of those attributes.</p>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>If you configured health checking in the service, the current health status of the service instance.</p>
        public let healthStatus: ServiceDiscoveryClientTypes.HealthStatus?
        /// <p>The ID of an instance that matches the values that you specified in the request.</p>
        public let instanceId: Swift.String?
        /// <p>
        ///             <code></code>
        ///             <code></code>
        ///             <code></code>
        ///          </p>
        ///          <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
        ///     <code>Properties</code> member of the namespace.</p>
        public let namespaceName: Swift.String?
        /// <p>The name of the service that you specified when you registered the instance.</p>
        public let serviceName: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            healthStatus: ServiceDiscoveryClientTypes.HealthStatus? = nil,
            instanceId: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.healthStatus = healthStatus
            self.instanceId = instanceId
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }
    }

}

extension ServiceDiscoveryClientTypes.HttpProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpName = "HttpName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpName = httpName {
            try encodeContainer.encode(httpName, forKey: .httpName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpName)
        httpName = httpNameDecoded
    }
}

extension ServiceDiscoveryClientTypes.HttpProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpProperties(httpName: \(Swift.String(describing: httpName)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains the name of an HTTP namespace.</p>
    public struct HttpProperties: Swift.Equatable {
        /// <p>The name of an HTTP namespace.</p>
        public let httpName: Swift.String?

        public init (
            httpName: Swift.String? = nil
        )
        {
            self.httpName = httpName
        }
    }

}

extension ServiceDiscoveryClientTypes.Instance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.Instance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Instance(attributes: \(Swift.String(describing: attributes)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), id: \(Swift.String(describing: id)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about an instance that AWS Cloud Map creates when you submit a
    ///     <code>RegisterInstance</code> request.</p>
    public struct Instance: Swift.Equatable {
        /// <p>A string map that contains the following information for the service that you specify in
        ///    <code>ServiceId</code>:</p>
        ///          <ul>
        ///             <li>
        ///                <p>The attributes that apply to the records that are defined in the service. </p>
        ///             </li>
        ///             <li>
        ///                <p>For each attribute, the applicable value.</p>
        ///             </li>
        ///          </ul>
        ///          <p>Supported attribute keys include the following:</p>
        ///          <dl>
        ///             <dt>AWS_ALIAS_DNS_NAME</dt>
        ///             <dd>
        ///                <p>If you want AWS Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify
        ///       the DNS name that's associated with the load balancer. For information about how to get the DNS name, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName">AliasTarget->DNSName</a> in the <i>Route 53 API Reference</i>.</p>
        ///                <p>Note the following:</p>
        ///                <ul>
        ///                   <li>
        ///                      <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
        ///          <code>A</code> record, an <code>AAAA</code> record, or both.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
        ///          <code>WEIGHTED</code>.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
        ///         AWS Cloud Map creates the health check, but it won't associate the health check with the alias record.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>Auto naming currently doesn't support creating alias records that route traffic to AWS resources other
        ///         than ELB load balancers.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
        ///          <code>AWS_INSTANCE</code> attributes.</p>
        ///                   </li>
        ///                </ul>
        ///             </dd>
        ///             <dt>AWS_EC2_INSTANCE_ID</dt>
        ///             <dd>
        ///                <p>
        ///                   <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. The
        ///        <code>AWS_INSTANCE_IPV4</code> attribute contains the primary private IPv4 address.</p>
        ///             </dd>
        ///             <dt>AWS_INIT_HEALTH_STATUS</dt>
        ///             <dd>
        ///                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
        ///        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
        ///        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
        ///        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_CNAME</dt>
        ///             <dd>
        ///                <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
        ///       return in response to DNS queries (for example, <code>example.com</code>).</p>
        ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
        ///        <code>CNAME</code> record.</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_IPV4</dt>
        ///             <dd>
        ///                <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
        ///       return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
        ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
        ///        <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
        ///       for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_IPV6</dt>
        ///             <dd>
        ///                <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
        ///       return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
        ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
        ///        <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
        ///       value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_PORT</dt>
        ///             <dd>
        ///                <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
        ///       port.</p>
        ///                <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
        ///       requests to. </p>
        ///                <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
        ///       you created the service.</p>
        ///             </dd>
        ///          </dl>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
        ///    retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
        ///    every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
        ///    namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
        ///    stamp).</p>
        public let creatorRequestId: Swift.String?
        /// <p>An identifier that you want to associate with the instance. Note the following:</p>
        ///          <ul>
        ///             <li>
        ///                <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
        ///      the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
        ///      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
        ///             </li>
        ///             <li>
        ///                <p>You can use this value to update an existing instance.</p>
        ///             </li>
        ///             <li>
        ///                <p>To register a new instance, you must specify a value that's unique among instances that you register by using
        ///      the same service. </p>
        ///             </li>
        ///             <li>
        ///                <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, AWS Cloud Map updates the existing
        ///      DNS records. If there's also an existing health check, AWS Cloud Map deletes the old health check and creates a new
        ///      one. </p>
        ///                <note>
        ///                   <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
        ///        <code>ListHealthChecks</code> request, for example.</p>
        ///                </note>
        ///             </li>
        ///          </ul>
        public let id: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.creatorRequestId = creatorRequestId
            self.id = id
        }
    }

}

extension InstanceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceNotFound(message: \(Swift.String(describing: message)))"}
}

extension InstanceNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InstanceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No instance exists with the specified ID, or the instance was recently registered, and information about the
///    instance hasn't propagated yet.</p>
public struct InstanceNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InstanceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.InstanceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.InstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceSummary(attributes: \(Swift.String(describing: attributes)), id: \(Swift.String(describing: id)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about the instances that you registered by using a specified
    ///    service.</p>
    public struct InstanceSummary: Swift.Equatable {
        /// <p>A string map that contains the following information:</p>
        ///          <ul>
        ///             <li>
        ///                <p>The attributes that are associated with the instance. </p>
        ///             </li>
        ///             <li>
        ///                <p>For each attribute, the applicable value.</p>
        ///             </li>
        ///          </ul>
        ///          <p>Supported attribute keys include the following:</p>
        ///          <dl>
        ///             <dt>AWS_ALIAS_DNS_NAME</dt>
        ///             <dd>
        ///                <p>For an alias record that routes traffic to an Elastic Load Balancing load balancer, the DNS name that's associated with the
        ///       load balancer. </p>
        ///             </dd>
        ///             <dt>AWS_EC2_INSTANCE_ID (HTTP namespaces only)</dt>
        ///             <dd>
        ///                <p>The Amazon EC2 instance ID for the instance. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified,
        ///       then the <code>AWS_INSTANCE_IPV4</code> attribute contains the primary private IPv4 address.</p>
        ///             </dd>
        ///             <dt>AWS_INIT_HEALTH_STATUS</dt>
        ///             <dd>
        ///                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
        ///        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
        ///        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
        ///        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_CNAME</dt>
        ///             <dd>
        ///                <p>For a <code>CNAME</code> record, the domain name that Route 53 returns in response to DNS queries (for example,
        ///        <code>example.com</code>).</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_IPV4</dt>
        ///             <dd>
        ///                <p>For an <code>A</code> record, the IPv4 address that Route 53 returns in response to DNS queries (for example,
        ///        <code>192.0.2.44</code>).</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_IPV6</dt>
        ///             <dd>
        ///                <p>For an <code>AAAA</code> record, the IPv6 address that Route 53 returns in response to DNS queries (for example,
        ///        <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
        ///             </dd>
        ///             <dt>AWS_INSTANCE_PORT</dt>
        ///             <dd>
        ///                <p>For an <code>SRV</code> record, the value that Route 53 returns for the port. In addition, if the service
        ///       includes <code>HealthCheckConfig</code>, the port on the endpoint that Route 53 sends requests to.</p>
        ///             </dd>
        ///          </dl>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>The ID for an instance that you created by using a specified service.</p>
        public let id: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.id = id
        }
    }

}

extension InvalidInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInput(message: \(Swift.String(describing: message)))"}
}

extension InvalidInput: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more specified values aren't valid. For example, a required value might be missing, a numeric value might
///    be outside the allowed range, or a string value might exceed length constraints.</p>
public struct InvalidInput: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstancesOutputError>
}

extension ListInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension ListInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct ListInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstancesOutputError>
}

public struct ListInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstancesOutputError>
}

public struct ListInstancesInput: Swift.Equatable {
    /// <p>The maximum number of instances that you want AWS Cloud Map to return in the response to a
    ///     <code>ListInstances</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up
    ///    to 100 instances.</p>
    public let maxResults: Swift.Int?
    /// <p>For the first <code>ListInstances</code> request, omit this value.</p>
    ///          <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
    ///    from the previous response in the next request.</p>
    public let nextToken: Swift.String?
    /// <p>The ID of the service that you want to list instances for.</p>
    public let serviceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstancesOutputResponse(instances: \(Swift.String(describing: instances)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Swift.Equatable {
    /// <p>Summary information about the instances that are associated with the specified service.</p>
    public let instances: [ServiceDiscoveryClientTypes.InstanceSummary]?
    /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
    ///    from the previous response in the next request.</p>
    public let nextToken: Swift.String?

    public init (
        instances: [ServiceDiscoveryClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Swift.Equatable {
    public let instances: [ServiceDiscoveryClientTypes.InstanceSummary]?
    public let nextToken: Swift.String?
}

extension ListInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.InstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[ServiceDiscoveryClientTypes.InstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [ServiceDiscoveryClientTypes.InstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNamespacesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNamespacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNamespacesOutputError>
}

extension ListNamespacesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNamespacesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNamespacesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for namespacefilters0 in filters {
                try filtersContainer.encode(namespacefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListNamespacesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNamespacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNamespacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInput: Swift.Equatable {
    /// <p>A complex type that contains specifications for the namespaces that you want to list.</p>
    ///          <p>If you specify more than one filter, a namespace must match all filters to be returned by
    ///     <code>ListNamespaces</code>.</p>
    public let filters: [ServiceDiscoveryClientTypes.NamespaceFilter]?
    /// <p>The maximum number of namespaces that you want AWS Cloud Map to return in the response to a
    ///     <code>ListNamespaces</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up
    ///    to 100 namespaces.</p>
    public let maxResults: Swift.Int?
    /// <p>For the first <code>ListNamespaces</code> request, omit this value.</p>
    ///          <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
    ///     possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
    ///          </note>
    public let nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.NamespaceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ServiceDiscoveryClientTypes.NamespaceFilter]?
}

extension ListNamespacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.NamespaceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.NamespaceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.NamespaceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListNamespacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamespacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamespacesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamespacesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNamespacesOutputResponse(namespaces: \(Swift.String(describing: namespaces)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNamespacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
        } else {
            self.namespaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamespacesOutputResponse: Swift.Equatable {
    /// <p>An array that contains one <code>NamespaceSummary</code> object for each namespace that matches the specified
    ///    filter criteria.</p>
    public let namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]?
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
    ///     possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
    ///          </note>
    public let nextToken: Swift.String?

    public init (
        namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

struct ListNamespacesOutputResponseBody: Swift.Equatable {
    public let namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]?
    public let nextToken: Swift.String?
}

extension ListNamespacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaces = "Namespaces"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespacesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.NamespaceSummary?].self, forKey: .namespaces)
        var namespacesDecoded0:[ServiceDiscoveryClientTypes.NamespaceSummary]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [ServiceDiscoveryClientTypes.NamespaceSummary]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOperationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

extension ListOperationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOperationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for operationfilters0 in filters {
                try filtersContainer.encode(operationfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOperationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInput: Swift.Equatable {
    /// <p>A complex type that contains specifications for the operations that you want to list, for example, operations
    ///    that you started between a specified start date and end date.</p>
    ///          <p>If you specify more than one filter, an operation must match all filters to be returned by
    ///     <code>ListOperations</code>.</p>
    public let filters: [ServiceDiscoveryClientTypes.OperationFilter]?
    /// <p>The maximum number of items that you want AWS Cloud Map to return in the response to a <code>ListOperations</code>
    ///    request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up to 100 operations.</p>
    public let maxResults: Swift.Int?
    /// <p>For the first <code>ListOperations</code> request, omit this value.</p>
    ///          <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
    ///     possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
    ///          </note>
    public let nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.OperationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ServiceDiscoveryClientTypes.OperationFilter]?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.OperationFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.OperationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.OperationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), operations: \(Swift.String(describing: operations)))"}
}

extension ListOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.operations = output.operations
        } else {
            self.nextToken = nil
            self.operations = nil
        }
    }
}

public struct ListOperationsOutputResponse: Swift.Equatable {
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
    ///     possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
    ///          </note>
    public let nextToken: Swift.String?
    /// <p>Summary information about the operations that match the specified criteria.</p>
    public let operations: [ServiceDiscoveryClientTypes.OperationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        operations: [ServiceDiscoveryClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operations = operations
    }
}

struct ListOperationsOutputResponseBody: Swift.Equatable {
    public let operations: [ServiceDiscoveryClientTypes.OperationSummary]?
    public let nextToken: Swift.String?
}

extension ListOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case operations = "Operations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.OperationSummary?].self, forKey: .operations)
        var operationsDecoded0:[ServiceDiscoveryClientTypes.OperationSummary]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [ServiceDiscoveryClientTypes.OperationSummary]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

extension ListServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for servicefilters0 in filters {
                try filtersContainer.encode(servicefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Swift.Equatable {
    /// <p>A complex type that contains specifications for the namespaces that you want to list services for. </p>
    ///          <p>If you specify more than one filter, an operation must match all filters to be returned by
    ///     <code>ListServices</code>.</p>
    public let filters: [ServiceDiscoveryClientTypes.ServiceFilter]?
    /// <p>The maximum number of services that you want AWS Cloud Map to return in the response to a <code>ListServices</code>
    ///    request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up to 100 services.</p>
    public let maxResults: Swift.Int?
    /// <p>For the first <code>ListServices</code> request, omit this value.</p>
    ///          <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
    ///     possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
    ///          </note>
    public let nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.ServiceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ServiceDiscoveryClientTypes.ServiceFilter]?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.ServiceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.ServiceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.ServiceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), services: \(Swift.String(describing: services)))"}
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
    ///     possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
    ///          </note>
    public let nextToken: Swift.String?
    /// <p>An array that contains one <code>ServiceSummary</code> object for each service that matches the specified filter
    ///    criteria.</p>
    public let services: [ServiceDiscoveryClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        services: [ServiceDiscoveryClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    public let services: [ServiceDiscoveryClientTypes.ServiceSummary]?
    public let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.ServiceSummary?].self, forKey: .services)
        var servicesDecoded0:[ServiceDiscoveryClientTypes.ServiceSummary]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceDiscoveryClientTypes.ServiceSummary]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    public let resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The tags that are assigned to the resource.</p>
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.Namespace: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.Namespace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Namespace(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), serviceCount: \(Swift.String(describing: serviceCount)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about a specified namespace.</p>
    public struct Namespace: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the namespace when you create it.</p>
        public let arn: Swift.String?
        /// <p>The date that the namespace was created, in Unix date/time format and Coordinated Universal Time (UTC). The
        ///    value of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code>
        ///    represents Friday, January 26, 2018 12:11:30.087 AM.</p>
        public let createDate: ClientRuntime.Date?
        /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of
        ///    running an operation twice. </p>
        public let creatorRequestId: Swift.String?
        /// <p>The description that you specify for the namespace when you create it.</p>
        public let description: Swift.String?
        /// <p>The ID of a namespace.</p>
        public let id: Swift.String?
        /// <p>The name of the namespace, such as <code>example.com</code>.</p>
        public let name: Swift.String?
        /// <p>A complex type that contains information that's specific to the type of the namespace.</p>
        public let properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// <p>The number of services that are associated with the namespace.</p>
        public let serviceCount: Swift.Int?
        /// <p>The type of the namespace. The methods for discovering instances depends on the value that you specify:</p>
        ///          <dl>
        ///             <dt>HTTP</dt>
        ///             <dd>
        ///                <p>Instances can be discovered only programmatically, using the AWS Cloud Map <code>DiscoverInstances</code>
        ///       API.</p>
        ///             </dd>
        ///             <dt>DNS_PUBLIC</dt>
        ///             <dd>
        ///                <p>Instances can be discovered using public DNS queries and using the <code>DiscoverInstances</code> API.</p>
        ///             </dd>
        ///             <dt>DNS_PRIVATE</dt>
        ///             <dd>
        ///                <p>Instances can be discovered using DNS queries in VPCs and using the <code>DiscoverInstances</code>
        ///       API.</p>
        ///             </dd>
        ///          </dl>
        public let type: ServiceDiscoveryClientTypes.NamespaceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

extension NamespaceAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceAlreadyExists(creatorRequestId: \(Swift.String(describing: creatorRequestId)), message: \(Swift.String(describing: message)), namespaceId: \(Swift.String(describing: namespaceId)))"}
}

extension NamespaceAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NamespaceAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.namespaceId = output.namespaceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.namespaceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The namespace that you're trying to create already exists.</p>
public struct NamespaceAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The <code>CreatorRequestId</code> that was used to create the namespace.</p>
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    /// <p>The ID of the existing namespace.</p>
    public var namespaceId: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        namespaceId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.namespaceId = namespaceId
    }
}

struct NamespaceAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
    public let creatorRequestId: Swift.String?
    public let namespaceId: Swift.String?
}

extension NamespaceAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case namespaceId = "NamespaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceFilter(condition: \(Swift.String(describing: condition)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that identifies the namespaces that you want to list. You can choose to list public or private
    ///    namespaces.</p>
    public struct NamespaceFilter: Swift.Equatable {
        /// <p>The operator that you want to use to determine whether <code>ListNamespaces</code> returns a namespace. Valid
        ///    values for <code>condition</code> include:</p>
        ///          <dl>
        ///             <dt>EQ</dt>
        ///             <dd>
        ///                <p>When you specify <code>EQ</code> for the condition, you can choose to list only public namespaces or private
        ///       namespaces, but not both. <code>EQ</code> is the default condition and can be omitted.</p>
        ///             </dd>
        ///             <dt>IN</dt>
        ///             <dd>
        ///                <p>When you specify <code>IN</code> for the condition, you can choose to list public namespaces, private
        ///       namespaces, or both. </p>
        ///             </dd>
        ///             <dt>BETWEEN</dt>
        ///             <dd>
        ///                <p> Not applicable</p>
        ///             </dd>
        ///          </dl>
        public let condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// <p>Specify <code>TYPE</code>.</p>
        public let name: ServiceDiscoveryClientTypes.NamespaceFilterName?
        /// <p>If you specify <code>EQ</code> for <code>Condition</code>, specify either <code>DNS_PUBLIC</code> or
        ///     <code>DNS_PRIVATE</code>.</p>
        ///          <p>If you specify <code>IN</code> for <code>Condition</code>, you can specify <code>DNS_PUBLIC</code>,
        ///     <code>DNS_PRIVATE</code>, or both.</p>
        public let values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.NamespaceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum NamespaceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceFilterName] {
            return [
                .type,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .type: return "TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceFilterName(rawValue: rawValue) ?? NamespaceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension NamespaceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceNotFound(message: \(Swift.String(describing: message)))"}
}

extension NamespaceNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NamespaceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No namespace exists with the specified ID.</p>
public struct NamespaceNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NamespaceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NamespaceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
        case httpProperties = "HttpProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
        if let httpProperties = httpProperties {
            try encodeContainer.encode(httpProperties, forKey: .httpProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsProperties.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
        let httpPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HttpProperties.self, forKey: .httpProperties)
        httpProperties = httpPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceProperties(dnsProperties: \(Swift.String(describing: dnsProperties)), httpProperties: \(Swift.String(describing: httpProperties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information that's specific to the namespace type.</p>
    public struct NamespaceProperties: Swift.Equatable {
        /// <p>A complex type that contains the ID for the Route 53 hosted zone that AWS Cloud Map creates when you create a
        ///    namespace.</p>
        public let dnsProperties: ServiceDiscoveryClientTypes.DnsProperties?
        /// <p>A complex type that contains the name of an HTTP namespace.</p>
        public let httpProperties: ServiceDiscoveryClientTypes.HttpProperties?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.DnsProperties? = nil,
            httpProperties: ServiceDiscoveryClientTypes.HttpProperties? = nil
        )
        {
            self.dnsProperties = dnsProperties
            self.httpProperties = httpProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.NamespaceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceSummary(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), serviceCount: \(Swift.String(describing: serviceCount)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about a namespace.</p>
    public struct NamespaceSummary: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the namespace when you create it.</p>
        public let arn: Swift.String?
        /// <p>The date and time that the namespace was created.</p>
        public let createDate: ClientRuntime.Date?
        /// <p>A description for the namespace.</p>
        public let description: Swift.String?
        /// <p>The ID of the namespace.</p>
        public let id: Swift.String?
        /// <p>The name of the namespace. When you create a namespace, AWS Cloud Map automatically creates a Route 53 hosted zone
        ///    that has the same name as the namespace.</p>
        public let name: Swift.String?
        /// <p>The properties of the namespace.</p>
        public let properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// <p>The number of services that were created using the namespace.</p>
        public let serviceCount: Swift.Int?
        /// <p>The type of the namespace, either public or private.</p>
        public let type: ServiceDiscoveryClientTypes.NamespaceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum NamespaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dnsPrivate
        case dnsPublic
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceType] {
            return [
                .dnsPrivate,
                .dnsPublic,
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dnsPrivate: return "DNS_PRIVATE"
            case .dnsPublic: return "DNS_PUBLIC"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceType(rawValue: rawValue) ?? NamespaceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.Operation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case status = "Status"
        case targets = "Targets"
        case type = "Type"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, operationtargetsmap0) in targets {
                try targetsContainer.encode(operationtargetsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateDate = updateDate {
            try encodeContainer.encode(updateDate.timeIntervalSince1970, forKey: .updateDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourceid0) in targetsContainer {
                if let resourceid0 = resourceid0 {
                    targetsDecoded0?[key0] = resourceid0
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.Operation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Operation(createDate: \(Swift.String(describing: createDate)), errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), targets: \(Swift.String(describing: targets)), type: \(Swift.String(describing: type)), updateDate: \(Swift.String(describing: updateDate)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about a specified operation.</p>
    public struct Operation: Swift.Equatable {
        /// <p>The date and time that the request was submitted, in Unix date/time format and Coordinated Universal Time (UTC).
        ///    The value of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code>
        ///    represents Friday, January 26, 2018 12:11:30.087 AM.</p>
        public let createDate: ClientRuntime.Date?
        /// <p>The code associated with <code>ErrorMessage</code>. Values for <code>ErrorCode</code> include the
        ///    following:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>ACCESS_DENIED</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>CANNOT_CREATE_HOSTED_ZONE</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>EXPIRED_TOKEN</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>HOSTED_ZONE_NOT_FOUND</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>INTERNAL_FAILURE</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>INVALID_CHANGE_BATCH</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>THROTTLED_REQUEST</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let errorCode: Swift.String?
        /// <p>If the value of <code>Status</code> is <code>FAIL</code>, the reason that the operation failed.</p>
        public let errorMessage: Swift.String?
        /// <p>The ID of the operation that you want to get information about.</p>
        public let id: Swift.String?
        /// <p>The status of the operation. Values include the following:</p>
        ///          <dl>
        ///             <dt>SUBMITTED</dt>
        ///             <dd>
        ///                <p>This is the initial state that occurs immediately after you submit a request.</p>
        ///             </dd>
        ///             <dt>PENDING</dt>
        ///             <dd>
        ///                <p>AWS Cloud Map is performing the operation.</p>
        ///             </dd>
        ///             <dt>SUCCESS</dt>
        ///             <dd>
        ///                <p>The operation succeeded.</p>
        ///             </dd>
        ///             <dt>FAIL</dt>
        ///             <dd>
        ///                <p>The operation failed. For the failure reason, see <code>ErrorMessage</code>.</p>
        ///             </dd>
        ///          </dl>
        public let status: ServiceDiscoveryClientTypes.OperationStatus?
        /// <p>The name of the target entity that's associated with the operation:</p>
        ///          <dl>
        ///             <dt>NAMESPACE</dt>
        ///             <dd>
        ///                <p>The namespace ID is returned in the <code>ResourceId</code> property.</p>
        ///             </dd>
        ///             <dt>SERVICE</dt>
        ///             <dd>
        ///                <p>The service ID is returned in the <code>ResourceId</code> property.</p>
        ///             </dd>
        ///             <dt>INSTANCE</dt>
        ///             <dd>
        ///                <p>The instance ID is returned in the <code>ResourceId</code> property.</p>
        ///             </dd>
        ///          </dl>
        public let targets: [Swift.String:Swift.String]?
        /// <p>The name of the operation that's associated with the specified ID.</p>
        public let type: ServiceDiscoveryClientTypes.OperationType?
        /// <p>The date and time that the value of <code>Status</code> changed to the current value, in Unix date/time format
        ///    and Coordinated Universal Time (UTC). The value of <code>UpdateDate</code> is accurate to milliseconds. For example,
        ///    the value <code>1516925490.087</code> represents Friday, January 26, 2018 12:11:30.087 AM.</p>
        public let updateDate: ClientRuntime.Date?

        public init (
            createDate: ClientRuntime.Date? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil,
            targets: [Swift.String:Swift.String]? = nil,
            type: ServiceDiscoveryClientTypes.OperationType? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.createDate = createDate
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.status = status
            self.targets = targets
            self.type = type
            self.updateDate = updateDate
        }
    }

}

extension ServiceDiscoveryClientTypes.OperationFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes.OperationFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationFilter(condition: \(Swift.String(describing: condition)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that lets you select the operations that you want to list.</p>
    public struct OperationFilter: Swift.Equatable {
        /// <p>The operator that you want to use to determine whether an operation matches the specified value. Valid values
        ///    for condition include:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>EQ</code>: When you specify <code>EQ</code> for the condition, you can specify only one value.
        ///       <code>EQ</code> is supported for <code>NAMESPACE_ID</code>, <code>SERVICE_ID</code>, <code>STATUS</code>, and
        ///       <code>TYPE</code>. <code>EQ</code> is the default condition and can be omitted.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>IN</code>: When you specify <code>IN</code> for the condition, you can specify a list of one or more
        ///      values. <code>IN</code> is supported for <code>STATUS</code> and <code>TYPE</code>. An operation must match one of
        ///      the specified values to be returned in the response.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>BETWEEN</code>: Specify a start date and an end date in Unix date/time format and Coordinated Universal
        ///      Time (UTC). The start date must be the first value. <code>BETWEEN</code> is supported for <code>UPDATE_DATE</code>.
        ///     </p>
        ///             </li>
        ///          </ul>
        public let condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// <p>Specify the operations that you want to get:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>NAMESPACE_ID</b>: Gets operations related to specified namespaces.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>SERVICE_ID</b>: Gets operations related to specified services.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>STATUS</b>: Gets operations based on the status of the operations:
        ///       <code>SUBMITTED</code>, <code>PENDING</code>, <code>SUCCEED</code>, or <code>FAIL</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>TYPE</b>: Gets specified types of operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>UPDATE_DATE</b>: Gets operations that changed status during a specified date/time
        ///      range. </p>
        ///             </li>
        ///          </ul>
        public let name: ServiceDiscoveryClientTypes.OperationFilterName?
        /// <p>Specify values that are applicable to the value that you specify for <code>Name</code>: </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>NAMESPACE_ID</b>: Specify one namespace ID.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>SERVICE_ID</b>: Specify one service ID.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>STATUS</b>: Specify one or more statuses: <code>SUBMITTED</code>,
        ///       <code>PENDING</code>, <code>SUCCEED</code>, or <code>FAIL</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>TYPE</b>: Specify one or more of the following types:
        ///       <code>CREATE_NAMESPACE</code>, <code>DELETE_NAMESPACE</code>, <code>UPDATE_SERVICE</code>,
        ///       <code>REGISTER_INSTANCE</code>, or <code>DEREGISTER_INSTANCE</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>UPDATE_DATE</b>: Specify a start date and an end date in Unix date/time format
        ///      and Coordinated Universal Time (UTC). The start date must be the first value.</p>
        ///             </li>
        ///          </ul>
        public let values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.OperationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum OperationFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case namespaceId
        case serviceId
        case status
        case type
        case updateDate
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationFilterName] {
            return [
                .namespaceId,
                .serviceId,
                .status,
                .type,
                .updateDate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case .serviceId: return "SERVICE_ID"
            case .status: return "STATUS"
            case .type: return "TYPE"
            case .updateDate: return "UPDATE_DATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationFilterName(rawValue: rawValue) ?? OperationFilterName.sdkUnknown(rawValue)
        }
    }
}

extension OperationNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationNotFound(message: \(Swift.String(describing: message)))"}
}

extension OperationNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No operation exists with the specified ID.</p>
public struct OperationNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case pending
        case submitted
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .fail,
                .pending,
                .submitted,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .pending: return "PENDING"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.OperationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceDiscoveryClientTypes.OperationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationSummary(id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about an operation that matches the criteria that you specified in a
    ///     <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations</a>
    ///    request.</p>
    public struct OperationSummary: Swift.Equatable {
        /// <p>The ID for an operation.</p>
        public let id: Swift.String?
        /// <p>The status of the operation. Values include the following:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>SUBMITTED</b>: This is the initial state immediately after you submit a
        ///      request.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>PENDING</b>: AWS Cloud Map is performing the operation.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>SUCCESS</b>: The operation succeeded.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>FAIL</b>: The operation failed. For the failure reason, see
        ///       <code>ErrorMessage</code>.</p>
        ///             </li>
        ///          </ul>
        public let status: ServiceDiscoveryClientTypes.OperationStatus?

        public init (
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil
        )
        {
            self.id = id
            self.status = status
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum OperationTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case namespace
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationTargetType] {
            return [
                .instance,
                .namespace,
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .namespace: return "NAMESPACE"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationTargetType(rawValue: rawValue) ?? OperationTargetType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createNamespace
        case deleteNamespace
        case deregisterInstance
        case registerInstance
        case updateService
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createNamespace,
                .deleteNamespace,
                .deregisterInstance,
                .registerInstance,
                .updateService,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createNamespace: return "CREATE_NAMESPACE"
            case .deleteNamespace: return "DELETE_NAMESPACE"
            case .deregisterInstance: return "DEREGISTER_INSTANCE"
            case .registerInstance: return "REGISTER_INSTANCE"
            case .updateService: return "UPDATE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum RecordType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case a
        case aaaa
        case cname
        case srv
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordType] {
            return [
                .a,
                .aaaa,
                .cname,
                .srv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .a: return "A"
            case .aaaa: return "AAAA"
            case .cname: return "CNAME"
            case .srv: return "SRV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordType(rawValue: rawValue) ?? RecordType.sdkUnknown(rawValue)
        }
    }
}

public struct RegisterInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

extension RegisterInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterInstanceInput(attributes: \(Swift.String(describing: attributes)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension RegisterInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct RegisterInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInput: Swift.Equatable {
    /// <p>A string map that contains the following information for the service that you specify in
    ///    <code>ServiceId</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The attributes that apply to the records that are defined in the service. </p>
    ///             </li>
    ///             <li>
    ///                <p>For each attribute, the applicable value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported attribute keys include the following:</p>
    ///          <dl>
    ///             <dt>AWS_ALIAS_DNS_NAME</dt>
    ///             <dd>
    ///                <p>If you want AWS Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer,
    ///       specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see
    ///       "DNSName" in the topic <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html">AliasTarget</a> in the <i>Route 53 API Reference</i>.</p>
    ///                <p>Note the following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
    ///          <code>A</code> record, an <code>AAAA</code> record, or both.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
    ///          <code>WEIGHTED</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
    ///         AWS Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias
    ///         record.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Auto naming currently doesn't support creating alias records that route traffic to AWS resources other than
    ///         Elastic Load Balancing load balancers.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
    ///          <code>AWS_INSTANCE</code> attributes.</p>
    ///                   </li>
    ///                </ul>
    ///             </dd>
    ///             <dt>AWS_EC2_INSTANCE_ID</dt>
    ///             <dd>
    ///                <p>
    ///                   <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. If the
    ///        <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the only other attribute that can be specified is
    ///        <code>AWS_INIT_HEALTH_STATUS</code>. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the
    ///        <code>AWS_INSTANCE_IPV4</code> attribute will be filled out with the primary private IPv4 address.</p>
    ///             </dd>
    ///             <dt>AWS_INIT_HEALTH_STATUS</dt>
    ///             <dd>
    ///                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
    ///        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
    ///        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
    ///        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_CNAME</dt>
    ///             <dd>
    ///                <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>example.com</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>CNAME</code> record.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV4</dt>
    ///             <dd>
    ///                <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
    ///       for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV6</dt>
    ///             <dd>
    ///                <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
    ///       value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_PORT</dt>
    ///             <dd>
    ///                <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
    ///       port.</p>
    ///                <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
    ///       requests to. </p>
    ///                <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
    ///       you created the service.</p>
    ///             </dd>
    ///             <dt>Custom attributes</dt>
    ///             <dd>
    ///                <p>You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is
    ///       255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided
    ///       attributes (sum of all keys and values) must not exceed 5,000 characters.</p>
    ///             </dd>
    ///          </dl>
    public let attributes: [Swift.String:Swift.String]?
    /// <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
    ///    retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
    ///    every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
    ///    namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
    ///    stamp).</p>
    public var creatorRequestId: Swift.String?
    /// <p>An identifier that you want to associate with the instance. Note the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
    ///      the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
    ///      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can use this value to update an existing instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>To register a new instance, you must specify a value that's unique among instances that you register by using
    ///      the same service. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, AWS Cloud Map updates the existing
    ///      DNS records, if any. If there's also an existing health check, AWS Cloud Map deletes the old health check and creates
    ///      a new one. </p>
    ///                <note>
    ///                   <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
    ///        <code>ListHealthChecks</code> request, for example.</p>
    ///                </note>
    ///             </li>
    ///          </ul>
    public let instanceId: Swift.String?
    /// <p>The ID of the service that you want to use for settings for the instance.</p>
    public let serviceId: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.creatorRequestId = creatorRequestId
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct RegisterInstanceInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
    public let creatorRequestId: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
}

extension RegisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension RegisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterInstanceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension RegisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct RegisterInstanceOutputResponse: Swift.Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RegisterInstanceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension RegisterInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension RequestLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension RequestLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation can't be completed because you've reached the quota for the number of requests. For more
///    information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/throttling.html">AWS Cloud Map API request throttling
///     quota</a> in the <i>AWS Cloud Map Developer Guide</i>.</p>
public struct RequestLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUse(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource can't be deleted because it contains other resources. For example, you can't delete a
///    service that contains any instances.</p>
public struct ResourceInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension ResourceLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource can't be created because you've reached the quota on the number of resources.</p>
public struct ResourceLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation can't be completed because the resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum RoutingPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multivalue
        case weighted
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingPolicy] {
            return [
                .multivalue,
                .weighted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multivalue: return "MULTIVALUE"
            case .weighted: return "WEIGHTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoutingPolicy(rawValue: rawValue) ?? RoutingPolicy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceType.self, forKey: .type)
        type = typeDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)), healthCheckCustomConfig: \(Swift.String(describing: healthCheckCustomConfig)), id: \(Swift.String(describing: id)), instanceCount: \(Swift.String(describing: instanceCount)), name: \(Swift.String(describing: name)), namespaceId: \(Swift.String(describing: namespaceId)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about the specified service.</p>
    public struct Service: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the service when you create it.</p>
        public let arn: Swift.String?
        /// <p>The date and time that the service was created, in Unix format and Coordinated Universal Time (UTC). The value
        ///    of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code> represents
        ///    Friday, January 26, 2018 12:11:30.087 AM.</p>
        public let createDate: ClientRuntime.Date?
        /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of
        ///    running the operation twice. <code>CreatorRequestId</code> can be any unique string (for example, a
        ///    date/timestamp).</p>
        public let creatorRequestId: Swift.String?
        /// <p>The description of the service.</p>
        public let description: Swift.String?
        /// <p>A complex type that contains information about the Route 53 DNS records that you want AWS Cloud Map to create when you
        ///    register an instance.</p>
        public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        /// <p>
        ///             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
        ///    health check. If you specify settings for a health check, AWS Cloud Map associates the health check with the records
        ///    that you specify in <code>DnsConfig</code>.</p>
        ///          <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
        public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// <p>A complex type that contains information about an optional custom health check.</p>
        ///          <important>
        ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        ///      <code>HealthCheckConfig</code> but not both.</p>
        ///          </important>
        public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// <p>The ID that AWS Cloud Map assigned to the service when you created it.</p>
        public let id: Swift.String?
        /// <p>The number of instances that are currently associated with the service. Instances that were previously
        ///    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
        ///    registrations and deregistrations.</p>
        public let instanceCount: Swift.Int?
        /// <p>The name of the service.</p>
        public let name: Swift.String?
        /// <p>The ID of the namespace that was used to create the service.</p>
        public let namespaceId: Swift.String?
        /// <p>Describes the systems that can be used to discover the service instances.</p>
        ///          <dl>
        ///             <dt>DNS_HTTP</dt>
        ///             <dd>
        ///                <p>The service instances can be discovered using either DNS queries or the <code>DiscoverInstances</code> API
        ///       operation.</p>
        ///             </dd>
        ///             <dt>HTTP</dt>
        ///             <dd>
        ///                <p>The service instances can only be discovered using the <code>DiscoverInstances</code> API operation.</p>
        ///             </dd>
        ///             <dt>DNS</dt>
        ///             <dd>
        ///                <p>Reserved.</p>
        ///             </dd>
        ///          </dl>
        public let type: ServiceDiscoveryClientTypes.ServiceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            namespaceId: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.namespaceId = namespaceId
            self.type = type
        }
    }

}

extension ServiceAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceAlreadyExists(creatorRequestId: \(Swift.String(describing: creatorRequestId)), message: \(Swift.String(describing: message)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension ServiceAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.serviceId = output.serviceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.serviceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service can't be created because a service with the same name already exists.</p>
public struct ServiceAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The <code>CreatorRequestId</code> that was used to create the service.</p>
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    /// <p>The ID of the existing service.</p>
    public var serviceId: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.serviceId = serviceId
    }
}

struct ServiceAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
    public let creatorRequestId: Swift.String?
    public let serviceId: Swift.String?
}

extension ServiceAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfigChange.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceChange(description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains changes to an existing service.</p>
    public struct ServiceChange: Swift.Equatable {
        /// <p>A description for the service.</p>
        public let description: Swift.String?
        /// <p>Information about the Route 53 DNS records that you want AWS Cloud Map to create when you register an instance.</p>
        public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange?
        /// <p>
        ///             <i>Public DNS and HTTP namespaces only.</i> Settings for an optional health check. If you specify
        ///    settings for a health check, AWS Cloud Map associates the health check with the records that you specify in
        ///     <code>DnsConfig</code>.</p>
        public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?

        public init (
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil
        )
        {
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
        }
    }

}

extension ServiceDiscoveryClientTypes.ServiceFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceFilter(condition: \(Swift.String(describing: condition)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that lets you specify the namespaces that you want to list services for.</p>
    public struct ServiceFilter: Swift.Equatable {
        /// <p>The operator that you want to use to determine whether a service is returned by <code>ListServices</code>. Valid
        ///    values for <code>Condition</code> include the following:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>EQ</code>: When you specify <code>EQ</code>, specify one namespace ID for <code>Values</code>.
        ///       <code>EQ</code> is the default condition and can be omitted.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>IN</code>: When you specify <code>IN</code>, specify a list of the IDs for the namespaces that you want
        ///       <code>ListServices</code> to return a list of services for.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>BETWEEN</code>: Not applicable.</p>
        ///             </li>
        ///          </ul>
        public let condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// <p>Specify <code>NAMESPACE_ID</code>.</p>
        public let name: ServiceDiscoveryClientTypes.ServiceFilterName?
        /// <p>The values that are applicable to the value that you specify for <code>Condition</code> to filter the list of
        ///    services.</p>
        public let values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.ServiceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum ServiceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case namespaceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceFilterName] {
            return [
                .namespaceId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceFilterName(rawValue: rawValue) ?? ServiceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNotFound(message: \(Swift.String(describing: message)))"}
}

extension ServiceNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No service exists with the specified ID.</p>
public struct ServiceNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSummary(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)), healthCheckCustomConfig: \(Swift.String(describing: healthCheckCustomConfig)), id: \(Swift.String(describing: id)), instanceCount: \(Swift.String(describing: instanceCount)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A complex type that contains information about a specified service.</p>
    public struct ServiceSummary: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the service when you create it.</p>
        public let arn: Swift.String?
        /// <p>The date and time that the service was created.</p>
        public let createDate: ClientRuntime.Date?
        /// <p>The description that you specify when you create the service.</p>
        public let description: Swift.String?
        /// <p>Information about the Route 53 DNS records that you want AWS Cloud Map to create when you register an instance.</p>
        public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        /// <p>
        ///             <i>Public DNS and HTTP namespaces only.</i> Settings for an optional health check. If you specify
        ///    settings for a health check, AWS Cloud Map associates the health check with the records that you specify in
        ///     <code>DnsConfig</code>.</p>
        public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// <p>Information about an optional custom health check. A custom health check, which requires that you use a
        ///    third-party health checker to evaluate the health of your resources, is useful in the following circumstances:</p>
        ///          <ul>
        ///             <li>
        ///                <p>You can't use a health check that's defined by <code>HealthCheckConfig</code> because the resource isn't
        ///      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
        ///      (To check the health of resources in a VPC, the health checker must also be in the VPC.)</p>
        ///             </li>
        ///             <li>
        ///                <p>You want to use a third-party health checker regardless of where your resources are located.</p>
        ///             </li>
        ///          </ul>
        ///          <important>
        ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        ///      <code>HealthCheckConfig</code> but not both.</p>
        ///          </important>
        public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// <p>The ID that AWS Cloud Map assigned to the service when you created it.</p>
        public let id: Swift.String?
        /// <p>The number of instances that are currently associated with the service. Instances that were previously
        ///    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
        ///    registrations and deregistrations.</p>
        public let instanceCount: Swift.Int?
        /// <p>The name of the service.</p>
        public let name: Swift.String?
        /// <p>Describes the systems that can be used to discover the service instances.</p>
        ///          <dl>
        ///             <dt>DNS_HTTP</dt>
        ///             <dd>
        ///                <p>The service instances can be discovered using either DNS queries or the <code>DiscoverInstances</code> API
        ///       operation.</p>
        ///             </dd>
        ///             <dt>HTTP</dt>
        ///             <dd>
        ///                <p>The service instances can only be discovered using the <code>DiscoverInstances</code> API operation.</p>
        ///             </dd>
        ///             <dt>DNS</dt>
        ///             <dd>
        ///                <p>Reserved.</p>
        ///             </dd>
        ///          </dl>
        public let type: ServiceDiscoveryClientTypes.ServiceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dns
        case dnsHttp
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .dns,
                .dnsHttp,
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dns: return "DNS"
            case .dnsHttp: return "DNS_HTTP"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum ServiceTypeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceTypeOption] {
            return [
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceTypeOption(rawValue: rawValue) ?? ServiceTypeOption.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceDiscoveryClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceDiscoveryClientTypes {
    /// <p>A custom key-value pair that's associated with a resource.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key identifier, or name, of the tag.</p>
        public let key: Swift.String?
        /// <p>The string value that's associated with the key of the tag. You can set the value of a tag to an empty string,
        ///    but you can't set the value of a tag to null.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    public let resourceARN: Swift.String?
    /// <p>The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to
    ///    an empty string, but you can't set the value of a tag to null.</p>
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TooManyTagsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The list of tags on the resource is over the quota. The maximum number of tags that can be applied to a resource
///    is 50.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The name of the resource.</p>
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    public let resourceARN: Swift.String?
    /// <p>The tag keys to remove from the specified resource.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateInstanceCustomHealthStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceCustomHealthStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

extension UpdateInstanceCustomHealthStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceCustomHealthStatusInput(instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)), status: \(Swift.String(describing: status)))"}
}

extension UpdateInstanceCustomHealthStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateInstanceCustomHealthStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceCustomHealthStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

public struct UpdateInstanceCustomHealthStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceCustomHealthStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

public struct UpdateInstanceCustomHealthStatusInput: Swift.Equatable {
    /// <p>The ID of the instance that you want to change the health status for.</p>
    public let instanceId: Swift.String?
    /// <p>The ID of the service that includes the configuration for the custom health check that you want to change the
    ///    status for.</p>
    public let serviceId: Swift.String?
    /// <p>The new status of the instance, <code>HEALTHY</code> or <code>UNHEALTHY</code>.</p>
    public let status: ServiceDiscoveryClientTypes.CustomHealthStatus?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        status: ServiceDiscoveryClientTypes.CustomHealthStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
        self.status = status
    }
}

struct UpdateInstanceCustomHealthStatusInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
    public let status: ServiceDiscoveryClientTypes.CustomHealthStatus?
}

extension UpdateInstanceCustomHealthStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.CustomHealthStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateInstanceCustomHealthStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceCustomHealthStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomHealthNotFound" : self = .customHealthNotFound(try CustomHealthNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceCustomHealthStatusOutputError: Swift.Error, Swift.Equatable {
    case customHealthNotFound(CustomHealthNotFound)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceCustomHealthStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceCustomHealthStatusOutputResponse()"}
}

extension UpdateInstanceCustomHealthStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceCustomHealthStatusOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateInstanceCustomHealthStatusOutputResponseBody: Swift.Equatable {
}

extension UpdateInstanceCustomHealthStatusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

extension UpdateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInput(id: \(Swift.String(describing: id)), service: \(Swift.String(describing: service)))"}
}

extension UpdateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }
}

public struct UpdateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInput: Swift.Equatable {
    /// <p>The ID of the service that you want to update.</p>
    public let id: Swift.String?
    /// <p>A complex type that contains the new settings for the service.</p>
    public let service: ServiceDiscoveryClientTypes.ServiceChange?

    public init (
        id: Swift.String? = nil,
        service: ServiceDiscoveryClientTypes.ServiceChange? = nil
    )
    {
        self.id = id
        self.service = service
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let service: ServiceDiscoveryClientTypes.ServiceChange?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceChange.self, forKey: .service)
        service = serviceDecoded
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}
