// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct CreateHttpNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHttpNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHttpNamespaceOutputError>
}

extension CreateHttpNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHttpNamespaceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateHttpNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateHttpNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHttpNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHttpNamespaceOutputError>
}

public struct CreateHttpNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHttpNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHttpNamespaceOutputError>
}

public struct CreateHttpNamespaceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreateHttpNamespace requests to
    ///    be retried without the risk of running the operation twice. CreatorRequestId can be any unique string
    ///    (for example, a date/time stamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public let description: Swift.String?
    /// The name that you want to assign to this namespace.
    /// This member is required.
    public let name: Swift.String?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256
    ///                                characters in length.
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateHttpNamespaceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension CreateHttpNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateHttpNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHttpNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHttpNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHttpNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHttpNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension CreateHttpNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHttpNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreateHttpNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreateHttpNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension CreateHttpNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreatePrivateDnsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePrivateDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePrivateDnsNamespaceOutputError>
}

extension CreatePrivateDnsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePrivateDnsNamespaceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), tags: \(Swift.String(describing: tags)), vpc: \(Swift.String(describing: vpc)))"}
}

extension CreatePrivateDnsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpc = vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }
}

public struct CreatePrivateDnsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePrivateDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePrivateDnsNamespaceOutputError>
}

public struct CreatePrivateDnsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePrivateDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePrivateDnsNamespaceOutputError>
}

public struct CreatePrivateDnsNamespaceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreatePrivateDnsNamespace
    ///    requests to be retried without the risk of running the operation twice. CreatorRequestId can be any
    ///    unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public let description: Swift.String?
    /// The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map
    ///    automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.
    /// This member is required.
    public let name: Swift.String?
    /// Properties for the private DNS
    ///    namespace.
    public let properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256
    ///                                characters in length.
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    /// The ID of the Amazon VPC that you want to associate the namespace with.
    /// This member is required.
    public let vpc: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        vpc: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.properties = properties
        self.tags = tags
        self.vpc = vpc
    }
}

struct CreatePrivateDnsNamespaceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let vpc: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    public let properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties?
}

extension CreatePrivateDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreatePrivateDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePrivateDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePrivateDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePrivateDnsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePrivateDnsNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension CreatePrivateDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePrivateDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePrivateDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePrivateDnsNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension CreatePrivateDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreatePublicDnsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicDnsNamespaceOutputError>
}

extension CreatePublicDnsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicDnsNamespaceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePublicDnsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePublicDnsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicDnsNamespaceOutputError>
}

public struct CreatePublicDnsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicDnsNamespaceOutputError>
}

public struct CreatePublicDnsNamespaceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreatePublicDnsNamespace
    ///    requests to be retried without the risk of running the operation twice. CreatorRequestId can be any
    ///    unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public let description: Swift.String?
    /// The name that you want to assign to this namespace.
    /// This member is required.
    public let name: Swift.String?
    /// Properties for the public DNS
    ///    namespace.
    public let properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256
    ///                                characters in length.
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.properties = properties
        self.tags = tags
    }
}

struct CreatePublicDnsNamespaceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    public let properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties?
}

extension CreatePublicDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case properties = "Properties"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreatePublicDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublicDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicDnsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicDnsNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension CreatePublicDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePublicDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePublicDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePublicDnsNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension CreatePublicDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInput(creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)), healthCheckCustomConfig: \(Swift.String(describing: healthCheckCustomConfig)), name: \(Swift.String(describing: name)), namespaceId: \(Swift.String(describing: namespaceId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed CreateService requests to be
    ///    retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for
    ///    example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the service.
    public let description: Swift.String?
    /// A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you
    ///    register an instance.
    public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
    ///
    ///             Public DNS and HTTP namespaces only. A complex type that contains settings for an optional
    ///    Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the
    ///    Route 53 DNS records that you specify in DnsConfig.
    ///
    ///             If you specify a health check configuration, you can specify either HealthCheckCustomConfig or
    ///      HealthCheckConfig but not both.
    ///
    ///          For information about the charges for health checks, see <a href="http://aws.amazon.com/cloud-map/pricing/">Cloud Map Pricing.
    public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
    /// A complex type that contains information about an optional custom health check.
    ///
    ///             If you specify a health check configuration, you can specify either HealthCheckCustomConfig or
    ///      HealthCheckConfig but not both.
    ///
    ///          You can't add, update, or delete a HealthCheckCustomConfig configuration from an existing
    ///    service.
    public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
    /// The name that you want to assign to the service.
    ///          If you want Cloud Map to create an SRV record when you register an instance and you're using a
    ///    system that requires a specific SRV format, such as <a href="http://www.haproxy.org/">HAProxy, specify the following for Name:
    ///
    ///
    ///                Start the name with an underscore (_), such as _exampleservice.
    ///
    ///
    ///                End the name with ._protocol, such as ._tcp.
    ///
    ///
    ///          When you register an instance, Cloud Map creates an SRV record and assigns a name to the record by
    ///    concatenating the service name and the namespace name (for example,
    ///
    ///             _exampleservice._tcp.example.com).
    ///
    ///             For services that are accessible by DNS queries, you can't create multiple services with names that differ only
    ///     by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished.
    ///     However, if you use a namespace that's only accessible by API calls, then you can create services that with names
    ///     that differ only by case.
    ///
    /// This member is required.
    public let name: Swift.String?
    /// The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it
    ///    can be specified either here or in the DnsConfig object.
    public let namespaceId: Swift.String?
    /// The tags to add to the service. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256
    ///                                characters in length.
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    /// If present, specifies that the service instances are only discoverable using the DiscoverInstances
    ///    API operation. No DNS records is registered for the service instances. The only valid value is
    ///    HTTP.
    public let type: ServiceDiscoveryClientTypes.ServiceTypeOption?

    public init (
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
        healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
        healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
        name: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        type: ServiceDiscoveryClientTypes.ServiceTypeOption? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
        self.healthCheckCustomConfig = healthCheckCustomConfig
        self.name = name
        self.namespaceId = namespaceId
        self.tags = tags
        self.type = type
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let namespaceId: Swift.String?
    public let creatorRequestId: Swift.String?
    public let description: Swift.String?
    public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
    public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
    public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
    public let type: ServiceDiscoveryClientTypes.ServiceTypeOption?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceTypeOption.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAlreadyExists" : self = .serviceAlreadyExists(try ServiceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceAlreadyExists(ServiceAlreadyExists)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the new service.
    public let service: ServiceDiscoveryClientTypes.Service?

    public init (
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    public let service: ServiceDiscoveryClientTypes.Service?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension CustomHealthNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomHealthNotFound(message: \(Swift.String(describing: message)))"}
}

extension CustomHealthNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CustomHealthNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The health check for the instance that's specified by ServiceId and InstanceId isn't a
///    custom health check.
public struct CustomHealthNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomHealthNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CustomHealthNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum CustomHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomHealthStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomHealthStatus(rawValue: rawValue) ?? CustomHealthStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNamespaceOutputError>
}

extension DeleteNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNamespaceInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to delete.
    /// This member is required.
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DeleteNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension DeleteNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeleteNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeleteNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension DeleteNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DeleteServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

extension DeleteServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The ID of the service that you want to delete.
    /// This member is required.
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceOutputResponse()"}
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

extension DeregisterInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterInstanceInput(instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension DeregisterInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct DeregisterInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInput: Swift.Equatable {
    /// The value that you specified for Id in the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance request.
    /// This member is required.
    public let instanceId: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public let serviceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct DeregisterInstanceInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
}

extension DeregisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterInstanceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension DeregisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeregisterInstanceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeregisterInstanceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension DeregisterInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DiscoverInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DiscoverInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DiscoverInstancesOutputError>
}

extension DiscoverInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DiscoverInstancesInput(healthStatus: \(Swift.String(describing: healthStatus)), maxResults: \(Swift.String(describing: maxResults)), namespaceName: \(Swift.String(describing: namespaceName)), optionalParameters: \(Swift.String(describing: optionalParameters)), queryParameters: \(Swift.String(describing: queryParameters)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension DiscoverInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let optionalParameters = optionalParameters {
            var optionalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .optionalParameters)
            for (dictKey0, attributes0) in optionalParameters {
                try optionalParametersContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .queryParameters)
            for (dictKey0, attributes0) in queryParameters {
                try queryParametersContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct DiscoverInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DiscoverInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DiscoverInstancesOutputError>
}

public struct DiscoverInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DiscoverInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DiscoverInstancesOutputError>
}

public struct DiscoverInstancesInput: Swift.Equatable {
    /// The health status of the instances that you want to discover. This parameter is ignored for services that don't
    ///    have a health check configured, and
    ///    all
    ///    instances are returned.
    ///
    ///             HEALTHY
    ///
    ///                Returns healthy instances.
    ///
    ///             UNHEALTHY
    ///
    ///                Returns unhealthy instances.
    ///
    ///             ALL
    ///
    ///                Returns all instances.
    ///
    ///             HEALTHY_OR_ELSE_ALL
    ///
    ///                Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances.
    ///       This is also called failing open.
    ///
    ///
    public let healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter?
    /// The maximum number of instances that you want Cloud Map to return in the response to a
    ///     DiscoverInstances request. If you don't specify a value for MaxResults, Cloud Map returns up
    ///    to 100 instances.
    public let maxResults: Swift.Int?
    /// The HttpName name of the namespace. It's found in the HttpProperties member of the
    ///     Properties member of the namespace.
    /// This member is required.
    public let namespaceName: Swift.String?
    /// Opportunistic filters to scope the results based on custom attributes. If there are instances that match both
    ///    the filters specified in both the QueryParameters parameter and this parameter, all of these instances
    ///    are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the
    ///     QueryParameters parameter are returned.
    public let optionalParameters: [Swift.String:Swift.String]?
    /// Filters to scope the results based on custom attributes for the instance (for example, {version=v1,
    ///     az=1a}). Only instances that match all the specified key-value pairs are returned.
    public let queryParameters: [Swift.String:Swift.String]?
    /// The name of the service that you specified when you registered the instance.
    /// This member is required.
    public let serviceName: Swift.String?

    public init (
        healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter? = nil,
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        optionalParameters: [Swift.String:Swift.String]? = nil,
        queryParameters: [Swift.String:Swift.String]? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.healthStatus = healthStatus
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.optionalParameters = optionalParameters
        self.queryParameters = queryParameters
        self.serviceName = serviceName
    }
}

struct DiscoverInstancesInputBody: Swift.Equatable {
    public let namespaceName: Swift.String?
    public let serviceName: Swift.String?
    public let maxResults: Swift.Int?
    public let queryParameters: [Swift.String:Swift.String]?
    public let optionalParameters: [Swift.String:Swift.String]?
    public let healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter?
}

extension DiscoverInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .queryParameters)
        var queryParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in queryParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    queryParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let optionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .optionalParameters)
        var optionalParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let optionalParametersContainer = optionalParametersContainer {
            optionalParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in optionalParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    optionalParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        optionalParameters = optionalParametersDecoded0
        let healthStatusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthStatusFilter.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
    }
}

extension DiscoverInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceeded" : self = .requestLimitExceeded(try RequestLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DiscoverInstancesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case requestLimitExceeded(RequestLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DiscoverInstancesOutputResponse(instances: \(Swift.String(describing: instances)))"}
}

extension DiscoverInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DiscoverInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

public struct DiscoverInstancesOutputResponse: Swift.Equatable {
    /// A complex type that contains one HttpInstanceSummary for each registered instance.
    public let instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]?

    public init (
        instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]? = nil
    )
    {
        self.instances = instances
    }
}

struct DiscoverInstancesOutputResponseBody: Swift.Equatable {
    public let instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]?
}

extension DiscoverInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.HttpInstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[ServiceDiscoveryClientTypes.HttpInstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [ServiceDiscoveryClientTypes.HttpInstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.DnsConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsRecords = "DnsRecords"
        case namespaceId = "NamespaceId"
        case routingPolicy = "RoutingPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let routingPolicy = routingPolicy {
            try encodeContainer.encode(routingPolicy.rawValue, forKey: .routingPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let routingPolicyDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.RoutingPolicy.self, forKey: .routingPolicy)
        routingPolicy = routingPolicyDecoded
        let dnsRecordsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[ServiceDiscoveryClientTypes.DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [ServiceDiscoveryClientTypes.DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.DnsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsConfig(dnsRecords: \(Swift.String(describing: dnsRecords)), namespaceId: \(Swift.String(describing: namespaceId)), routingPolicy: \(Swift.String(describing: routingPolicy)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the Amazon Route 53 DNS records that you want Cloud Map to create when
    ///    you register an instance.
    public struct DnsConfig: Swift.Equatable {
        /// An array that contains one DnsRecord object for each Route 53 DNS record that you want Cloud Map to
        ///    create when you register an instance.
        /// This member is required.
        public let dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?
        /// The ID of the namespace to use for DNS configuration.
        @available(*, deprecated, message: "Top level attribute in request should be used to reference namespace-id")
        public let namespaceId: Swift.String?
        /// The routing policy that you want to apply to all Route 53 DNS records that Cloud Map creates when you register an
        ///    instance and specify this service.
        ///
        ///             If you want to use this service to register instances that create alias records, specify WEIGHTED
        ///     for the routing policy.
        ///
        ///          You can specify the following values:
        ///
        ///             MULTIVALUE
        ///
        ///                If you define a health check for the service and the health check is healthy, Route 53 returns the applicable
        ///       value for up to eight instances.
        ///                For example, suppose that the service includes configurations for one A record and a health
        ///       check. You use the service to register 10 instances. Route 53 responds to DNS queries with IP addresses for up to
        ///       eight healthy instances. If fewer than eight instances are healthy, Route 53 responds to every DNS query with the IP
        ///       addresses for all of the healthy instances.
        ///                If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
        ///       the values for up to eight instances.
        ///                For more information about the multivalue routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-multivalue">Multivalue Answer
        ///        Routing in the Route 53 Developer Guide.
        ///
        ///             WEIGHTED
        ///
        ///                Route 53 returns the applicable value from one randomly selected instance from among the instances that you
        ///       registered using the same service. Currently, all records have the same weight, so you can't route more or less
        ///       traffic to any instances.
        ///                For example, suppose that the service includes configurations for one A record and a health
        ///       check. You use the service to register 10 instances. Route 53 responds to DNS queries with the IP address for one
        ///       randomly selected instance from among the healthy instances. If no instances are healthy, Route 53 responds to DNS
        ///       queries as if all of the instances were healthy.
        ///                If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
        ///       the applicable value for one randomly selected instance.
        ///                For more information about the weighted routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted">Weighted Routing in the
        ///        Route 53 Developer Guide.
        ///
        ///
        public let routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy?

        public init (
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil,
            namespaceId: Swift.String? = nil,
            routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy? = nil
        )
        {
            self.dnsRecords = dnsRecords
            self.namespaceId = namespaceId
            self.routingPolicy = routingPolicy
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsConfigChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsRecords = "DnsRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsRecordsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[ServiceDiscoveryClientTypes.DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [ServiceDiscoveryClientTypes.DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.DnsConfigChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsConfigChange(dnsRecords: \(Swift.String(describing: dnsRecords)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about changes to the Route 53 DNS records that Cloud Map creates when you
    ///    register an instance.
    public struct DnsConfigChange: Swift.Equatable {
        /// An array that contains one DnsRecord object for each Route 53 record that you want Cloud Map to
        ///    create when you register an instance.
        /// This member is required.
        public let dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?

        public init (
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil
        )
        {
            self.dnsRecords = dnsRecords
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostedZoneId = "HostedZoneId"
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOA.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes.DnsProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsProperties(hostedZoneId: \(Swift.String(describing: hostedZoneId)), sOA: \(Swift.String(describing: sOA)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a
    ///    namespace.
    public struct DnsProperties: Swift.Equatable {
        /// The ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.
        public let hostedZoneId: Swift.String?
        /// Start of Authority (SOA) record for the hosted zone.
        public let sOA: ServiceDiscoveryClientTypes.SOA?

        public init (
            hostedZoneId: Swift.String? = nil,
            sOA: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.hostedZoneId = hostedZoneId
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.DnsRecord: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tTL = "TTL"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.RecordType.self, forKey: .type)
        type = typeDecoded
        let tTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension ServiceDiscoveryClientTypes.DnsRecord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DnsRecord(tTL: \(Swift.String(describing: tTL)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you
    ///    register an instance.
    public struct DnsRecord: Swift.Equatable {
        /// The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record.
        ///
        ///             Alias records don't include a TTL because Route 53 uses the TTL for the Amazon Web Services resource that an alias record routes
        ///     traffic to. If you include the AWS_ALIAS_DNS_NAME attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance request, the
        ///      TTL value is ignored. Always specify a TTL for the service; you can use a service to register
        ///     instances that create either alias or non-alias records.
        ///
        /// This member is required.
        public let tTL: Swift.Int?
        /// The type of the resource, which indicates the type of value that Route 53 returns in response to DNS queries. You
        ///    can specify values for Type in the following combinations:
        ///
        ///
        ///
        ///
        ///                      A
        ///
        ///
        ///
        ///
        ///
        ///
        ///                      AAAA
        ///
        ///
        ///
        ///
        ///
        ///
        ///                      A
        ///                    and
        ///                      AAAA
        ///
        ///
        ///
        ///
        ///
        ///
        ///                      SRV
        ///
        ///
        ///
        ///
        ///
        ///
        ///                      CNAME
        ///
        ///
        ///
        ///
        ///          If you want Cloud Map to create a Route 53 alias record when you register an instance, specify A or
        ///     AAAA for Type.
        ///          You specify other settings, such as the IP address for A and AAAA records, when you
        ///    register an instance. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance.
        ///          The following values are supported:
        ///
        ///             A
        ///
        ///                Route 53 returns the IP address of the resource in IPv4 format, such as 192.0.2.44.
        ///
        ///             AAAA
        ///
        ///                Route 53 returns the IP address of the resource in IPv6 format, such as
        ///       2001:0db8:85a3:0000:0000:abcd:0001:2345.
        ///
        ///             CNAME
        ///
        ///                Route 53 returns the domain name of the resource, such as www.example.com. Note the following:
        ///
        ///
        ///                      You specify the domain name that you want to route traffic to when you register an instance. For more
        ///         information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html#cloudmap-RegisterInstance-request-Attributes">Attributes in the topic <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance.
        ///
        ///
        ///                      You must specify WEIGHTED for the value of RoutingPolicy.
        ///
        ///
        ///                      You can't specify both CNAME for Type and settings for
        ///          HealthCheckConfig. If you do, the request will fail with an InvalidInput
        ///         error.
        ///
        ///
        ///
        ///             SRV
        ///
        ///                Route 53 returns the value for an SRV record. The value for an SRV record uses the
        ///       following values:
        ///
        ///                   priority weight port service-hostname
        ///
        ///                Note the following about the values:
        ///
        ///
        ///                      The values of priority and weight are both set to 1 and can't be
        ///         changed.
        ///
        ///
        ///                      The value of port comes from the value that you specify for the AWS_INSTANCE_PORT
        ///         attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance request.
        ///
        ///
        ///                      The value of service-hostname is a concatenation of the following values:
        ///
        ///
        ///                            The value that you specify for InstanceId when you register an instance.
        ///
        ///
        ///                            The name of the service.
        ///
        ///
        ///                            The name of the namespace.
        ///
        ///
        ///                      For example, if the value of InstanceId is test, the name of the service is
        ///          backend, and the name of the namespace is example.com, the value of
        ///          service-hostname is the following:
        ///
        ///                         test.backend.example.com
        ///
        ///
        ///
        ///                If you specify settings for an SRV record, note the following:
        ///
        ///
        ///                      If you specify values for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both in the
        ///          RegisterInstance request, Cloud Map automatically creates A and/or AAAA
        ///         records that have the same name as the value of service-hostname in the SRV record.
        ///         You can ignore these records.
        ///
        ///
        ///                      If you're using a system that requires a specific SRV format, such as HAProxy, see the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html#cloudmap-CreateService-request-Name">Name element in the documentation about CreateService for information about how to
        ///         specify the correct name format.
        ///
        ///
        ///
        ///
        /// This member is required.
        public let type: ServiceDiscoveryClientTypes.RecordType?

        public init (
            tTL: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.RecordType? = nil
        )
        {
            self.tTL = tTL
            self.type = type
        }
    }

}

extension DuplicateRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateRequest(duplicateOperationId: \(Swift.String(describing: duplicateOperationId)), message: \(Swift.String(describing: message)))"}
}

extension DuplicateRequest {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateRequestBody = try responseDecoder.decode(responseBody: data)
            self.duplicateOperationId = output.duplicateOperationId
            self.message = output.message
        } else {
            self.duplicateOperationId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation is already in progress.
public struct DuplicateRequest: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The ID of the operation that's already in progress.
    public var duplicateOperationId: Swift.String?
    public var message: Swift.String?

    public init (
        duplicateOperationId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.duplicateOperationId = duplicateOperationId
        self.message = message
    }
}

struct DuplicateRequestBody: Swift.Equatable {
    public let message: Swift.String?
    public let duplicateOperationId: Swift.String?
}

extension DuplicateRequestBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duplicateOperationId = "DuplicateOperationId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let duplicateOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duplicateOperationId)
        duplicateOperationId = duplicateOperationIdDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum FilterCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case eq
        case `in`
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterCondition] {
            return [
                .between,
                .eq,
                .in,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .eq: return "EQ"
            case .in: return "IN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterCondition(rawValue: rawValue) ?? FilterCondition.sdkUnknown(rawValue)
        }
    }
}

public struct GetInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceOutputError>
}

extension GetInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstanceInput(instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension GetInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct GetInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceOutputError>
}

public struct GetInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceOutputError>
}

public struct GetInstanceInput: Swift.Equatable {
    /// The ID of the instance that you want to get information about.
    /// This member is required.
    public let instanceId: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public let serviceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct GetInstanceInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
}

extension GetInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension GetInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstanceOutputError: Swift.Error, Swift.Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstanceOutputResponse(instance: \(Swift.String(describing: instance)))"}
}

extension GetInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instance = output.instance
        } else {
            self.instance = nil
        }
    }
}

public struct GetInstanceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about a specified instance.
    public let instance: ServiceDiscoveryClientTypes.Instance?

    public init (
        instance: ServiceDiscoveryClientTypes.Instance? = nil
    )
    {
        self.instance = instance
    }
}

struct GetInstanceOutputResponseBody: Swift.Equatable {
    public let instance: ServiceDiscoveryClientTypes.Instance?
}

extension GetInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance = "Instance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Instance.self, forKey: .instance)
        instance = instanceDecoded
    }
}

public struct GetInstancesHealthStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstancesHealthStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstancesHealthStatusOutputError>
}

extension GetInstancesHealthStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstancesHealthStatusInput(instances: \(Swift.String(describing: instances)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension GetInstancesHealthStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for instanceidlist0 in instances {
                try instancesContainer.encode(instanceidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct GetInstancesHealthStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstancesHealthStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstancesHealthStatusOutputError>
}

public struct GetInstancesHealthStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstancesHealthStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstancesHealthStatusOutputError>
}

public struct GetInstancesHealthStatusInput: Swift.Equatable {
    /// An array that contains the IDs of all the instances that you want to get the health status for.
    ///          If you omit Instances, Cloud Map returns the health status for all the instances that are
    ///    associated with the specified service.
    ///
    ///             To get the IDs for the instances that you've registered by using a specified service, submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html">ListInstances request.
    ///
    public let instances: [Swift.String]?
    /// The maximum number of instances that you want Cloud Map to return in the response to a
    ///     GetInstancesHealthStatus request. If you don't specify a value for MaxResults, Cloud Map
    ///    returns up to 100 instances.
    public let maxResults: Swift.Int?
    /// For the first GetInstancesHealthStatus request, omit this value.
    ///          If more than MaxResults instances match the specified criteria, you can submit another
    ///     GetInstancesHealthStatus request to get the next group of results. Specify the value of
    ///     NextToken from the previous response in the next request.
    public let nextToken: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public let serviceId: Swift.String?

    public init (
        instances: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instances = instances
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct GetInstancesHealthStatusInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instances: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension GetInstancesHealthStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instancesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instances)
        var instancesDecoded0:[Swift.String]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [Swift.String]()
            for string0 in instancesContainer {
                if let string0 = string0 {
                    instancesDecoded0?.append(string0)
                }
            }
        }
        instances = instancesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInstancesHealthStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstancesHealthStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstancesHealthStatusOutputError: Swift.Error, Swift.Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstancesHealthStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstancesHealthStatusOutputResponse(nextToken: \(Swift.String(describing: nextToken)), status: \(Swift.String(describing: status)))"}
}

extension GetInstancesHealthStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInstancesHealthStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.status = output.status
        } else {
            self.nextToken = nil
            self.status = nil
        }
    }
}

public struct GetInstancesHealthStatusOutputResponse: Swift.Equatable {
    /// If more than MaxResults instances match the specified criteria, you can submit another
    ///     GetInstancesHealthStatus request to get the next group of results. Specify the value of
    ///     NextToken from the previous response in the next request.
    public let nextToken: Swift.String?
    /// A complex type that contains the IDs and the health status of the instances that you specified in the
    ///     GetInstancesHealthStatus request.
    public let status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]?

    public init (
        nextToken: Swift.String? = nil,
        status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
    }
}

struct GetInstancesHealthStatusOutputResponseBody: Swift.Equatable {
    public let status: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]?
    public let nextToken: Swift.String?
}

extension GetInstancesHealthStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusContainer = try containerValues.decodeIfPresent([Swift.String: ServiceDiscoveryClientTypes.HealthStatus?].self, forKey: .status)
        var statusDecoded0: [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]? = nil
        if let statusContainer = statusContainer {
            statusDecoded0 = [Swift.String:ServiceDiscoveryClientTypes.HealthStatus]()
            for (key0, healthstatus0) in statusContainer {
                if let healthstatus0 = healthstatus0 {
                    statusDecoded0?[key0] = healthstatus0
                }
            }
        }
        status = statusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNamespaceOutputError>
}

extension GetNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNamespaceInput(id: \(Swift.String(describing: id)))"}
}

extension GetNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNamespaceOutputError>
}

public struct GetNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNamespaceOutputError>
}

public struct GetNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to get information about.
    /// This member is required.
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetNamespaceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension GetNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNamespaceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNamespaceOutputResponse(namespace: \(Swift.String(describing: namespace)))"}
}

extension GetNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct GetNamespaceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the specified namespace.
    public let namespace: ServiceDiscoveryClientTypes.Namespace?

    public init (
        namespace: ServiceDiscoveryClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct GetNamespaceOutputResponseBody: Swift.Equatable {
    public let namespace: ServiceDiscoveryClientTypes.Namespace?
}

extension GetNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace = "Namespace"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

public struct GetOperationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOperationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOperationOutputError>
}

extension GetOperationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOperationInput(operationId: \(Swift.String(describing: operationId)))"}
}

extension GetOperationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

public struct GetOperationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOperationOutputError>
}

public struct GetOperationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOperationOutputError>
}

public struct GetOperationInput: Swift.Equatable {
    /// The ID of the operation that you want to get more information about.
    /// This member is required.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationInputBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension GetOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotFound" : self = .operationNotFound(try OperationNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOperationOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationNotFound(OperationNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOperationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOperationOutputResponse(operation: \(Swift.String(describing: operation)))"}
}

extension GetOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operation = output.operation
        } else {
            self.operation = nil
        }
    }
}

public struct GetOperationOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the operation.
    public let operation: ServiceDiscoveryClientTypes.Operation?

    public init (
        operation: ServiceDiscoveryClientTypes.Operation? = nil
    )
    {
        self.operation = operation
    }
}

struct GetOperationOutputResponseBody: Swift.Equatable {
    public let operation: ServiceDiscoveryClientTypes.Operation?
}

extension GetOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

public struct GetServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

extension GetServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceInput(id: \(Swift.String(describing: id)))"}
}

extension GetServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceOutputError>
}

public struct GetServiceInput: Swift.Equatable {
    /// The ID of the service that you want to get settings for.
    /// This member is required.
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension GetServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension GetServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct GetServiceOutputResponse: Swift.Equatable {
    /// A complex type that contains information about the service.
    public let service: ServiceDiscoveryClientTypes.Service?

    public init (
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct GetServiceOutputResponseBody: Swift.Equatable {
    public let service: ServiceDiscoveryClientTypes.Service?
}

extension GetServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureThreshold = "FailureThreshold"
        case resourcePath = "ResourcePath"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
        if let resourcePath = resourcePath {
            try encodeContainer.encode(resourcePath, forKey: .resourcePath)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckType.self, forKey: .type)
        type = typeDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HealthCheckConfig(failureThreshold: \(Swift.String(describing: failureThreshold)), resourcePath: \(Swift.String(describing: resourcePath)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    ///
    ///             Public DNS and HTTP namespaces only. A complex type that contains settings for an optional
    ///    health check. If you specify settings for a health check, Cloud Map associates the health check with the records
    ///    that you specify in DnsConfig.
    ///
    ///             If you specify a health check configuration, you can specify either HealthCheckCustomConfig or
    ///      HealthCheckConfig but not both.
    ///
    ///          Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about
    ///    pricing for health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing.
    ///          Note the following about configuring health checks.
    ///
    ///             A and AAAA records
    ///
    ///                If DnsConfig includes configurations for both A and AAAA records,
    ///       Cloud Map creates a health check that uses the IPv4 address to check the health of the resource. If the endpoint
    ///       tthat's specified by the IPv4 address is unhealthy, Route 53 considers both the A and AAAA
    ///       records to be unhealthy.
    ///
    ///             CNAME records
    ///
    ///                You can't specify settings for HealthCheckConfig when the DNSConfig includes
    ///        CNAME for the value of Type. If you do, the CreateService request will
    ///       fail with an InvalidInput error.
    ///
    ///             Request interval
    ///
    ///                A Route 53 health checker in each health-checking Amazon Web Services Region sends a health check request to an endpoint every
    ///       30 seconds. On average, your endpoint receives a health check request about every two seconds. However, health
    ///       checkers don't coordinate with one another. Therefore, you might sometimes see several requests in one second
    ///       that's followed by a few seconds with no health checks at all.
    ///
    ///             Health checking regions
    ///
    ///                Health checkers perform checks from all Route 53 health-checking Regions. For a list of the current Regions, see
    ///        <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions">Regions.
    ///
    ///             Alias records
    ///
    ///                When you register an instance, if you include the AWS_ALIAS_DNS_NAME attribute, Cloud Map
    ///       creates a Route 53 alias record. Note the following:
    ///
    ///
    ///                      Route 53 automatically sets EvaluateTargetHealth to true for alias records. When
    ///          EvaluateTargetHealth is true, the alias record inherits the health of the referenced Amazon Web Services
    ///         resource. such as an ELB load balancer. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-EvaluateTargetHealth">EvaluateTargetHealth.
    ///
    ///
    ///                      If you include HealthCheckConfig and then use the service to register an instance that creates
    ///         an alias record, Route 53 doesn't create the health check.
    ///
    ///
    ///
    ///             Charges for health checks
    ///
    ///                Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about pricing for
    ///       health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing.
    ///
    ///
    public struct HealthCheckConfig: Swift.Equatable {
        /// The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current
        ///    status of the endpoint from unhealthy to healthy or the other way around. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53
        ///     Determines Whether an Endpoint Is Healthy in the Route 53 Developer Guide.
        public let failureThreshold: Swift.Int?
        /// The path that you want Route 53 to request when performing health checks. The path can be any value that your
        ///    endpoint returns an HTTP status code of a 2xx or 3xx format for when the endpoint is healthy. An example file is
        ///     /docs/route53-health-check.html. Route 53 automatically adds the DNS name for the service. If you don't
        ///    specify a value for ResourcePath, the default value is /.
        ///          If you specify TCP for Type, you must not specify a value for
        ///     ResourcePath.
        public let resourcePath: Swift.String?
        /// The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is
        ///    healthy.
        ///
        ///             You can't change the value of Type after you create a health check.
        ///
        ///          You can create the following types of health checks:
        ///
        ///
        ///
        ///                   HTTP: Route 53 tries to establish a TCP connection. If successful, Route 53 submits
        ///      an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.
        ///
        ///
        ///
        ///                   HTTPS: Route 53 tries to establish a TCP connection. If successful, Route 53
        ///      submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.
        ///
        ///                   If you specify HTTPS for the value of Type, the endpoint must support TLS v1.0 or later.
        ///
        ///
        ///
        ///
        ///                   TCP: Route 53 tries to establish a TCP connection.
        ///                If you specify TCP for Type, don't specify a value for
        ///      ResourcePath.
        ///
        ///
        ///          For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53 Determines Whether
        ///     an Endpoint Is Healthy in the Route 53 Developer Guide.
        /// This member is required.
        public let type: ServiceDiscoveryClientTypes.HealthCheckType?

        public init (
            failureThreshold: Swift.Int? = nil,
            resourcePath: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.HealthCheckType? = nil
        )
        {
            self.failureThreshold = failureThreshold
            self.resourcePath = resourcePath
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes.HealthCheckCustomConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureThreshold = "FailureThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckCustomConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HealthCheckCustomConfig(failureThreshold: \(Swift.String(describing: failureThreshold)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an optional custom health check. A custom health check, which
    ///    requires that you use a third-party health checker to evaluate the health of your resources, is useful in the
    ///    following circumstances:
    ///
    ///
    ///                You can't use a health check that's defined by HealthCheckConfig because the resource isn't
    ///      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
    ///      (To check the health of resources in a VPC, the health checker must also be in the VPC.)
    ///
    ///
    ///                You want to use a third-party health checker regardless of where your resources are located.
    ///
    ///
    ///
    ///             If you specify a health check configuration, you can specify either HealthCheckCustomConfig or
    ///      HealthCheckConfig but not both.
    ///
    ///          To change the status of a custom health check, submit an UpdateInstanceCustomHealthStatus request.
    ///    Cloud Map doesn't monitor the status of the resource, it just keeps a record of the status specified in the most recent
    ///     UpdateInstanceCustomHealthStatus request.
    ///          Here's how custom health checks work:
    ///          <ol>
    ///
    ///                You create a service.
    ///
    ///
    ///                You register an instance.
    ///
    ///
    ///                You configure a third-party health checker to monitor the resource that's associated with the new instance.
    ///
    ///                   Cloud Map doesn't check the health of the resource directly.
    ///
    ///
    ///
    ///                The third-party health-checker determines that the resource is unhealthy and notifies your application.
    ///
    ///
    ///                Your application submits an UpdateInstanceCustomHealthStatus request.
    ///
    ///
    ///                Cloud Map waits for 30 seconds.
    ///
    ///
    ///                If another UpdateInstanceCustomHealthStatus request doesn't arrive during that time to change the
    ///      status back to healthy, Cloud Map stops routing traffic to the resource.
    ///
    ///          </ol>
    public struct HealthCheckCustomConfig: Swift.Equatable {
        ///
        ///             This parameter is no longer supported and is always set to 1. Cloud Map waits for approximately 30 seconds after
        ///     receiving an UpdateInstanceCustomHealthStatus request before changing the status of the service
        ///     instance.
        ///
        ///          The number of 30-second intervals that you want Cloud Map to wait after receiving an
        ///     UpdateInstanceCustomHealthStatus request before it changes the health status of a service
        ///    instance.
        ///          Sending a second or subsequent UpdateInstanceCustomHealthStatus request with the same value before
        ///    30 seconds has passed doesn't accelerate the change. Cloud Map still waits 30 seconds after the first
        ///    request to make the change.
        @available(*, deprecated, message: "Configurable FailureThreshold of HealthCheckCustomConfig is deprecated.  It will always have value 1.")
        public let failureThreshold: Swift.Int?

        public init (
            failureThreshold: Swift.Int? = nil
        )
        {
            self.failureThreshold = failureThreshold
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum HealthCheckType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckType] {
            return [
                .http,
                .https,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckType(rawValue: rawValue) ?? HealthCheckType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum HealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatus] {
            return [
                .healthy,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatus(rawValue: rawValue) ?? HealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum HealthStatusFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case healthy
        case healthyOrElseAll
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatusFilter] {
            return [
                .all,
                .healthy,
                .healthyOrElseAll,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .healthy: return "HEALTHY"
            case .healthyOrElseAll: return "HEALTHY_OR_ELSE_ALL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatusFilter(rawValue: rawValue) ?? HealthStatusFilter.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.HttpInstanceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case healthStatus = "HealthStatus"
        case instanceId = "InstanceId"
        case namespaceName = "NamespaceName"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.HttpInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpInstanceSummary(attributes: \(Swift.String(describing: attributes)), healthStatus: \(Swift.String(describing: healthStatus)), instanceId: \(Swift.String(describing: instanceId)), namespaceName: \(Swift.String(describing: namespaceName)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ServiceDiscoveryClientTypes {
    /// In a response to a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances request, HttpInstanceSummary contains information about one instance that
    ///    matches the values that you specified in the request.
    public struct HttpInstanceSummary: Swift.Equatable {
        /// If you included any attributes when you registered the instance, the values of those attributes.
        public let attributes: [Swift.String:Swift.String]?
        /// If you configured health checking in the service, the current health status of the service instance.
        public let healthStatus: ServiceDiscoveryClientTypes.HealthStatus?
        /// The ID of an instance that matches the values that you specified in the request.
        public let instanceId: Swift.String?
        ///
        ///
        ///
        ///
        ///
        ///          The HttpName name of the namespace. It's found in the HttpProperties member of the
        ///     Properties member of the namespace.
        public let namespaceName: Swift.String?
        /// The name of the service that you specified when you registered the instance.
        public let serviceName: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            healthStatus: ServiceDiscoveryClientTypes.HealthStatus? = nil,
            instanceId: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.healthStatus = healthStatus
            self.instanceId = instanceId
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }
    }

}

extension ServiceDiscoveryClientTypes.HttpNamespaceChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceDiscoveryClientTypes.HttpNamespaceChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpNamespaceChange(description: \(Swift.String(describing: description)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the HTTP
    ///    namespace.
    public struct HttpNamespaceChange: Swift.Equatable {
        /// An updated description for the HTTP
        ///    namespace.
        /// This member is required.
        public let description: Swift.String?

        public init (
            description: Swift.String? = nil
        )
        {
            self.description = description
        }
    }

}

extension ServiceDiscoveryClientTypes.HttpProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpName = "HttpName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpName = httpName {
            try encodeContainer.encode(httpName, forKey: .httpName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpName)
        httpName = httpNameDecoded
    }
}

extension ServiceDiscoveryClientTypes.HttpProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpProperties(httpName: \(Swift.String(describing: httpName)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains the name of an HTTP namespace.
    public struct HttpProperties: Swift.Equatable {
        /// The name of an HTTP namespace.
        public let httpName: Swift.String?

        public init (
            httpName: Swift.String? = nil
        )
        {
            self.httpName = httpName
        }
    }

}

extension ServiceDiscoveryClientTypes.Instance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.Instance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Instance(attributes: \(Swift.String(describing: attributes)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), id: \(Swift.String(describing: id)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an instance that Cloud Map creates when you submit a
    ///     RegisterInstance request.
    public struct Instance: Swift.Equatable {
        /// A string map that contains the following information for the service that you specify in
        ///    ServiceId:
        ///
        ///
        ///                The attributes that apply to the records that are defined in the service.
        ///
        ///
        ///                For each attribute, the applicable value.
        ///
        ///
        ///          Supported attribute keys include the following:
        ///
        ///             AWS_ALIAS_DNS_NAME
        ///
        ///                If you want Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify
        ///       the DNS name that's associated with the load balancer. For information about how to get the DNS name, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName">AliasTarget->DNSName in the Route 53 API Reference.
        ///                Note the following:
        ///
        ///
        ///                      The configuration for the service that's specified by ServiceId must include settings for an
        ///          A record, an AAAA record, or both.
        ///
        ///
        ///                      In the service that's specified by ServiceId, the value of RoutingPolicy must be
        ///          WEIGHTED.
        ///
        ///
        ///                      If the service that's specified by ServiceId includes HealthCheckConfig settings,
        ///         Cloud Map creates the health check, but it won't associate the health check with the alias record.
        ///
        ///
        ///                      Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services resources other
        ///         than ELB load balancers.
        ///
        ///
        ///                      If you specify a value for AWS_ALIAS_DNS_NAME, don't specify values for any of the
        ///          AWS_INSTANCE attributes.
        ///
        ///
        ///
        ///             AWS_EC2_INSTANCE_ID
        ///
        ///
        ///                   HTTP namespaces only. The Amazon EC2 instance ID for the instance. The
        ///        AWS_INSTANCE_IPV4 attribute contains the primary private IPv4 address.
        ///
        ///             AWS_INIT_HEALTH_STATUS
        ///
        ///                If the service configuration includes HealthCheckCustomConfig, you can optionally use
        ///        AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check,
        ///        HEALTHY or UNHEALTHY. If you don't specify a value for
        ///        AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY.
        ///
        ///             AWS_INSTANCE_CNAME
        ///
        ///                If the service configuration includes a CNAME record, the domain name that you want Route 53 to
        ///       return in response to DNS queries (for example, example.com).
        ///                This value is required if the service specified by ServiceId includes settings for an
        ///        CNAME record.
        ///
        ///             AWS_INSTANCE_IPV4
        ///
        ///                If the service configuration includes an A record, the IPv4 address that you want Route 53 to
        ///       return in response to DNS queries (for example, 192.0.2.44).
        ///                This value is required if the service specified by ServiceId includes settings for an
        ///        A record. If the service includes settings for an SRV record, you must specify a value
        ///       for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both.
        ///
        ///             AWS_INSTANCE_IPV6
        ///
        ///                If the service configuration includes an AAAA record, the IPv6 address that you want Route 53 to
        ///       return in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345).
        ///                This value is required if the service specified by ServiceId includes settings for an
        ///        AAAA record. If the service includes settings for an SRV record, you must specify a
        ///       value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both.
        ///
        ///             AWS_INSTANCE_PORT
        ///
        ///                If the service includes an SRV record, the value that you want Route 53 to return for the
        ///       port.
        ///                If the service includes HealthCheckConfig, the port on the endpoint that you want Route 53 to send
        ///       requests to.
        ///                This value is required if you specified settings for an SRV record or a Route 53 health check when
        ///       you created the service.
        ///
        ///
        public let attributes: [Swift.String:Swift.String]?
        /// A unique string that identifies the request and that allows failed RegisterInstance requests to be
        ///    retried without the risk of executing the operation twice. You must use a unique CreatorRequestId string
        ///    every time you submit a RegisterInstance request if you're registering additional instances for the same
        ///    namespace and service. CreatorRequestId can be any unique string (for example, a date/time
        ///    stamp).
        public let creatorRequestId: Swift.String?
        /// An identifier that you want to associate with the instance. Note the following:
        ///
        ///
        ///                If the service that's specified by ServiceId includes settings for an SRV record,
        ///      the value of InstanceId is automatically included as part of the value for the SRV
        ///      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type.
        ///
        ///
        ///                You can use this value to update an existing instance.
        ///
        ///
        ///                To register a new instance, you must specify a value that's unique among instances that you register by using
        ///      the same service.
        ///
        ///
        ///                If you specify an existing InstanceId and ServiceId, Cloud Map updates the existing
        ///      DNS records. If there's also an existing health check, Cloud Map deletes the old health check and creates a new
        ///      one.
        ///
        ///                   The health check isn't deleted immediately, so it will still appear for a while if you submit a
        ///        ListHealthChecks request, for example.
        ///
        ///
        ///
        /// This member is required.
        public let id: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.creatorRequestId = creatorRequestId
            self.id = id
        }
    }

}

extension InstanceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceNotFound(message: \(Swift.String(describing: message)))"}
}

extension InstanceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InstanceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No instance exists with the specified ID, or the instance was recently registered, and information about the
///    instance hasn't propagated yet.
public struct InstanceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InstanceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.InstanceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ServiceDiscoveryClientTypes.InstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceSummary(attributes: \(Swift.String(describing: attributes)), id: \(Swift.String(describing: id)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the instances that you registered by using a specified
    ///    service.
    public struct InstanceSummary: Swift.Equatable {
        /// A string map that contains the following information:
        ///
        ///
        ///                The attributes that are associated with the instance.
        ///
        ///
        ///                For each attribute, the applicable value.
        ///
        ///
        ///          Supported attribute keys include the following:
        ///
        ///             AWS_ALIAS_DNS_NAME
        ///
        ///                For an alias record that routes traffic to an Elastic Load Balancing load balancer, the DNS name that's associated with the
        ///       load balancer.
        ///
        ///             AWS_EC2_INSTANCE_ID (HTTP namespaces only)
        ///
        ///                The Amazon EC2 instance ID for the instance. When the AWS_EC2_INSTANCE_ID attribute is specified,
        ///       then the AWS_INSTANCE_IPV4 attribute contains the primary private IPv4 address.
        ///
        ///             AWS_INIT_HEALTH_STATUS
        ///
        ///                If the service configuration includes HealthCheckCustomConfig, you can optionally use
        ///        AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check,
        ///        HEALTHY or UNHEALTHY. If you don't specify a value for
        ///        AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY.
        ///
        ///             AWS_INSTANCE_CNAME
        ///
        ///                For a CNAME record, the domain name that Route 53 returns in response to DNS queries (for example,
        ///        example.com).
        ///
        ///             AWS_INSTANCE_IPV4
        ///
        ///                For an A record, the IPv4 address that Route 53 returns in response to DNS queries (for example,
        ///        192.0.2.44).
        ///
        ///             AWS_INSTANCE_IPV6
        ///
        ///                For an AAAA record, the IPv6 address that Route 53 returns in response to DNS queries (for example,
        ///        2001:0db8:85a3:0000:0000:abcd:0001:2345).
        ///
        ///             AWS_INSTANCE_PORT
        ///
        ///                For an SRV record, the value that Route 53 returns for the port. In addition, if the service
        ///       includes HealthCheckConfig, the port on the endpoint that Route 53 sends requests to.
        ///
        ///
        public let attributes: [Swift.String:Swift.String]?
        /// The ID for an instance that you created by using a specified service.
        public let id: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.id = id
        }
    }

}

extension InvalidInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInput(message: \(Swift.String(describing: message)))"}
}

extension InvalidInput {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more specified values aren't valid. For example, a required value might be missing, a numeric value might
///    be outside the allowed range, or a string value might exceed length constraints.
public struct InvalidInput: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstancesOutputError>
}

extension ListInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension ListInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct ListInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstancesOutputError>
}

public struct ListInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstancesOutputError>
}

public struct ListInstancesInput: Swift.Equatable {
    /// The maximum number of instances that you want Cloud Map to return in the response to a
    ///     ListInstances request. If you don't specify a value for MaxResults, Cloud Map returns up
    ///    to 100 instances.
    public let maxResults: Swift.Int?
    /// For the first ListInstances request, omit this value.
    ///          If more than MaxResults instances match the specified criteria, you can submit another
    ///     ListInstances request to get the next group of results. Specify the value of NextToken
    ///    from the previous response in the next request.
    public let nextToken: Swift.String?
    /// The ID of the service that you want to list instances for.
    /// This member is required.
    public let serviceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstancesOutputResponse(instances: \(Swift.String(describing: instances)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Swift.Equatable {
    /// Summary information about the instances that are associated with the specified service.
    public let instances: [ServiceDiscoveryClientTypes.InstanceSummary]?
    /// If more than MaxResults instances match the specified criteria, you can submit another
    ///     ListInstances request to get the next group of results. Specify the value of NextToken
    ///    from the previous response in the next request.
    public let nextToken: Swift.String?

    public init (
        instances: [ServiceDiscoveryClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Swift.Equatable {
    public let instances: [ServiceDiscoveryClientTypes.InstanceSummary]?
    public let nextToken: Swift.String?
}

extension ListInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.InstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[ServiceDiscoveryClientTypes.InstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [ServiceDiscoveryClientTypes.InstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNamespacesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNamespacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNamespacesOutputError>
}

extension ListNamespacesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNamespacesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNamespacesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for namespacefilters0 in filters {
                try filtersContainer.encode(namespacefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListNamespacesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNamespacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNamespacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInput: Swift.Equatable {
    /// A complex type that contains specifications for the namespaces that you want to list.
    ///          If you specify more than one filter, a namespace must match all filters to be returned by
    ///     ListNamespaces.
    public let filters: [ServiceDiscoveryClientTypes.NamespaceFilter]?
    /// The maximum number of namespaces that you want Cloud Map to return in the response to a
    ///     ListNamespaces request. If you don't specify a value for MaxResults, Cloud Map returns up
    ///    to 100 namespaces.
    public let maxResults: Swift.Int?
    /// For the first ListNamespaces request, omit this value.
    ///          If the response contains NextToken, submit another ListNamespaces request to get the
    ///    next group of results. Specify the value of NextToken from the previous response in the next
    ///    request.
    ///
    ///             Cloud Map gets MaxResults namespaces and then filters them based on the specified criteria. It's
    ///     possible that no namespaces in the first MaxResults namespaces matched the specified criteria but that
    ///     subsequent groups of MaxResults namespaces do contain namespaces that match the criteria.
    ///
    public let nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.NamespaceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ServiceDiscoveryClientTypes.NamespaceFilter]?
}

extension ListNamespacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.NamespaceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.NamespaceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.NamespaceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListNamespacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamespacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamespacesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamespacesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNamespacesOutputResponse(namespaces: \(Swift.String(describing: namespaces)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNamespacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
        } else {
            self.namespaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamespacesOutputResponse: Swift.Equatable {
    /// An array that contains one NamespaceSummary object for each namespace that matches the specified
    ///    filter criteria.
    public let namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]?
    /// If the response contains NextToken, submit another ListNamespaces request to get the
    ///    next group of results. Specify the value of NextToken from the previous response in the next
    ///    request.
    ///
    ///             Cloud Map gets MaxResults namespaces and then filters them based on the specified criteria. It's
    ///     possible that no namespaces in the first MaxResults namespaces matched the specified criteria but that
    ///     subsequent groups of MaxResults namespaces do contain namespaces that match the criteria.
    ///
    public let nextToken: Swift.String?

    public init (
        namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

struct ListNamespacesOutputResponseBody: Swift.Equatable {
    public let namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]?
    public let nextToken: Swift.String?
}

extension ListNamespacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaces = "Namespaces"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespacesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.NamespaceSummary?].self, forKey: .namespaces)
        var namespacesDecoded0:[ServiceDiscoveryClientTypes.NamespaceSummary]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [ServiceDiscoveryClientTypes.NamespaceSummary]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOperationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

extension ListOperationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOperationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for operationfilters0 in filters {
                try filtersContainer.encode(operationfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOperationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInput: Swift.Equatable {
    /// A complex type that contains specifications for the operations that you want to list, for example, operations
    ///    that you started between a specified start date and end date.
    ///          If you specify more than one filter, an operation must match all filters to be returned by
    ///     ListOperations.
    public let filters: [ServiceDiscoveryClientTypes.OperationFilter]?
    /// The maximum number of items that you want Cloud Map to return in the response to a ListOperations
    ///    request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 operations.
    public let maxResults: Swift.Int?
    /// For the first ListOperations request, omit this value.
    ///          If the response contains NextToken, submit another ListOperations request to get the
    ///    next group of results. Specify the value of NextToken from the previous response in the next
    ///    request.
    ///
    ///             Cloud Map gets MaxResults operations and then filters them based on the specified criteria. It's
    ///     possible that no operations in the first MaxResults operations matched the specified criteria but that
    ///     subsequent groups of MaxResults operations do contain operations that match the criteria.
    ///
    public let nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.OperationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ServiceDiscoveryClientTypes.OperationFilter]?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.OperationFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.OperationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.OperationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), operations: \(Swift.String(describing: operations)))"}
}

extension ListOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.operations = output.operations
        } else {
            self.nextToken = nil
            self.operations = nil
        }
    }
}

public struct ListOperationsOutputResponse: Swift.Equatable {
    /// If the response contains NextToken, submit another ListOperations request to get the
    ///    next group of results. Specify the value of NextToken from the previous response in the next
    ///    request.
    ///
    ///             Cloud Map gets MaxResults operations and then filters them based on the specified criteria. It's
    ///     possible that no operations in the first MaxResults operations matched the specified criteria but that
    ///     subsequent groups of MaxResults operations do contain operations that match the criteria.
    ///
    public let nextToken: Swift.String?
    /// Summary information about the operations that match the specified criteria.
    public let operations: [ServiceDiscoveryClientTypes.OperationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        operations: [ServiceDiscoveryClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operations = operations
    }
}

struct ListOperationsOutputResponseBody: Swift.Equatable {
    public let operations: [ServiceDiscoveryClientTypes.OperationSummary]?
    public let nextToken: Swift.String?
}

extension ListOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case operations = "Operations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.OperationSummary?].self, forKey: .operations)
        var operationsDecoded0:[ServiceDiscoveryClientTypes.OperationSummary]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [ServiceDiscoveryClientTypes.OperationSummary]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

extension ListServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for servicefilters0 in filters {
                try filtersContainer.encode(servicefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Swift.Equatable {
    /// A complex type that contains specifications for the namespaces that you want to list services for.
    ///          If you specify more than one filter, an operation must match all filters to be returned by
    ///     ListServices.
    public let filters: [ServiceDiscoveryClientTypes.ServiceFilter]?
    /// The maximum number of services that you want Cloud Map to return in the response to a ListServices
    ///    request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 services.
    public let maxResults: Swift.Int?
    /// For the first ListServices request, omit this value.
    ///          If the response contains NextToken, submit another ListServices request to get the
    ///    next group of results. Specify the value of NextToken from the previous response in the next
    ///    request.
    ///
    ///             Cloud Map gets MaxResults services and then filters them based on the specified criteria. It's
    ///     possible that no services in the first MaxResults services matched the specified criteria but that
    ///     subsequent groups of MaxResults services do contain services that match the criteria.
    ///
    public let nextToken: Swift.String?

    public init (
        filters: [ServiceDiscoveryClientTypes.ServiceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [ServiceDiscoveryClientTypes.ServiceFilter]?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.ServiceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceDiscoveryClientTypes.ServiceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceDiscoveryClientTypes.ServiceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), services: \(Swift.String(describing: services)))"}
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// If the response contains NextToken, submit another ListServices request to get the
    ///    next group of results. Specify the value of NextToken from the previous response in the next
    ///    request.
    ///
    ///             Cloud Map gets MaxResults services and then filters them based on the specified criteria. It's
    ///     possible that no services in the first MaxResults services matched the specified criteria but that
    ///     subsequent groups of MaxResults services do contain services that match the criteria.
    ///
    public let nextToken: Swift.String?
    /// An array that contains one ServiceSummary object for each service that matches the specified filter
    ///    criteria.
    public let services: [ServiceDiscoveryClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        services: [ServiceDiscoveryClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    public let services: [ServiceDiscoveryClientTypes.ServiceSummary]?
    public let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.ServiceSummary?].self, forKey: .services)
        var servicesDecoded0:[ServiceDiscoveryClientTypes.ServiceSummary]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceDiscoveryClientTypes.ServiceSummary]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public let resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags that are assigned to the resource.
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.Namespace: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.Namespace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Namespace(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), serviceCount: \(Swift.String(describing: serviceCount)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified namespace.
    public struct Namespace: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.
        public let arn: Swift.String?
        /// The date that the namespace was created, in Unix date/time format and Coordinated Universal Time (UTC). The
        ///    value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087
        ///    represents Friday, January 26, 2018 12:11:30.087 AM.
        public let createDate: ClientRuntime.Date?
        /// A unique string that identifies the request and that allows failed requests to be retried without the risk of
        ///    running an operation twice.
        public let creatorRequestId: Swift.String?
        /// The description that you specify for the namespace when you create it.
        public let description: Swift.String?
        /// The ID of a namespace.
        public let id: Swift.String?
        /// The name of the namespace, such as example.com.
        public let name: Swift.String?
        /// A complex type that contains information that's specific to the type of the namespace.
        public let properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// The number of services that are associated with the namespace.
        public let serviceCount: Swift.Int?
        /// The type of the namespace. The methods for discovering instances depends on the value that you specify:
        ///
        ///             HTTP
        ///
        ///                Instances can be discovered only programmatically, using the Cloud Map DiscoverInstances
        ///       API.
        ///
        ///             DNS_PUBLIC
        ///
        ///                Instances can be discovered using public DNS queries and using the DiscoverInstances API.
        ///
        ///             DNS_PRIVATE
        ///
        ///                Instances can be discovered using DNS queries in VPCs and using the DiscoverInstances
        ///       API.
        ///
        ///
        public let type: ServiceDiscoveryClientTypes.NamespaceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

extension NamespaceAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceAlreadyExists(creatorRequestId: \(Swift.String(describing: creatorRequestId)), message: \(Swift.String(describing: message)), namespaceId: \(Swift.String(describing: namespaceId)))"}
}

extension NamespaceAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NamespaceAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.namespaceId = output.namespaceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.namespaceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The namespace that you're trying to create already exists.
public struct NamespaceAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The CreatorRequestId that was used to create the namespace.
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    /// The ID of the existing namespace.
    public var namespaceId: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        namespaceId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.namespaceId = namespaceId
    }
}

struct NamespaceAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
    public let creatorRequestId: Swift.String?
    public let namespaceId: Swift.String?
}

extension NamespaceAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case namespaceId = "NamespaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceFilter(condition: \(Swift.String(describing: condition)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that identifies the namespaces that you want to list. You can choose to list public or private
    ///    namespaces.
    public struct NamespaceFilter: Swift.Equatable {
        /// The operator that you want to use to determine whether ListNamespaces returns a namespace. Valid
        ///    values for condition include:
        ///
        ///             EQ
        ///
        ///                When you specify EQ for the condition, you can choose to list only public namespaces or private
        ///       namespaces, but not both. EQ is the default condition and can be omitted.
        ///
        ///             IN
        ///
        ///                When you specify IN for the condition, you can choose to list public namespaces, private
        ///       namespaces, or both.
        ///
        ///             BETWEEN
        ///
        ///                 Not applicable
        ///
        ///
        public let condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify TYPE.
        /// This member is required.
        public let name: ServiceDiscoveryClientTypes.NamespaceFilterName?
        /// If you specify EQ for Condition, specify either DNS_PUBLIC or
        ///     DNS_PRIVATE.
        ///          If you specify IN for Condition, you can specify DNS_PUBLIC,
        ///     DNS_PRIVATE, or both.
        /// This member is required.
        public let values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.NamespaceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum NamespaceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceFilterName] {
            return [
                .type,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .type: return "TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceFilterName(rawValue: rawValue) ?? NamespaceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension NamespaceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceNotFound(message: \(Swift.String(describing: message)))"}
}

extension NamespaceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NamespaceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No namespace exists with the specified ID.
public struct NamespaceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NamespaceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NamespaceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
        case httpProperties = "HttpProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
        if let httpProperties = httpProperties {
            try encodeContainer.encode(httpProperties, forKey: .httpProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsProperties.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
        let httpPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HttpProperties.self, forKey: .httpProperties)
        httpProperties = httpPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceProperties(dnsProperties: \(Swift.String(describing: dnsProperties)), httpProperties: \(Swift.String(describing: httpProperties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information that's specific to the namespace type.
    public struct NamespaceProperties: Swift.Equatable {
        /// A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a
        ///    namespace.
        public let dnsProperties: ServiceDiscoveryClientTypes.DnsProperties?
        /// A complex type that contains the name of an HTTP namespace.
        public let httpProperties: ServiceDiscoveryClientTypes.HttpProperties?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.DnsProperties? = nil,
            httpProperties: ServiceDiscoveryClientTypes.HttpProperties? = nil
        )
        {
            self.dnsProperties = dnsProperties
            self.httpProperties = httpProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.NamespaceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension ServiceDiscoveryClientTypes.NamespaceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NamespaceSummary(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), serviceCount: \(Swift.String(describing: serviceCount)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a namespace.
    public struct NamespaceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.
        public let arn: Swift.String?
        /// The date and time that the namespace was created.
        public let createDate: ClientRuntime.Date?
        /// A description for the namespace.
        public let description: Swift.String?
        /// The ID of the namespace.
        public let id: Swift.String?
        /// The name of the namespace. When you create a namespace, Cloud Map automatically creates a Route 53 hosted zone
        ///    that has the same name as the namespace.
        public let name: Swift.String?
        /// The properties of the namespace.
        public let properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// The number of services that were created using the namespace.
        public let serviceCount: Swift.Int?
        /// The type of the namespace, either public or private.
        public let type: ServiceDiscoveryClientTypes.NamespaceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum NamespaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dnsPrivate
        case dnsPublic
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceType] {
            return [
                .dnsPrivate,
                .dnsPublic,
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dnsPrivate: return "DNS_PRIVATE"
            case .dnsPublic: return "DNS_PUBLIC"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceType(rawValue: rawValue) ?? NamespaceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.Operation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case status = "Status"
        case targets = "Targets"
        case type = "Type"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, operationtargetsmap0) in targets {
                try targetsContainer.encode(operationtargetsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateDate = updateDate {
            try encodeContainer.encode(updateDate.timeIntervalSince1970, forKey: .updateDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourceid0) in targetsContainer {
                if let resourceid0 = resourceid0 {
                    targetsDecoded0?[key0] = resourceid0
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension ServiceDiscoveryClientTypes.Operation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Operation(createDate: \(Swift.String(describing: createDate)), errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), targets: \(Swift.String(describing: targets)), type: \(Swift.String(describing: type)), updateDate: \(Swift.String(describing: updateDate)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified operation.
    public struct Operation: Swift.Equatable {
        /// The date and time that the request was submitted, in Unix date/time format and Coordinated Universal Time (UTC).
        ///    The value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087
        ///    represents Friday, January 26, 2018 12:11:30.087 AM.
        public let createDate: ClientRuntime.Date?
        /// The code associated with ErrorMessage. Values for ErrorCode include the
        ///    following:
        ///
        ///
        ///
        ///                   ACCESS_DENIED
        ///
        ///
        ///
        ///
        ///                   CANNOT_CREATE_HOSTED_ZONE
        ///
        ///
        ///
        ///
        ///                   EXPIRED_TOKEN
        ///
        ///
        ///
        ///
        ///                   HOSTED_ZONE_NOT_FOUND
        ///
        ///
        ///
        ///
        ///                   INTERNAL_FAILURE
        ///
        ///
        ///
        ///
        ///                   INVALID_CHANGE_BATCH
        ///
        ///
        ///
        ///
        ///                   THROTTLED_REQUEST
        ///
        ///
        ///
        public let errorCode: Swift.String?
        /// If the value of Status is FAIL, the reason that the operation failed.
        public let errorMessage: Swift.String?
        /// The ID of the operation that you want to get information about.
        public let id: Swift.String?
        /// The status of the operation. Values include the following:
        ///
        ///             SUBMITTED
        ///
        ///                This is the initial state that occurs immediately after you submit a request.
        ///
        ///             PENDING
        ///
        ///                Cloud Map is performing the operation.
        ///
        ///             SUCCESS
        ///
        ///                The operation succeeded.
        ///
        ///             FAIL
        ///
        ///                The operation failed. For the failure reason, see ErrorMessage.
        ///
        ///
        public let status: ServiceDiscoveryClientTypes.OperationStatus?
        /// The name of the target entity that's associated with the operation:
        ///
        ///             NAMESPACE
        ///
        ///                The namespace ID is returned in the ResourceId property.
        ///
        ///             SERVICE
        ///
        ///                The service ID is returned in the ResourceId property.
        ///
        ///             INSTANCE
        ///
        ///                The instance ID is returned in the ResourceId property.
        ///
        ///
        public let targets: [Swift.String:Swift.String]?
        /// The name of the operation that's associated with the specified ID.
        public let type: ServiceDiscoveryClientTypes.OperationType?
        /// The date and time that the value of Status changed to the current value, in Unix date/time format
        ///    and Coordinated Universal Time (UTC). The value of UpdateDate is accurate to milliseconds. For example,
        ///    the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let updateDate: ClientRuntime.Date?

        public init (
            createDate: ClientRuntime.Date? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil,
            targets: [Swift.String:Swift.String]? = nil,
            type: ServiceDiscoveryClientTypes.OperationType? = nil,
            updateDate: ClientRuntime.Date? = nil
        )
        {
            self.createDate = createDate
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.status = status
            self.targets = targets
            self.type = type
            self.updateDate = updateDate
        }
    }

}

extension ServiceDiscoveryClientTypes.OperationFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes.OperationFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationFilter(condition: \(Swift.String(describing: condition)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that lets you select the operations that you want to list.
    public struct OperationFilter: Swift.Equatable {
        /// The operator that you want to use to determine whether an operation matches the specified value. Valid values
        ///    for condition include:
        ///
        ///
        ///
        ///                   EQ: When you specify EQ for the condition, you can specify only one value.
        ///       EQ is supported for NAMESPACE_ID, SERVICE_ID, STATUS, and
        ///       TYPE. EQ is the default condition and can be omitted.
        ///
        ///
        ///
        ///                   IN: When you specify IN for the condition, you can specify a list of one or more
        ///      values. IN is supported for STATUS and TYPE. An operation must match one of
        ///      the specified values to be returned in the response.
        ///
        ///
        ///
        ///                   BETWEEN: Specify a start date and an end date in Unix date/time format and Coordinated Universal
        ///      Time (UTC). The start date must be the first value. BETWEEN is supported for UPDATE_DATE.
        ///
        ///
        ///
        public let condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify the operations that you want to get:
        ///
        ///
        ///
        ///                   NAMESPACE_ID: Gets operations related to specified namespaces.
        ///
        ///
        ///
        ///                   SERVICE_ID: Gets operations related to specified services.
        ///
        ///
        ///
        ///                   STATUS: Gets operations based on the status of the operations:
        ///       SUBMITTED, PENDING, SUCCEED, or FAIL.
        ///
        ///
        ///
        ///                   TYPE: Gets specified types of operation.
        ///
        ///
        ///
        ///                   UPDATE_DATE: Gets operations that changed status during a specified date/time
        ///      range.
        ///
        ///
        /// This member is required.
        public let name: ServiceDiscoveryClientTypes.OperationFilterName?
        /// Specify values that are applicable to the value that you specify for Name:
        ///
        ///
        ///
        ///                   NAMESPACE_ID: Specify one namespace ID.
        ///
        ///
        ///
        ///                   SERVICE_ID: Specify one service ID.
        ///
        ///
        ///
        ///                   STATUS: Specify one or more statuses: SUBMITTED,
        ///       PENDING, SUCCEED, or FAIL.
        ///
        ///
        ///
        ///                   TYPE: Specify one or more of the following types:
        ///       CREATE_NAMESPACE, DELETE_NAMESPACE, UPDATE_SERVICE,
        ///       REGISTER_INSTANCE, or DEREGISTER_INSTANCE.
        ///
        ///
        ///
        ///                   UPDATE_DATE: Specify a start date and an end date in Unix date/time format
        ///      and Coordinated Universal Time (UTC). The start date must be the first value.
        ///
        ///
        /// This member is required.
        public let values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.OperationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum OperationFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case namespaceId
        case serviceId
        case status
        case type
        case updateDate
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationFilterName] {
            return [
                .namespaceId,
                .serviceId,
                .status,
                .type,
                .updateDate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case .serviceId: return "SERVICE_ID"
            case .status: return "STATUS"
            case .type: return "TYPE"
            case .updateDate: return "UPDATE_DATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationFilterName(rawValue: rawValue) ?? OperationFilterName.sdkUnknown(rawValue)
        }
    }
}

extension OperationNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationNotFound(message: \(Swift.String(describing: message)))"}
}

extension OperationNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No operation exists with the specified ID.
public struct OperationNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case pending
        case submitted
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .fail,
                .pending,
                .submitted,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .pending: return "PENDING"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.OperationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceDiscoveryClientTypes.OperationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationSummary(id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an operation that matches the criteria that you specified in a
    ///     <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations
    ///    request.
    public struct OperationSummary: Swift.Equatable {
        /// The ID for an operation.
        public let id: Swift.String?
        /// The status of the operation. Values include the following:
        ///
        ///
        ///
        ///                   SUBMITTED: This is the initial state immediately after you submit a
        ///      request.
        ///
        ///
        ///
        ///                   PENDING: Cloud Map is performing the operation.
        ///
        ///
        ///
        ///                   SUCCESS: The operation succeeded.
        ///
        ///
        ///
        ///                   FAIL: The operation failed. For the failure reason, see
        ///       ErrorMessage.
        ///
        ///
        public let status: ServiceDiscoveryClientTypes.OperationStatus?

        public init (
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil
        )
        {
            self.id = id
            self.status = status
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum OperationTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case namespace
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationTargetType] {
            return [
                .instance,
                .namespace,
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .namespace: return "NAMESPACE"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationTargetType(rawValue: rawValue) ?? OperationTargetType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createNamespace
        case deleteNamespace
        case deregisterInstance
        case registerInstance
        case updateNamespace
        case updateService
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createNamespace,
                .deleteNamespace,
                .deregisterInstance,
                .registerInstance,
                .updateNamespace,
                .updateService,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createNamespace: return "CREATE_NAMESPACE"
            case .deleteNamespace: return "DELETE_NAMESPACE"
            case .deregisterInstance: return "DEREGISTER_INSTANCE"
            case .registerInstance: return "REGISTER_INSTANCE"
            case .updateNamespace: return "UPDATE_NAMESPACE"
            case .updateService: return "UPDATE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateDnsNamespaceChange(description: \(Swift.String(describing: description)), properties: \(Swift.String(describing: properties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the private DNS
    ///    namespace.
    public struct PrivateDnsNamespaceChange: Swift.Equatable {
        /// An updated description for the private
        ///    DNS namespace.
        public let description: Swift.String?
        /// Properties to be updated in the private
        ///    DNS namespace.
        public let properties: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange?

        public init (
            description: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange? = nil
        )
        {
            self.description = description
            self.properties = properties
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateDnsNamespaceProperties(dnsProperties: \(Swift.String(describing: dnsProperties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the private DNS
    ///    namespace.
    public struct PrivateDnsNamespaceProperties: Swift.Equatable {
        /// DNS properties for the private DNS
        ///    namespace.
        /// This member is required.
        public let dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateDnsNamespacePropertiesChange(dnsProperties: \(Swift.String(describing: dnsProperties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the private DNS
    ///    namespace.
    public struct PrivateDnsNamespacePropertiesChange: Swift.Equatable {
        /// Updated DNS properties for the private
        ///    DNS namespace.
        /// This member is required.
        public let dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOA.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateDnsPropertiesMutable(sOA: \(Swift.String(describing: sOA)))"}
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the private DNS
    ///    namespace.
    public struct PrivateDnsPropertiesMutable: Swift.Equatable {
        /// Fields for the Start of Authority (SOA)
        ///    record for the hosted zone for the private DNS namespace.
        /// This member is required.
        public let sOA: ServiceDiscoveryClientTypes.SOA?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOAChange.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateDnsPropertiesMutableChange(sOA: \(Swift.String(describing: sOA)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated DNS properties for the private
    ///    DNS namespace.
    public struct PrivateDnsPropertiesMutableChange: Swift.Equatable {
        /// Updated fields for the Start of Authority
        ///    (SOA) record for the hosted zone for the private DNS namespace.
        /// This member is required.
        public let sOA: ServiceDiscoveryClientTypes.SOAChange?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOAChange? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicDnsNamespaceChange(description: \(Swift.String(describing: description)), properties: \(Swift.String(describing: properties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the public DNS
    ///    namespace.
    public struct PublicDnsNamespaceChange: Swift.Equatable {
        /// An updated description for the public DNS
        ///    namespace.
        public let description: Swift.String?
        /// Properties to be updated in the public
        ///    DNS namespace.
        public let properties: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange?

        public init (
            description: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange? = nil
        )
        {
            self.description = description
            self.properties = properties
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicDnsNamespaceProperties(dnsProperties: \(Swift.String(describing: dnsProperties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the public DNS
    ///    namespace.
    public struct PublicDnsNamespaceProperties: Swift.Equatable {
        /// DNS properties for the public DNS
        ///    namespace.
        /// This member is required.
        public let dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsProperties = "DnsProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicDnsNamespacePropertiesChange(dnsProperties: \(Swift.String(describing: dnsProperties)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the public DNS
    ///    namespace.
    public struct PublicDnsNamespacePropertiesChange: Swift.Equatable {
        /// Updated DNS properties for the hosted
        ///    zone for the public DNS namespace.
        /// This member is required.
        public let dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange?

        public init (
            dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOA.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicDnsPropertiesMutable(sOA: \(Swift.String(describing: sOA)))"}
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the public DNS
    ///    namespace.
    public struct PublicDnsPropertiesMutable: Swift.Equatable {
        /// Start of Authority (SOA) record for the
        ///    hosted zone for the public DNS namespace.
        /// This member is required.
        public let sOA: ServiceDiscoveryClientTypes.SOA?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sOA = "SOA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sOA = sOA {
            try encodeContainer.encode(sOA, forKey: .sOA)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sOADecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.SOAChange.self, forKey: .sOA)
        sOA = sOADecoded
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicDnsPropertiesMutableChange(sOA: \(Swift.String(describing: sOA)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated DNS properties for the public DNS
    ///    namespace.
    public struct PublicDnsPropertiesMutableChange: Swift.Equatable {
        /// Updated fields for the Start of Authority
        ///    (SOA) record for the hosted zone for the public DNS namespace.
        /// This member is required.
        public let sOA: ServiceDiscoveryClientTypes.SOAChange?

        public init (
            sOA: ServiceDiscoveryClientTypes.SOAChange? = nil
        )
        {
            self.sOA = sOA
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum RecordType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case a
        case aaaa
        case cname
        case srv
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordType] {
            return [
                .a,
                .aaaa,
                .cname,
                .srv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .a: return "A"
            case .aaaa: return "AAAA"
            case .cname: return "CNAME"
            case .srv: return "SRV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordType(rawValue: rawValue) ?? RecordType.sdkUnknown(rawValue)
        }
    }
}

public struct RegisterInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

extension RegisterInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterInstanceInput(attributes: \(Swift.String(describing: attributes)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension RegisterInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct RegisterInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInput: Swift.Equatable {
    /// A string map that contains the following information for the service that you specify in
    ///    ServiceId:
    ///
    ///
    ///                The attributes that apply to the records that are defined in the service.
    ///
    ///
    ///                For each attribute, the applicable value.
    ///
    ///
    ///          Supported attribute keys include the following:
    ///
    ///             AWS_ALIAS_DNS_NAME
    ///
    ///                If you want Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer,
    ///       specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see
    ///       "DNSName" in the topic <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html">AliasTarget in the Route 53 API Reference.
    ///                Note the following:
    ///
    ///
    ///                      The configuration for the service that's specified by ServiceId must include settings for an
    ///          A record, an AAAA record, or both.
    ///
    ///
    ///                      In the service that's specified by ServiceId, the value of RoutingPolicy must be
    ///          WEIGHTED.
    ///
    ///
    ///                      If the service that's specified by ServiceId includes HealthCheckConfig settings,
    ///         Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias
    ///         record.
    ///
    ///
    ///                      Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services
    ///         resources other than Elastic Load Balancing load balancers.
    ///
    ///
    ///                      If you specify a value for AWS_ALIAS_DNS_NAME, don't specify values for any of the
    ///          AWS_INSTANCE attributes.
    ///
    ///
    ///
    ///             AWS_EC2_INSTANCE_ID
    ///
    ///
    ///                   HTTP namespaces only. The Amazon EC2 instance ID for the instance. If the
    ///        AWS_EC2_INSTANCE_ID attribute is specified, then the only other attribute that can be specified is
    ///        AWS_INIT_HEALTH_STATUS. When the AWS_EC2_INSTANCE_ID attribute is specified, then the
    ///        AWS_INSTANCE_IPV4 attribute will be filled out with the primary private IPv4 address.
    ///
    ///             AWS_INIT_HEALTH_STATUS
    ///
    ///                If the service configuration includes HealthCheckCustomConfig, you can optionally use
    ///        AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check,
    ///        HEALTHY or UNHEALTHY. If you don't specify a value for
    ///        AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY.
    ///
    ///             AWS_INSTANCE_CNAME
    ///
    ///                If the service configuration includes a CNAME record, the domain name that you want Route 53 to
    ///       return in response to DNS queries (for example, example.com).
    ///                This value is required if the service specified by ServiceId includes settings for an
    ///        CNAME record.
    ///
    ///             AWS_INSTANCE_IPV4
    ///
    ///                If the service configuration includes an A record, the IPv4 address that you want Route 53 to
    ///       return in response to DNS queries (for example, 192.0.2.44).
    ///                This value is required if the service specified by ServiceId includes settings for an
    ///        A record. If the service includes settings for an SRV record, you must specify a value
    ///       for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both.
    ///
    ///             AWS_INSTANCE_IPV6
    ///
    ///                If the service configuration includes an AAAA record, the IPv6 address that you want Route 53 to
    ///       return in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345).
    ///                This value is required if the service specified by ServiceId includes settings for an
    ///        AAAA record. If the service includes settings for an SRV record, you must specify a
    ///       value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both.
    ///
    ///             AWS_INSTANCE_PORT
    ///
    ///                If the service includes an SRV record, the value that you want Route 53 to return for the
    ///       port.
    ///                If the service includes HealthCheckConfig, the port on the endpoint that you want Route 53 to send
    ///       requests to.
    ///                This value is required if you specified settings for an SRV record or a Route 53 health check when
    ///       you created the service.
    ///
    ///             Custom attributes
    ///
    ///                You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is
    ///       255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided
    ///       attributes (sum of all keys and values) must not exceed 5,000 characters.
    ///
    ///
    /// This member is required.
    public let attributes: [Swift.String:Swift.String]?
    /// A unique string that identifies the request and that allows failed RegisterInstance requests to be
    ///    retried without the risk of executing the operation twice. You must use a unique CreatorRequestId string
    ///    every time you submit a RegisterInstance request if you're registering additional instances for the same
    ///    namespace and service. CreatorRequestId can be any unique string (for example, a date/time
    ///    stamp).
    public var creatorRequestId: Swift.String?
    /// An identifier that you want to associate with the instance. Note the following:
    ///
    ///
    ///                If the service that's specified by ServiceId includes settings for an SRV record,
    ///      the value of InstanceId is automatically included as part of the value for the SRV
    ///      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type.
    ///
    ///
    ///                You can use this value to update an existing instance.
    ///
    ///
    ///                To register a new instance, you must specify a value that's unique among instances that you register by using
    ///      the same service.
    ///
    ///
    ///                If you specify an existing InstanceId and ServiceId, Cloud Map updates the existing
    ///      DNS records, if any. If there's also an existing health check, Cloud Map deletes the old health check and creates
    ///      a new one.
    ///
    ///                   The health check isn't deleted immediately, so it will still appear for a while if you submit a
    ///        ListHealthChecks request, for example.
    ///
    ///
    ///
    /// This member is required.
    public let instanceId: Swift.String?
    /// The ID of the service that you want to use for settings for the instance.
    /// This member is required.
    public let serviceId: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.creatorRequestId = creatorRequestId
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct RegisterInstanceInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
    public let creatorRequestId: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
}

extension RegisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension RegisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterInstanceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension RegisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct RegisterInstanceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RegisterInstanceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension RegisterInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension RequestLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension RequestLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation can't be completed because you've reached the quota for the number of requests. For more
///    information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/throttling.html">Cloud Map API request throttling
///     quota in the Cloud Map Developer Guide.
public struct RequestLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUse(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource can't be deleted because it contains other resources. For example, you can't delete a
///    service that contains any instances.
public struct ResourceInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension ResourceLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource can't be created because you've reached the quota on the number of resources.
public struct ResourceLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation can't be completed because the resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes {
    public enum RoutingPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multivalue
        case weighted
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingPolicy] {
            return [
                .multivalue,
                .weighted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multivalue: return "MULTIVALUE"
            case .weighted: return "WEIGHTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoutingPolicy(rawValue: rawValue) ?? RoutingPolicy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.SOA: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tTL = "TTL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension ServiceDiscoveryClientTypes.SOA: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SOA(tTL: \(Swift.String(describing: tTL)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Start of Authority (SOA) properties for a
    ///    public or private DNS namespace.
    public struct SOA: Swift.Equatable {
        /// The time to live (TTL) for purposes of
        ///    negative caching.
        /// This member is required.
        public let tTL: Swift.Int?

        public init (
            tTL: Swift.Int? = nil
        )
        {
            self.tTL = tTL
        }
    }

}

extension ServiceDiscoveryClientTypes.SOAChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tTL = "TTL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension ServiceDiscoveryClientTypes.SOAChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SOAChange(tTL: \(Swift.String(describing: tTL)))"}
}

extension ServiceDiscoveryClientTypes {
    /// Updated Start of Authority (SOA)
    ///    properties for a public or private DNS namespace.
    public struct SOAChange: Swift.Equatable {
        /// The updated time to live (TTL) for
        ///    purposes of negative caching.
        /// This member is required.
        public let tTL: Swift.Int?

        public init (
            tTL: Swift.Int? = nil
        )
        {
            self.tTL = tTL
        }
    }

}

extension ServiceDiscoveryClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceType.self, forKey: .type)
        type = typeDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)), healthCheckCustomConfig: \(Swift.String(describing: healthCheckCustomConfig)), id: \(Swift.String(describing: id)), instanceCount: \(Swift.String(describing: instanceCount)), name: \(Swift.String(describing: name)), namespaceId: \(Swift.String(describing: namespaceId)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the specified service.
    public struct Service: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.
        public let arn: Swift.String?
        /// The date and time that the service was created, in Unix format and Coordinated Universal Time (UTC). The value
        ///    of CreateDate is accurate to milliseconds. For example, the value 1516925490.087 represents
        ///    Friday, January 26, 2018 12:11:30.087 AM.
        public let createDate: ClientRuntime.Date?
        /// A unique string that identifies the request and that allows failed requests to be retried without the risk of
        ///    running the operation twice. CreatorRequestId can be any unique string (for example, a
        ///    date/timestamp).
        public let creatorRequestId: Swift.String?
        /// The description of the service.
        public let description: Swift.String?
        /// A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you
        ///    register an instance.
        public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        ///
        ///             Public DNS and HTTP namespaces only. A complex type that contains settings for an optional
        ///    health check. If you specify settings for a health check, Cloud Map associates the health check with the records
        ///    that you specify in DnsConfig.
        ///          For information about the charges for health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing.
        public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// A complex type that contains information about an optional custom health check.
        ///
        ///             If you specify a health check configuration, you can specify either HealthCheckCustomConfig or
        ///      HealthCheckConfig but not both.
        ///
        public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// The ID that Cloud Map assigned to the service when you created it.
        public let id: Swift.String?
        /// The number of instances that are currently associated with the service. Instances that were previously
        ///    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
        ///    registrations and deregistrations.
        public let instanceCount: Swift.Int?
        /// The name of the service.
        public let name: Swift.String?
        /// The ID of the namespace that was used to create the service.
        public let namespaceId: Swift.String?
        /// Describes the systems that can be used to discover the service instances.
        ///
        ///             DNS_HTTP
        ///
        ///                The service instances can be discovered using either DNS queries or the DiscoverInstances API
        ///       operation.
        ///
        ///             HTTP
        ///
        ///                The service instances can only be discovered using the DiscoverInstances API operation.
        ///
        ///             DNS
        ///
        ///                Reserved.
        ///
        ///
        public let type: ServiceDiscoveryClientTypes.ServiceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            namespaceId: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.namespaceId = namespaceId
            self.type = type
        }
    }

}

extension ServiceAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceAlreadyExists(creatorRequestId: \(Swift.String(describing: creatorRequestId)), message: \(Swift.String(describing: message)), serviceId: \(Swift.String(describing: serviceId)))"}
}

extension ServiceAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.serviceId = output.serviceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.serviceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service can't be created because a service with the same name already exists.
public struct ServiceAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The CreatorRequestId that was used to create the service.
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    /// The ID of the existing service.
    public var serviceId: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.serviceId = serviceId
    }
}

struct ServiceAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
    public let creatorRequestId: Swift.String?
    public let serviceId: Swift.String?
}

extension ServiceAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfigChange.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceChange(description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains changes to an existing service.
    public struct ServiceChange: Swift.Equatable {
        /// A description for the service.
        public let description: Swift.String?
        /// Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
        public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange?
        ///
        ///             Public DNS and HTTP namespaces only. Settings for an optional health check. If you specify
        ///    settings for a health check, Cloud Map associates the health check with the records that you specify in
        ///     DnsConfig.
        public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?

        public init (
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil
        )
        {
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
        }
    }

}

extension ServiceDiscoveryClientTypes.ServiceFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceFilter(condition: \(Swift.String(describing: condition)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that lets you specify the namespaces that you want to list services for.
    public struct ServiceFilter: Swift.Equatable {
        /// The operator that you want to use to determine whether a service is returned by ListServices. Valid
        ///    values for Condition include the following:
        ///
        ///
        ///
        ///                   EQ: When you specify EQ, specify one namespace ID for Values.
        ///       EQ is the default condition and can be omitted.
        ///
        ///
        ///
        ///                   IN: When you specify IN, specify a list of the IDs for the namespaces that you want
        ///       ListServices to return a list of services for.
        ///
        ///
        ///
        ///                   BETWEEN: Not applicable.
        ///
        ///
        public let condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify NAMESPACE_ID.
        /// This member is required.
        public let name: ServiceDiscoveryClientTypes.ServiceFilterName?
        /// The values that are applicable to the value that you specify for Condition to filter the list of
        ///    services.
        /// This member is required.
        public let values: [Swift.String]?

        public init (
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.ServiceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum ServiceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case namespaceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceFilterName] {
            return [
                .namespaceId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceFilterName(rawValue: rawValue) ?? ServiceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNotFound(message: \(Swift.String(describing: message)))"}
}

extension ServiceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No service exists with the specified ID.
public struct ServiceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension ServiceDiscoveryClientTypes.ServiceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSummary(arn: \(Swift.String(describing: arn)), createDate: \(Swift.String(describing: createDate)), description: \(Swift.String(describing: description)), dnsConfig: \(Swift.String(describing: dnsConfig)), healthCheckConfig: \(Swift.String(describing: healthCheckConfig)), healthCheckCustomConfig: \(Swift.String(describing: healthCheckCustomConfig)), id: \(Swift.String(describing: id)), instanceCount: \(Swift.String(describing: instanceCount)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified service.
    public struct ServiceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.
        public let arn: Swift.String?
        /// The date and time that the service was created.
        public let createDate: ClientRuntime.Date?
        /// The description that you specify when you create the service.
        public let description: Swift.String?
        /// Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
        public let dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        ///
        ///             Public DNS and HTTP namespaces only. Settings for an optional health check. If you specify
        ///    settings for a health check, Cloud Map associates the health check with the records that you specify in
        ///     DnsConfig.
        public let healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// Information about an optional custom health check. A custom health check, which requires that you use a
        ///    third-party health checker to evaluate the health of your resources, is useful in the following circumstances:
        ///
        ///
        ///                You can't use a health check that's defined by HealthCheckConfig because the resource isn't
        ///      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
        ///      (To check the health of resources in a VPC, the health checker must also be in the VPC.)
        ///
        ///
        ///                You want to use a third-party health checker regardless of where your resources are located.
        ///
        ///
        ///
        ///             If you specify a health check configuration, you can specify either HealthCheckCustomConfig or
        ///      HealthCheckConfig but not both.
        ///
        public let healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// The ID that Cloud Map assigned to the service when you created it.
        public let id: Swift.String?
        /// The number of instances that are currently associated with the service. Instances that were previously
        ///    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
        ///    registrations and deregistrations.
        public let instanceCount: Swift.Int?
        /// The name of the service.
        public let name: Swift.String?
        /// Describes the systems that can be used to discover the service instances.
        ///
        ///             DNS_HTTP
        ///
        ///                The service instances can be discovered using either DNS queries or the DiscoverInstances API
        ///       operation.
        ///
        ///             HTTP
        ///
        ///                The service instances can only be discovered using the DiscoverInstances API operation.
        ///
        ///             DNS
        ///
        ///                Reserved.
        ///
        ///
        public let type: ServiceDiscoveryClientTypes.ServiceType?

        public init (
            arn: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dns
        case dnsHttp
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .dns,
                .dnsHttp,
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dns: return "DNS"
            case .dnsHttp: return "DNS_HTTP"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes {
    public enum ServiceTypeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceTypeOption] {
            return [
                .http,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceTypeOption(rawValue: rawValue) ?? ServiceTypeOption.sdkUnknown(rawValue)
        }
    }
}

extension ServiceDiscoveryClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceDiscoveryClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceDiscoveryClientTypes {
    /// A custom key-value pair that's associated with a resource.
    public struct Tag: Swift.Equatable {
        /// The key identifier, or name, of the tag.
        /// This member is required.
        public let key: Swift.String?
        /// The string value that's associated with the key of the tag. You can set the value of a tag to an empty string,
        ///    but you can't set the value of a tag to null.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to
    ///    an empty string, but you can't set the value of a tag to null.
    /// This member is required.
    public let tags: [ServiceDiscoveryClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [ServiceDiscoveryClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags on the resource is over the quota. The maximum number of tags that can be applied to a resource
///    is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The name of the resource.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// The tag keys to remove from the specified resource.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateHttpNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHttpNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHttpNamespaceOutputError>
}

extension UpdateHttpNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHttpNamespaceInput(id: \(Swift.String(describing: id)), namespace: \(Swift.String(describing: namespace)), updaterRequestId: \(Swift.String(describing: updaterRequestId)))"}
}

extension UpdateHttpNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let updaterRequestId = updaterRequestId {
            try encodeContainer.encode(updaterRequestId, forKey: .updaterRequestId)
        }
    }
}

public struct UpdateHttpNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHttpNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHttpNamespaceOutputError>
}

public struct UpdateHttpNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateHttpNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateHttpNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateHttpNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateHttpNamespaceOutputError>
}

public struct UpdateHttpNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to
    ///    update.
    /// This member is required.
    public let id: Swift.String?
    /// Updated properties for the the HTTP
    ///    namespace.
    /// This member is required.
    public let namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange?
    /// A unique string that identifies the
    ///    request and that allows failed UpdateHttpNamespace requests to be retried without the risk of running
    ///    the operation twice. UpdaterRequestId can be any unique string (for example, a
    ///    date/timestamp).
    public var updaterRequestId: Swift.String?

    public init (
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

struct UpdateHttpNamespaceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let updaterRequestId: Swift.String?
    public let namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange?
}

extension UpdateHttpNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updaterRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updaterRequestId)
        updaterRequestId = updaterRequestIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.HttpNamespaceChange.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension UpdateHttpNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHttpNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHttpNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHttpNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateHttpNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension UpdateHttpNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateHttpNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateHttpNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateHttpNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension UpdateHttpNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct UpdateInstanceCustomHealthStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceCustomHealthStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

extension UpdateInstanceCustomHealthStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceCustomHealthStatusInput(instanceId: \(Swift.String(describing: instanceId)), serviceId: \(Swift.String(describing: serviceId)), status: \(Swift.String(describing: status)))"}
}

extension UpdateInstanceCustomHealthStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateInstanceCustomHealthStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceCustomHealthStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

public struct UpdateInstanceCustomHealthStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceCustomHealthStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

public struct UpdateInstanceCustomHealthStatusInput: Swift.Equatable {
    /// The ID of the instance that you want to change the health status for.
    /// This member is required.
    public let instanceId: Swift.String?
    /// The ID of the service that includes the configuration for the custom health check that you want to change the
    ///    status for.
    /// This member is required.
    public let serviceId: Swift.String?
    /// The new status of the instance, HEALTHY or UNHEALTHY.
    /// This member is required.
    public let status: ServiceDiscoveryClientTypes.CustomHealthStatus?

    public init (
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        status: ServiceDiscoveryClientTypes.CustomHealthStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
        self.status = status
    }
}

struct UpdateInstanceCustomHealthStatusInputBody: Swift.Equatable {
    public let serviceId: Swift.String?
    public let instanceId: Swift.String?
    public let status: ServiceDiscoveryClientTypes.CustomHealthStatus?
}

extension UpdateInstanceCustomHealthStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.CustomHealthStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateInstanceCustomHealthStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceCustomHealthStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomHealthNotFound" : self = .customHealthNotFound(try CustomHealthNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceCustomHealthStatusOutputError: Swift.Error, Swift.Equatable {
    case customHealthNotFound(CustomHealthNotFound)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceCustomHealthStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceCustomHealthStatusOutputResponse()"}
}

extension UpdateInstanceCustomHealthStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceCustomHealthStatusOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateInstanceCustomHealthStatusOutputResponseBody: Swift.Equatable {
}

extension UpdateInstanceCustomHealthStatusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePrivateDnsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrivateDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrivateDnsNamespaceOutputError>
}

extension UpdatePrivateDnsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePrivateDnsNamespaceInput(id: \(Swift.String(describing: id)), namespace: \(Swift.String(describing: namespace)), updaterRequestId: \(Swift.String(describing: updaterRequestId)))"}
}

extension UpdatePrivateDnsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let updaterRequestId = updaterRequestId {
            try encodeContainer.encode(updaterRequestId, forKey: .updaterRequestId)
        }
    }
}

public struct UpdatePrivateDnsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrivateDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrivateDnsNamespaceOutputError>
}

public struct UpdatePrivateDnsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrivateDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePrivateDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrivateDnsNamespaceOutputError>
}

public struct UpdatePrivateDnsNamespaceInput: Swift.Equatable {
    /// The ID of the namespace that you want to
    ///    update.
    /// This member is required.
    public let id: Swift.String?
    /// Updated properties for the private DNS
    ///    namespace.
    /// This member is required.
    public let namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange?
    /// A unique string that identifies the
    ///    request and that allows failed UpdatePrivateDnsNamespace requests to be retried without the risk of
    ///    running the operation twice. UpdaterRequestId can be any unique string (for example, a
    ///    date/timestamp).
    public var updaterRequestId: Swift.String?

    public init (
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

struct UpdatePrivateDnsNamespaceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let updaterRequestId: Swift.String?
    public let namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange?
}

extension UpdatePrivateDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updaterRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updaterRequestId)
        updaterRequestId = updaterRequestIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension UpdatePrivateDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePrivateDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePrivateDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePrivateDnsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePrivateDnsNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension UpdatePrivateDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePrivateDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdatePrivateDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdatePrivateDnsNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension UpdatePrivateDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct UpdatePublicDnsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicDnsNamespaceOutputError>
}

extension UpdatePublicDnsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePublicDnsNamespaceInput(id: \(Swift.String(describing: id)), namespace: \(Swift.String(describing: namespace)), updaterRequestId: \(Swift.String(describing: updaterRequestId)))"}
}

extension UpdatePublicDnsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let updaterRequestId = updaterRequestId {
            try encodeContainer.encode(updaterRequestId, forKey: .updaterRequestId)
        }
    }
}

public struct UpdatePublicDnsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicDnsNamespaceOutputError>
}

public struct UpdatePublicDnsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicDnsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicDnsNamespaceOutputError>
}

public struct UpdatePublicDnsNamespaceInput: Swift.Equatable {
    /// The ID of the namespace being
    ///    updated.
    /// This member is required.
    public let id: Swift.String?
    /// Updated properties for the public DNS
    ///    namespace.
    /// This member is required.
    public let namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange?
    /// A unique string that identifies the
    ///    request and that allows failed UpdatePublicDnsNamespace requests to be retried without the risk of
    ///    running the operation twice. UpdaterRequestId can be any unique string (for example, a
    ///    date/timestamp).
    public var updaterRequestId: Swift.String?

    public init (
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

struct UpdatePublicDnsNamespaceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let updaterRequestId: Swift.String?
    public let namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange?
}

extension UpdatePublicDnsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case namespace = "Namespace"
        case updaterRequestId = "UpdaterRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updaterRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updaterRequestId)
        updaterRequestId = updaterRequestIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.PublicDnsNamespaceChange.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension UpdatePublicDnsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePublicDnsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublicDnsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublicDnsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePublicDnsNamespaceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension UpdatePublicDnsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePublicDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdatePublicDnsNamespaceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdatePublicDnsNamespaceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension UpdatePublicDnsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct UpdateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

extension UpdateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInput(id: \(Swift.String(describing: id)), service: \(Swift.String(describing: service)))"}
}

extension UpdateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }
}

public struct UpdateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The ID of the service that you want to update.
    /// This member is required.
    public let id: Swift.String?
    /// A complex type that contains the new settings for the service.
    /// This member is required.
    public let service: ServiceDiscoveryClientTypes.ServiceChange?

    public init (
        id: Swift.String? = nil,
        service: ServiceDiscoveryClientTypes.ServiceChange? = nil
    )
    {
        self.id = id
        self.service = service
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let service: ServiceDiscoveryClientTypes.ServiceChange?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceDiscoveryClientTypes.ServiceChange.self, forKey: .service)
        service = serviceDecoded
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// A value that you can use to determine whether the request completed successfully.
    ///                                 To get the status of the operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation.
    public let operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}
