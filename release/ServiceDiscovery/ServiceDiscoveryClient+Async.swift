// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension ServiceDiscoveryClient {
    /// <p>Creates an HTTP namespace. Service instances registered using an HTTP namespace can be discovered using a
    ///     <code>DiscoverInstances</code> request but can't be discovered using DNS.</p>
    ///          <p>For the current quota on the number of namespaces that you can create using the same AWS account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">AWS Cloud Map quotas</a> in the
    ///     <i>AWS Cloud Map Developer Guide</i>.</p>
    func createHttpNamespace(input: CreateHttpNamespaceInput) async throws -> CreateHttpNamespaceOutputResponse
    {
        typealias createHttpNamespaceContinuation = CheckedContinuation<CreateHttpNamespaceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createHttpNamespaceContinuation) in
            createHttpNamespace(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a private namespace based on DNS, which is visible only inside a specified Amazon VPC. The namespace
    ///    defines your service naming scheme. For example, if you name your namespace <code>example.com</code> and name your
    ///    service <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. Service
    ///    instances that are registered using a private DNS namespace can be discovered using either a
    ///     <code>DiscoverInstances</code> request or using DNS. For the current quota on the number of namespaces that you can
    ///    create using the same AWS account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">AWS Cloud Map Limits</a> in the <i>AWS Cloud Map Developer Guide</i>.</p>
    func createPrivateDnsNamespace(input: CreatePrivateDnsNamespaceInput) async throws -> CreatePrivateDnsNamespaceOutputResponse
    {
        typealias createPrivateDnsNamespaceContinuation = CheckedContinuation<CreatePrivateDnsNamespaceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPrivateDnsNamespaceContinuation) in
            createPrivateDnsNamespace(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a public namespace based on DNS, which is visible on the internet. The namespace defines your service
    ///    naming scheme. For example, if you name your namespace <code>example.com</code> and name your service
    ///     <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. You can discover
    ///    instances that were registered with a public DNS namespace by using either a <code>DiscoverInstances</code> request
    ///    or using DNS. For the current quota on the number of namespaces that you can create using the same AWS account, see
    ///     <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">AWS Cloud Map Quotas</a>in the
    ///     <i>AWS Cloud Map Developer Guide</i>.</p>
    func createPublicDnsNamespace(input: CreatePublicDnsNamespaceInput) async throws -> CreatePublicDnsNamespaceOutputResponse
    {
        typealias createPublicDnsNamespaceContinuation = CheckedContinuation<CreatePublicDnsNamespaceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPublicDnsNamespaceContinuation) in
            createPublicDnsNamespace(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a service. This action defines the configuration for the following entities:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For public and private DNS namespaces, one of the following combinations of DNS records in Amazon Route 53:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>A</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>AAAA</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>A</code> and <code>AAAA</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>SRV</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>CNAME</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Optionally, a health check</p>
    ///             </li>
    ///          </ul>
    ///          <p>After you create the service, you can submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request, and AWS Cloud Map uses the
    ///    values in the configuration to create the specified entities.</p>
    ///          <p>For the current quota on the number of instances that you can register using the same namespace and using the
    ///    same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">AWS Cloud Map
    ///     Limits</a> in the <i>AWS Cloud Map Developer Guide</i>.</p>
    func createService(input: CreateServiceInput) async throws -> CreateServiceOutputResponse
    {
        typealias createServiceContinuation = CheckedContinuation<CreateServiceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createServiceContinuation) in
            createService(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a namespace from the current account. If the namespace still contains one or more services, the request
    ///    fails.</p>
    func deleteNamespace(input: DeleteNamespaceInput) async throws -> DeleteNamespaceOutputResponse
    {
        typealias deleteNamespaceContinuation = CheckedContinuation<DeleteNamespaceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteNamespaceContinuation) in
            deleteNamespace(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a specified service. If the service still contains one or more registered instances, the request
    ///    fails.</p>
    func deleteService(input: DeleteServiceInput) async throws -> DeleteServiceOutputResponse
    {
        typealias deleteServiceContinuation = CheckedContinuation<DeleteServiceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteServiceContinuation) in
            deleteService(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the Amazon Route 53 DNS records and health check, if any, that AWS Cloud Map created for the specified
    ///    instance.</p>
    func deregisterInstance(input: DeregisterInstanceInput) async throws -> DeregisterInstanceOutputResponse
    {
        typealias deregisterInstanceContinuation = CheckedContinuation<DeregisterInstanceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deregisterInstanceContinuation) in
            deregisterInstance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Discovers registered instances for a specified namespace and service. You can use <code>DiscoverInstances</code>
    ///    to discover instances for any type of namespace. For public and private DNS namespaces, you can also use DNS queries
    ///    to discover instances.</p>
    func discoverInstances(input: DiscoverInstancesInput) async throws -> DiscoverInstancesOutputResponse
    {
        typealias discoverInstancesContinuation = CheckedContinuation<DiscoverInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: discoverInstancesContinuation) in
            discoverInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a specified instance.</p>
    func getInstance(input: GetInstanceInput) async throws -> GetInstanceOutputResponse
    {
        typealias getInstanceContinuation = CheckedContinuation<GetInstanceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getInstanceContinuation) in
            getInstance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets the current health status (<code>Healthy</code>, <code>Unhealthy</code>, or <code>Unknown</code>) of one or
    ///    more instances that are associated with a specified service.</p>
    ///          <note>
    ///             <p>There's a brief delay between when you register an instance and when the health status for the instance is
    ///     available. </p>
    ///          </note>
    func getInstancesHealthStatus(input: GetInstancesHealthStatusInput) async throws -> GetInstancesHealthStatusOutputResponse
    {
        typealias getInstancesHealthStatusContinuation = CheckedContinuation<GetInstancesHealthStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getInstancesHealthStatusContinuation) in
            getInstancesHealthStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a namespace.</p>
    func getNamespace(input: GetNamespaceInput) async throws -> GetNamespaceOutputResponse
    {
        typealias getNamespaceContinuation = CheckedContinuation<GetNamespaceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getNamespaceContinuation) in
            getNamespace(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about any operation that returns an operation ID in the response, such as a
    ///     <code>CreateService</code> request.</p>
    ///          <note>
    ///             <p>To get a list of operations that match specified criteria, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations</a>.</p>
    ///          </note>
    func getOperation(input: GetOperationInput) async throws -> GetOperationOutputResponse
    {
        typealias getOperationContinuation = CheckedContinuation<GetOperationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getOperationContinuation) in
            getOperation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets the settings for a specified service.</p>
    func getService(input: GetServiceInput) async throws -> GetServiceOutputResponse
    {
        typealias getServiceContinuation = CheckedContinuation<GetServiceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getServiceContinuation) in
            getService(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists summary information about the instances that you registered by using a specified service.</p>
    func listInstances(input: ListInstancesInput) async throws -> ListInstancesOutputResponse
    {
        typealias listInstancesContinuation = CheckedContinuation<ListInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listInstancesContinuation) in
            listInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists summary information about the namespaces that were created by the current AWS account.</p>
    func listNamespaces(input: ListNamespacesInput) async throws -> ListNamespacesOutputResponse
    {
        typealias listNamespacesContinuation = CheckedContinuation<ListNamespacesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listNamespacesContinuation) in
            listNamespaces(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists operations that match the criteria that you specify.</p>
    func listOperations(input: ListOperationsInput) async throws -> ListOperationsOutputResponse
    {
        typealias listOperationsContinuation = CheckedContinuation<ListOperationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listOperationsContinuation) in
            listOperations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists summary information for all the services that are associated with one or more specified namespaces.</p>
    func listServices(input: ListServicesInput) async throws -> ListServicesOutputResponse
    {
        typealias listServicesContinuation = CheckedContinuation<ListServicesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listServicesContinuation) in
            listServices(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists tags for the specified resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates one or more records and, optionally, creates a health check based on the settings in a
    ///    specified service. When you submit a <code>RegisterInstance</code> request, the following occurs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For each DNS record that you define in the service that's specified by <code>ServiceId</code>, a record is
    ///      created or updated in the hosted zone that's associated with the corresponding namespace.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the service includes <code>HealthCheckConfig</code>, a health check is created based on the settings in the
    ///      health check configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>The health check, if any, is associated with each of the new or updated records.</p>
    ///             </li>
    ///          </ul>
    ///          <important>
    ///             <p>One <code>RegisterInstance</code> request must complete before you can submit another request and specify the
    ///     same service ID and instance ID.</p>
    ///          </important>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html">CreateService</a>.</p>
    ///          <p>When AWS Cloud Map receives a DNS query for the specified DNS name, it returns the applicable value:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>If the health check is healthy</b>: returns all the records</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>If the health check is unhealthy</b>: returns the applicable value for the last
    ///      healthy instance</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>If you didn't specify a health check configuration</b>: returns all the
    ///      records</p>
    ///             </li>
    ///          </ul>
    ///          <p>For the current quota on the number of instances that you can register using the same namespace and using the
    ///    same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">AWS Cloud Map
    ///     Limits</a> in the <i>AWS Cloud Map Developer Guide</i>.</p>
    func registerInstance(input: RegisterInstanceInput) async throws -> RegisterInstanceOutputResponse
    {
        typealias registerInstanceContinuation = CheckedContinuation<RegisterInstanceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: registerInstanceContinuation) in
            registerInstance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds one or more tags to the specified resource.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes one or more tags from the specified resource.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Submits a request to change the health status of a custom health check to healthy or unhealthy.</p>
    ///          <p>You can use <code>UpdateInstanceCustomHealthStatus</code> to change the status only for custom health checks,
    ///    which you define using <code>HealthCheckCustomConfig</code> when you create a service. You can't use it to change the
    ///    status for Route 53 health checks, which you define using <code>HealthCheckConfig</code>.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html">HealthCheckCustomConfig</a>.</p>
    func updateInstanceCustomHealthStatus(input: UpdateInstanceCustomHealthStatusInput) async throws -> UpdateInstanceCustomHealthStatusOutputResponse
    {
        typealias updateInstanceCustomHealthStatusContinuation = CheckedContinuation<UpdateInstanceCustomHealthStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateInstanceCustomHealthStatusContinuation) in
            updateInstanceCustomHealthStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Submits a request to perform the following operations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Update the TTL setting for existing <code>DnsRecords</code> configurations</p>
    ///             </li>
    ///             <li>
    ///                <p>Add, update, or delete <code>HealthCheckConfig</code> for a specified service</p>
    ///                <note>
    ///                   <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration.</p>
    ///                </note>
    ///             </li>
    ///          </ul>
    ///          <p>For public and private DNS namespaces, note the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you omit any existing <code>DnsRecords</code> or <code>HealthCheckConfig</code> configurations from an
    ///       <code>UpdateService</code> request, the configurations are deleted from the service.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you omit an existing <code>HealthCheckCustomConfig</code> configuration from an <code>UpdateService</code>
    ///      request, the configuration isn't deleted from the service.</p>
    ///             </li>
    ///          </ul>
    ///          <p>When you update settings for a service, AWS Cloud Map also updates the corresponding settings in all the records
    ///    and health checks that were created by using the specified service.</p>
    func updateService(input: UpdateServiceInput) async throws -> UpdateServiceOutputResponse
    {
        typealias updateServiceContinuation = CheckedContinuation<UpdateServiceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateServiceContinuation) in
            updateService(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
