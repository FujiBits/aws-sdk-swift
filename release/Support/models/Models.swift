// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddAttachmentsToSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

extension AddAttachmentsToSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddAttachmentsToSetInput(attachmentSetId: \(Swift.String(describing: attachmentSetId)), attachments: \(Swift.String(describing: attachments)))"}
}

extension AddAttachmentsToSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case attachments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachments0 in attachments {
                try attachmentsContainer.encode(attachments0)
            }
        }
    }
}

public struct AddAttachmentsToSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInput: Swift.Equatable {
    /// <p>The ID of the attachment set. If an <code>attachmentSetId</code> is not specified, a
    ///             new attachment set is created, and the ID of the set is returned in the response. If an
    ///                 <code>attachmentSetId</code> is specified, the attachments are added to the
    ///             specified set, if it exists.</p>
    public let attachmentSetId: Swift.String?
    /// <p>One or more attachments to add to the set. You can add up to three attachments per
    ///             set. The size limit is 5 MB per attachment.</p>
    ///         <p>In the <code>Attachment</code> object, use the <code>data</code> parameter to specify
    ///             the contents of the attachment file. In the previous request syntax, the value for
    ///                 <code>data</code> appear as <code>blob</code>, which is represented as a
    ///             base64-encoded string. The value for <code>fileName</code> is the name of the
    ///             attachment, such as <code>troubleshoot-screenshot.png</code>.</p>
    public let attachments: [SupportClientTypes.Attachment]?

    public init (
        attachmentSetId: Swift.String? = nil,
        attachments: [SupportClientTypes.Attachment]? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.attachments = attachments
    }
}

struct AddAttachmentsToSetInputBody: Swift.Equatable {
    public let attachmentSetId: Swift.String?
    public let attachments: [SupportClientTypes.Attachment]?
}

extension AddAttachmentsToSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case attachments
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([SupportClientTypes.Attachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[SupportClientTypes.Attachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [SupportClientTypes.Attachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
    }
}

extension AddAttachmentsToSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddAttachmentsToSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentLimitExceeded" : self = .attachmentLimitExceeded(try AttachmentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetSizeLimitExceeded" : self = .attachmentSetSizeLimitExceeded(try AttachmentSetSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddAttachmentsToSetOutputError: Swift.Error, Swift.Equatable {
    case attachmentLimitExceeded(AttachmentLimitExceeded)
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case attachmentSetSizeLimitExceeded(AttachmentSetSizeLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddAttachmentsToSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddAttachmentsToSetOutputResponse(attachmentSetId: \(Swift.String(describing: attachmentSetId)), expiryTime: \(Swift.String(describing: expiryTime)))"}
}

extension AddAttachmentsToSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddAttachmentsToSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachmentSetId = output.attachmentSetId
            self.expiryTime = output.expiryTime
        } else {
            self.attachmentSetId = nil
            self.expiryTime = nil
        }
    }
}

/// <p>The ID and expiry time of the attachment set returned by the <a>AddAttachmentsToSet</a> operation.</p>
public struct AddAttachmentsToSetOutputResponse: Swift.Equatable {
    /// <p>The ID of the attachment set. If an <code>attachmentSetId</code> was not specified, a
    ///             new attachment set is created, and the ID of the set is returned in the response. If an
    ///                 <code>attachmentSetId</code> was specified, the attachments are added to the
    ///             specified set, if it exists.</p>
    public let attachmentSetId: Swift.String?
    /// <p>The time and date when the attachment set expires.</p>
    public let expiryTime: Swift.String?

    public init (
        attachmentSetId: Swift.String? = nil,
        expiryTime: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.expiryTime = expiryTime
    }
}

struct AddAttachmentsToSetOutputResponseBody: Swift.Equatable {
    public let attachmentSetId: Swift.String?
    public let expiryTime: Swift.String?
}

extension AddAttachmentsToSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case expiryTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
        let expiryTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
    }
}

public struct AddCommunicationToCaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

extension AddCommunicationToCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCommunicationToCaseInput(attachmentSetId: \(Swift.String(describing: attachmentSetId)), caseId: \(Swift.String(describing: caseId)), ccEmailAddresses: \(Swift.String(describing: ccEmailAddresses)), communicationBody: \(Swift.String(describing: communicationBody)))"}
}

extension AddCommunicationToCaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case caseId
        case ccEmailAddresses
        case communicationBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let communicationBody = communicationBody {
            try encodeContainer.encode(communicationBody, forKey: .communicationBody)
        }
    }
}

public struct AddCommunicationToCaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInput: Swift.Equatable {
    /// <p>The ID of a set of one or more attachments for the communication to add to the case.
    ///             Create the set by calling <a>AddAttachmentsToSet</a>
    ///         </p>
    public let attachmentSetId: Swift.String?
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: Swift.String?
    /// <p>The email addresses in the CC line of an email to be added to the support case.</p>
    public let ccEmailAddresses: [Swift.String]?
    /// <p>The body of an email communication to add to the support case.</p>
    public let communicationBody: Swift.String?

    public init (
        attachmentSetId: Swift.String? = nil,
        caseId: Swift.String? = nil,
        ccEmailAddresses: [Swift.String]? = nil,
        communicationBody: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.caseId = caseId
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
    }
}

struct AddCommunicationToCaseInputBody: Swift.Equatable {
    public let caseId: Swift.String?
    public let communicationBody: Swift.String?
    public let ccEmailAddresses: [Swift.String]?
    public let attachmentSetId: Swift.String?
}

extension AddCommunicationToCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case caseId
        case ccEmailAddresses
        case communicationBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let communicationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .communicationBody)
        communicationBody = communicationBodyDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[Swift.String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [Swift.String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
    }
}

extension AddCommunicationToCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCommunicationToCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCommunicationToCaseOutputError: Swift.Error, Swift.Equatable {
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCommunicationToCaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCommunicationToCaseOutputResponse(result: \(Swift.String(describing: result)))"}
}

extension AddCommunicationToCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddCommunicationToCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = false
        }
    }
}

/// <p>The result of the <a>AddCommunicationToCase</a> operation.</p>
public struct AddCommunicationToCaseOutputResponse: Swift.Equatable {
    /// <p>True if <a>AddCommunicationToCase</a> succeeds. Otherwise, returns an
    ///             error.</p>
    public let result: Swift.Bool

    public init (
        result: Swift.Bool = false
    )
    {
        self.result = result
    }
}

struct AddCommunicationToCaseOutputResponseBody: Swift.Equatable {
    public let result: Swift.Bool
}

extension AddCommunicationToCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .result)
        result = resultDecoded
    }
}

extension SupportClientTypes.Attachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case fileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension SupportClientTypes.Attachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attachment(data: \(Swift.String(describing: data)), fileName: \(Swift.String(describing: fileName)))"}
}

extension SupportClientTypes {
    /// <p>An attachment to a case communication. The attachment consists of the file name and
    ///             the content of the file.</p>
    public struct Attachment: Swift.Equatable {
        /// <p>The content of the attachment file.</p>
        public let data: ClientRuntime.Data?
        /// <p>The name of the attachment file.</p>
        public let fileName: Swift.String?

        public init (
            data: ClientRuntime.Data? = nil,
            fileName: Swift.String? = nil
        )
        {
            self.data = data
            self.fileName = fileName
        }
    }

}

extension SupportClientTypes.AttachmentDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId
        case fileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension SupportClientTypes.AttachmentDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentDetails(attachmentId: \(Swift.String(describing: attachmentId)), fileName: \(Swift.String(describing: fileName)))"}
}

extension SupportClientTypes {
    /// <p>The file name and ID of an attachment to a case communication. You can use the ID to
    ///             retrieve the attachment with the <a>DescribeAttachment</a> operation.</p>
    public struct AttachmentDetails: Swift.Equatable {
        /// <p>The ID of the attachment.</p>
        public let attachmentId: Swift.String?
        /// <p>The file name of the attachment.</p>
        public let fileName: Swift.String?

        public init (
            attachmentId: Swift.String? = nil,
            fileName: Swift.String? = nil
        )
        {
            self.attachmentId = attachmentId
            self.fileName = fileName
        }
    }

}

extension AttachmentIdNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentIdNotFound(message: \(Swift.String(describing: message)))"}
}

extension AttachmentIdNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attachment with the specified ID could not be found.</p>
public struct AttachmentIdNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>An attachment with the specified ID could not be found.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentIdNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentIdNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension AttachmentLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit for the number of attachment sets created in a short period of time has been
///             exceeded.</p>
public struct AttachmentLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The limit for the number of attachment sets created in a short period of time has been
    ///             exceeded.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetExpired: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentSetExpired(message: \(Swift.String(describing: message)))"}
}

extension AttachmentSetExpired: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetExpiredBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The expiration time of the attachment set has passed. The set expires 1 hour after it
///             is created.</p>
public struct AttachmentSetExpired: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The expiration time of the attachment set has passed. The set expires one hour after
    ///             it is created.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetExpiredBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentSetExpiredBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetIdNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentSetIdNotFound(message: \(Swift.String(describing: message)))"}
}

extension AttachmentSetIdNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attachment set with the specified ID could not be found.</p>
public struct AttachmentSetIdNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>An attachment set with the specified ID could not be found.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetIdNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentSetIdNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetSizeLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentSetSizeLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension AttachmentSetSizeLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetSizeLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit for the size of an attachment set has been exceeded. The limits are three
///             attachments and 5 MB per attachment.</p>
public struct AttachmentSetSizeLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A limit for the size of an attachment set has been exceeded. The limits are three
    ///             attachments and 5 MB per attachment.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetSizeLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentSetSizeLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CaseCreationLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseCreationLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension CaseCreationLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CaseCreationLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The case creation limit for the account has been exceeded.</p>
public struct CaseCreationLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>An error message that indicates that you have exceeded the number of cases you can
    ///             have open.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CaseCreationLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CaseCreationLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportClientTypes.CaseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
        case categoryCode
        case ccEmailAddresses
        case displayId
        case language
        case recentCommunications
        case serviceCode
        case severityCode
        case status
        case subject
        case submittedBy
        case timeCreated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let categoryCode = categoryCode {
            try encodeContainer.encode(categoryCode, forKey: .categoryCode)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let displayId = displayId {
            try encodeContainer.encode(displayId, forKey: .displayId)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let recentCommunications = recentCommunications {
            try encodeContainer.encode(recentCommunications, forKey: .recentCommunications)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let severityCode = severityCode {
            try encodeContainer.encode(severityCode, forKey: .severityCode)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let submittedBy = submittedBy {
            try encodeContainer.encode(submittedBy, forKey: .submittedBy)
        }
        if let timeCreated = timeCreated {
            try encodeContainer.encode(timeCreated, forKey: .timeCreated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let displayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayId)
        displayId = displayIdDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let categoryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryCode)
        categoryCode = categoryCodeDecoded
        let severityCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severityCode)
        severityCode = severityCodeDecoded
        let submittedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .submittedBy)
        submittedBy = submittedByDecoded
        let timeCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeCreated)
        timeCreated = timeCreatedDecoded
        let recentCommunicationsDecoded = try containerValues.decodeIfPresent(SupportClientTypes.RecentCaseCommunications.self, forKey: .recentCommunications)
        recentCommunications = recentCommunicationsDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[Swift.String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [Swift.String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension SupportClientTypes.CaseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseDetails(caseId: \(Swift.String(describing: caseId)), categoryCode: \(Swift.String(describing: categoryCode)), ccEmailAddresses: \(Swift.String(describing: ccEmailAddresses)), displayId: \(Swift.String(describing: displayId)), language: \(Swift.String(describing: language)), recentCommunications: \(Swift.String(describing: recentCommunications)), serviceCode: \(Swift.String(describing: serviceCode)), severityCode: \(Swift.String(describing: severityCode)), status: \(Swift.String(describing: status)), subject: \(Swift.String(describing: subject)), submittedBy: \(Swift.String(describing: submittedBy)), timeCreated: \(Swift.String(describing: timeCreated)))"}
}

extension SupportClientTypes {
    /// <p>A JSON-formatted object that contains the metadata for a support case. It is contained
    ///             in the response from a <a>DescribeCases</a> request. <b>CaseDetails</b> contains the following fields:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>caseId</b> - The support case ID requested or
    ///                     returned in the call. The case ID is an alphanumeric string formatted as shown
    ///                     in this example:
    ///                     case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>categoryCode</b> - The category of problem for the
    ///                     support case. Corresponds to the <code>CategoryCode</code> values returned by a call to
    ///                         <a>DescribeServices</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>displayId</b> - The identifier for the case on pages
    ///                     in the AWS Support Center.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>language</b> - The ISO 639-1 code for the language
    ///                     in which AWS provides support. AWS Support currently supports English ("en") and
    ///                     Japanese ("ja"). Language parameters must be passed explicitly for operations
    ///                     that take them.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>nextToken</b> - A resumption point for
    ///                     pagination.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>recentCommunications</b> - One or more <a>Communication</a> objects. Fields of these objects are
    ///                         <code>attachments</code>, <code>body</code>, <code>caseId</code>,
    ///                         <code>submittedBy</code>, and <code>timeCreated</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>serviceCode</b> - The identifier for the AWS service
    ///                     that corresponds to the service code defined in the call to <a>DescribeServices</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>severityCode</b> - The severity code assigned to the
    ///                     case. Contains one of the values returned by the call to <a>DescribeSeverityLevels</a>. The possible values are:
    ///                         <code>low</code>, <code>normal</code>, <code>high</code>,
    ///                         <code>urgent</code>, and <code>critical</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>status</b> - The status of the case in the AWS Support Center. Valid values:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>
    ///                         <code>opened</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>pending-customer-action</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>reopened</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>resolved</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>unassigned</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>work-in-progress</code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>subject</b> - The subject line of the case.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>submittedBy</b> - The email address of the account
    ///                     that submitted the case.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>timeCreated</b> - The time the case was created, in
    ///                     ISO-8601 format.</p>
    ///             </li>
    ///          </ul>
    public struct CaseDetails: Swift.Equatable {
        /// <p>The support case ID requested or returned in the call. The case ID is an
        ///             alphanumeric string formatted as shown in this example:
        ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
        ///         </p>
        public let caseId: Swift.String?
        /// <p>The category of problem for the support case.</p>
        public let categoryCode: Swift.String?
        /// <p>The email addresses that receive copies of communication about the case.</p>
        public let ccEmailAddresses: [Swift.String]?
        /// <p>The ID displayed for the case in the AWS Support Center. This is a numeric
        ///             string.</p>
        public let displayId: Swift.String?
        /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
        ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
        ///             passed explicitly for operations that take them.</p>
        public let language: Swift.String?
        /// <p>The five most recent communications between you and AWS Support Center, including the
        ///             IDs of any attachments to the communications. Also includes a <code>nextToken</code>
        ///             that you can use to retrieve earlier communications.</p>
        public let recentCommunications: SupportClientTypes.RecentCaseCommunications?
        /// <p>The code for the AWS service. You can get a list of codes and the corresponding
        ///             service names by calling <a>DescribeServices</a>.</p>
        public let serviceCode: Swift.String?
        /// <p>The code for the severity level returned by the call to <a>DescribeSeverityLevels</a>.</p>
        public let severityCode: Swift.String?
        /// <p>The status of the case.</p>
        ///         <p>Valid values:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <code>opened</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>pending-customer-action</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>reopened</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>resolved</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>unassigned</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>work-in-progress</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?
        /// <p>The subject line for the case in the AWS Support Center.</p>
        public let subject: Swift.String?
        /// <p>The email address of the account that submitted the case.</p>
        public let submittedBy: Swift.String?
        /// <p>The time that the case was created in the AWS Support Center.</p>
        public let timeCreated: Swift.String?

        public init (
            caseId: Swift.String? = nil,
            categoryCode: Swift.String? = nil,
            ccEmailAddresses: [Swift.String]? = nil,
            displayId: Swift.String? = nil,
            language: Swift.String? = nil,
            recentCommunications: SupportClientTypes.RecentCaseCommunications? = nil,
            serviceCode: Swift.String? = nil,
            severityCode: Swift.String? = nil,
            status: Swift.String? = nil,
            subject: Swift.String? = nil,
            submittedBy: Swift.String? = nil,
            timeCreated: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.categoryCode = categoryCode
            self.ccEmailAddresses = ccEmailAddresses
            self.displayId = displayId
            self.language = language
            self.recentCommunications = recentCommunications
            self.serviceCode = serviceCode
            self.severityCode = severityCode
            self.status = status
            self.subject = subject
            self.submittedBy = submittedBy
            self.timeCreated = timeCreated
        }
    }

}

extension CaseIdNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseIdNotFound(message: \(Swift.String(describing: message)))"}
}

extension CaseIdNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CaseIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested <code>caseId</code> couldn't be located.</p>
public struct CaseIdNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The requested <code>CaseId</code> could not be located.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CaseIdNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CaseIdNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportClientTypes.Category: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SupportClientTypes.Category: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Category(code: \(Swift.String(describing: code)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// <p>A JSON-formatted name/value pair that represents the category name and category code
    ///             of the problem, selected from the <a>DescribeServices</a> response for each
    ///             AWS service.</p>
    public struct Category: Swift.Equatable {
        /// <p>The category code for the support case.</p>
        public let code: Swift.String?
        /// <p>The category name for the support case.</p>
        public let name: Swift.String?

        public init (
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }

}

extension SupportClientTypes.Communication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSet
        case body
        case caseId
        case submittedBy
        case timeCreated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSet = attachmentSet {
            var attachmentSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentSet)
            for attachmentset0 in attachmentSet {
                try attachmentSetContainer.encode(attachmentset0)
            }
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let submittedBy = submittedBy {
            try encodeContainer.encode(submittedBy, forKey: .submittedBy)
        }
        if let timeCreated = timeCreated {
            try encodeContainer.encode(timeCreated, forKey: .timeCreated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let submittedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .submittedBy)
        submittedBy = submittedByDecoded
        let timeCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeCreated)
        timeCreated = timeCreatedDecoded
        let attachmentSetContainer = try containerValues.decodeIfPresent([SupportClientTypes.AttachmentDetails?].self, forKey: .attachmentSet)
        var attachmentSetDecoded0:[SupportClientTypes.AttachmentDetails]? = nil
        if let attachmentSetContainer = attachmentSetContainer {
            attachmentSetDecoded0 = [SupportClientTypes.AttachmentDetails]()
            for structure0 in attachmentSetContainer {
                if let structure0 = structure0 {
                    attachmentSetDecoded0?.append(structure0)
                }
            }
        }
        attachmentSet = attachmentSetDecoded0
    }
}

extension SupportClientTypes.Communication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Communication(attachmentSet: \(Swift.String(describing: attachmentSet)), body: \(Swift.String(describing: body)), caseId: \(Swift.String(describing: caseId)), submittedBy: \(Swift.String(describing: submittedBy)), timeCreated: \(Swift.String(describing: timeCreated)))"}
}

extension SupportClientTypes {
    /// <p>A communication associated with a support case. The communication consists of the
    ///             case ID, the message body, attachment information, the submitter of the communication,
    ///             and the date and time of the communication.</p>
    public struct Communication: Swift.Equatable {
        /// <p>Information about the attachments to the case communication.</p>
        public let attachmentSet: [SupportClientTypes.AttachmentDetails]?
        /// <p>The text of the communication between the customer and AWS Support.</p>
        public let body: Swift.String?
        /// <p>The support case ID requested or returned in the call. The case ID is an
        ///             alphanumeric string formatted as shown in this example:
        ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
        ///         </p>
        public let caseId: Swift.String?
        /// <p>The identity of the account that submitted, or responded to, the support case.
        ///             Customer entries include the role or IAM user as well as the email address. For example,
        ///             "AdminRole (Role) <janedoe@example.com>. Entries from the AWS Support team display
        ///             "Amazon Web Services," and don't show an email address.
        ///             </p>
        public let submittedBy: Swift.String?
        /// <p>The time the communication was created.</p>
        public let timeCreated: Swift.String?

        public init (
            attachmentSet: [SupportClientTypes.AttachmentDetails]? = nil,
            body: Swift.String? = nil,
            caseId: Swift.String? = nil,
            submittedBy: Swift.String? = nil,
            timeCreated: Swift.String? = nil
        )
        {
            self.attachmentSet = attachmentSet
            self.body = body
            self.caseId = caseId
            self.submittedBy = submittedBy
            self.timeCreated = timeCreated
        }
    }

}

public struct CreateCaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

extension CreateCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCaseInput(attachmentSetId: \(Swift.String(describing: attachmentSetId)), categoryCode: \(Swift.String(describing: categoryCode)), ccEmailAddresses: \(Swift.String(describing: ccEmailAddresses)), communicationBody: \(Swift.String(describing: communicationBody)), issueType: \(Swift.String(describing: issueType)), language: \(Swift.String(describing: language)), serviceCode: \(Swift.String(describing: serviceCode)), severityCode: \(Swift.String(describing: severityCode)), subject: \(Swift.String(describing: subject)))"}
}

extension CreateCaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case categoryCode
        case ccEmailAddresses
        case communicationBody
        case issueType
        case language
        case serviceCode
        case severityCode
        case subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let categoryCode = categoryCode {
            try encodeContainer.encode(categoryCode, forKey: .categoryCode)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let communicationBody = communicationBody {
            try encodeContainer.encode(communicationBody, forKey: .communicationBody)
        }
        if let issueType = issueType {
            try encodeContainer.encode(issueType, forKey: .issueType)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let severityCode = severityCode {
            try encodeContainer.encode(severityCode, forKey: .severityCode)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }
}

public struct CreateCaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

public struct CreateCaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

public struct CreateCaseInput: Swift.Equatable {
    /// <p>The ID of a set of one or more attachments for the case. Create the set by using the
    ///                 <a>AddAttachmentsToSet</a> operation.</p>
    public let attachmentSetId: Swift.String?
    /// <p>The category of problem for the support case. You also use the <a>DescribeServices</a> operation to get the category code for a service. Each
    ///             AWS service defines its own set of category codes.</p>
    public let categoryCode: Swift.String?
    /// <p>A list of email addresses that AWS Support copies on case correspondence. AWS Support
    ///             identifies the account that creates the case when you specify your AWS credentials in an
    ///             HTTP POST method or use the <a href="http://aws.amazon.com/tools/">AWS SDKs</a>.
    ///         </p>
    public let ccEmailAddresses: [Swift.String]?
    /// <p>The communication body text that describes the issue. This text appears in the
    ///                 <b>Description</b> field on the AWS Support Center <a href="https://console.aws.amazon.com/support/home#/case/create">Create Case</a> page.</p>
    public let communicationBody: Swift.String?
    /// <p>The type of issue for the case. You can specify <code>customer-service</code> or
    ///                 <code>technical</code>. If you don't specify a value, the default is
    ///                 <code>technical</code>.</p>
    public let issueType: Swift.String?
    /// <p>The language in which AWS Support handles the case. You must specify the ISO 639-1
    ///             code for the <code>language</code> parameter if you want support in that language.
    ///             Currently, English ("en") and Japanese ("ja") are supported.</p>
    public let language: Swift.String?
    /// <p>The code for the AWS service. You can use the <a>DescribeServices</a>
    ///             operation to get the possible <code>serviceCode</code> values.</p>
    public let serviceCode: Swift.String?
    /// <p>A value that indicates the urgency of the case. This value determines the response
    ///             time according to your service level agreement with AWS Support. You can use the <a>DescribeSeverityLevels</a> operation to get the possible values for
    ///                 <code>severityCode</code>. </p>
    ///         <p>For more information, see <a>SeverityLevel</a> and <a href="https://docs.aws.amazon.com/awssupport/latest/user/getting-started.html#choosing-severity">Choosing a
    ///                 Severity</a> in the <i>AWS Support User Guide</i>.</p>
    ///         <note>
    ///             <p>The availability of severity levels depends on the support plan for the AWS
    ///                 account.</p>
    ///         </note>
    public let severityCode: Swift.String?
    /// <p>The title of the support case. The title appears in the <b>Subject</b> field on the AWS Support Center <a href="https://console.aws.amazon.com/support/home#/case/create">Create Case</a> page.</p>
    public let subject: Swift.String?

    public init (
        attachmentSetId: Swift.String? = nil,
        categoryCode: Swift.String? = nil,
        ccEmailAddresses: [Swift.String]? = nil,
        communicationBody: Swift.String? = nil,
        issueType: Swift.String? = nil,
        language: Swift.String? = nil,
        serviceCode: Swift.String? = nil,
        severityCode: Swift.String? = nil,
        subject: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.categoryCode = categoryCode
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
        self.issueType = issueType
        self.language = language
        self.serviceCode = serviceCode
        self.severityCode = severityCode
        self.subject = subject
    }
}

struct CreateCaseInputBody: Swift.Equatable {
    public let subject: Swift.String?
    public let serviceCode: Swift.String?
    public let severityCode: Swift.String?
    public let categoryCode: Swift.String?
    public let communicationBody: Swift.String?
    public let ccEmailAddresses: [Swift.String]?
    public let language: Swift.String?
    public let issueType: Swift.String?
    public let attachmentSetId: Swift.String?
}

extension CreateCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case categoryCode
        case ccEmailAddresses
        case communicationBody
        case issueType
        case language
        case serviceCode
        case severityCode
        case subject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let severityCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severityCode)
        severityCode = severityCodeDecoded
        let categoryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryCode)
        categoryCode = categoryCodeDecoded
        let communicationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .communicationBody)
        communicationBody = communicationBodyDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[Swift.String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [Swift.String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let issueTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issueType)
        issueType = issueTypeDecoded
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
    }
}

extension CreateCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CaseCreationLimitExceeded" : self = .caseCreationLimitExceeded(try CaseCreationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCaseOutputError: Swift.Error, Swift.Equatable {
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case caseCreationLimitExceeded(CaseCreationLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCaseOutputResponse(caseId: \(Swift.String(describing: caseId)))"}
}

extension CreateCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.caseId = output.caseId
        } else {
            self.caseId = nil
        }
    }
}

/// <p>The support case ID returned by a successful completion of the <a>CreateCase</a> operation.</p>
public struct CreateCaseOutputResponse: Swift.Equatable {
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string in the following format:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: Swift.String?

    public init (
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

struct CreateCaseOutputResponseBody: Swift.Equatable {
    public let caseId: Swift.String?
}

extension CreateCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
    }
}

public struct DescribeAttachmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

extension DescribeAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension DescribeAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
    }
}

public struct DescribeAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInput: Swift.Equatable {
    /// <p>The ID of the attachment to return. Attachment IDs are returned by the <a>DescribeCommunications</a> operation.</p>
    public let attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct DescribeAttachmentInputBody: Swift.Equatable {
    public let attachmentId: Swift.String?
}

extension DescribeAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
    }
}

extension DescribeAttachmentLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAttachmentLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension DescribeAttachmentLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttachmentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit for the number of <a>DescribeAttachment</a> requests in a short
///             period of time has been exceeded.</p>
public struct DescribeAttachmentLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The limit for the number of <a>DescribeAttachment</a> requests in a short
    ///             period of time has been exceeded.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DescribeAttachmentLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DescribeAttachmentLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentIdNotFound" : self = .attachmentIdNotFound(try AttachmentIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DescribeAttachmentLimitExceeded" : self = .describeAttachmentLimitExceeded(try DescribeAttachmentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAttachmentOutputError: Swift.Error, Swift.Equatable {
    case attachmentIdNotFound(AttachmentIdNotFound)
    case describeAttachmentLimitExceeded(DescribeAttachmentLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAttachmentOutputResponse(attachment: \(Swift.String(describing: attachment)))"}
}

extension DescribeAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

/// <p>The content and file name of the attachment returned by the <a>DescribeAttachment</a> operation.</p>
public struct DescribeAttachmentOutputResponse: Swift.Equatable {
    /// <p>This object includes the attachment content and file name.</p>
    ///         <p>In the previous response syntax, the value for the <code>data</code> parameter appears
    ///             as <code>blob</code>, which is represented as a base64-encoded string. The value for
    ///                 <code>fileName</code> is the name of the attachment, such as
    ///                 <code>troubleshoot-screenshot.png</code>.</p>
    public let attachment: SupportClientTypes.Attachment?

    public init (
        attachment: SupportClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct DescribeAttachmentOutputResponseBody: Swift.Equatable {
    public let attachment: SupportClientTypes.Attachment?
}

extension DescribeAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(SupportClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

public struct DescribeCasesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

extension DescribeCasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCasesInput(afterTime: \(Swift.String(describing: afterTime)), beforeTime: \(Swift.String(describing: beforeTime)), caseIdList: \(Swift.String(describing: caseIdList)), displayId: \(Swift.String(describing: displayId)), includeCommunications: \(Swift.String(describing: includeCommunications)), includeResolvedCases: \(Swift.String(describing: includeResolvedCases)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCasesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseIdList
        case displayId
        case includeCommunications
        case includeResolvedCases
        case language
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterTime = afterTime {
            try encodeContainer.encode(afterTime, forKey: .afterTime)
        }
        if let beforeTime = beforeTime {
            try encodeContainer.encode(beforeTime, forKey: .beforeTime)
        }
        if let caseIdList = caseIdList {
            var caseIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .caseIdList)
            for caseidlist0 in caseIdList {
                try caseIdListContainer.encode(caseidlist0)
            }
        }
        if let displayId = displayId {
            try encodeContainer.encode(displayId, forKey: .displayId)
        }
        if let includeCommunications = includeCommunications {
            try encodeContainer.encode(includeCommunications, forKey: .includeCommunications)
        }
        if includeResolvedCases != false {
            try encodeContainer.encode(includeResolvedCases, forKey: .includeResolvedCases)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInput: Swift.Equatable {
    /// <p>The start date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let afterTime: Swift.String?
    /// <p>The end date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let beforeTime: Swift.String?
    /// <p>A list of ID numbers of the support cases you want returned. The maximum number of
    ///             cases is 100.</p>
    public let caseIdList: [Swift.String]?
    /// <p>The ID displayed for a case in the AWS Support Center user interface.</p>
    public let displayId: Swift.String?
    /// <p>Specifies whether to include communications in the <code>DescribeCases</code>
    ///             response. By default, communications are included.</p>
    public let includeCommunications: Swift.Bool?
    /// <p>Specifies whether to include resolved support cases in the <code>DescribeCases</code>
    ///             response. By default, resolved cases aren't included.</p>
    public let includeResolvedCases: Swift.Bool
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: Swift.String?
    /// <p>The maximum number of results to return before paginating.</p>
    public let maxResults: Swift.Int?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: Swift.String?

    public init (
        afterTime: Swift.String? = nil,
        beforeTime: Swift.String? = nil,
        caseIdList: [Swift.String]? = nil,
        displayId: Swift.String? = nil,
        includeCommunications: Swift.Bool? = nil,
        includeResolvedCases: Swift.Bool = false,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseIdList = caseIdList
        self.displayId = displayId
        self.includeCommunications = includeCommunications
        self.includeResolvedCases = includeResolvedCases
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCasesInputBody: Swift.Equatable {
    public let caseIdList: [Swift.String]?
    public let displayId: Swift.String?
    public let afterTime: Swift.String?
    public let beforeTime: Swift.String?
    public let includeResolvedCases: Swift.Bool
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let language: Swift.String?
    public let includeCommunications: Swift.Bool?
}

extension DescribeCasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseIdList
        case displayId
        case includeCommunications
        case includeResolvedCases
        case language
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .caseIdList)
        var caseIdListDecoded0:[Swift.String]? = nil
        if let caseIdListContainer = caseIdListContainer {
            caseIdListDecoded0 = [Swift.String]()
            for string0 in caseIdListContainer {
                if let string0 = string0 {
                    caseIdListDecoded0?.append(string0)
                }
            }
        }
        caseIdList = caseIdListDecoded0
        let displayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayId)
        displayId = displayIdDecoded
        let afterTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterTime)
        afterTime = afterTimeDecoded
        let beforeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeTime)
        beforeTime = beforeTimeDecoded
        let includeResolvedCasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeResolvedCases)
        includeResolvedCases = includeResolvedCasesDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let includeCommunicationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCommunications)
        includeCommunications = includeCommunicationsDecoded
    }
}

extension DescribeCasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCasesOutputError: Swift.Error, Swift.Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCasesOutputResponse(cases: \(Swift.String(describing: cases)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cases = output.cases
            self.nextToken = output.nextToken
        } else {
            self.cases = nil
            self.nextToken = nil
        }
    }
}

/// <p>Returns an array of <a href="https://docs.aws.amazon.com/awssupport/latest/APIReference/API_CaseDetails.html">CaseDetails</a>
///             objects and a <code>nextToken</code> that defines a point for pagination in the result
///             set.</p>
public struct DescribeCasesOutputResponse: Swift.Equatable {
    /// <p>The details for the cases that match the request.</p>
    public let cases: [SupportClientTypes.CaseDetails]?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: Swift.String?

    public init (
        cases: [SupportClientTypes.CaseDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

struct DescribeCasesOutputResponseBody: Swift.Equatable {
    public let cases: [SupportClientTypes.CaseDetails]?
    public let nextToken: Swift.String?
}

extension DescribeCasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cases
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let casesContainer = try containerValues.decodeIfPresent([SupportClientTypes.CaseDetails?].self, forKey: .cases)
        var casesDecoded0:[SupportClientTypes.CaseDetails]? = nil
        if let casesContainer = casesContainer {
            casesDecoded0 = [SupportClientTypes.CaseDetails]()
            for structure0 in casesContainer {
                if let structure0 = structure0 {
                    casesDecoded0?.append(structure0)
                }
            }
        }
        cases = casesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeCommunicationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

extension DescribeCommunicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommunicationsInput(afterTime: \(Swift.String(describing: afterTime)), beforeTime: \(Swift.String(describing: beforeTime)), caseId: \(Swift.String(describing: caseId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCommunicationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterTime = afterTime {
            try encodeContainer.encode(afterTime, forKey: .afterTime)
        }
        if let beforeTime = beforeTime {
            try encodeContainer.encode(beforeTime, forKey: .beforeTime)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCommunicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInput: Swift.Equatable {
    /// <p>The start date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let afterTime: Swift.String?
    /// <p>The end date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let beforeTime: Swift.String?
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: Swift.String?
    /// <p>The maximum number of results to return before paginating.</p>
    public let maxResults: Swift.Int?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: Swift.String?

    public init (
        afterTime: Swift.String? = nil,
        beforeTime: Swift.String? = nil,
        caseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseId = caseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCommunicationsInputBody: Swift.Equatable {
    public let caseId: Swift.String?
    public let beforeTime: Swift.String?
    public let afterTime: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeCommunicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseId
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let beforeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeTime)
        beforeTime = beforeTimeDecoded
        let afterTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterTime)
        afterTime = afterTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCommunicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCommunicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCommunicationsOutputError: Swift.Error, Swift.Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCommunicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommunicationsOutputResponse(communications: \(Swift.String(describing: communications)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCommunicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCommunicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.communications = output.communications
            self.nextToken = output.nextToken
        } else {
            self.communications = nil
            self.nextToken = nil
        }
    }
}

/// <p>The communications returned by the <a>DescribeCommunications</a>
///             operation.</p>
public struct DescribeCommunicationsOutputResponse: Swift.Equatable {
    /// <p>The communications for the case.</p>
    public let communications: [SupportClientTypes.Communication]?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: Swift.String?

    public init (
        communications: [SupportClientTypes.Communication]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.communications = communications
        self.nextToken = nextToken
    }
}

struct DescribeCommunicationsOutputResponseBody: Swift.Equatable {
    public let communications: [SupportClientTypes.Communication]?
    public let nextToken: Swift.String?
}

extension DescribeCommunicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case communications
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let communicationsContainer = try containerValues.decodeIfPresent([SupportClientTypes.Communication?].self, forKey: .communications)
        var communicationsDecoded0:[SupportClientTypes.Communication]? = nil
        if let communicationsContainer = communicationsContainer {
            communicationsDecoded0 = [SupportClientTypes.Communication]()
            for structure0 in communicationsContainer {
                if let structure0 = structure0 {
                    communicationsDecoded0?.append(structure0)
                }
            }
        }
        communications = communicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

extension DescribeServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServicesInput(language: \(Swift.String(describing: language)), serviceCodeList: \(Swift.String(describing: serviceCodeList)))"}
}

extension DescribeServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
        case serviceCodeList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let serviceCodeList = serviceCodeList {
            var serviceCodeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceCodeList)
            for servicecodelist0 in serviceCodeList {
                try serviceCodeListContainer.encode(servicecodelist0)
            }
        }
    }
}

public struct DescribeServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInput: Swift.Equatable {
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: Swift.String?
    /// <p>A JSON-formatted list of service codes available for AWS services.</p>
    public let serviceCodeList: [Swift.String]?

    public init (
        language: Swift.String? = nil,
        serviceCodeList: [Swift.String]? = nil
    )
    {
        self.language = language
        self.serviceCodeList = serviceCodeList
    }
}

struct DescribeServicesInputBody: Swift.Equatable {
    public let serviceCodeList: [Swift.String]?
    public let language: Swift.String?
}

extension DescribeServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
        case serviceCodeList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceCodeList)
        var serviceCodeListDecoded0:[Swift.String]? = nil
        if let serviceCodeListContainer = serviceCodeListContainer {
            serviceCodeListDecoded0 = [Swift.String]()
            for string0 in serviceCodeListContainer {
                if let string0 = string0 {
                    serviceCodeListDecoded0?.append(string0)
                }
            }
        }
        serviceCodeList = serviceCodeListDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServicesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServicesOutputResponse(services: \(Swift.String(describing: services)))"}
}

extension DescribeServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.services = output.services
        } else {
            self.services = nil
        }
    }
}

/// <p>The list of AWS services returned by the <a>DescribeServices</a>
///             operation.</p>
public struct DescribeServicesOutputResponse: Swift.Equatable {
    /// <p>A JSON-formatted list of AWS services.</p>
    public let services: [SupportClientTypes.Service]?

    public init (
        services: [SupportClientTypes.Service]? = nil
    )
    {
        self.services = services
    }
}

struct DescribeServicesOutputResponseBody: Swift.Equatable {
    public let services: [SupportClientTypes.Service]?
}

extension DescribeServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case services
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([SupportClientTypes.Service?].self, forKey: .services)
        var servicesDecoded0:[SupportClientTypes.Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [SupportClientTypes.Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

public struct DescribeSeverityLevelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

extension DescribeSeverityLevelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSeverityLevelsInput(language: \(Swift.String(describing: language)))"}
}

extension DescribeSeverityLevelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeSeverityLevelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInput: Swift.Equatable {
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: Swift.String?

    public init (
        language: Swift.String? = nil
    )
    {
        self.language = language
    }
}

struct DescribeSeverityLevelsInputBody: Swift.Equatable {
    public let language: Swift.String?
}

extension DescribeSeverityLevelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeSeverityLevelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSeverityLevelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSeverityLevelsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSeverityLevelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSeverityLevelsOutputResponse(severityLevels: \(Swift.String(describing: severityLevels)))"}
}

extension DescribeSeverityLevelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSeverityLevelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.severityLevels = output.severityLevels
        } else {
            self.severityLevels = nil
        }
    }
}

/// <p>The list of severity levels returned by the <a>DescribeSeverityLevels</a>
///             operation.</p>
public struct DescribeSeverityLevelsOutputResponse: Swift.Equatable {
    /// <p>The available severity levels for the support case. Available severity levels are
    ///             defined by your service level agreement with AWS.</p>
    public let severityLevels: [SupportClientTypes.SeverityLevel]?

    public init (
        severityLevels: [SupportClientTypes.SeverityLevel]? = nil
    )
    {
        self.severityLevels = severityLevels
    }
}

struct DescribeSeverityLevelsOutputResponseBody: Swift.Equatable {
    public let severityLevels: [SupportClientTypes.SeverityLevel]?
}

extension DescribeSeverityLevelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case severityLevels
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severityLevelsContainer = try containerValues.decodeIfPresent([SupportClientTypes.SeverityLevel?].self, forKey: .severityLevels)
        var severityLevelsDecoded0:[SupportClientTypes.SeverityLevel]? = nil
        if let severityLevelsContainer = severityLevelsContainer {
            severityLevelsDecoded0 = [SupportClientTypes.SeverityLevel]()
            for structure0 in severityLevelsContainer {
                if let structure0 = structure0 {
                    severityLevelsDecoded0?.append(structure0)
                }
            }
        }
        severityLevels = severityLevelsDecoded0
    }
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckRefreshStatusesInput(checkIds: \(Swift.String(describing: checkIds)))"}
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkIds = checkIds {
            var checkIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkIds)
            for stringlist0 in checkIds {
                try checkIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInput: Swift.Equatable {
    /// <p>The IDs of the Trusted Advisor checks to get the status.</p>
    ///         <note>
    ///             <p>If you specify the check ID of a check that is automatically refreshed, you might
    ///                 see an <code>InvalidParameterValue</code> error.</p>
    ///         </note>
    public let checkIds: [Swift.String]?

    public init (
        checkIds: [Swift.String]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

struct DescribeTrustedAdvisorCheckRefreshStatusesInputBody: Swift.Equatable {
    public let checkIds: [Swift.String]?
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .checkIds)
        var checkIdsDecoded0:[Swift.String]? = nil
        if let checkIdsContainer = checkIdsContainer {
            checkIdsDecoded0 = [Swift.String]()
            for string0 in checkIdsContainer {
                if let string0 = string0 {
                    checkIdsDecoded0?.append(string0)
                }
            }
        }
        checkIds = checkIdsDecoded0
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckRefreshStatusesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse(statuses: \(Swift.String(describing: statuses)))"}
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statuses = output.statuses
        } else {
            self.statuses = nil
        }
    }
}

/// <p>The statuses of the Trusted Advisor checks returned by the <a>DescribeTrustedAdvisorCheckRefreshStatuses</a> operation.</p>
public struct DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: Swift.Equatable {
    /// <p>The refresh status of the specified Trusted Advisor checks.</p>
    public let statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]?

    public init (
        statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]? = nil
    )
    {
        self.statuses = statuses
    }
}

struct DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody: Swift.Equatable {
    public let statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]?
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statuses
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusesContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorCheckRefreshStatus?].self, forKey: .statuses)
        var statusesDecoded0:[SupportClientTypes.TrustedAdvisorCheckRefreshStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]()
            for structure0 in statusesContainer {
                if let structure0 = structure0 {
                    statusesDecoded0?.append(structure0)
                }
            }
        }
        statuses = statusesDecoded0
    }
}

public struct DescribeTrustedAdvisorCheckResultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

extension DescribeTrustedAdvisorCheckResultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckResultInput(checkId: \(Swift.String(describing: checkId)), language: \(Swift.String(describing: language)))"}
}

extension DescribeTrustedAdvisorCheckResultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
        case language
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeTrustedAdvisorCheckResultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

public struct DescribeTrustedAdvisorCheckResultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

/// <p></p>
public struct DescribeTrustedAdvisorCheckResultInput: Swift.Equatable {
    /// <p>The unique identifier for the Trusted Advisor check.</p>
    public let checkId: Swift.String?
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: Swift.String?

    public init (
        checkId: Swift.String? = nil,
        language: Swift.String? = nil
    )
    {
        self.checkId = checkId
        self.language = language
    }
}

struct DescribeTrustedAdvisorCheckResultInputBody: Swift.Equatable {
    public let checkId: Swift.String?
    public let language: Swift.String?
}

extension DescribeTrustedAdvisorCheckResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
        case language
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeTrustedAdvisorCheckResultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckResultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckResultOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckResultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckResultOutputResponse(result: \(Swift.String(describing: result)))"}
}

extension DescribeTrustedAdvisorCheckResultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckResultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

/// <p>The result of the Trusted Advisor check returned by the <a>DescribeTrustedAdvisorCheckResult</a> operation.</p>
public struct DescribeTrustedAdvisorCheckResultOutputResponse: Swift.Equatable {
    /// <p>The detailed results of the Trusted Advisor check.</p>
    public let result: SupportClientTypes.TrustedAdvisorCheckResult?

    public init (
        result: SupportClientTypes.TrustedAdvisorCheckResult? = nil
    )
    {
        self.result = result
    }
}

struct DescribeTrustedAdvisorCheckResultOutputResponseBody: Swift.Equatable {
    public let result: SupportClientTypes.TrustedAdvisorCheckResult?
}

extension DescribeTrustedAdvisorCheckResultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCheckResult.self, forKey: .result)
        result = resultDecoded
    }
}

public struct DescribeTrustedAdvisorCheckSummariesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

extension DescribeTrustedAdvisorCheckSummariesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckSummariesInput(checkIds: \(Swift.String(describing: checkIds)))"}
}

extension DescribeTrustedAdvisorCheckSummariesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkIds = checkIds {
            var checkIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkIds)
            for stringlist0 in checkIds {
                try checkIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct DescribeTrustedAdvisorCheckSummariesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInput: Swift.Equatable {
    /// <p>The IDs of the Trusted Advisor checks.</p>
    public let checkIds: [Swift.String]?

    public init (
        checkIds: [Swift.String]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

struct DescribeTrustedAdvisorCheckSummariesInputBody: Swift.Equatable {
    public let checkIds: [Swift.String]?
}

extension DescribeTrustedAdvisorCheckSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .checkIds)
        var checkIdsDecoded0:[Swift.String]? = nil
        if let checkIdsContainer = checkIdsContainer {
            checkIdsDecoded0 = [Swift.String]()
            for string0 in checkIdsContainer {
                if let string0 = string0 {
                    checkIdsDecoded0?.append(string0)
                }
            }
        }
        checkIds = checkIdsDecoded0
    }
}

extension DescribeTrustedAdvisorCheckSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckSummariesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckSummariesOutputResponse(summaries: \(Swift.String(describing: summaries)))"}
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summaries = output.summaries
        } else {
            self.summaries = nil
        }
    }
}

/// <p>The summaries of the Trusted Advisor checks returned by the <a>DescribeTrustedAdvisorCheckSummaries</a> operation.</p>
public struct DescribeTrustedAdvisorCheckSummariesOutputResponse: Swift.Equatable {
    /// <p>The summary information for the requested Trusted Advisor checks.</p>
    public let summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]?

    public init (
        summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]? = nil
    )
    {
        self.summaries = summaries
    }
}

struct DescribeTrustedAdvisorCheckSummariesOutputResponseBody: Swift.Equatable {
    public let summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]?
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorCheckSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SupportClientTypes.TrustedAdvisorCheckSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SupportClientTypes.TrustedAdvisorCheckSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

public struct DescribeTrustedAdvisorChecksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

extension DescribeTrustedAdvisorChecksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorChecksInput(language: \(Swift.String(describing: language)))"}
}

extension DescribeTrustedAdvisorChecksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeTrustedAdvisorChecksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInput: Swift.Equatable {
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: Swift.String?

    public init (
        language: Swift.String? = nil
    )
    {
        self.language = language
    }
}

struct DescribeTrustedAdvisorChecksInputBody: Swift.Equatable {
    public let language: Swift.String?
}

extension DescribeTrustedAdvisorChecksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeTrustedAdvisorChecksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorChecksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorChecksOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorChecksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorChecksOutputResponse(checks: \(Swift.String(describing: checks)))"}
}

extension DescribeTrustedAdvisorChecksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorChecksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.checks = output.checks
        } else {
            self.checks = nil
        }
    }
}

/// <p>Information about the Trusted Advisor checks returned by the <a>DescribeTrustedAdvisorChecks</a> operation.</p>
public struct DescribeTrustedAdvisorChecksOutputResponse: Swift.Equatable {
    /// <p>Information about all available Trusted Advisor checks.</p>
    public let checks: [SupportClientTypes.TrustedAdvisorCheckDescription]?

    public init (
        checks: [SupportClientTypes.TrustedAdvisorCheckDescription]? = nil
    )
    {
        self.checks = checks
    }
}

struct DescribeTrustedAdvisorChecksOutputResponseBody: Swift.Equatable {
    public let checks: [SupportClientTypes.TrustedAdvisorCheckDescription]?
}

extension DescribeTrustedAdvisorChecksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checksContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorCheckDescription?].self, forKey: .checks)
        var checksDecoded0:[SupportClientTypes.TrustedAdvisorCheckDescription]? = nil
        if let checksContainer = checksContainer {
            checksDecoded0 = [SupportClientTypes.TrustedAdvisorCheckDescription]()
            for structure0 in checksContainer {
                if let structure0 = structure0 {
                    checksDecoded0?.append(structure0)
                }
            }
        }
        checks = checksDecoded0
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(message: \(Swift.String(describing: message)))"}
}

extension InternalServerError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>An internal server error occurred.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportClientTypes.RecentCaseCommunications: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case communications
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let communications = communications {
            var communicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .communications)
            for communicationlist0 in communications {
                try communicationsContainer.encode(communicationlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let communicationsContainer = try containerValues.decodeIfPresent([SupportClientTypes.Communication?].self, forKey: .communications)
        var communicationsDecoded0:[SupportClientTypes.Communication]? = nil
        if let communicationsContainer = communicationsContainer {
            communicationsDecoded0 = [SupportClientTypes.Communication]()
            for structure0 in communicationsContainer {
                if let structure0 = structure0 {
                    communicationsDecoded0?.append(structure0)
                }
            }
        }
        communications = communicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SupportClientTypes.RecentCaseCommunications: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecentCaseCommunications(communications: \(Swift.String(describing: communications)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension SupportClientTypes {
    /// <p>The five most recent communications associated with the case.</p>
    public struct RecentCaseCommunications: Swift.Equatable {
        /// <p>The five most recent communications associated with the case.</p>
        public let communications: [SupportClientTypes.Communication]?
        /// <p>A resumption point for pagination.</p>
        public let nextToken: Swift.String?

        public init (
            communications: [SupportClientTypes.Communication]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.communications = communications
            self.nextToken = nextToken
        }
    }

}

public struct RefreshTrustedAdvisorCheckInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

extension RefreshTrustedAdvisorCheckInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTrustedAdvisorCheckInput(checkId: \(Swift.String(describing: checkId)))"}
}

extension RefreshTrustedAdvisorCheckInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
    }
}

public struct RefreshTrustedAdvisorCheckInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

public struct RefreshTrustedAdvisorCheckInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

/// <p></p>
public struct RefreshTrustedAdvisorCheckInput: Swift.Equatable {
    /// <p>The unique identifier for the Trusted Advisor check to refresh.</p>
    ///             <note>
    ///                 <p>Specifying the check ID of a check that is automatically refreshed
    ///                     causes an <code>InvalidParameterValue</code> error.</p>
    ///             </note>
    public let checkId: Swift.String?

    public init (
        checkId: Swift.String? = nil
    )
    {
        self.checkId = checkId
    }
}

struct RefreshTrustedAdvisorCheckInputBody: Swift.Equatable {
    public let checkId: Swift.String?
}

extension RefreshTrustedAdvisorCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
    }
}

extension RefreshTrustedAdvisorCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshTrustedAdvisorCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshTrustedAdvisorCheckOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshTrustedAdvisorCheckOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTrustedAdvisorCheckOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension RefreshTrustedAdvisorCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RefreshTrustedAdvisorCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>The current refresh status of a Trusted Advisor check.</p>
public struct RefreshTrustedAdvisorCheckOutputResponse: Swift.Equatable {
    /// <p>The current refresh status for a check, including the amount of time until the check
    ///             is eligible for refresh.</p>
    public let status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus?

    public init (
        status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus? = nil
    )
    {
        self.status = status
    }
}

struct RefreshTrustedAdvisorCheckOutputResponseBody: Swift.Equatable {
    public let status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus?
}

extension RefreshTrustedAdvisorCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCheckRefreshStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct ResolveCaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

extension ResolveCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveCaseInput(caseId: \(Swift.String(describing: caseId)))"}
}

extension ResolveCaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
    }
}

public struct ResolveCaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInput: Swift.Equatable {
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: Swift.String?

    public init (
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

struct ResolveCaseInputBody: Swift.Equatable {
    public let caseId: Swift.String?
}

extension ResolveCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
    }
}

extension ResolveCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveCaseOutputError: Swift.Error, Swift.Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveCaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveCaseOutputResponse(finalCaseStatus: \(Swift.String(describing: finalCaseStatus)), initialCaseStatus: \(Swift.String(describing: initialCaseStatus)))"}
}

extension ResolveCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.finalCaseStatus = output.finalCaseStatus
            self.initialCaseStatus = output.initialCaseStatus
        } else {
            self.finalCaseStatus = nil
            self.initialCaseStatus = nil
        }
    }
}

/// <p>The status of the case returned by the <a>ResolveCase</a> operation.</p>
public struct ResolveCaseOutputResponse: Swift.Equatable {
    /// <p>The status of the case after the <a>ResolveCase</a> request was
    ///             processed.</p>
    public let finalCaseStatus: Swift.String?
    /// <p>The status of the case when the <a>ResolveCase</a> request was sent.</p>
    public let initialCaseStatus: Swift.String?

    public init (
        finalCaseStatus: Swift.String? = nil,
        initialCaseStatus: Swift.String? = nil
    )
    {
        self.finalCaseStatus = finalCaseStatus
        self.initialCaseStatus = initialCaseStatus
    }
}

struct ResolveCaseOutputResponseBody: Swift.Equatable {
    public let initialCaseStatus: Swift.String?
    public let finalCaseStatus: Swift.String?
}

extension ResolveCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalCaseStatus
        case initialCaseStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialCaseStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialCaseStatus)
        initialCaseStatus = initialCaseStatusDecoded
        let finalCaseStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalCaseStatus)
        finalCaseStatus = finalCaseStatusDecoded
    }
}

extension SupportClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categories
        case code
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for categorylist0 in categories {
                try categoriesContainer.encode(categorylist0)
            }
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([SupportClientTypes.Category?].self, forKey: .categories)
        var categoriesDecoded0:[SupportClientTypes.Category]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [SupportClientTypes.Category]()
            for structure0 in categoriesContainer {
                if let structure0 = structure0 {
                    categoriesDecoded0?.append(structure0)
                }
            }
        }
        categories = categoriesDecoded0
    }
}

extension SupportClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(categories: \(Swift.String(describing: categories)), code: \(Swift.String(describing: code)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// <p>Information about an AWS service returned by the <a>DescribeServices</a>
    ///             operation.</p>
    public struct Service: Swift.Equatable {
        /// <p>A list of categories that describe the type of support issue a case describes.
        ///             Categories consist of a category name and a category code. Category names and codes are
        ///             passed to AWS Support when you call <a>CreateCase</a>.</p>
        public let categories: [SupportClientTypes.Category]?
        /// <p>The code for an AWS service returned by the <a>DescribeServices</a>
        ///             response. The <code>name</code> element contains the corresponding friendly name.</p>
        public let code: Swift.String?
        /// <p>The friendly name for an AWS service. The <code>code</code> element contains the
        ///             corresponding code.</p>
        public let name: Swift.String?

        public init (
            categories: [SupportClientTypes.Category]? = nil,
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.categories = categories
            self.code = code
            self.name = name
        }
    }

}

extension SupportClientTypes.SeverityLevel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SupportClientTypes.SeverityLevel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SeverityLevel(code: \(Swift.String(describing: code)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// <p>A code and name pair that represents the severity level of a support case. The
    ///             available values depend on the support plan for the account. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity">Choosing a
    ///                 severity</a> in the <i>AWS Support User Guide</i>.</p>
    public struct SeverityLevel: Swift.Equatable {
        /// <p>The code for case severity level.</p>
        ///         <p>Valid values: <code>low</code> | <code>normal</code> | <code>high</code> |
        ///                 <code>urgent</code> | <code>critical</code>
        ///          </p>
        public let code: Swift.String?
        /// <p>The name of the severity level that corresponds to the severity level code.</p>
        ///         <note>
        ///             <p>The values returned by the API are different from the values that appear in the
        ///                 AWS Support Center. For example, the API uses the code <code>low</code>, but the name
        ///                 appears as General guidance in Support Center. </p>
        ///             <p>The following are the API code names and how they appear in the console:</p>
        ///             <ul>
        ///                <li>
        ///                     <p>
        ///                      <code>low</code> - General guidance</p>
        ///                 </li>
        ///                <li>
        ///                     <p>
        ///                      <code>normal</code> - System impaired</p>
        ///                 </li>
        ///                <li>
        ///                     <p>
        ///                      <code>high</code> - Production system impaired</p>
        ///                 </li>
        ///                <li>
        ///                     <p>
        ///                      <code>urgent</code> - Production system down</p>
        ///                 </li>
        ///                <li>
        ///                     <p>
        ///                      <code>critical</code> - Business-critical system down</p>
        ///                 </li>
        ///             </ul>
        ///         </note>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity">Choosing a
        ///                 severity</a> in the <i>AWS Support User Guide</i>.</p>
        public let name: Swift.String?

        public init (
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCategorySpecificSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costOptimizing
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costOptimizing = costOptimizing {
            try encodeContainer.encode(costOptimizing, forKey: .costOptimizing)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costOptimizingDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCostOptimizingSummary.self, forKey: .costOptimizing)
        costOptimizing = costOptimizingDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCategorySpecificSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCategorySpecificSummary(costOptimizing: \(Swift.String(describing: costOptimizing)))"}
}

extension SupportClientTypes {
    /// <p>The container for summary information that relates to the category of the Trusted Advisor check.</p>
    public struct TrustedAdvisorCategorySpecificSummary: Swift.Equatable {
        /// <p>The summary information about cost savings for a Trusted Advisor check that is in the
        ///             Cost Optimizing category.</p>
        public let costOptimizing: SupportClientTypes.TrustedAdvisorCostOptimizingSummary?

        public init (
            costOptimizing: SupportClientTypes.TrustedAdvisorCostOptimizingSummary? = nil
        )
        {
            self.costOptimizing = costOptimizing
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case description
        case id
        case metadata
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for stringlist0 in metadata {
                try metadataContainer.encode(stringlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metadata)
        var metadataDecoded0:[Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String]()
            for string0 in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?.append(string0)
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension SupportClientTypes.TrustedAdvisorCheckDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckDescription(category: \(Swift.String(describing: category)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// <p>The description and metadata for a Trusted Advisor check.</p>
    public struct TrustedAdvisorCheckDescription: Swift.Equatable {
        /// <p>The category of the Trusted Advisor check.</p>
        public let category: Swift.String?
        /// <p>The description of the Trusted Advisor check, which includes the alert criteria and
        ///             recommended operations (contains HTML markup).</p>
        public let description: Swift.String?
        /// <p>The unique identifier for the Trusted Advisor check.</p>
        public let id: Swift.String?
        /// <p>The column headings for the data returned by the Trusted Advisor check. The order of
        ///             the headings corresponds to the order of the data in the <b>Metadata</b> element of the <a>TrustedAdvisorResourceDetail</a>
        ///             for the check. <b>Metadata</b> contains all the data that is
        ///             shown in the Excel download, even in those cases where the UI shows just summary data.
        ///         </p>
        public let metadata: [Swift.String]?
        /// <p>The display name for the Trusted Advisor check.</p>
        public let name: Swift.String?

        public init (
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.description = description
            self.id = id
            self.metadata = metadata
            self.name = name
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckRefreshStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
        case millisUntilNextRefreshable
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if millisUntilNextRefreshable != 0 {
            try encodeContainer.encode(millisUntilNextRefreshable, forKey: .millisUntilNextRefreshable)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let millisUntilNextRefreshableDecoded = try containerValues.decode(Swift.Int.self, forKey: .millisUntilNextRefreshable)
        millisUntilNextRefreshable = millisUntilNextRefreshableDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCheckRefreshStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckRefreshStatus(checkId: \(Swift.String(describing: checkId)), millisUntilNextRefreshable: \(Swift.String(describing: millisUntilNextRefreshable)), status: \(Swift.String(describing: status)))"}
}

extension SupportClientTypes {
    /// <p>The refresh status of a Trusted Advisor check.</p>
    public struct TrustedAdvisorCheckRefreshStatus: Swift.Equatable {
        /// <p>The unique identifier for the Trusted Advisor check.</p>
        public let checkId: Swift.String?
        /// <p>The amount of time, in milliseconds, until the Trusted Advisor check is eligible for
        ///             refresh.</p>
        public let millisUntilNextRefreshable: Swift.Int
        /// <p>The status of the Trusted Advisor check for which a refresh has been requested:
        ///             </p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <code>none</code> - The check is not refreshed or the non-success status
        ///                     exceeds the timeout</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>enqueued</code> - The check refresh requests has entered the refresh
        ///                     queue</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>processing</code> - The check refresh request is picked up by the rule
        ///                     processing engine</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>success</code> - The check is successfully refreshed</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>abandoned</code> - The check refresh has failed</p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?

        public init (
            checkId: Swift.String? = nil,
            millisUntilNextRefreshable: Swift.Int = 0,
            status: Swift.String? = nil
        )
        {
            self.checkId = checkId
            self.millisUntilNextRefreshable = millisUntilNextRefreshable
            self.status = status
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categorySpecificSummary
        case checkId
        case flaggedResources
        case resourcesSummary
        case status
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySpecificSummary = categorySpecificSummary {
            try encodeContainer.encode(categorySpecificSummary, forKey: .categorySpecificSummary)
        }
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if let flaggedResources = flaggedResources {
            var flaggedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .flaggedResources)
            for trustedadvisorresourcedetaillist0 in flaggedResources {
                try flaggedResourcesContainer.encode(trustedadvisorresourcedetaillist0)
            }
        }
        if let resourcesSummary = resourcesSummary {
            try encodeContainer.encode(resourcesSummary, forKey: .resourcesSummary)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let resourcesSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorResourcesSummary.self, forKey: .resourcesSummary)
        resourcesSummary = resourcesSummaryDecoded
        let categorySpecificSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCategorySpecificSummary.self, forKey: .categorySpecificSummary)
        categorySpecificSummary = categorySpecificSummaryDecoded
        let flaggedResourcesContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorResourceDetail?].self, forKey: .flaggedResources)
        var flaggedResourcesDecoded0:[SupportClientTypes.TrustedAdvisorResourceDetail]? = nil
        if let flaggedResourcesContainer = flaggedResourcesContainer {
            flaggedResourcesDecoded0 = [SupportClientTypes.TrustedAdvisorResourceDetail]()
            for structure0 in flaggedResourcesContainer {
                if let structure0 = structure0 {
                    flaggedResourcesDecoded0?.append(structure0)
                }
            }
        }
        flaggedResources = flaggedResourcesDecoded0
    }
}

extension SupportClientTypes.TrustedAdvisorCheckResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckResult(categorySpecificSummary: \(Swift.String(describing: categorySpecificSummary)), checkId: \(Swift.String(describing: checkId)), flaggedResources: \(Swift.String(describing: flaggedResources)), resourcesSummary: \(Swift.String(describing: resourcesSummary)), status: \(Swift.String(describing: status)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension SupportClientTypes {
    /// <p>The results of a Trusted Advisor check returned by <a>DescribeTrustedAdvisorCheckResult</a>.</p>
    public struct TrustedAdvisorCheckResult: Swift.Equatable {
        /// <p>Summary information that relates to the category of the check. Cost Optimizing is the
        ///             only category that is currently supported.</p>
        public let categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary?
        /// <p>The unique identifier for the Trusted Advisor check.</p>
        public let checkId: Swift.String?
        /// <p>The details about each resource listed in the check result.</p>
        public let flaggedResources: [SupportClientTypes.TrustedAdvisorResourceDetail]?
        /// <p>Details about AWS resources that were analyzed in a call to Trusted Advisor <a>DescribeTrustedAdvisorCheckSummaries</a>.</p>
        public let resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary?
        /// <p>The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or
        ///             "not_available".</p>
        public let status: Swift.String?
        /// <p>The time of the last refresh of the check.</p>
        public let timestamp: Swift.String?

        public init (
            categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary? = nil,
            checkId: Swift.String? = nil,
            flaggedResources: [SupportClientTypes.TrustedAdvisorResourceDetail]? = nil,
            resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary? = nil,
            status: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.categorySpecificSummary = categorySpecificSummary
            self.checkId = checkId
            self.flaggedResources = flaggedResources
            self.resourcesSummary = resourcesSummary
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categorySpecificSummary
        case checkId
        case hasFlaggedResources
        case resourcesSummary
        case status
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySpecificSummary = categorySpecificSummary {
            try encodeContainer.encode(categorySpecificSummary, forKey: .categorySpecificSummary)
        }
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if hasFlaggedResources != false {
            try encodeContainer.encode(hasFlaggedResources, forKey: .hasFlaggedResources)
        }
        if let resourcesSummary = resourcesSummary {
            try encodeContainer.encode(resourcesSummary, forKey: .resourcesSummary)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let hasFlaggedResourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hasFlaggedResources)
        hasFlaggedResources = hasFlaggedResourcesDecoded
        let resourcesSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorResourcesSummary.self, forKey: .resourcesSummary)
        resourcesSummary = resourcesSummaryDecoded
        let categorySpecificSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCategorySpecificSummary.self, forKey: .categorySpecificSummary)
        categorySpecificSummary = categorySpecificSummaryDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCheckSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckSummary(categorySpecificSummary: \(Swift.String(describing: categorySpecificSummary)), checkId: \(Swift.String(describing: checkId)), hasFlaggedResources: \(Swift.String(describing: hasFlaggedResources)), resourcesSummary: \(Swift.String(describing: resourcesSummary)), status: \(Swift.String(describing: status)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension SupportClientTypes {
    /// <p>A summary of a Trusted Advisor check result, including the alert status, last refresh,
    ///             and number of resources examined.</p>
    public struct TrustedAdvisorCheckSummary: Swift.Equatable {
        /// <p>Summary information that relates to the category of the check. Cost Optimizing is the
        ///             only category that is currently supported.</p>
        public let categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary?
        /// <p>The unique identifier for the Trusted Advisor check.</p>
        public let checkId: Swift.String?
        /// <p>Specifies whether the Trusted Advisor check has flagged resources.</p>
        public let hasFlaggedResources: Swift.Bool
        /// <p>Details about AWS resources that were analyzed in a call to Trusted Advisor <a>DescribeTrustedAdvisorCheckSummaries</a>.</p>
        public let resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary?
        /// <p>The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or
        ///             "not_available".</p>
        public let status: Swift.String?
        /// <p>The time of the last refresh of the check.</p>
        public let timestamp: Swift.String?

        public init (
            categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary? = nil,
            checkId: Swift.String? = nil,
            hasFlaggedResources: Swift.Bool = false,
            resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary? = nil,
            status: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.categorySpecificSummary = categorySpecificSummary
            self.checkId = checkId
            self.hasFlaggedResources = hasFlaggedResources
            self.resourcesSummary = resourcesSummary
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCostOptimizingSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMonthlySavings
        case estimatedPercentMonthlySavings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if estimatedMonthlySavings != 0.0 {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if estimatedPercentMonthlySavings != 0.0 {
            try encodeContainer.encode(estimatedPercentMonthlySavings, forKey: .estimatedPercentMonthlySavings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlySavingsDecoded = try containerValues.decode(Swift.Double.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let estimatedPercentMonthlySavingsDecoded = try containerValues.decode(Swift.Double.self, forKey: .estimatedPercentMonthlySavings)
        estimatedPercentMonthlySavings = estimatedPercentMonthlySavingsDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCostOptimizingSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCostOptimizingSummary(estimatedMonthlySavings: \(Swift.String(describing: estimatedMonthlySavings)), estimatedPercentMonthlySavings: \(Swift.String(describing: estimatedPercentMonthlySavings)))"}
}

extension SupportClientTypes {
    /// <p>The estimated cost savings that might be realized if the recommended operations are
    ///             taken.</p>
    public struct TrustedAdvisorCostOptimizingSummary: Swift.Equatable {
        /// <p>The estimated monthly savings that might be realized if the recommended operations are
        ///             taken.</p>
        public let estimatedMonthlySavings: Swift.Double
        /// <p>The estimated percentage of savings that might be realized if the recommended
        ///             operations are taken.</p>
        public let estimatedPercentMonthlySavings: Swift.Double

        public init (
            estimatedMonthlySavings: Swift.Double = 0.0,
            estimatedPercentMonthlySavings: Swift.Double = 0.0
        )
        {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedPercentMonthlySavings = estimatedPercentMonthlySavings
        }
    }

}

extension SupportClientTypes.TrustedAdvisorResourceDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isSuppressed
        case metadata
        case region
        case resourceId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isSuppressed != false {
            try encodeContainer.encode(isSuppressed, forKey: .isSuppressed)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for stringlist0 in metadata {
                try metadataContainer.encode(stringlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let isSuppressedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isSuppressed)
        isSuppressed = isSuppressedDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metadata)
        var metadataDecoded0:[Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String]()
            for string0 in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?.append(string0)
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension SupportClientTypes.TrustedAdvisorResourceDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorResourceDetail(isSuppressed: \(Swift.String(describing: isSuppressed)), metadata: \(Swift.String(describing: metadata)), region: \(Swift.String(describing: region)), resourceId: \(Swift.String(describing: resourceId)), status: \(Swift.String(describing: status)))"}
}

extension SupportClientTypes {
    /// <p>Contains information about a resource identified by a Trusted Advisor check.</p>
    public struct TrustedAdvisorResourceDetail: Swift.Equatable {
        /// <p>Specifies whether the AWS resource was ignored by Trusted Advisor because it was
        ///             marked as suppressed by the user.</p>
        public let isSuppressed: Swift.Bool
        /// <p>Additional information about the identified resource. The exact metadata and its order
        ///             can be obtained by inspecting the <a>TrustedAdvisorCheckDescription</a>
        ///             object returned by the call to <a>DescribeTrustedAdvisorChecks</a>. <b>Metadata</b> contains all the data that is shown in the Excel
        ///             download, even in those cases where the UI shows just summary data.</p>
        public let metadata: [Swift.String]?
        /// <p>The AWS Region in which the identified resource is located.</p>
        public let region: Swift.String?
        /// <p>The unique identifier for the identified resource.</p>
        public let resourceId: Swift.String?
        /// <p>The status code for the resource identified in the Trusted Advisor check.</p>
        public let status: Swift.String?

        public init (
            isSuppressed: Swift.Bool = false,
            metadata: [Swift.String]? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.isSuppressed = isSuppressed
            self.metadata = metadata
            self.region = region
            self.resourceId = resourceId
            self.status = status
        }
    }

}

extension SupportClientTypes.TrustedAdvisorResourcesSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcesFlagged
        case resourcesIgnored
        case resourcesProcessed
        case resourcesSuppressed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if resourcesFlagged != 0 {
            try encodeContainer.encode(resourcesFlagged, forKey: .resourcesFlagged)
        }
        if resourcesIgnored != 0 {
            try encodeContainer.encode(resourcesIgnored, forKey: .resourcesIgnored)
        }
        if resourcesProcessed != 0 {
            try encodeContainer.encode(resourcesProcessed, forKey: .resourcesProcessed)
        }
        if resourcesSuppressed != 0 {
            try encodeContainer.encode(resourcesSuppressed, forKey: .resourcesSuppressed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesProcessedDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesProcessed)
        resourcesProcessed = resourcesProcessedDecoded
        let resourcesFlaggedDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesFlagged)
        resourcesFlagged = resourcesFlaggedDecoded
        let resourcesIgnoredDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesIgnored)
        resourcesIgnored = resourcesIgnoredDecoded
        let resourcesSuppressedDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesSuppressed)
        resourcesSuppressed = resourcesSuppressedDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorResourcesSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorResourcesSummary(resourcesFlagged: \(Swift.String(describing: resourcesFlagged)), resourcesIgnored: \(Swift.String(describing: resourcesIgnored)), resourcesProcessed: \(Swift.String(describing: resourcesProcessed)), resourcesSuppressed: \(Swift.String(describing: resourcesSuppressed)))"}
}

extension SupportClientTypes {
    /// <p>Details about AWS resources that were analyzed in a call to Trusted Advisor <a>DescribeTrustedAdvisorCheckSummaries</a>.</p>
    public struct TrustedAdvisorResourcesSummary: Swift.Equatable {
        /// <p>The number of AWS resources that were flagged (listed) by the Trusted Advisor
        ///             check.</p>
        public let resourcesFlagged: Swift.Int
        /// <p>The number of AWS resources ignored by Trusted Advisor because information was
        ///             unavailable.</p>
        public let resourcesIgnored: Swift.Int
        /// <p>The number of AWS resources that were analyzed by the Trusted Advisor check.</p>
        public let resourcesProcessed: Swift.Int
        /// <p>The number of AWS resources ignored by Trusted Advisor because they were marked as
        ///             suppressed by the user.</p>
        public let resourcesSuppressed: Swift.Int

        public init (
            resourcesFlagged: Swift.Int = 0,
            resourcesIgnored: Swift.Int = 0,
            resourcesProcessed: Swift.Int = 0,
            resourcesSuppressed: Swift.Int = 0
        )
        {
            self.resourcesFlagged = resourcesFlagged
            self.resourcesIgnored = resourcesIgnored
            self.resourcesProcessed = resourcesProcessed
            self.resourcesSuppressed = resourcesSuppressed
        }
    }

}
