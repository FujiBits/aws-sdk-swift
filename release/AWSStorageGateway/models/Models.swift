// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct ActivateGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateGatewayOutputError>
}

extension ActivateGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateGatewayInput(activationKey: \(Swift.String(describing: activationKey)), gatewayName: \(Swift.String(describing: gatewayName)), gatewayRegion: \(Swift.String(describing: gatewayRegion)), gatewayTimezone: \(Swift.String(describing: gatewayTimezone)), gatewayType: \(Swift.String(describing: gatewayType)), mediumChangerType: \(Swift.String(describing: mediumChangerType)), tags: \(Swift.String(describing: tags)), tapeDriveType: \(Swift.String(describing: tapeDriveType)))"}
}

extension ActivateGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayName = "GatewayName"
        case gatewayRegion = "GatewayRegion"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case mediumChangerType = "MediumChangerType"
        case tags = "Tags"
        case tapeDriveType = "TapeDriveType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationKey = activationKey {
            try encodeContainer.encode(activationKey, forKey: .activationKey)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayRegion = gatewayRegion {
            try encodeContainer.encode(gatewayRegion, forKey: .gatewayRegion)
        }
        if let gatewayTimezone = gatewayTimezone {
            try encodeContainer.encode(gatewayTimezone, forKey: .gatewayTimezone)
        }
        if let gatewayType = gatewayType {
            try encodeContainer.encode(gatewayType, forKey: .gatewayType)
        }
        if let mediumChangerType = mediumChangerType {
            try encodeContainer.encode(mediumChangerType, forKey: .mediumChangerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let tapeDriveType = tapeDriveType {
            try encodeContainer.encode(tapeDriveType, forKey: .tapeDriveType)
        }
    }
}

public struct ActivateGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateGatewayOutputError>
}

public struct ActivateGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateGatewayOutputError>
}

public struct ActivateGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ActivateGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ActivateGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateGatewayOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   ActivateGatewayInput$ActivationKey
///
///
///
///
///                   ActivateGatewayInput$GatewayName
///
///
///
///
///                   ActivateGatewayInput$GatewayRegion
///
///
///
///
///                   ActivateGatewayInput$GatewayTimezone
///
///
///
///
///                   ActivateGatewayInput$GatewayType
///
///
///
///
///                   ActivateGatewayInput$MediumChangerType
///
///
///
///
///                   ActivateGatewayInput$TapeDriveType
///
///
///
public struct ActivateGatewayInput: Swift.Equatable {
    /// Your gateway activation key. You can obtain the activation key by sending an HTTP GET
    ///          request with redirects enabled to the gateway IP address (port 80). The redirect URL
    ///          returned in the response provides you the activation key for your gateway in the query
    ///          string parameter activationKey. It may also include other activation-related
    ///          parameters, however, these are merely defaults -- the arguments you pass to the
    ///             ActivateGateway API call determine the actual configuration of your
    ///          gateway.
    ///
    ///
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/get-activation-key.html">Getting activation
    ///          key in the Storage Gateway User Guide.
    /// This member is required.
    public var activationKey: Swift.String?
    /// The name you configured for your gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// A value that indicates the Region where you want to store your data.
    ///          The gateway Region specified must be the same Region
    ///          as the Region in your Host
    ///          header in the request. For more information about available Regions and endpoints for
    ///          Storage Gateway, see <a href="https://docs.aws.amazon.com/general/latest/gr/sg.html">
    ///             Storage Gateway endpoints and quotas in the Amazon Web Services General
    ///             Reference.
    ///
    ///          Valid Values: See <a href="https://docs.aws.amazon.com/general/latest/gr/sg.html">
    ///          Storage Gateway endpoints and quotas in the Amazon Web Services General
    ///             Reference.
    ///
    ///
    /// This member is required.
    public var gatewayRegion: Swift.String?
    /// A value that indicates the time zone you want to set for the gateway. The time zone is
    ///          of the format "GMT-hr:mm" or "GMT+hr:mm". For example, GMT-4:00 indicates the time is 4
    ///          hours behind GMT. GMT+2:00 indicates the time is 2 hours ahead of GMT. The time zone is
    ///          used, for example, for scheduling snapshots and your gateway's maintenance
    ///          schedule.
    /// This member is required.
    public var gatewayTimezone: Swift.String?
    /// A value that defines the type of gateway to activate. The type specified is critical to
    ///          all later functions of the gateway and cannot be changed after activation. The default
    ///          value is CACHED.
    ///
    ///          Valid Values: STORED | CACHED | VTL |
    ///          FILE_S3 | FILE_FSX_SMB|
    ///
    public var gatewayType: Swift.String?
    /// The value that indicates the type of medium changer to use for tape gateway. This field
    ///          is optional.
    ///
    ///          Valid Values: STK-L700 | AWS-Gateway-VTL |
    ///             IBM-03584L32-0402
    ///
    public var mediumChangerType: Swift.String?
    /// A list of up to 50 tags that you can assign to the gateway. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers that can be
    ///             represented in UTF-8 format, and the following special characters: + - = . _ : / @. The
    ///             maximum length of a tag's key is 128 characters, and the maximum length for a
    ///             tag's value is 256 characters.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The value that indicates the type of tape drive to use for tape gateway. This field is
    ///          optional.
    ///
    ///          Valid Values: IBM-ULT3580-TD5
    ///
    public var tapeDriveType: Swift.String?

    public init (
        activationKey: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayRegion: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil,
        gatewayType: Swift.String? = nil,
        mediumChangerType: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeDriveType: Swift.String? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayName = gatewayName
        self.gatewayRegion = gatewayRegion
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.mediumChangerType = mediumChangerType
        self.tags = tags
        self.tapeDriveType = tapeDriveType
    }
}

struct ActivateGatewayInputBody: Swift.Equatable {
    public let activationKey: Swift.String?
    public let gatewayName: Swift.String?
    public let gatewayTimezone: Swift.String?
    public let gatewayRegion: Swift.String?
    public let gatewayType: Swift.String?
    public let tapeDriveType: Swift.String?
    public let mediumChangerType: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension ActivateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayName = "GatewayName"
        case gatewayRegion = "GatewayRegion"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case mediumChangerType = "MediumChangerType"
        case tags = "Tags"
        case tapeDriveType = "TapeDriveType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationKey)
        activationKey = activationKeyDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let gatewayRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayRegion)
        gatewayRegion = gatewayRegionDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let tapeDriveTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeDriveType)
        tapeDriveType = tapeDriveTypeDecoded
        let mediumChangerTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediumChangerType)
        mediumChangerType = mediumChangerTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ActivateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateGatewayOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ActivateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActivateGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// Storage Gateway returns the Amazon Resource Name (ARN) of the activated gateway. It
///          is a string made of information such as your account, gateway name, and Region. This
///          ARN is used to reference the gateway in other API operations as well as resource-based
///          authorization.
///
///
///             For gateways activated prior to September 02, 2015, the gateway ARN contains the
///             gateway name rather than the gateway ID. Changing the name of the gateway has no effect
///             on the gateway ARN.
///
public struct ActivateGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ActivateGatewayOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ActivateGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes {
    public enum ActiveDirectoryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case detached
        case joined
        case joining
        case networkError
        case timeout
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [ActiveDirectoryStatus] {
            return [
                .accessDenied,
                .detached,
                .joined,
                .joining,
                .networkError,
                .timeout,
                .unknownError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .detached: return "DETACHED"
            case .joined: return "JOINED"
            case .joining: return "JOINING"
            case .networkError: return "NETWORK_ERROR"
            case .timeout: return "TIMEOUT"
            case .unknownError: return "UNKNOWN_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActiveDirectoryStatus(rawValue: rawValue) ?? ActiveDirectoryStatus.sdkUnknown(rawValue)
        }
    }
}

public struct AddCacheInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCacheOutputError>
}

extension AddCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCacheInput(diskIds: \(Swift.String(describing: diskIds)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension AddCacheInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskids0 in diskIds {
                try diskIdsContainer.encode(diskids0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct AddCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCacheOutputError>
}

public struct AddCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCacheOutputError>
}

public struct AddCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCacheOutputError>
}

public struct AddCacheInput: Swift.Equatable {
    /// An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the ListLocalDisks API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddCacheInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let diskIds: [Swift.String]?
}

extension AddCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCacheOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension AddCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct AddCacheOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddCacheOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension AddCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct AddTagsToResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension AddTagsToResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddTagsToResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddTagsToResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

/// AddTagsToResourceInput
public struct AddTagsToResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value pair that represents the tag you want to add to the resource. The value
    ///          can be an empty string.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    /// This member is required.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceOutputResponse(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddTagsToResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

/// AddTagsToResourceOutput
public struct AddTagsToResourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

public struct AddUploadBufferInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddUploadBufferInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddUploadBufferInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddUploadBufferInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddUploadBufferOutputError>
}

extension AddUploadBufferInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddUploadBufferInput(diskIds: \(Swift.String(describing: diskIds)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension AddUploadBufferInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskids0 in diskIds {
                try diskIdsContainer.encode(diskids0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct AddUploadBufferInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddUploadBufferInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddUploadBufferInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddUploadBufferInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddUploadBufferOutputError>
}

public struct AddUploadBufferInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddUploadBufferInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddUploadBufferInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddUploadBufferInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddUploadBufferOutputError>
}

public struct AddUploadBufferInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddUploadBufferInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddUploadBufferInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddUploadBufferInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddUploadBufferOutputError>
}

public struct AddUploadBufferInput: Swift.Equatable {
    /// An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the ListLocalDisks API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddUploadBufferInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let diskIds: [Swift.String]?
}

extension AddUploadBufferInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddUploadBufferOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddUploadBufferOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddUploadBufferOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddUploadBufferOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddUploadBufferOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension AddUploadBufferOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddUploadBufferOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct AddUploadBufferOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddUploadBufferOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension AddUploadBufferOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct AddWorkingStorageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddWorkingStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddWorkingStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddWorkingStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddWorkingStorageOutputError>
}

extension AddWorkingStorageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddWorkingStorageInput(diskIds: \(Swift.String(describing: diskIds)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension AddWorkingStorageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskids0 in diskIds {
                try diskIdsContainer.encode(diskids0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct AddWorkingStorageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddWorkingStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddWorkingStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddWorkingStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddWorkingStorageOutputError>
}

public struct AddWorkingStorageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddWorkingStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddWorkingStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddWorkingStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddWorkingStorageOutputError>
}

public struct AddWorkingStorageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddWorkingStorageInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddWorkingStorageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddWorkingStorageInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddWorkingStorageOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   AddWorkingStorageInput$DiskIds
///
///
///
public struct AddWorkingStorageInput: Swift.Equatable {
    /// An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the ListLocalDisks API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddWorkingStorageInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let diskIds: [Swift.String]?
}

extension AddWorkingStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddWorkingStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddWorkingStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddWorkingStorageOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddWorkingStorageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddWorkingStorageOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension AddWorkingStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddWorkingStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway for which working
///          storage was configured.
public struct AddWorkingStorageOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddWorkingStorageOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension AddWorkingStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct AssignTapePoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignTapePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignTapePoolOutputError>
}

extension AssignTapePoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignTapePoolInput(bypassGovernanceRetention: \(Swift.String(describing: bypassGovernanceRetention)), poolId: \(Swift.String(describing: poolId)), tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension AssignTapePoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case poolId = "PoolId"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct AssignTapePoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignTapePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignTapePoolOutputError>
}

public struct AssignTapePoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignTapePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignTapePoolOutputError>
}

public struct AssignTapePoolInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignTapePoolInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssignTapePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssignTapePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssignTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignTapePoolOutputError>
}

public struct AssignTapePoolInput: Swift.Equatable {
    /// Set permissions to bypass governance retention. If the lock type of the archived tape is
    ///             Governance, the tape's archived age is not older than
    ///             RetentionLockInDays, and the user does not already have
    ///             BypassGovernanceRetention, setting this to TRUE enables the user to bypass
    ///          the retention lock. This parameter is set to true by default for calls from the
    ///          console.
    ///
    ///          Valid values: TRUE | FALSE
    ///
    public var bypassGovernanceRetention: Swift.Bool
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the S3 storage class that is associated with the pool. When you use
    ///          your backup application to eject the tape, the tape is archived directly into the storage
    ///          class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    ///
    ///          Valid Values: GLACIER | DEEP_ARCHIVE
    ///
    /// This member is required.
    public var poolId: Swift.String?
    /// The unique Amazon Resource Name (ARN) of the virtual tape that you want to add to the
    ///          tape pool.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        bypassGovernanceRetention: Swift.Bool = false,
        poolId: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.poolId = poolId
        self.tapeARN = tapeARN
    }
}

struct AssignTapePoolInputBody: Swift.Equatable {
    public let tapeARN: Swift.String?
    public let poolId: Swift.String?
    public let bypassGovernanceRetention: Swift.Bool
}

extension AssignTapePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case poolId = "PoolId"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .bypassGovernanceRetention)
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension AssignTapePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssignTapePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssignTapePoolOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssignTapePoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignTapePoolOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension AssignTapePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssignTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

public struct AssignTapePoolOutputResponse: Swift.Equatable {
    /// The unique Amazon Resource Names (ARN) of the virtual tape that was added to the tape
    ///          pool.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct AssignTapePoolOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension AssignTapePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct AssociateFileSystemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFileSystemOutputError>
}

extension AssociateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFileSystemInput(auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), clientToken: \(Swift.String(describing: clientToken)), endpointNetworkConfiguration: \(Swift.String(describing: endpointNetworkConfiguration)), gatewayARN: \(Swift.String(describing: gatewayARN)), locationARN: \(Swift.String(describing: locationARN)), password: \(Swift.String(describing: password)), tags: \(Swift.String(describing: tags)), userName: \(Swift.String(describing: userName)))"}
}

extension AssociateFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientToken = "ClientToken"
        case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case password = "Password"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let endpointNetworkConfiguration = endpointNetworkConfiguration {
            try encodeContainer.encode(endpointNetworkConfiguration, forKey: .endpointNetworkConfiguration)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct AssociateFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFileSystemOutputError>
}

public struct AssociateFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFileSystemOutputError>
}

public struct AssociateFileSystemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFileSystemInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateFileSystemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateFileSystemInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFileSystemOutputError>
}

public struct AssociateFileSystemInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
    public var auditDestinationARN: Swift.String?
    /// The refresh cache information for the file share or FSx file systems.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// A unique string value that you supply that is used by the FSx File Gateway to ensure
    ///          idempotent file system association creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Specifies the network configuration information for the gateway associated with the Amazon FSx file system.
    ///
    ///             If multiple file systems are associated with this gateway, this parameter's IpAddresses field is required.
    ///
    public var endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon FSx file system to associate with the
    ///          FSx File Gateway.
    /// This member is required.
    public var locationARN: Swift.String?
    /// The password of the user credential.
    /// This member is required.
    public var password: Swift.String?
    /// A list of up to 50 tags that can be assigned to the file system association. Each tag is a key-value pair.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The user name of the user credential that has permission to access the root share D$ of
    ///          the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin
    ///          user group.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientToken: Swift.String? = nil,
        endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration? = nil,
        gatewayARN: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        password: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.clientToken = clientToken
        self.endpointNetworkConfiguration = endpointNetworkConfiguration
        self.gatewayARN = gatewayARN
        self.locationARN = locationARN
        self.password = password
        self.tags = tags
        self.userName = userName
    }
}

struct AssociateFileSystemInputBody: Swift.Equatable {
    public let userName: Swift.String?
    public let password: Swift.String?
    public let clientToken: Swift.String?
    public let gatewayARN: Swift.String?
    public let locationARN: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
    public let auditDestinationARN: Swift.String?
    public let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    public let endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
}

extension AssociateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientToken = "ClientToken"
        case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case password = "Password"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let endpointNetworkConfigurationDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.EndpointNetworkConfiguration.self, forKey: .endpointNetworkConfiguration)
        endpointNetworkConfiguration = endpointNetworkConfigurationDecoded
    }
}

extension AssociateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFileSystemOutputResponse(fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)))"}
}

extension AssociateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct AssociateFileSystemOutputResponse: Swift.Equatable {
    /// The ARN of the newly created file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init (
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct AssociateFileSystemOutputResponseBody: Swift.Equatable {
    public let fileSystemAssociationARN: Swift.String?
}

extension AssociateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

public struct AttachVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachVolumeOutputError>
}

extension AttachVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachVolumeInput(diskId: \(Swift.String(describing: diskId)), gatewayARN: \(Swift.String(describing: gatewayARN)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), targetName: \(Swift.String(describing: targetName)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension AttachVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case networkInterfaceId = "NetworkInterfaceId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskId = diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct AttachVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachVolumeOutputError>
}

public struct AttachVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachVolumeOutputError>
}

public struct AttachVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AttachVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachVolumeOutputError>
}

/// AttachVolumeInput
public struct AttachVolumeInput: Swift.Equatable {
    /// The unique device ID or other distinguishing data that identifies the local disk used to
    ///          create the volume. This value is only required when you are attaching a stored
    ///          volume.
    public var diskId: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway that you want to attach the volume
    ///          to.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4
    ///          addresses are accepted. Use DescribeGatewayInformation to get a list of
    ///          the network interfaces available on a gateway.
    ///
    ///          Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying TargetName as
    ///             myvolume results in the target ARN of
    ///             arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume.
    ///          The target name must be unique across all volumes on a gateway.
    ///
    ///          If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.
    public var targetName: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume to attach to the specified gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        diskId: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        targetName: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.networkInterfaceId = networkInterfaceId
        self.targetName = targetName
        self.volumeARN = volumeARN
    }
}

struct AttachVolumeInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let targetName: Swift.String?
    public let volumeARN: Swift.String?
    public let networkInterfaceId: Swift.String?
    public let diskId: Swift.String?
}

extension AttachVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case networkInterfaceId = "NetworkInterfaceId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let diskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskId)
        diskId = diskIdDecoded
    }
}

extension AttachVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachVolumeOutputResponse(targetARN: \(Swift.String(describing: targetARN)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension AttachVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
        } else {
            self.targetARN = nil
            self.volumeARN = nil
        }
    }
}

/// AttachVolumeOutput
public struct AttachVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name for
    ///          the initiator that was used to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume that was attached to the gateway.
    public var volumeARN: Swift.String?

    public init (
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

struct AttachVolumeOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let targetARN: Swift.String?
}

extension AttachVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTapeCreationRules = automaticTapeCreationRules {
            var automaticTapeCreationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automaticTapeCreationRules)
            for automatictapecreationrules0 in automaticTapeCreationRules {
                try automaticTapeCreationRulesContainer.encode(automatictapecreationrules0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationRulesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.AutomaticTapeCreationRule?].self, forKey: .automaticTapeCreationRules)
        var automaticTapeCreationRulesDecoded0:[StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil
        if let automaticTapeCreationRulesContainer = automaticTapeCreationRulesContainer {
            automaticTapeCreationRulesDecoded0 = [StorageGatewayClientTypes.AutomaticTapeCreationRule]()
            for structure0 in automaticTapeCreationRulesContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationRulesDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationRules = automaticTapeCreationRulesDecoded0
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomaticTapeCreationPolicyInfo(automaticTapeCreationRules: \(Swift.String(describing: automaticTapeCreationRules)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension StorageGatewayClientTypes {
    /// Information about the gateway's automatic tape creation policies, including the
    ///          automatic tape creation rules and the gateway that is using the policies.
    public struct AutomaticTapeCreationPolicyInfo: Swift.Equatable {
        /// An automatic tape creation policy consists of a list of automatic tape creation rules.
        ///          This returns the rules that determine when and how to automatically create new
        ///          tapes.
        public var automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?

        public init (
            automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.automaticTapeCreationRules = automaticTapeCreationRules
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes.AutomaticTapeCreationRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minimumNumTapes = "MinimumNumTapes"
        case poolId = "PoolId"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minimumNumTapes = minimumNumTapes {
            try encodeContainer.encode(minimumNumTapes, forKey: .minimumNumTapes)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tapeBarcodePrefix = tapeBarcodePrefix {
            try encodeContainer.encode(tapeBarcodePrefix, forKey: .tapeBarcodePrefix)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeBarcodePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcodePrefix)
        tapeBarcodePrefix = tapeBarcodePrefixDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let minimumNumTapesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumNumTapes)
        minimumNumTapes = minimumNumTapesDecoded
        let wormDecoded = try containerValues.decode(Swift.Bool.self, forKey: .worm)
        worm = wormDecoded
    }
}

extension StorageGatewayClientTypes.AutomaticTapeCreationRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomaticTapeCreationRule(minimumNumTapes: \(Swift.String(describing: minimumNumTapes)), poolId: \(Swift.String(describing: poolId)), tapeBarcodePrefix: \(Swift.String(describing: tapeBarcodePrefix)), tapeSizeInBytes: \(Swift.String(describing: tapeSizeInBytes)), worm: \(Swift.String(describing: worm)))"}
}

extension StorageGatewayClientTypes {
    /// An automatic tape creation policy consists of automatic tape creation rules where each
    ///          rule defines when and how to create new tapes. For more information about automatic tape
    ///          creation, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically">Creating Tapes Automatically.
    public struct AutomaticTapeCreationRule: Swift.Equatable {
        /// The minimum number of available virtual tapes that the gateway maintains at all times.
        ///          If the number of tapes on the gateway goes below this value, the gateway creates as many
        ///          new tapes as are needed to have MinimumNumTapes on the gateway. For more
        ///          information about automatic tape creation, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically">Creating Tapes Automatically.
        /// This member is required.
        public var minimumNumTapes: Swift.Int?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this
        ///          pool is archived in the Amazon S3 storage class that is associated with the pool. When you
        ///          use your backup application to eject the tape, the tape is archived directly into the
        ///          storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        ///
        ///          Valid Values: GLACIER | DEEP_ARCHIVE
        ///
        /// This member is required.
        public var poolId: Swift.String?
        /// A prefix that you append to the barcode of the virtual tape that you are creating. This
        ///          prefix makes the barcode unique.
        ///
        ///
        ///             The prefix must be 1-4 characters in length and must be one of the uppercase letters
        ///             from A to Z.
        ///
        /// This member is required.
        public var tapeBarcodePrefix: Swift.String?
        /// The size, in bytes, of the virtual tape capacity.
        /// This member is required.
        public var tapeSizeInBytes: Swift.Int?
        /// Set to true to indicate that tapes are to be archived as
        ///          write-once-read-many (WORM). Set to false when WORM is not enabled for
        ///          tapes.
        public var worm: Swift.Bool

        public init (
            minimumNumTapes: Swift.Int? = nil,
            poolId: Swift.String? = nil,
            tapeBarcodePrefix: Swift.String? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            worm: Swift.Bool = false
        )
        {
            self.minimumNumTapes = minimumNumTapes
            self.poolId = poolId
            self.tapeBarcodePrefix = tapeBarcodePrefix
            self.tapeSizeInBytes = tapeSizeInBytes
            self.worm = worm
        }
    }

}

extension StorageGatewayClientTypes {
    public enum AvailabilityMonitorTestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [AvailabilityMonitorTestStatus] {
            return [
                .complete,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AvailabilityMonitorTestStatus(rawValue: rawValue) ?? AvailabilityMonitorTestStatus.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.BandwidthRateLimitInterval: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case daysOfWeek = "DaysOfWeek"
        case endHourOfDay = "EndHourOfDay"
        case endMinuteOfHour = "EndMinuteOfHour"
        case startHourOfDay = "StartHourOfDay"
        case startMinuteOfHour = "StartMinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageDownloadRateLimitInBitsPerSec, forKey: .averageDownloadRateLimitInBitsPerSec)
        }
        if let averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let daysOfWeek = daysOfWeek {
            var daysOfWeekContainer = encodeContainer.nestedUnkeyedContainer(forKey: .daysOfWeek)
            for daysofweek0 in daysOfWeek {
                try daysOfWeekContainer.encode(daysofweek0)
            }
        }
        if let endHourOfDay = endHourOfDay {
            try encodeContainer.encode(endHourOfDay, forKey: .endHourOfDay)
        }
        if let endMinuteOfHour = endMinuteOfHour {
            try encodeContainer.encode(endMinuteOfHour, forKey: .endMinuteOfHour)
        }
        if let startHourOfDay = startHourOfDay {
            try encodeContainer.encode(startHourOfDay, forKey: .startHourOfDay)
        }
        if let startMinuteOfHour = startMinuteOfHour {
            try encodeContainer.encode(startMinuteOfHour, forKey: .startMinuteOfHour)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startHourOfDay)
        startHourOfDay = startHourOfDayDecoded
        let startMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startMinuteOfHour)
        startMinuteOfHour = startMinuteOfHourDecoded
        let endHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endHourOfDay)
        endHourOfDay = endHourOfDayDecoded
        let endMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endMinuteOfHour)
        endMinuteOfHour = endMinuteOfHourDecoded
        let daysOfWeekContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .daysOfWeek)
        var daysOfWeekDecoded0:[Swift.Int]? = nil
        if let daysOfWeekContainer = daysOfWeekContainer {
            daysOfWeekDecoded0 = [Swift.Int]()
            for integer0 in daysOfWeekContainer {
                if let integer0 = integer0 {
                    daysOfWeekDecoded0?.append(integer0)
                }
            }
        }
        daysOfWeek = daysOfWeekDecoded0
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

extension StorageGatewayClientTypes.BandwidthRateLimitInterval: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BandwidthRateLimitInterval(averageDownloadRateLimitInBitsPerSec: \(Swift.String(describing: averageDownloadRateLimitInBitsPerSec)), averageUploadRateLimitInBitsPerSec: \(Swift.String(describing: averageUploadRateLimitInBitsPerSec)), daysOfWeek: \(Swift.String(describing: daysOfWeek)), endHourOfDay: \(Swift.String(describing: endHourOfDay)), endMinuteOfHour: \(Swift.String(describing: endMinuteOfHour)), startHourOfDay: \(Swift.String(describing: startHourOfDay)), startMinuteOfHour: \(Swift.String(describing: startMinuteOfHour)))"}
}

extension StorageGatewayClientTypes {
    ///
    ///          Describes a bandwidth rate limit interval for a gateway. A bandwidth
    ///          rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit
    ///          interval defines a period of time on one or more days of the week, during which bandwidth rate
    ///          limits are specified for uploading, downloading, or both.
    ///
    public struct BandwidthRateLimitInterval: Swift.Equatable {
        ///
        ///          The average download rate limit component of the bandwidth rate limit interval,
        ///          in bits per second. This field does not appear in the response if the download rate limit is not set.
        ///
        public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
        ///
        ///          The average upload rate limit component of the bandwidth rate limit interval,
        ///          in bits per second. This field does not appear in the response if the upload rate limit is not set.
        ///
        public var averageUploadRateLimitInBitsPerSec: Swift.Int?
        ///  The days of the week component of the bandwidth rate limit interval, represented as
        ///          ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        /// This member is required.
        public var daysOfWeek: [Swift.Int]?
        ///
        ///          The hour of the day to end the bandwidth rate limit interval.
        ///
        /// This member is required.
        public var endHourOfDay: Swift.Int?
        ///
        ///          The minute of the hour to end the bandwidth rate limit interval.
        ///
        ///
        ///
        ///
        ///             The bandwidth rate limit interval ends at the end of the minute. To end an interval
        ///             at the end of an hour, use the value 59.
        ///
        ///
        /// This member is required.
        public var endMinuteOfHour: Swift.Int?
        ///
        ///          The hour of the day to start the bandwidth rate limit interval.
        ///
        /// This member is required.
        public var startHourOfDay: Swift.Int?
        ///
        ///          The minute of the hour to start the bandwidth rate limit interval.
        ///          The interval begins at the start of that minute. To begin an interval exactly at
        ///          the start of the hour, use the value 0.
        ///
        /// This member is required.
        public var startMinuteOfHour: Swift.Int?

        public init (
            averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
            averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
            daysOfWeek: [Swift.Int]? = nil,
            endHourOfDay: Swift.Int? = nil,
            endMinuteOfHour: Swift.Int? = nil,
            startHourOfDay: Swift.Int? = nil,
            startMinuteOfHour: Swift.Int? = nil
        )
        {
            self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }
    }

}

extension StorageGatewayClientTypes.CacheAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheStaleTimeoutInSeconds = "CacheStaleTimeoutInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSeconds {
            try encodeContainer.encode(cacheStaleTimeoutInSeconds, forKey: .cacheStaleTimeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheStaleTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cacheStaleTimeoutInSeconds)
        cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSecondsDecoded
    }
}

extension StorageGatewayClientTypes.CacheAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CacheAttributes(cacheStaleTimeoutInSeconds: \(Swift.String(describing: cacheStaleTimeoutInSeconds)))"}
}

extension StorageGatewayClientTypes {
    /// The refresh cache information for the file share or FSx file systems.
    public struct CacheAttributes: Swift.Equatable {
        /// Refreshes a file share's cache by using Time To Live (TTL). TTL is the length of
        ///          time since the last refresh after which access to the directory would cause the file
        ///          gateway to first refresh that directory's contents from the Amazon S3 bucket or Amazon FSx file system. The TTL
        ///          duration is in seconds.
        ///
        ///          Valid Values:0, 300 to 2,592,000 seconds (5 minutes to 30 days)
        public var cacheStaleTimeoutInSeconds: Swift.Int?

        public init (
            cacheStaleTimeoutInSeconds: Swift.Int? = nil
        )
        {
            self.cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSeconds
        }
    }

}

extension StorageGatewayClientTypes.CachediSCSIVolume: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case kMSKey = "KMSKey"
        case sourceSnapshotId = "SourceSnapshotId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeId = "VolumeId"
        case volumeProgress = "VolumeProgress"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeStatus = "VolumeStatus"
        case volumeType = "VolumeType"
        case volumeUsedInBytes = "VolumeUsedInBytes"
        case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let sourceSnapshotId = sourceSnapshotId {
            try encodeContainer.encode(sourceSnapshotId, forKey: .sourceSnapshotId)
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeProgress = volumeProgress {
            try encodeContainer.encode(volumeProgress, forKey: .volumeProgress)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeStatus = volumeStatus {
            try encodeContainer.encode(volumeStatus, forKey: .volumeStatus)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
        if let volumeUsedInBytes = volumeUsedInBytes {
            try encodeContainer.encode(volumeUsedInBytes, forKey: .volumeUsedInBytes)
        }
        if let volumeiSCSIAttributes = volumeiSCSIAttributes {
            try encodeContainer.encode(volumeiSCSIAttributes, forKey: .volumeiSCSIAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeStatus)
        volumeStatus = volumeStatusDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeProgressDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .volumeProgress)
        volumeProgress = volumeProgressDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let volumeiSCSIAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.VolumeiSCSIAttributes.self, forKey: .volumeiSCSIAttributes)
        volumeiSCSIAttributes = volumeiSCSIAttributesDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let volumeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsedInBytes)
        volumeUsedInBytes = volumeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension StorageGatewayClientTypes.CachediSCSIVolume: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachediSCSIVolume(createdDate: \(Swift.String(describing: createdDate)), kMSKey: \(Swift.String(describing: kMSKey)), sourceSnapshotId: \(Swift.String(describing: sourceSnapshotId)), targetName: \(Swift.String(describing: targetName)), volumeARN: \(Swift.String(describing: volumeARN)), volumeAttachmentStatus: \(Swift.String(describing: volumeAttachmentStatus)), volumeId: \(Swift.String(describing: volumeId)), volumeProgress: \(Swift.String(describing: volumeProgress)), volumeSizeInBytes: \(Swift.String(describing: volumeSizeInBytes)), volumeStatus: \(Swift.String(describing: volumeStatus)), volumeType: \(Swift.String(describing: volumeType)), volumeUsedInBytes: \(Swift.String(describing: volumeUsedInBytes)), volumeiSCSIAttributes: \(Swift.String(describing: volumeiSCSIAttributes)))"}
}

extension StorageGatewayClientTypes {
    /// Describes an iSCSI cached volume.
    public struct CachediSCSIVolume: Swift.Equatable {
        /// The date the volume was created. Volumes created prior to March 28, 2017 don’t have this
        ///          timestamp.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        ///          only be set when KMSEncrypted is true. Optional.
        public var kMSKey: Swift.String?
        /// If the cached volume was created from a snapshot, this field contains the snapshot ID
        ///          used, e.g., snap-78e22663. Otherwise, this field is not included.
        public var sourceSnapshotId: Swift.String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a
        ///          suffix for the target ARN. For example, specifying TargetName as
        ///             myvolume results in the target ARN of
        ///             arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume.
        ///          The target name must be unique across all volumes on a gateway.
        ///
        ///          If you don't specify a value, Storage Gateway uses the value that was previously
        ///          used for this volume as the new target name.
        public var targetName: Swift.String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public var volumeARN: Swift.String?
        /// A value that indicates whether a storage volume is attached to or detached from a
        ///          gateway. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume">Moving
        ///             your volumes to a different gateway.
        public var volumeAttachmentStatus: Swift.String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public var volumeId: Swift.String?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that
        ///          represents the percent of data transferred. This field does not appear in the response if
        ///          the cached volume is not restoring or bootstrapping.
        public var volumeProgress: Swift.Double?
        /// The size, in bytes, of the volume capacity.
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeStatus: Swift.String?
        /// One of the VolumeType enumeration values that describes the type of the volume.
        public var volumeType: Swift.String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on
        ///          the number of blocks that are touched, instead of the actual amount of data written. This
        ///          value can be useful for sequential write patterns but less accurate for random write
        ///          patterns. VolumeUsedInBytes is different from the compressed size of the
        ///          volume, which is the value that is used to calculate your bill.
        ///
        ///
        ///             This value is not available for volumes created prior to May 13, 2015, until you
        ///             store data on the volume.
        ///
        public var volumeUsedInBytes: Swift.Int?
        /// An VolumeiSCSIAttributes object that represents a collection of iSCSI
        ///          attributes for one stored volume.
        public var volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            kMSKey: Swift.String? = nil,
            sourceSnapshotId: Swift.String? = nil,
            targetName: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeProgress: Swift.Double? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil,
            volumeUsedInBytes: Swift.Int? = nil,
            volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes? = nil
        )
        {
            self.createdDate = createdDate
            self.kMSKey = kMSKey
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
        }
    }

}

public struct CancelArchivalInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelArchivalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelArchivalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelArchivalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelArchivalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelArchivalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelArchivalOutputError>
}

extension CancelArchivalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelArchivalInput(gatewayARN: \(Swift.String(describing: gatewayARN)), tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension CancelArchivalInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct CancelArchivalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelArchivalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelArchivalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelArchivalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelArchivalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelArchivalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelArchivalOutputError>
}

public struct CancelArchivalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelArchivalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelArchivalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelArchivalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelArchivalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelArchivalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelArchivalOutputError>
}

public struct CancelArchivalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelArchivalInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelArchivalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelArchivalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelArchivalInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelArchivalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelArchivalOutputError>
}

/// CancelArchivalInput
public struct CancelArchivalInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel archiving
    ///          for.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct CancelArchivalInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let tapeARN: Swift.String?
}

extension CancelArchivalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CancelArchivalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelArchivalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelArchivalOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelArchivalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelArchivalOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension CancelArchivalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelArchivalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// CancelArchivalOutput
public struct CancelArchivalOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape for which archiving was
    ///          canceled.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CancelArchivalOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension CancelArchivalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct CancelRetrievalInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRetrievalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRetrievalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRetrievalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRetrievalOutputError>
}

extension CancelRetrievalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelRetrievalInput(gatewayARN: \(Swift.String(describing: gatewayARN)), tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension CancelRetrievalInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct CancelRetrievalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRetrievalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRetrievalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRetrievalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRetrievalOutputError>
}

public struct CancelRetrievalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRetrievalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelRetrievalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelRetrievalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRetrievalOutputError>
}

public struct CancelRetrievalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelRetrievalInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelRetrievalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelRetrievalInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelRetrievalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelRetrievalOutputError>
}

/// CancelRetrievalInput
public struct CancelRetrievalInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel retrieval
    ///          for.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct CancelRetrievalInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let tapeARN: Swift.String?
}

extension CancelRetrievalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CancelRetrievalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelRetrievalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelRetrievalOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelRetrievalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelRetrievalOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension CancelRetrievalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelRetrievalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// CancelRetrievalOutput
public struct CancelRetrievalOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape for which retrieval was
    ///          canceled.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CancelRetrievalOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension CancelRetrievalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension StorageGatewayClientTypes {
    public enum CaseSensitivity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case casesensitive
        case clientspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [CaseSensitivity] {
            return [
                .casesensitive,
                .clientspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .casesensitive: return "CaseSensitive"
            case .clientspecified: return "ClientSpecified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CaseSensitivity(rawValue: rawValue) ?? CaseSensitivity.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.ChapInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let secretToAuthenticateInitiator = secretToAuthenticateInitiator {
            try encodeContainer.encode(secretToAuthenticateInitiator, forKey: .secretToAuthenticateInitiator)
        }
        if let secretToAuthenticateTarget = secretToAuthenticateTarget {
            try encodeContainer.encode(secretToAuthenticateTarget, forKey: .secretToAuthenticateTarget)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let secretToAuthenticateInitiatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateInitiator)
        secretToAuthenticateInitiator = secretToAuthenticateInitiatorDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
        let secretToAuthenticateTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateTarget)
        secretToAuthenticateTarget = secretToAuthenticateTargetDecoded
    }
}

extension StorageGatewayClientTypes.ChapInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChapInfo(initiatorName: \(Swift.String(describing: initiatorName)), secretToAuthenticateInitiator: \(Swift.String(describing: secretToAuthenticateInitiator)), secretToAuthenticateTarget: \(Swift.String(describing: secretToAuthenticateTarget)), targetARN: \(Swift.String(describing: targetARN)))"}
}

extension StorageGatewayClientTypes {
    /// Describes Challenge-Handshake Authentication Protocol (CHAP) information that supports
    ///          authentication between your gateway and iSCSI initiators.
    public struct ChapInfo: Swift.Equatable {
        /// The iSCSI initiator that connects to the target.
        public var initiatorName: Swift.String?
        /// The secret key that the initiator (for example, the Windows client) must provide to
        ///          participate in mutual CHAP with the target.
        public var secretToAuthenticateInitiator: Swift.String?
        /// The secret key that the target must provide to participate in mutual CHAP with the
        ///          initiator (e.g., Windows client).
        public var secretToAuthenticateTarget: Swift.String?
        /// The Amazon Resource Name (ARN) of the volume.
        ///
        ///          Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var targetARN: Swift.String?

        public init (
            initiatorName: Swift.String? = nil,
            secretToAuthenticateInitiator: Swift.String? = nil,
            secretToAuthenticateTarget: Swift.String? = nil,
            targetARN: Swift.String? = nil
        )
        {
            self.initiatorName = initiatorName
            self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
            self.secretToAuthenticateTarget = secretToAuthenticateTarget
            self.targetARN = targetARN
        }
    }

}

public struct CreateCachediSCSIVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachediSCSIVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachediSCSIVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachediSCSIVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachediSCSIVolumeOutputError>
}

extension CreateCachediSCSIVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCachediSCSIVolumeInput(clientToken: \(Swift.String(describing: clientToken)), gatewayARN: \(Swift.String(describing: gatewayARN)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), snapshotId: \(Swift.String(describing: snapshotId)), sourceVolumeARN: \(Swift.String(describing: sourceVolumeARN)), tags: \(Swift.String(describing: tags)), targetName: \(Swift.String(describing: targetName)), volumeSizeInBytes: \(Swift.String(describing: volumeSizeInBytes)))"}
}

extension CreateCachediSCSIVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case snapshotId = "SnapshotId"
        case sourceVolumeARN = "SourceVolumeARN"
        case tags = "Tags"
        case targetName = "TargetName"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let sourceVolumeARN = sourceVolumeARN {
            try encodeContainer.encode(sourceVolumeARN, forKey: .sourceVolumeARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
    }
}

public struct CreateCachediSCSIVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachediSCSIVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachediSCSIVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachediSCSIVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachediSCSIVolumeOutputError>
}

public struct CreateCachediSCSIVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachediSCSIVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachediSCSIVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachediSCSIVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachediSCSIVolumeOutputError>
}

public struct CreateCachediSCSIVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachediSCSIVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateCachediSCSIVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCachediSCSIVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachediSCSIVolumeOutputError>
}

public struct CreateCachediSCSIVolumeInput: Swift.Equatable {
    /// A unique identifier that you use to retry a request. If you retry a request, use the
    ///          same ClientToken you specified in the initial request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4
    ///          addresses are accepted. Use DescribeGatewayInformation to get a list of
    ///          the network interfaces available on a gateway.
    ///
    ///          Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// The snapshot ID (e.g. "snap-1122aabb") of the snapshot to restore as the new cached
    ///          volume. Specify this field if you want to create the iSCSI storage volume from a snapshot;
    ///          otherwise, do not include this field. To list snapshots for your account use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots in the Amazon Elastic Compute Cloud API
    ///             Reference.
    public var snapshotId: Swift.String?
    /// The ARN for an existing volume. Specifying this ARN makes the new volume into an exact
    ///          copy of the specified existing volume's latest recovery point. The
    ///             VolumeSizeInBytes value for this new volume must be equal to or larger than
    ///          the size of the existing volume, in bytes.
    public var sourceVolumeARN: Swift.String?
    /// A list of up to 50 tags that you can assign to a cached volume. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers that you can
    ///             represent in UTF-8 format, and the following special characters: + - = . _ : / @. The
    ///             maximum length of a tag's key is 128 characters, and the maximum length for a
    ///             tag's value is 256 characters.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying TargetName as
    ///             myvolume results in the target ARN of
    ///             arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume.
    ///          The target name must be unique across all volumes on a gateway.
    ///
    ///          If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.
    /// This member is required.
    public var targetName: Swift.String?
    /// The size of the volume in bytes.
    /// This member is required.
    public var volumeSizeInBytes: Swift.Int

    public init (
        clientToken: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        sourceVolumeARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        targetName: Swift.String? = nil,
        volumeSizeInBytes: Swift.Int = 0
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.networkInterfaceId = networkInterfaceId
        self.snapshotId = snapshotId
        self.sourceVolumeARN = sourceVolumeARN
        self.tags = tags
        self.targetName = targetName
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

struct CreateCachediSCSIVolumeInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let volumeSizeInBytes: Swift.Int
    public let snapshotId: Swift.String?
    public let targetName: Swift.String?
    public let sourceVolumeARN: Swift.String?
    public let networkInterfaceId: Swift.String?
    public let clientToken: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateCachediSCSIVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case snapshotId = "SnapshotId"
        case sourceVolumeARN = "SourceVolumeARN"
        case tags = "Tags"
        case targetName = "TargetName"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let sourceVolumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVolumeARN)
        sourceVolumeARN = sourceVolumeARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCachediSCSIVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCachediSCSIVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCachediSCSIVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCachediSCSIVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCachediSCSIVolumeOutputResponse(targetARN: \(Swift.String(describing: targetARN)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension CreateCachediSCSIVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCachediSCSIVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
        } else {
            self.targetARN = nil
            self.volumeARN = nil
        }
    }
}

public struct CreateCachediSCSIVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that
    ///          initiators can use to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured volume.
    public var volumeARN: Swift.String?

    public init (
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

struct CreateCachediSCSIVolumeOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let targetARN: Swift.String?
}

extension CreateCachediSCSIVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

public struct CreateNFSFileShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNFSFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNFSFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNFSFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNFSFileShareOutputError>
}

extension CreateNFSFileShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNFSFileShareInput(bucketRegion: \(Swift.String(describing: bucketRegion)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), clientList: \(Swift.String(describing: clientList)), clientToken: \(Swift.String(describing: clientToken)), defaultStorageClass: \(Swift.String(describing: defaultStorageClass)), fileShareName: \(Swift.String(describing: fileShareName)), gatewayARN: \(Swift.String(describing: gatewayARN)), guessMIMETypeEnabled: \(Swift.String(describing: guessMIMETypeEnabled)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), locationARN: \(Swift.String(describing: locationARN)), nFSFileShareDefaults: \(Swift.String(describing: nFSFileShareDefaults)), notificationPolicy: \(Swift.String(describing: notificationPolicy)), objectACL: \(Swift.String(describing: objectACL)), readOnly: \(Swift.String(describing: readOnly)), requesterPays: \(Swift.String(describing: requesterPays)), role: \(Swift.String(describing: role)), squash: \(Swift.String(describing: squash)), tags: \(Swift.String(describing: tags)), vPCEndpointDNSName: \(Swift.String(describing: vPCEndpointDNSName)))"}
}

extension CreateNFSFileShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
        case vPCEndpointDNSName = "VPCEndpointDNSName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketRegion = bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for fileshareclientlist0 in clientList {
                try clientListContainer.encode(fileshareclientlist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let nFSFileShareDefaults = nFSFileShareDefaults {
            try encodeContainer.encode(nFSFileShareDefaults, forKey: .nFSFileShareDefaults)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let squash = squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vPCEndpointDNSName = vPCEndpointDNSName {
            try encodeContainer.encode(vPCEndpointDNSName, forKey: .vPCEndpointDNSName)
        }
    }
}

public struct CreateNFSFileShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNFSFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNFSFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNFSFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNFSFileShareOutputError>
}

public struct CreateNFSFileShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNFSFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNFSFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNFSFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNFSFileShareOutputError>
}

public struct CreateNFSFileShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNFSFileShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateNFSFileShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateNFSFileShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNFSFileShareOutputError>
}

/// CreateNFSFileShareInput
public struct CreateNFSFileShareInput: Swift.Equatable {
    /// Specifies the Region of the S3 bucket where the NFS file share stores files.
    ///
    ///             This parameter is required for NFS file shares that connect to Amazon S3
    ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    ///
    public var bucketRegion: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The list of clients that are allowed to access the S3 File Gateway. The list must contain
    ///          either valid IP addresses or valid CIDR blocks.
    public var clientList: [Swift.String]?
    /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent
    ///          file share creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway.
    ///          The default value is S3_INTELLIGENT_TIERING. Optional.
    ///
    ///          Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING |
    ///             S3_STANDARD_IA | S3_ONEZONE_IA
    ///
    public var defaultStorageClass: Swift.String?
    /// The name of the file share. Optional.
    ///
    ///
    ///
    ///                FileShareName must be set if an S3 prefix name is set in
    ///                LocationARN.
    ///
    public var fileShareName: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 File Gateway on which you want to create a file
    ///          share.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to true to enable MIME type guessing, otherwise set
    ///          to false. The default value is true.
    ///
    ///          Valid Values: true | false
    ///
    public var guessMIMETypeEnabled: Swift.Bool?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The ARN of the backend storage used for storing file data. A prefix name can be added to
    ///          the S3 bucket name. It must end with a "/".
    ///
    ///             You can specify a bucket attached to an access point using a complete ARN that includes the
    ///             bucket region as shown:
    ///
    ///                arn:aws:s3:region:account-id:accesspoint/access-point-name
    ///
    ///
    ///             If you specify a bucket attached to an access point, the bucket policy must be
    ///             configured to delegate access control to the access point. For information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control">Delegating access control to access points in the Amazon S3 User Guide.
    ///
    /// This member is required.
    public var locationARN: Swift.String?
    /// File share default values. Optional.
    public var nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    /// The notification policy of the file share. SettlingTimeInSeconds controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an ObjectUploaded notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.
    ///
    ///
    ///
    ///                SettlingTimeInSeconds has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.
    ///
    ///
    ///          The following example sets NotificationPolicy on with
    ///             SettlingTimeInSeconds set to 60.
    ///
    ///
    ///             {\"Upload\": {\"SettlingTimeInSeconds\": 60}}
    ///
    ///
    ///          The following example sets NotificationPolicy off.
    ///
    ///
    ///             {}
    ///
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// A value that sets the write status of a file share. Set this value to true
    ///          to set the write status to read-only, otherwise set to false.
    ///
    ///          Valid Values: true | false
    ///
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to true, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.
    ///
    ///
    ///
    ///                RequesterPays is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.
    ///
    ///
    ///          Valid Values: true | false
    ///
    public var requesterPays: Swift.Bool?
    /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes
    ///          when it accesses the underlying storage.
    /// This member is required.
    public var role: Swift.String?
    /// A value that maps a user to anonymous user.
    ///
    ///          Valid values are the following:
    ///
    ///
    ///
    ///
    ///                   RootSquash: Only root is mapped to anonymous user.
    ///
    ///
    ///
    ///                   NoSquash: No one is mapped to anonymous user.
    ///
    ///
    ///
    ///                   AllSquash: Everyone is mapped to anonymous user.
    ///
    ///
    public var squash: Swift.String?
    /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a
    ///          key-value pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to
    ///          Amazon S3.
    ///
    ///             This parameter is required for NFS file shares that connect to Amazon S3
    ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    ///
    public var vPCEndpointDNSName: Swift.String?

    public init (
        bucketRegion: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientList: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        role: Swift.String? = nil,
        squash: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        vPCEndpointDNSName: Swift.String? = nil
    )
    {
        self.bucketRegion = bucketRegion
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.locationARN = locationARN
        self.nFSFileShareDefaults = nFSFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.squash = squash
        self.tags = tags
        self.vPCEndpointDNSName = vPCEndpointDNSName
    }
}

struct CreateNFSFileShareInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    public let gatewayARN: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let role: Swift.String?
    public let locationARN: Swift.String?
    public let defaultStorageClass: Swift.String?
    public let objectACL: StorageGatewayClientTypes.ObjectACL?
    public let clientList: [Swift.String]?
    public let squash: Swift.String?
    public let readOnly: Swift.Bool?
    public let guessMIMETypeEnabled: Swift.Bool?
    public let requesterPays: Swift.Bool?
    public let tags: [StorageGatewayClientTypes.Tag]?
    public let fileShareName: Swift.String?
    public let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    public let notificationPolicy: Swift.String?
    public let vPCEndpointDNSName: Swift.String?
    public let bucketRegion: Swift.String?
}

extension CreateNFSFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
        case vPCEndpointDNSName = "VPCEndpointDNSName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nFSFileShareDefaultsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.NFSFileShareDefaults.self, forKey: .nFSFileShareDefaults)
        nFSFileShareDefaults = nFSFileShareDefaultsDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vPCEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCEndpointDNSName)
        vPCEndpointDNSName = vPCEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
    }
}

extension CreateNFSFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNFSFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNFSFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNFSFileShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNFSFileShareOutputResponse(fileShareARN: \(Swift.String(describing: fileShareARN)))"}
}

extension CreateNFSFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNFSFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// CreateNFSFileShareOutput
public struct CreateNFSFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct CreateNFSFileShareOutputResponseBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
}

extension CreateNFSFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct CreateSMBFileShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSMBFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSMBFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSMBFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSMBFileShareOutputError>
}

extension CreateSMBFileShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSMBFileShareInput(accessBasedEnumeration: \(Swift.String(describing: accessBasedEnumeration)), adminUserList: \(Swift.String(describing: adminUserList)), auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), authentication: \(Swift.String(describing: authentication)), bucketRegion: \(Swift.String(describing: bucketRegion)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), caseSensitivity: \(Swift.String(describing: caseSensitivity)), clientToken: \(Swift.String(describing: clientToken)), defaultStorageClass: \(Swift.String(describing: defaultStorageClass)), fileShareName: \(Swift.String(describing: fileShareName)), gatewayARN: \(Swift.String(describing: gatewayARN)), guessMIMETypeEnabled: \(Swift.String(describing: guessMIMETypeEnabled)), invalidUserList: \(Swift.String(describing: invalidUserList)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), locationARN: \(Swift.String(describing: locationARN)), notificationPolicy: \(Swift.String(describing: notificationPolicy)), objectACL: \(Swift.String(describing: objectACL)), oplocksEnabled: \(Swift.String(describing: oplocksEnabled)), readOnly: \(Swift.String(describing: readOnly)), requesterPays: \(Swift.String(describing: requesterPays)), role: \(Swift.String(describing: role)), sMBACLEnabled: \(Swift.String(describing: sMBACLEnabled)), tags: \(Swift.String(describing: tags)), vPCEndpointDNSName: \(Swift.String(describing: vPCEndpointDNSName)), validUserList: \(Swift.String(describing: validUserList)))"}
}

extension CreateSMBFileShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case sMBACLEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case vPCEndpointDNSName = "VPCEndpointDNSName"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlist0 in adminUserList {
                try adminUserListContainer.encode(userlist0)
            }
        }
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let authentication = authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let bucketRegion = bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlist0 in invalidUserList {
                try invalidUserListContainer.encode(userlist0)
            }
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let oplocksEnabled = oplocksEnabled {
            try encodeContainer.encode(oplocksEnabled, forKey: .oplocksEnabled)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sMBACLEnabled = sMBACLEnabled {
            try encodeContainer.encode(sMBACLEnabled, forKey: .sMBACLEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vPCEndpointDNSName = vPCEndpointDNSName {
            try encodeContainer.encode(vPCEndpointDNSName, forKey: .vPCEndpointDNSName)
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlist0 in validUserList {
                try validUserListContainer.encode(userlist0)
            }
        }
    }
}

public struct CreateSMBFileShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSMBFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSMBFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSMBFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSMBFileShareOutputError>
}

public struct CreateSMBFileShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSMBFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSMBFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSMBFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSMBFileShareOutputError>
}

public struct CreateSMBFileShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSMBFileShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSMBFileShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSMBFileShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSMBFileShareOutputError>
}

/// CreateSMBFileShareInput
public struct CreateSMBFileShareInput: Swift.Equatable {
    /// The files and folders on this share will only be visible to users with read
    ///          access.
    public var accessBasedEnumeration: Swift.Bool?
    /// A list of users or groups in the Active Directory that will be granted administrator
    ///          privileges on the file share. These users can do all file operations as the super-user.
    ///          Acceptable formats include: DOMAIN\User1, user1,
    ///             @group1, and @DOMAIN\group1.
    ///
    ///
    ///             Use this option very carefully, because any user in this list can do anything they
    ///             like on the file share, regardless of file permissions.
    ///
    public var adminUserList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// The authentication method that users use to access the file share. The default is
    ///             ActiveDirectory.
    ///
    ///          Valid Values: ActiveDirectory | GuestAccess
    ///
    public var authentication: Swift.String?
    /// Specifies the Region of the S3 bucket where the SMB file share stores files.
    ///
    ///             This parameter is required for SMB file shares that connect to Amazon S3
    ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    ///
    public var bucketRegion: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the
    ///          client determines the case sensitivity. For CaseSensitive, the gateway
    ///          determines the case sensitivity. The default value is ClientSpecified.
    public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent
    ///          file share creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway.
    ///          The default value is S3_INTELLIGENT_TIERING. Optional.
    ///
    ///          Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING |
    ///             S3_STANDARD_IA | S3_ONEZONE_IA
    ///
    public var defaultStorageClass: Swift.String?
    /// The name of the file share. Optional.
    ///
    ///
    ///
    ///                FileShareName must be set if an S3 prefix name is set in
    ///                LocationARN.
    ///
    public var fileShareName: Swift.String?
    /// The ARN of the S3 File Gateway on which you want to create a file share.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to true to enable MIME type guessing, otherwise set
    ///          to false. The default value is true.
    ///
    ///          Valid Values: true | false
    ///
    public var guessMIMETypeEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are not allowed to access the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             DOMAIN\User1, user1, @group1, and
    ///             @DOMAIN\group1. Can only be set if Authentication is set to
    ///             ActiveDirectory.
    public var invalidUserList: [Swift.String]?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The ARN of the backend storage used for storing file data. A prefix name can be added to
    ///          the S3 bucket name. It must end with a "/".
    ///
    ///             You can specify a bucket attached to an access point using a complete ARN that includes the
    ///          bucket region as shown:
    ///
    ///                arn:aws:s3:region:account-id:accesspoint/access-point-name
    ///
    ///
    ///             If you specify a bucket attached to an access point, the bucket policy must be
    ///             configured to delegate access control to the access point. For information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control">Delegating access control to access points in the Amazon S3 User Guide.
    ///
    /// This member is required.
    public var locationARN: Swift.String?
    /// The notification policy of the file share. SettlingTimeInSeconds controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an ObjectUploaded notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.
    ///
    ///
    ///
    ///                SettlingTimeInSeconds has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.
    ///
    ///
    ///          The following example sets NotificationPolicy on with
    ///             SettlingTimeInSeconds set to 60.
    ///
    ///
    ///             {\"Upload\": {\"SettlingTimeInSeconds\": 60}}
    ///
    ///
    ///          The following example sets NotificationPolicy off.
    ///
    ///
    ///             {}
    ///
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// Specifies whether opportunistic locking is enabled for the SMB file share.
    ///
    ///             Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve
    ///             access to files with the same name in different case.
    ///
    ///          Valid Values: true | false
    ///
    public var oplocksEnabled: Swift.Bool?
    /// A value that sets the write status of a file share. Set this value to true
    ///          to set the write status to read-only, otherwise set to false.
    ///
    ///          Valid Values: true | false
    ///
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to true, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.
    ///
    ///
    ///
    ///                RequesterPays is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.
    ///
    ///
    ///          Valid Values: true | false
    ///
    public var requesterPays: Swift.Bool?
    /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes
    ///          when it accesses the underlying storage.
    /// This member is required.
    public var role: Swift.String?
    /// Set this value to true to enable access control list (ACL) on the SMB file
    ///          share. Set it to false to map file and directory permissions to the POSIX
    ///          permissions.
    ///
    ///
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
    ///             control access to an SMB file share in the Storage Gateway User
    ///             Guide.
    ///
    ///          Valid Values: true | false
    ///
    public var sMBACLEnabled: Swift.Bool?
    /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a
    ///          key-value pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3.
    ///
    ///             This parameter is required for SMB file shares that connect to Amazon S3
    ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    ///
    public var vPCEndpointDNSName: Swift.String?
    /// A list of users or groups in the Active Directory that are allowed to access the file
    ///             <a href=""> share. A group must be prefixed with the @ character. Acceptable formats
    ///          include: DOMAIN\User1, user1, @group1, and
    ///             @DOMAIN\group1. Can only be set if Authentication is set to
    ///             ActiveDirectory.
    public var validUserList: [Swift.String]?

    public init (
        accessBasedEnumeration: Swift.Bool? = nil,
        adminUserList: [Swift.String]? = nil,
        auditDestinationARN: Swift.String? = nil,
        authentication: Swift.String? = nil,
        bucketRegion: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
        clientToken: Swift.String? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        invalidUserList: [Swift.String]? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        oplocksEnabled: Swift.Bool? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        role: Swift.String? = nil,
        sMBACLEnabled: Swift.Bool? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        vPCEndpointDNSName: Swift.String? = nil,
        validUserList: [Swift.String]? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.authentication = authentication
        self.bucketRegion = bucketRegion
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.locationARN = locationARN
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.oplocksEnabled = oplocksEnabled
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.sMBACLEnabled = sMBACLEnabled
        self.tags = tags
        self.vPCEndpointDNSName = vPCEndpointDNSName
        self.validUserList = validUserList
    }
}

struct CreateSMBFileShareInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let gatewayARN: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let role: Swift.String?
    public let locationARN: Swift.String?
    public let defaultStorageClass: Swift.String?
    public let objectACL: StorageGatewayClientTypes.ObjectACL?
    public let readOnly: Swift.Bool?
    public let guessMIMETypeEnabled: Swift.Bool?
    public let requesterPays: Swift.Bool?
    public let sMBACLEnabled: Swift.Bool?
    public let accessBasedEnumeration: Swift.Bool?
    public let adminUserList: [Swift.String]?
    public let validUserList: [Swift.String]?
    public let invalidUserList: [Swift.String]?
    public let auditDestinationARN: Swift.String?
    public let authentication: Swift.String?
    public let caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    public let tags: [StorageGatewayClientTypes.Tag]?
    public let fileShareName: Swift.String?
    public let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    public let notificationPolicy: Swift.String?
    public let vPCEndpointDNSName: Swift.String?
    public let bucketRegion: Swift.String?
    public let oplocksEnabled: Swift.Bool?
}

extension CreateSMBFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case sMBACLEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case vPCEndpointDNSName = "VPCEndpointDNSName"
        case validUserList = "ValidUserList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let sMBACLEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sMBACLEnabled)
        sMBACLEnabled = sMBACLEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[Swift.String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [Swift.String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validUserList)
        var validUserListDecoded0:[Swift.String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [Swift.String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[Swift.String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [Swift.String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vPCEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCEndpointDNSName)
        vPCEndpointDNSName = vPCEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
        let oplocksEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .oplocksEnabled)
        oplocksEnabled = oplocksEnabledDecoded
    }
}

extension CreateSMBFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSMBFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSMBFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSMBFileShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSMBFileShareOutputResponse(fileShareARN: \(Swift.String(describing: fileShareARN)))"}
}

extension CreateSMBFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSMBFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// CreateSMBFileShareOutput
public struct CreateSMBFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct CreateSMBFileShareOutputResponseBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
}

extension CreateSMBFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotFromVolumeRecoveryPointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotFromVolumeRecoveryPointOutputError>
}

extension CreateSnapshotFromVolumeRecoveryPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotFromVolumeRecoveryPointInput(snapshotDescription: \(Swift.String(describing: snapshotDescription)), tags: \(Swift.String(describing: tags)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension CreateSnapshotFromVolumeRecoveryPointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotDescription = snapshotDescription {
            try encodeContainer.encode(snapshotDescription, forKey: .snapshotDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotFromVolumeRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotFromVolumeRecoveryPointOutputError>
}

public struct CreateSnapshotFromVolumeRecoveryPointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotFromVolumeRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotFromVolumeRecoveryPointOutputError>
}

public struct CreateSnapshotFromVolumeRecoveryPointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotFromVolumeRecoveryPointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSnapshotFromVolumeRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSnapshotFromVolumeRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotFromVolumeRecoveryPointOutputError>
}

public struct CreateSnapshotFromVolumeRecoveryPointInput: Swift.Equatable {
    /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic
    ///          Block Store snapshots panel in the Description field, and
    ///          in the Storage Gateway snapshot Details pane,
    ///             Description field.
    /// This member is required.
    public var snapshotDescription: Swift.String?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        snapshotDescription: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotFromVolumeRecoveryPointInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let snapshotDescription: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateSnapshotFromVolumeRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotDescription)
        snapshotDescription = snapshotDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotFromVolumeRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotFromVolumeRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotFromVolumeRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotFromVolumeRecoveryPointOutputResponse(snapshotId: \(Swift.String(describing: snapshotId)), volumeARN: \(Swift.String(describing: volumeARN)), volumeRecoveryPointTime: \(Swift.String(describing: volumeRecoveryPointTime)))"}
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSnapshotFromVolumeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshotId = output.snapshotId
            self.volumeARN = output.volumeARN
            self.volumeRecoveryPointTime = output.volumeRecoveryPointTime
        } else {
            self.snapshotId = nil
            self.volumeARN = nil
            self.volumeRecoveryPointTime = nil
        }
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointOutputResponse: Swift.Equatable {
    /// The ID of the snapshot.
    public var snapshotId: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.
    public var volumeARN: Swift.String?
    /// The time the volume was created from the recovery point.
    public var volumeRecoveryPointTime: Swift.String?

    public init (
        snapshotId: Swift.String? = nil,
        volumeARN: Swift.String? = nil,
        volumeRecoveryPointTime: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
        self.volumeRecoveryPointTime = volumeRecoveryPointTime
    }
}

struct CreateSnapshotFromVolumeRecoveryPointOutputResponseBody: Swift.Equatable {
    public let snapshotId: Swift.String?
    public let volumeARN: Swift.String?
    public let volumeRecoveryPointTime: Swift.String?
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
        case volumeARN = "VolumeARN"
        case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeRecoveryPointTime)
        volumeRecoveryPointTime = volumeRecoveryPointTimeDecoded
    }
}

public struct CreateSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotOutputError>
}

extension CreateSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotInput(snapshotDescription: \(Swift.String(describing: snapshotDescription)), tags: \(Swift.String(describing: tags)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension CreateSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotDescription = snapshotDescription {
            try encodeContainer.encode(snapshotDescription, forKey: .snapshotDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct CreateSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotOutputError>
}

public struct CreateSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotOutputError>
}

public struct CreateSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSnapshotOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   CreateSnapshotInput$SnapshotDescription
///
///
///
///
///                   CreateSnapshotInput$VolumeARN
///
///
///
public struct CreateSnapshotInput: Swift.Equatable {
    /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic
    ///          Block Store snapshots panel in the Description field, and
    ///          in the Storage Gateway snapshot Details pane,
    ///             Description field.
    /// This member is required.
    public var snapshotDescription: Swift.String?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes
    ///          operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        snapshotDescription: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let snapshotDescription: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotDescription)
        snapshotDescription = snapshotDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSnapshotOutputResponse(snapshotId: \(Swift.String(describing: snapshotId)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension CreateSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshotId = output.snapshotId
            self.volumeARN = output.volumeARN
        } else {
            self.snapshotId = nil
            self.volumeARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct CreateSnapshotOutputResponse: Swift.Equatable {
    /// The snapshot ID that is used to refer to the snapshot in future operations such as
    ///          describing snapshots (Amazon Elastic Compute Cloud API DescribeSnapshots) or
    ///          creating a volume from a snapshot (CreateStorediSCSIVolume).
    public var snapshotId: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume of which the snapshot was taken.
    public var volumeARN: Swift.String?

    public init (
        snapshotId: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let snapshotId: Swift.String?
}

extension CreateSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

public struct CreateStorediSCSIVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStorediSCSIVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStorediSCSIVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStorediSCSIVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStorediSCSIVolumeOutputError>
}

extension CreateStorediSCSIVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStorediSCSIVolumeInput(diskId: \(Swift.String(describing: diskId)), gatewayARN: \(Swift.String(describing: gatewayARN)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), preserveExistingData: \(Swift.String(describing: preserveExistingData)), snapshotId: \(Swift.String(describing: snapshotId)), tags: \(Swift.String(describing: tags)), targetName: \(Swift.String(describing: targetName)))"}
}

extension CreateStorediSCSIVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case preserveExistingData = "PreserveExistingData"
        case snapshotId = "SnapshotId"
        case tags = "Tags"
        case targetName = "TargetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskId = diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if preserveExistingData != false {
            try encodeContainer.encode(preserveExistingData, forKey: .preserveExistingData)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
    }
}

public struct CreateStorediSCSIVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStorediSCSIVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStorediSCSIVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStorediSCSIVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStorediSCSIVolumeOutputError>
}

public struct CreateStorediSCSIVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStorediSCSIVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStorediSCSIVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStorediSCSIVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStorediSCSIVolumeOutputError>
}

public struct CreateStorediSCSIVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStorediSCSIVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStorediSCSIVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStorediSCSIVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStorediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStorediSCSIVolumeOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   CreateStorediSCSIVolumeInput$DiskId
///
///
///
///
///                   CreateStorediSCSIVolumeInput$NetworkInterfaceId
///
///
///
///
///                   CreateStorediSCSIVolumeInput$PreserveExistingData
///
///
///
///
///                   CreateStorediSCSIVolumeInput$SnapshotId
///
///
///
///
///                   CreateStorediSCSIVolumeInput$TargetName
///
///
///
public struct CreateStorediSCSIVolumeInput: Swift.Equatable {
    /// The unique identifier for the gateway local disk that is configured as a stored volume.
    ///          Use <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/API_ListLocalDisks.html">ListLocalDisks to
    ///          list disk IDs for a gateway.
    /// This member is required.
    public var diskId: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4
    ///          addresses are accepted. Use DescribeGatewayInformation to get a list of
    ///          the network interfaces available on a gateway.
    ///
    ///          Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// Set to true if you want to preserve the data on the local disk. Otherwise,
    ///          set to false to create an empty volume.
    ///
    ///          Valid Values: true | false
    ///
    /// This member is required.
    public var preserveExistingData: Swift.Bool
    /// The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as the new stored
    ///          volume. Specify this field if you want to create the iSCSI storage volume from a snapshot;
    ///          otherwise, do not include this field. To list snapshots for your account use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots in the Amazon Elastic Compute Cloud API
    ///             Reference.
    public var snapshotId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a stored volume. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying TargetName as
    ///             myvolume results in the target ARN of
    ///             arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume.
    ///          The target name must be unique across all volumes on a gateway.
    ///
    ///          If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.
    /// This member is required.
    public var targetName: Swift.String?

    public init (
        diskId: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        preserveExistingData: Swift.Bool = false,
        snapshotId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.networkInterfaceId = networkInterfaceId
        self.preserveExistingData = preserveExistingData
        self.snapshotId = snapshotId
        self.tags = tags
        self.targetName = targetName
    }
}

struct CreateStorediSCSIVolumeInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let diskId: Swift.String?
    public let snapshotId: Swift.String?
    public let preserveExistingData: Swift.Bool
    public let targetName: Swift.String?
    public let networkInterfaceId: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateStorediSCSIVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case preserveExistingData = "PreserveExistingData"
        case snapshotId = "SnapshotId"
        case tags = "Tags"
        case targetName = "TargetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskId)
        diskId = diskIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let preserveExistingDataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .preserveExistingData)
        preserveExistingData = preserveExistingDataDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStorediSCSIVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStorediSCSIVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStorediSCSIVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStorediSCSIVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStorediSCSIVolumeOutputResponse(targetARN: \(Swift.String(describing: targetARN)), volumeARN: \(Swift.String(describing: volumeARN)), volumeSizeInBytes: \(Swift.String(describing: volumeSizeInBytes)))"}
}

extension CreateStorediSCSIVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStorediSCSIVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
            self.volumeSizeInBytes = output.volumeSizeInBytes
        } else {
            self.targetARN = nil
            self.volumeARN = nil
            self.volumeSizeInBytes = 0
        }
    }
}

/// A JSON object containing the following fields:
public struct CreateStorediSCSIVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that
    ///          initiators can use to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured volume.
    public var volumeARN: Swift.String?
    /// The size of the volume in bytes.
    public var volumeSizeInBytes: Swift.Int

    public init (
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil,
        volumeSizeInBytes: Swift.Int = 0
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

struct CreateStorediSCSIVolumeOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let volumeSizeInBytes: Swift.Int
    public let targetARN: Swift.String?
}

extension CreateStorediSCSIVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

public struct CreateTapePoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapePoolOutputError>
}

extension CreateTapePoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTapePoolInput(poolName: \(Swift.String(describing: poolName)), retentionLockTimeInDays: \(Swift.String(describing: retentionLockTimeInDays)), retentionLockType: \(Swift.String(describing: retentionLockType)), storageClass: \(Swift.String(describing: storageClass)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateTapePoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolName = "PoolName"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let retentionLockTimeInDays = retentionLockTimeInDays {
            try encodeContainer.encode(retentionLockTimeInDays, forKey: .retentionLockTimeInDays)
        }
        if let retentionLockType = retentionLockType {
            try encodeContainer.encode(retentionLockType.rawValue, forKey: .retentionLockType)
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateTapePoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapePoolOutputError>
}

public struct CreateTapePoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapePoolOutputError>
}

public struct CreateTapePoolInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapePoolInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateTapePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTapePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapePoolOutputError>
}

public struct CreateTapePoolInput: Swift.Equatable {
    /// The name of the new custom tape pool.
    /// This member is required.
    public var poolName: Swift.String?
    /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to
    ///          100 years (36,500 days).
    public var retentionLockTimeInDays: Swift.Int?
    /// Tape retention lock can be configured in two modes. When configured in governance mode,
    ///          accounts with specific IAM permissions are authorized to remove the tape retention lock
    ///          from archived virtual tapes. When configured in compliance mode, the tape retention lock
    ///          cannot be removed by any user, including the root account.
    public var retentionLockType: StorageGatewayClientTypes.RetentionLockType?
    /// The storage class that is associated with the new custom pool. When you use your backup
    ///          application to eject the tape, the tape is archived directly into the storage class (S3
    ///          Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    /// This member is required.
    public var storageClass: StorageGatewayClientTypes.TapeStorageClass?
    /// A list of up to 50 tags that can be assigned to tape pool. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init (
        poolName: Swift.String? = nil,
        retentionLockTimeInDays: Swift.Int? = nil,
        retentionLockType: StorageGatewayClientTypes.RetentionLockType? = nil,
        storageClass: StorageGatewayClientTypes.TapeStorageClass? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.poolName = poolName
        self.retentionLockTimeInDays = retentionLockTimeInDays
        self.retentionLockType = retentionLockType
        self.storageClass = storageClass
        self.tags = tags
    }
}

struct CreateTapePoolInputBody: Swift.Equatable {
    public let poolName: Swift.String?
    public let storageClass: StorageGatewayClientTypes.TapeStorageClass?
    public let retentionLockType: StorageGatewayClientTypes.RetentionLockType?
    public let retentionLockTimeInDays: Swift.Int?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateTapePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolName = "PoolName"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.TapeStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let retentionLockTypeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.RetentionLockType.self, forKey: .retentionLockType)
        retentionLockType = retentionLockTypeDecoded
        let retentionLockTimeInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionLockTimeInDays)
        retentionLockTimeInDays = retentionLockTimeInDaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTapePoolOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapePoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTapePoolOutputResponse(poolARN: \(Swift.String(describing: poolARN)))"}
}

extension CreateTapePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.poolARN = output.poolARN
        } else {
            self.poolARN = nil
        }
    }
}

public struct CreateTapePoolOutputResponse: Swift.Equatable {
    /// The unique Amazon Resource Name (ARN) that represents the custom tape pool. Use the
    ///             ListTapePools operation to return a list of tape pools for your
    ///          account and Region.
    public var poolARN: Swift.String?

    public init (
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct CreateTapePoolOutputResponseBody: Swift.Equatable {
    public let poolARN: Swift.String?
}

extension CreateTapePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

public struct CreateTapeWithBarcodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapeWithBarcodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapeWithBarcodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapeWithBarcodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapeWithBarcodeOutputError>
}

extension CreateTapeWithBarcodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTapeWithBarcodeInput(gatewayARN: \(Swift.String(describing: gatewayARN)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), poolId: \(Swift.String(describing: poolId)), tags: \(Swift.String(describing: tags)), tapeBarcode: \(Swift.String(describing: tapeBarcode)), tapeSizeInBytes: \(Swift.String(describing: tapeSizeInBytes)), worm: \(Swift.String(describing: worm)))"}
}

extension CreateTapeWithBarcodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }
}

public struct CreateTapeWithBarcodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapeWithBarcodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapeWithBarcodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapeWithBarcodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapeWithBarcodeOutputError>
}

public struct CreateTapeWithBarcodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapeWithBarcodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapeWithBarcodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapeWithBarcodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapeWithBarcodeOutputError>
}

public struct CreateTapeWithBarcodeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapeWithBarcodeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateTapeWithBarcodeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTapeWithBarcodeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapeWithBarcodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapeWithBarcodeOutputError>
}

/// CreateTapeWithBarcodeInput
public struct CreateTapeWithBarcodeInput: Swift.Equatable {
    /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the
    ///          virtual tape with. Use the ListGateways operation to return a list of
    ///          gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the S3 storage class that is associated with the pool. When you use
    ///          your backup application to eject the tape, the tape is archived directly into the storage
    ///          class (S3 Glacier or S3 Deep Archive) that corresponds to the pool.
    ///
    ///          Valid Values: GLACIER | DEEP_ARCHIVE
    ///
    public var poolId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a virtual tape that has a barcode. Each
    ///          tag is a key-value pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The barcode that you want to assign to the tape.
    ///
    ///
    ///             Barcodes cannot be reused. This includes barcodes used for tapes that have been
    ///             deleted.
    ///
    /// This member is required.
    public var tapeBarcode: Swift.String?
    /// The size, in bytes, of the virtual tape that you want to create.
    ///
    ///
    ///             The size must be aligned by gigabyte (1024*1024*1024 bytes).
    ///
    /// This member is required.
    public var tapeSizeInBytes: Swift.Int?
    /// Set to TRUE if the tape you are creating is to be configured as a
    ///          write-once-read-many (WORM) tape.
    public var worm: Swift.Bool

    public init (
        gatewayARN: Swift.String? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        poolId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeBarcode: Swift.String? = nil,
        tapeSizeInBytes: Swift.Int? = nil,
        worm: Swift.Bool = false
    )
    {
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcode = tapeBarcode
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

struct CreateTapeWithBarcodeInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let tapeSizeInBytes: Swift.Int?
    public let tapeBarcode: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let poolId: Swift.String?
    public let worm: Swift.Bool
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateTapeWithBarcodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Swift.Bool.self, forKey: .worm)
        worm = wormDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapeWithBarcodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapeWithBarcodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTapeWithBarcodeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapeWithBarcodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTapeWithBarcodeOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension CreateTapeWithBarcodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTapeWithBarcodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// CreateTapeOutput
public struct CreateTapeWithBarcodeOutputResponse: Swift.Equatable {
    /// A unique Amazon Resource Name (ARN) that represents the virtual tape that was
    ///          created.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CreateTapeWithBarcodeOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension CreateTapeWithBarcodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct CreateTapesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapesOutputError>
}

extension CreateTapesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTapesInput(clientToken: \(Swift.String(describing: clientToken)), gatewayARN: \(Swift.String(describing: gatewayARN)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), numTapesToCreate: \(Swift.String(describing: numTapesToCreate)), poolId: \(Swift.String(describing: poolId)), tags: \(Swift.String(describing: tags)), tapeBarcodePrefix: \(Swift.String(describing: tapeBarcodePrefix)), tapeSizeInBytes: \(Swift.String(describing: tapeSizeInBytes)), worm: \(Swift.String(describing: worm)))"}
}

extension CreateTapesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case numTapesToCreate = "NumTapesToCreate"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let numTapesToCreate = numTapesToCreate {
            try encodeContainer.encode(numTapesToCreate, forKey: .numTapesToCreate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let tapeBarcodePrefix = tapeBarcodePrefix {
            try encodeContainer.encode(tapeBarcodePrefix, forKey: .tapeBarcodePrefix)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }
}

public struct CreateTapesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapesOutputError>
}

public struct CreateTapesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapesOutputError>
}

public struct CreateTapesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTapesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateTapesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTapesInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTapesOutputError>
}

/// CreateTapesInput
public struct CreateTapesInput: Swift.Equatable {
    /// A unique identifier that you use to retry a request. If you retry a request, use the
    ///          same ClientToken you specified in the initial request.
    ///
    ///
    ///             Using the same ClientToken prevents creating the tape multiple
    ///             times.
    ///
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the
    ///          virtual tapes with. Use the ListGateways operation to return a list of
    ///          gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The number of virtual tapes that you want to create.
    /// This member is required.
    public var numTapesToCreate: Swift.Int?
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the S3 storage class that is associated with the pool. When you use
    ///          your backup application to eject the tape, the tape is archived directly into the storage
    ///          class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    ///
    ///          Valid Values: GLACIER | DEEP_ARCHIVE
    ///
    public var poolId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a virtual tape. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A prefix that you append to the barcode of the virtual tape you are creating. This
    ///          prefix makes the barcode unique.
    ///
    ///
    ///             The prefix must be 1-4 characters in length and must be one of the uppercase letters
    ///             from A to Z.
    ///
    /// This member is required.
    public var tapeBarcodePrefix: Swift.String?
    /// The size, in bytes, of the virtual tapes that you want to create.
    ///
    ///
    ///             The size must be aligned by gigabyte (1024*1024*1024 bytes).
    ///
    /// This member is required.
    public var tapeSizeInBytes: Swift.Int?
    /// Set to TRUE if the tape you are creating is to be configured as a
    ///          write-once-read-many (WORM) tape.
    public var worm: Swift.Bool

    public init (
        clientToken: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        numTapesToCreate: Swift.Int? = nil,
        poolId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeBarcodePrefix: Swift.String? = nil,
        tapeSizeInBytes: Swift.Int? = nil,
        worm: Swift.Bool = false
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.numTapesToCreate = numTapesToCreate
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcodePrefix = tapeBarcodePrefix
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

struct CreateTapesInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let tapeSizeInBytes: Swift.Int?
    public let clientToken: Swift.String?
    public let numTapesToCreate: Swift.Int?
    public let tapeBarcodePrefix: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let poolId: Swift.String?
    public let worm: Swift.Bool
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateTapesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case numTapesToCreate = "NumTapesToCreate"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let numTapesToCreateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numTapesToCreate)
        numTapesToCreate = numTapesToCreateDecoded
        let tapeBarcodePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcodePrefix)
        tapeBarcodePrefix = tapeBarcodePrefixDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Swift.Bool.self, forKey: .worm)
        worm = wormDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTapesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTapesOutputResponse(tapeARNs: \(Swift.String(describing: tapeARNs)))"}
}

extension CreateTapesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTapesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARNs = output.tapeARNs
        } else {
            self.tapeARNs = nil
        }
    }
}

/// CreateTapeOutput
public struct CreateTapesOutputResponse: Swift.Equatable {
    /// A list of unique Amazon Resource Names (ARNs) that represents the virtual tapes that
    ///          were created.
    public var tapeARNs: [Swift.String]?

    public init (
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.tapeARNs = tapeARNs
    }
}

struct CreateTapesOutputResponseBody: Swift.Equatable {
    public let tapeARNs: [Swift.String]?
}

extension CreateTapesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
    }
}

public struct DeleteAutomaticTapeCreationPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutomaticTapeCreationPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutomaticTapeCreationPolicyOutputError>
}

extension DeleteAutomaticTapeCreationPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAutomaticTapeCreationPolicyInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DeleteAutomaticTapeCreationPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DeleteAutomaticTapeCreationPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutomaticTapeCreationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutomaticTapeCreationPolicyOutputError>
}

public struct DeleteAutomaticTapeCreationPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutomaticTapeCreationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutomaticTapeCreationPolicyOutputError>
}

public struct DeleteAutomaticTapeCreationPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutomaticTapeCreationPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAutomaticTapeCreationPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAutomaticTapeCreationPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutomaticTapeCreationPolicyOutputError>
}

public struct DeleteAutomaticTapeCreationPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteAutomaticTapeCreationPolicyInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DeleteAutomaticTapeCreationPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteAutomaticTapeCreationPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAutomaticTapeCreationPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAutomaticTapeCreationPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAutomaticTapeCreationPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAutomaticTapeCreationPolicyOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DeleteAutomaticTapeCreationPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAutomaticTapeCreationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct DeleteAutomaticTapeCreationPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteAutomaticTapeCreationPolicyOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DeleteAutomaticTapeCreationPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DeleteBandwidthRateLimitInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBandwidthRateLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBandwidthRateLimitOutputError>
}

extension DeleteBandwidthRateLimitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBandwidthRateLimitInput(bandwidthType: \(Swift.String(describing: bandwidthType)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DeleteBandwidthRateLimitInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthType = "BandwidthType"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthType = bandwidthType {
            try encodeContainer.encode(bandwidthType, forKey: .bandwidthType)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DeleteBandwidthRateLimitInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBandwidthRateLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBandwidthRateLimitOutputError>
}

public struct DeleteBandwidthRateLimitInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBandwidthRateLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBandwidthRateLimitOutputError>
}

public struct DeleteBandwidthRateLimitInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBandwidthRateLimitInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteBandwidthRateLimitInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBandwidthRateLimitInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBandwidthRateLimitOutputError>
}

/// A JSON object containing the following fields:
///
///
///
///
///                   DeleteBandwidthRateLimitInput$BandwidthType
///
///
///
public struct DeleteBandwidthRateLimitInput: Swift.Equatable {
    /// One of the BandwidthType values that indicates the gateway bandwidth rate limit to
    ///          delete.
    ///
    ///          Valid Values: UPLOAD | DOWNLOAD | ALL
    ///
    /// This member is required.
    public var bandwidthType: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        bandwidthType: Swift.String? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthType = bandwidthType
        self.gatewayARN = gatewayARN
    }
}

struct DeleteBandwidthRateLimitInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let bandwidthType: Swift.String?
}

extension DeleteBandwidthRateLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthType = "BandwidthType"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidthType)
        bandwidthType = bandwidthTypeDecoded
    }
}

extension DeleteBandwidthRateLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBandwidthRateLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBandwidthRateLimitOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBandwidthRateLimitOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBandwidthRateLimitOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DeleteBandwidthRateLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose bandwidth
///          rate information was deleted.
public struct DeleteBandwidthRateLimitOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteBandwidthRateLimitOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DeleteBandwidthRateLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DeleteChapCredentialsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChapCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChapCredentialsOutputError>
}

extension DeleteChapCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChapCredentialsInput(initiatorName: \(Swift.String(describing: initiatorName)), targetARN: \(Swift.String(describing: targetARN)))"}
}

extension DeleteChapCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

public struct DeleteChapCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChapCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChapCredentialsOutputError>
}

public struct DeleteChapCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChapCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChapCredentialsOutputError>
}

public struct DeleteChapCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChapCredentialsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteChapCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChapCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChapCredentialsOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   DeleteChapCredentialsInput$InitiatorName
///
///
///
///
///                   DeleteChapCredentialsInput$TargetARN
///
///
///
public struct DeleteChapCredentialsInput: Swift.Equatable {
    /// The iSCSI initiator that connects to the target.
    /// This member is required.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct DeleteChapCredentialsInputBody: Swift.Equatable {
    public let targetARN: Swift.String?
    public let initiatorName: Swift.String?
}

extension DeleteChapCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

extension DeleteChapCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChapCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChapCredentialsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChapCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChapCredentialsOutputResponse(initiatorName: \(Swift.String(describing: initiatorName)), targetARN: \(Swift.String(describing: targetARN)))"}
}

extension DeleteChapCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiatorName = output.initiatorName
            self.targetARN = output.targetARN
        } else {
            self.initiatorName = nil
            self.targetARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DeleteChapCredentialsOutputResponse: Swift.Equatable {
    /// The iSCSI initiator that connects to the target.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the target.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct DeleteChapCredentialsOutputResponseBody: Swift.Equatable {
    public let targetARN: Swift.String?
    public let initiatorName: Swift.String?
}

extension DeleteChapCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

public struct DeleteFileShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileShareOutputError>
}

extension DeleteFileShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileShareInput(fileShareARN: \(Swift.String(describing: fileShareARN)), forceDelete: \(Swift.String(describing: forceDelete)))"}
}

extension DeleteFileShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case forceDelete = "ForceDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DeleteFileShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileShareOutputError>
}

public struct DeleteFileShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileShareOutputError>
}

public struct DeleteFileShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteFileShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFileShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileShareOutputError>
}

/// DeleteFileShareInput
public struct DeleteFileShareInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share to be deleted.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// If this value is set to true, the operation deletes a file share
    ///          immediately and aborts all data uploads to Amazon Web Services. Otherwise, the file share is not deleted
    ///          until all data is uploaded to Amazon Web Services. This process aborts the data upload process, and the
    ///          file share enters the FORCE_DELETING status.
    ///
    ///          Valid Values: true | false
    ///
    public var forceDelete: Swift.Bool

    public init (
        fileShareARN: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.fileShareARN = fileShareARN
        self.forceDelete = forceDelete
    }
}

struct DeleteFileShareInputBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
    public let forceDelete: Swift.Bool
}

extension DeleteFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case forceDelete = "ForceDelete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let forceDeleteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileShareOutputResponse(fileShareARN: \(Swift.String(describing: fileShareARN)))"}
}

extension DeleteFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// DeleteFileShareOutput
public struct DeleteFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct DeleteFileShareOutputResponseBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
}

extension DeleteFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct DeleteGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGatewayOutputError>
}

extension DeleteGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGatewayInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DeleteGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DeleteGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGatewayOutputError>
}

/// A JSON object containing the ID of the gateway to delete.
public struct DeleteGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DeleteGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGatewayOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DeleteGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the ID of the deleted gateway.
public struct DeleteGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteGatewayOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DeleteGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DeleteSnapshotScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotScheduleOutputError>
}

extension DeleteSnapshotScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSnapshotScheduleInput(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DeleteSnapshotScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DeleteSnapshotScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSnapshotScheduleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteSnapshotScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSnapshotScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInput: Swift.Equatable {
    /// The volume which snapshot schedule to delete.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteSnapshotScheduleInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension DeleteSnapshotScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeleteSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSnapshotScheduleOutputResponse(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DeleteSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

public struct DeleteSnapshotScheduleOutputResponse: Swift.Equatable {
    /// The volume which snapshot schedule was deleted.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteSnapshotScheduleOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension DeleteSnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

public struct DeleteTapeArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeArchiveOutputError>
}

extension DeleteTapeArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTapeArchiveInput(bypassGovernanceRetention: \(Swift.String(describing: bypassGovernanceRetention)), tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension DeleteTapeArchiveInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct DeleteTapeArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeArchiveOutputError>
}

public struct DeleteTapeArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeArchiveOutputError>
}

public struct DeleteTapeArchiveInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeArchiveInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteTapeArchiveInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTapeArchiveInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeArchiveOutputError>
}

/// DeleteTapeArchiveInput
public struct DeleteTapeArchiveInput: Swift.Equatable {
    /// Set to TRUE to delete an archived tape that belongs to a custom pool with
    ///          tape retention lock. Only archived tapes with tape retention lock set to
    ///             governance can be deleted. Archived tapes with tape retention lock set to
    ///             compliance can't be deleted.
    public var bypassGovernanceRetention: Swift.Bool
    /// The Amazon Resource Name (ARN) of the virtual tape to delete from the virtual tape shelf
    ///          (VTS).
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        bypassGovernanceRetention: Swift.Bool = false,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeArchiveInputBody: Swift.Equatable {
    public let tapeARN: Swift.String?
    public let bypassGovernanceRetention: Swift.Bool
}

extension DeleteTapeArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .bypassGovernanceRetention)
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension DeleteTapeArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapeArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTapeArchiveOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapeArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTapeArchiveOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension DeleteTapeArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteTapeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// DeleteTapeArchiveOutput
public struct DeleteTapeArchiveOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape that was deleted from the virtual
    ///          tape shelf (VTS).
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeArchiveOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension DeleteTapeArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct DeleteTapeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeOutputError>
}

extension DeleteTapeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTapeInput(bypassGovernanceRetention: \(Swift.String(describing: bypassGovernanceRetention)), gatewayARN: \(Swift.String(describing: gatewayARN)), tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension DeleteTapeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct DeleteTapeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeOutputError>
}

public struct DeleteTapeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeOutputError>
}

public struct DeleteTapeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteTapeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTapeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapeOutputError>
}

/// DeleteTapeInput
public struct DeleteTapeInput: Swift.Equatable {
    /// Set to TRUE to delete an archived tape that belongs to a custom pool with
    ///          tape retention lock. Only archived tapes with tape retention lock set to
    ///             governance can be deleted. Archived tapes with tape retention lock set to
    ///             compliance can't be deleted.
    public var bypassGovernanceRetention: Swift.Bool
    /// The unique Amazon Resource Name (ARN) of the gateway that the virtual tape to delete is
    ///          associated with. Use the ListGateways operation to return a list of
    ///          gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape to delete.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        bypassGovernanceRetention: Swift.Bool = false,
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let tapeARN: Swift.String?
    public let bypassGovernanceRetention: Swift.Bool
}

extension DeleteTapeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .bypassGovernanceRetention)
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension DeleteTapeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTapeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTapeOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension DeleteTapeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteTapeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// DeleteTapeOutput
public struct DeleteTapeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted virtual tape.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension DeleteTapeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct DeleteTapePoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapePoolOutputError>
}

extension DeleteTapePoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTapePoolInput(poolARN: \(Swift.String(describing: poolARN)))"}
}

extension DeleteTapePoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolARN = poolARN {
            try encodeContainer.encode(poolARN, forKey: .poolARN)
        }
    }
}

public struct DeleteTapePoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapePoolOutputError>
}

public struct DeleteTapePoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTapePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTapePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapePoolOutputError>
}

public struct DeleteTapePoolInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTapePoolInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteTapePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTapePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTapePoolOutputError>
}

public struct DeleteTapePoolInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom tape pool to delete.
    /// This member is required.
    public var poolARN: Swift.String?

    public init (
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct DeleteTapePoolInputBody: Swift.Equatable {
    public let poolARN: Swift.String?
}

extension DeleteTapePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

extension DeleteTapePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTapePoolOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapePoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTapePoolOutputResponse(poolARN: \(Swift.String(describing: poolARN)))"}
}

extension DeleteTapePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.poolARN = output.poolARN
        } else {
            self.poolARN = nil
        }
    }
}

public struct DeleteTapePoolOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom tape pool being deleted.
    public var poolARN: Swift.String?

    public init (
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct DeleteTapePoolOutputResponseBody: Swift.Equatable {
    public let poolARN: Swift.String?
}

extension DeleteTapePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

public struct DeleteVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVolumeOutputError>
}

extension DeleteVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVolumeInput(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DeleteVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DeleteVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVolumeOutputError>
}

public struct DeleteVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVolumeOutputError>
}

public struct DeleteVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVolumeOutputError>
}

/// A JSON object containing the DeleteVolumeInput$VolumeARN to
///          delete.
public struct DeleteVolumeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes
    ///          operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteVolumeInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension DeleteVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeleteVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVolumeOutputResponse(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DeleteVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the storage volume that was
///          deleted.
public struct DeleteVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage volume that was deleted. It is the same
    ///          ARN you provided in the request.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteVolumeOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension DeleteVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

public struct DescribeAvailabilityMonitorTestInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityMonitorTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailabilityMonitorTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityMonitorTestOutputError>
}

extension DescribeAvailabilityMonitorTestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAvailabilityMonitorTestInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeAvailabilityMonitorTestInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeAvailabilityMonitorTestInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityMonitorTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailabilityMonitorTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityMonitorTestOutputError>
}

public struct DescribeAvailabilityMonitorTestInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityMonitorTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAvailabilityMonitorTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityMonitorTestOutputError>
}

public struct DescribeAvailabilityMonitorTestInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAvailabilityMonitorTestInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAvailabilityMonitorTestInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAvailabilityMonitorTestInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAvailabilityMonitorTestOutputError>
}

public struct DescribeAvailabilityMonitorTestInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeAvailabilityMonitorTestInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeAvailabilityMonitorTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeAvailabilityMonitorTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAvailabilityMonitorTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAvailabilityMonitorTestOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailabilityMonitorTestOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAvailabilityMonitorTestOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)))"}
}

extension DescribeAvailabilityMonitorTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAvailabilityMonitorTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.gatewayARN = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeAvailabilityMonitorTestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// The time the high availability monitoring test was started. If a test hasn't been
    ///          performed, the value of this field is null.
    public var startTime: ClientRuntime.Date?
    /// The status of the high availability monitoring test. If a test hasn't been
    ///          performed, the value of this field is null.
    public var status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus?

    public init (
        gatewayARN: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeAvailabilityMonitorTestOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus?
    public let startTime: ClientRuntime.Date?
}

extension DescribeAvailabilityMonitorTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case startTime = "StartTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.AvailabilityMonitorTestStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

public struct DescribeBandwidthRateLimitInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitOutputError>
}

extension DescribeBandwidthRateLimitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBandwidthRateLimitInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeBandwidthRateLimitInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitOutputError>
}

public struct DescribeBandwidthRateLimitInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitOutputError>
}

public struct DescribeBandwidthRateLimitInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeBandwidthRateLimitInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBandwidthRateLimitInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeBandwidthRateLimitInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeBandwidthRateLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeBandwidthRateLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBandwidthRateLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBandwidthRateLimitOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBandwidthRateLimitOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBandwidthRateLimitOutputResponse(averageDownloadRateLimitInBitsPerSec: \(Swift.String(describing: averageDownloadRateLimitInBitsPerSec)), averageUploadRateLimitInBitsPerSec: \(Swift.String(describing: averageUploadRateLimitInBitsPerSec)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.averageDownloadRateLimitInBitsPerSec = output.averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = output.averageUploadRateLimitInBitsPerSec
            self.gatewayARN = output.gatewayARN
        } else {
            self.averageDownloadRateLimitInBitsPerSec = nil
            self.averageUploadRateLimitInBitsPerSec = nil
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeBandwidthRateLimitOutputResponse: Swift.Equatable {
    /// The average download bandwidth rate limit in bits per second. This field does not appear
    ///          in the response if the download rate limit is not set.
    public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
    /// The average upload bandwidth rate limit in bits per second. This field does not appear
    ///          in the response if the upload rate limit is not set.
    public var averageUploadRateLimitInBitsPerSec: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
        averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let averageUploadRateLimitInBitsPerSec: Swift.Int?
    public let averageDownloadRateLimitInBitsPerSec: Swift.Int?
}

extension DescribeBandwidthRateLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

public struct DescribeBandwidthRateLimitScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitScheduleOutputError>
}

extension DescribeBandwidthRateLimitScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBandwidthRateLimitScheduleInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeBandwidthRateLimitScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitScheduleOutputError>
}

public struct DescribeBandwidthRateLimitScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitScheduleOutputError>
}

public struct DescribeBandwidthRateLimitScheduleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBandwidthRateLimitScheduleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeBandwidthRateLimitScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBandwidthRateLimitScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBandwidthRateLimitScheduleOutputError>
}

public struct DescribeBandwidthRateLimitScheduleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBandwidthRateLimitScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBandwidthRateLimitScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBandwidthRateLimitScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBandwidthRateLimitScheduleOutputResponse(bandwidthRateLimitIntervals: \(Swift.String(describing: bandwidthRateLimitIntervals)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bandwidthRateLimitIntervals = output.bandwidthRateLimitIntervals
            self.gatewayARN = output.gatewayARN
        } else {
            self.bandwidthRateLimitIntervals = nil
            self.gatewayARN = nil
        }
    }
}

public struct DescribeBandwidthRateLimitScheduleOutputResponse: Swift.Equatable {
    ///
    ///          An array that contains the bandwidth rate limit intervals for a tape or volume gateway.
    ///
    public var bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitScheduleOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension DescribeBandwidthRateLimitScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [StorageGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

public struct DescribeCacheInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCacheOutputError>
}

extension DescribeCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCacheInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeCacheInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCacheOutputError>
}

public struct DescribeCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCacheOutputError>
}

public struct DescribeCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCacheOutputError>
}

public struct DescribeCacheInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeCacheInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCacheOutputResponse(cacheAllocatedInBytes: \(Swift.String(describing: cacheAllocatedInBytes)), cacheDirtyPercentage: \(Swift.String(describing: cacheDirtyPercentage)), cacheHitPercentage: \(Swift.String(describing: cacheHitPercentage)), cacheMissPercentage: \(Swift.String(describing: cacheMissPercentage)), cacheUsedPercentage: \(Swift.String(describing: cacheUsedPercentage)), diskIds: \(Swift.String(describing: diskIds)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cacheAllocatedInBytes = output.cacheAllocatedInBytes
            self.cacheDirtyPercentage = output.cacheDirtyPercentage
            self.cacheHitPercentage = output.cacheHitPercentage
            self.cacheMissPercentage = output.cacheMissPercentage
            self.cacheUsedPercentage = output.cacheUsedPercentage
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
        } else {
            self.cacheAllocatedInBytes = 0
            self.cacheDirtyPercentage = 0.0
            self.cacheHitPercentage = 0.0
            self.cacheMissPercentage = 0.0
            self.cacheUsedPercentage = 0.0
            self.diskIds = nil
            self.gatewayARN = nil
        }
    }
}

public struct DescribeCacheOutputResponse: Swift.Equatable {
    /// The amount of cache in bytes allocated to a gateway.
    public var cacheAllocatedInBytes: Swift.Int
    /// The file share's contribution to the overall percentage of the gateway's cache
    ///          that has not been persisted to Amazon Web Services. The sample is taken at the end of the reporting
    ///          period.
    public var cacheDirtyPercentage: Swift.Double
    /// Percent of application read operations from the file shares that are served from cache.
    ///          The sample is taken at the end of the reporting period.
    public var cacheHitPercentage: Swift.Double
    /// Percent of application read operations from the file shares that are not served from
    ///          cache. The sample is taken at the end of the reporting period.
    public var cacheMissPercentage: Swift.Double
    /// Percent use of the gateway's cache storage. This metric applies only to the
    ///          gateway-cached volume setup. The sample is taken at the end of the reporting period.
    public var cacheUsedPercentage: Swift.Double
    /// An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the ListLocalDisks API.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        cacheAllocatedInBytes: Swift.Int = 0,
        cacheDirtyPercentage: Swift.Double = 0.0,
        cacheHitPercentage: Swift.Double = 0.0,
        cacheMissPercentage: Swift.Double = 0.0,
        cacheUsedPercentage: Swift.Double = 0.0,
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.cacheAllocatedInBytes = cacheAllocatedInBytes
        self.cacheDirtyPercentage = cacheDirtyPercentage
        self.cacheHitPercentage = cacheHitPercentage
        self.cacheMissPercentage = cacheMissPercentage
        self.cacheUsedPercentage = cacheUsedPercentage
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct DescribeCacheOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let diskIds: [Swift.String]?
    public let cacheAllocatedInBytes: Swift.Int
    public let cacheUsedPercentage: Swift.Double
    public let cacheDirtyPercentage: Swift.Double
    public let cacheHitPercentage: Swift.Double
    public let cacheMissPercentage: Swift.Double
}

extension DescribeCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheAllocatedInBytes = "CacheAllocatedInBytes"
        case cacheDirtyPercentage = "CacheDirtyPercentage"
        case cacheHitPercentage = "CacheHitPercentage"
        case cacheMissPercentage = "CacheMissPercentage"
        case cacheUsedPercentage = "CacheUsedPercentage"
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let cacheAllocatedInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .cacheAllocatedInBytes)
        cacheAllocatedInBytes = cacheAllocatedInBytesDecoded
        let cacheUsedPercentageDecoded = try containerValues.decode(Swift.Double.self, forKey: .cacheUsedPercentage)
        cacheUsedPercentage = cacheUsedPercentageDecoded
        let cacheDirtyPercentageDecoded = try containerValues.decode(Swift.Double.self, forKey: .cacheDirtyPercentage)
        cacheDirtyPercentage = cacheDirtyPercentageDecoded
        let cacheHitPercentageDecoded = try containerValues.decode(Swift.Double.self, forKey: .cacheHitPercentage)
        cacheHitPercentage = cacheHitPercentageDecoded
        let cacheMissPercentageDecoded = try containerValues.decode(Swift.Double.self, forKey: .cacheMissPercentage)
        cacheMissPercentage = cacheMissPercentageDecoded
    }
}

public struct DescribeCachediSCSIVolumesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCachediSCSIVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCachediSCSIVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCachediSCSIVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCachediSCSIVolumesOutputError>
}

extension DescribeCachediSCSIVolumesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCachediSCSIVolumesInput(volumeARNs: \(Swift.String(describing: volumeARNs)))"}
}

extension DescribeCachediSCSIVolumesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARNs = volumeARNs {
            var volumeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeARNs)
            for volumearns0 in volumeARNs {
                try volumeARNsContainer.encode(volumearns0)
            }
        }
    }
}

public struct DescribeCachediSCSIVolumesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCachediSCSIVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCachediSCSIVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCachediSCSIVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCachediSCSIVolumesOutputError>
}

public struct DescribeCachediSCSIVolumesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCachediSCSIVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCachediSCSIVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCachediSCSIVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCachediSCSIVolumesOutputError>
}

public struct DescribeCachediSCSIVolumesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCachediSCSIVolumesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCachediSCSIVolumesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCachediSCSIVolumesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCachediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCachediSCSIVolumesOutputError>
}

public struct DescribeCachediSCSIVolumesInput: Swift.Equatable {
    /// An array of strings where each string represents the Amazon Resource Name (ARN) of a
    ///          cached volume. All of the specified cached volumes must be from the same gateway. Use ListVolumes to get volume ARNs for a gateway.
    /// This member is required.
    public var volumeARNs: [Swift.String]?

    public init (
        volumeARNs: [Swift.String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

struct DescribeCachediSCSIVolumesInputBody: Swift.Equatable {
    public let volumeARNs: [Swift.String]?
}

extension DescribeCachediSCSIVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .volumeARNs)
        var volumeARNsDecoded0:[Swift.String]? = nil
        if let volumeARNsContainer = volumeARNsContainer {
            volumeARNsDecoded0 = [Swift.String]()
            for string0 in volumeARNsContainer {
                if let string0 = string0 {
                    volumeARNsDecoded0?.append(string0)
                }
            }
        }
        volumeARNs = volumeARNsDecoded0
    }
}

extension DescribeCachediSCSIVolumesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCachediSCSIVolumesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCachediSCSIVolumesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCachediSCSIVolumesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCachediSCSIVolumesOutputResponse(cachediSCSIVolumes: \(Swift.String(describing: cachediSCSIVolumes)))"}
}

extension DescribeCachediSCSIVolumesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCachediSCSIVolumesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cachediSCSIVolumes = output.cachediSCSIVolumes
        } else {
            self.cachediSCSIVolumes = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeCachediSCSIVolumesOutputResponse: Swift.Equatable {
    /// An array of objects where each object contains metadata about one cached volume.
    public var cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]?

    public init (
        cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]? = nil
    )
    {
        self.cachediSCSIVolumes = cachediSCSIVolumes
    }
}

struct DescribeCachediSCSIVolumesOutputResponseBody: Swift.Equatable {
    public let cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]?
}

extension DescribeCachediSCSIVolumesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachediSCSIVolumes = "CachediSCSIVolumes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachediSCSIVolumesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.CachediSCSIVolume?].self, forKey: .cachediSCSIVolumes)
        var cachediSCSIVolumesDecoded0:[StorageGatewayClientTypes.CachediSCSIVolume]? = nil
        if let cachediSCSIVolumesContainer = cachediSCSIVolumesContainer {
            cachediSCSIVolumesDecoded0 = [StorageGatewayClientTypes.CachediSCSIVolume]()
            for structure0 in cachediSCSIVolumesContainer {
                if let structure0 = structure0 {
                    cachediSCSIVolumesDecoded0?.append(structure0)
                }
            }
        }
        cachediSCSIVolumes = cachediSCSIVolumesDecoded0
    }
}

public struct DescribeChapCredentialsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChapCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChapCredentialsOutputError>
}

extension DescribeChapCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChapCredentialsInput(targetARN: \(Swift.String(describing: targetARN)))"}
}

extension DescribeChapCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

public struct DescribeChapCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChapCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChapCredentialsOutputError>
}

public struct DescribeChapCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChapCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChapCredentialsOutputError>
}

public struct DescribeChapCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChapCredentialsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeChapCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChapCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChapCredentialsOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the iSCSI volume
///          target.
public struct DescribeChapCredentialsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init (
        targetARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
    }
}

struct DescribeChapCredentialsInputBody: Swift.Equatable {
    public let targetARN: Swift.String?
}

extension DescribeChapCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension DescribeChapCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChapCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChapCredentialsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChapCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChapCredentialsOutputResponse(chapCredentials: \(Swift.String(describing: chapCredentials)))"}
}

extension DescribeChapCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.chapCredentials = output.chapCredentials
        } else {
            self.chapCredentials = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeChapCredentialsOutputResponse: Swift.Equatable {
    /// An array of ChapInfo objects that represent CHAP credentials. Each
    ///          object in the array contains CHAP credential information for one target-initiator pair. If
    ///          no CHAP credentials are set, an empty array is returned. CHAP credential information is
    ///          provided in a JSON object with the following fields:
    ///
    ///
    ///
    ///
    ///                   InitiatorName: The iSCSI initiator that connects to
    ///                the target.
    ///
    ///
    ///
    ///
    ///                   SecretToAuthenticateInitiator: The secret key that
    ///                the initiator (for example, the Windows client) must provide to participate in mutual
    ///                CHAP with the target.
    ///
    ///
    ///
    ///
    ///                   SecretToAuthenticateTarget: The secret key that the
    ///                target must provide to participate in mutual CHAP with the initiator (e.g. Windows
    ///                client).
    ///
    ///
    ///
    ///
    ///                   TargetARN: The Amazon Resource Name (ARN) of the
    ///                storage volume.
    ///
    ///
    ///
    public var chapCredentials: [StorageGatewayClientTypes.ChapInfo]?

    public init (
        chapCredentials: [StorageGatewayClientTypes.ChapInfo]? = nil
    )
    {
        self.chapCredentials = chapCredentials
    }
}

struct DescribeChapCredentialsOutputResponseBody: Swift.Equatable {
    public let chapCredentials: [StorageGatewayClientTypes.ChapInfo]?
}

extension DescribeChapCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chapCredentials = "ChapCredentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chapCredentialsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.ChapInfo?].self, forKey: .chapCredentials)
        var chapCredentialsDecoded0:[StorageGatewayClientTypes.ChapInfo]? = nil
        if let chapCredentialsContainer = chapCredentialsContainer {
            chapCredentialsDecoded0 = [StorageGatewayClientTypes.ChapInfo]()
            for structure0 in chapCredentialsContainer {
                if let structure0 = structure0 {
                    chapCredentialsDecoded0?.append(structure0)
                }
            }
        }
        chapCredentials = chapCredentialsDecoded0
    }
}

public struct DescribeFileSystemAssociationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemAssociationsOutputError>
}

extension DescribeFileSystemAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemAssociationsInput(fileSystemAssociationARNList: \(Swift.String(describing: fileSystemAssociationARNList)))"}
}

extension DescribeFileSystemAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARNList = "FileSystemAssociationARNList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARNList = fileSystemAssociationARNList {
            var fileSystemAssociationARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemAssociationARNList)
            for filesystemassociationarnlist0 in fileSystemAssociationARNList {
                try fileSystemAssociationARNListContainer.encode(filesystemassociationarnlist0)
            }
        }
    }
}

public struct DescribeFileSystemAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemAssociationsOutputError>
}

public struct DescribeFileSystemAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemAssociationsOutputError>
}

public struct DescribeFileSystemAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemAssociationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFileSystemAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFileSystemAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemAssociationsOutputError>
}

public struct DescribeFileSystemAssociationsInput: Swift.Equatable {
    /// An array containing the Amazon Resource Name (ARN) of each file system association to be described.
    /// This member is required.
    public var fileSystemAssociationARNList: [Swift.String]?

    public init (
        fileSystemAssociationARNList: [Swift.String]? = nil
    )
    {
        self.fileSystemAssociationARNList = fileSystemAssociationARNList
    }
}

struct DescribeFileSystemAssociationsInputBody: Swift.Equatable {
    public let fileSystemAssociationARNList: [Swift.String]?
}

extension DescribeFileSystemAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARNList = "FileSystemAssociationARNList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileSystemAssociationARNList)
        var fileSystemAssociationARNListDecoded0:[Swift.String]? = nil
        if let fileSystemAssociationARNListContainer = fileSystemAssociationARNListContainer {
            fileSystemAssociationARNListDecoded0 = [Swift.String]()
            for string0 in fileSystemAssociationARNListContainer {
                if let string0 = string0 {
                    fileSystemAssociationARNListDecoded0?.append(string0)
                }
            }
        }
        fileSystemAssociationARNList = fileSystemAssociationARNListDecoded0
    }
}

extension DescribeFileSystemAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemAssociationsOutputResponse(fileSystemAssociationInfoList: \(Swift.String(describing: fileSystemAssociationInfoList)))"}
}

extension DescribeFileSystemAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFileSystemAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationInfoList = output.fileSystemAssociationInfoList
        } else {
            self.fileSystemAssociationInfoList = nil
        }
    }
}

public struct DescribeFileSystemAssociationsOutputResponse: Swift.Equatable {
    /// An array containing the FileSystemAssociationInfo data type of each file system association to be described.
    ///
    public var fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]?

    public init (
        fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]? = nil
    )
    {
        self.fileSystemAssociationInfoList = fileSystemAssociationInfoList
    }
}

struct DescribeFileSystemAssociationsOutputResponseBody: Swift.Equatable {
    public let fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]?
}

extension DescribeFileSystemAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationInfoList = "FileSystemAssociationInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.FileSystemAssociationInfo?].self, forKey: .fileSystemAssociationInfoList)
        var fileSystemAssociationInfoListDecoded0:[StorageGatewayClientTypes.FileSystemAssociationInfo]? = nil
        if let fileSystemAssociationInfoListContainer = fileSystemAssociationInfoListContainer {
            fileSystemAssociationInfoListDecoded0 = [StorageGatewayClientTypes.FileSystemAssociationInfo]()
            for structure0 in fileSystemAssociationInfoListContainer {
                if let structure0 = structure0 {
                    fileSystemAssociationInfoListDecoded0?.append(structure0)
                }
            }
        }
        fileSystemAssociationInfoList = fileSystemAssociationInfoListDecoded0
    }
}

public struct DescribeGatewayInformationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGatewayInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGatewayInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayInformationOutputError>
}

extension DescribeGatewayInformationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGatewayInformationInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeGatewayInformationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeGatewayInformationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGatewayInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGatewayInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayInformationOutputError>
}

public struct DescribeGatewayInformationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGatewayInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGatewayInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayInformationOutputError>
}

public struct DescribeGatewayInformationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayInformationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeGatewayInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGatewayInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayInformationOutputError>
}

/// A JSON object containing the ID of the gateway.
public struct DescribeGatewayInformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeGatewayInformationInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeGatewayInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeGatewayInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGatewayInformationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayInformationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGatewayInformationOutputResponse(cloudWatchLogGroupARN: \(Swift.String(describing: cloudWatchLogGroupARN)), deprecationDate: \(Swift.String(describing: deprecationDate)), ec2InstanceId: \(Swift.String(describing: ec2InstanceId)), ec2InstanceRegion: \(Swift.String(describing: ec2InstanceRegion)), endpointType: \(Swift.String(describing: endpointType)), gatewayARN: \(Swift.String(describing: gatewayARN)), gatewayCapacity: \(Swift.String(describing: gatewayCapacity)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayName: \(Swift.String(describing: gatewayName)), gatewayNetworkInterfaces: \(Swift.String(describing: gatewayNetworkInterfaces)), gatewayState: \(Swift.String(describing: gatewayState)), gatewayTimezone: \(Swift.String(describing: gatewayTimezone)), gatewayType: \(Swift.String(describing: gatewayType)), hostEnvironment: \(Swift.String(describing: hostEnvironment)), lastSoftwareUpdate: \(Swift.String(describing: lastSoftwareUpdate)), nextUpdateAvailabilityDate: \(Swift.String(describing: nextUpdateAvailabilityDate)), softwareUpdatesEndDate: \(Swift.String(describing: softwareUpdatesEndDate)), supportedGatewayCapacities: \(Swift.String(describing: supportedGatewayCapacities)), tags: \(Swift.String(describing: tags)), vPCEndpoint: \(Swift.String(describing: vPCEndpoint)))"}
}

extension DescribeGatewayInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGatewayInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogGroupARN = output.cloudWatchLogGroupARN
            self.deprecationDate = output.deprecationDate
            self.ec2InstanceId = output.ec2InstanceId
            self.ec2InstanceRegion = output.ec2InstanceRegion
            self.endpointType = output.endpointType
            self.gatewayARN = output.gatewayARN
            self.gatewayCapacity = output.gatewayCapacity
            self.gatewayId = output.gatewayId
            self.gatewayName = output.gatewayName
            self.gatewayNetworkInterfaces = output.gatewayNetworkInterfaces
            self.gatewayState = output.gatewayState
            self.gatewayTimezone = output.gatewayTimezone
            self.gatewayType = output.gatewayType
            self.hostEnvironment = output.hostEnvironment
            self.lastSoftwareUpdate = output.lastSoftwareUpdate
            self.nextUpdateAvailabilityDate = output.nextUpdateAvailabilityDate
            self.softwareUpdatesEndDate = output.softwareUpdatesEndDate
            self.supportedGatewayCapacities = output.supportedGatewayCapacities
            self.tags = output.tags
            self.vPCEndpoint = output.vPCEndpoint
        } else {
            self.cloudWatchLogGroupARN = nil
            self.deprecationDate = nil
            self.ec2InstanceId = nil
            self.ec2InstanceRegion = nil
            self.endpointType = nil
            self.gatewayARN = nil
            self.gatewayCapacity = nil
            self.gatewayId = nil
            self.gatewayName = nil
            self.gatewayNetworkInterfaces = nil
            self.gatewayState = nil
            self.gatewayTimezone = nil
            self.gatewayType = nil
            self.hostEnvironment = nil
            self.lastSoftwareUpdate = nil
            self.nextUpdateAvailabilityDate = nil
            self.softwareUpdatesEndDate = nil
            self.supportedGatewayCapacities = nil
            self.tags = nil
            self.vPCEndpoint = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeGatewayInformationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that is used to
    ///          monitor events in the gateway.
    public var cloudWatchLogGroupARN: Swift.String?
    /// Date after which this gateway will not receive software updates for new features and bug
    ///          fixes.
    public var deprecationDate: Swift.String?
    /// The ID of the Amazon EC2 instance that was used to launch the gateway.
    public var ec2InstanceId: Swift.String?
    /// The Region where the Amazon EC2 instance is located.
    public var ec2InstanceRegion: Swift.String?
    /// The type of endpoint for your gateway.
    ///
    ///          Valid Values: STANDARD | FIPS
    ///
    public var endpointType: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// Specifies the size of the gateway's metadata cache.
    public var gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    /// The unique identifier assigned to your gateway during activation. This ID becomes part
    ///          of the gateway Amazon Resource Name (ARN), which you use as input for other
    ///          operations.
    public var gatewayId: Swift.String?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?
    /// A NetworkInterface array that contains descriptions of the gateway
    ///          network interfaces.
    public var gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]?
    /// A value that indicates the operating state of the gateway.
    public var gatewayState: Swift.String?
    /// A value that indicates the time zone configured for the gateway.
    public var gatewayTimezone: Swift.String?
    /// The type of the gateway.
    public var gatewayType: Swift.String?
    /// The type of hypervisor environment used by the host.
    public var hostEnvironment: StorageGatewayClientTypes.HostEnvironment?
    /// The date on which the last software update was applied to the gateway. If the gateway
    ///          has never been updated, this field does not return a value in the response.
    public var lastSoftwareUpdate: Swift.String?
    /// The date on which an update to the gateway is available. This date is in the time zone
    ///          of the gateway. If the gateway is not available for an update this field is not returned in
    ///          the response.
    public var nextUpdateAvailabilityDate: Swift.String?
    /// Date after which this gateway will not receive software updates for new features.
    public var softwareUpdatesEndDate: Swift.String?
    /// A list of the metadata cache sizes that the gateway can support based on its current hardware specifications.
    public var supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]?
    /// A list of up to 50 tags assigned to the gateway, sorted alphabetically by key name. Each
    ///          tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all
    ///          tags using the ListTagsForResource API operation.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The configuration settings for the virtual private cloud (VPC) endpoint for your
    ///          gateway.
    public var vPCEndpoint: Swift.String?

    public init (
        cloudWatchLogGroupARN: Swift.String? = nil,
        deprecationDate: Swift.String? = nil,
        ec2InstanceId: Swift.String? = nil,
        ec2InstanceRegion: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity? = nil,
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]? = nil,
        gatewayState: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil,
        gatewayType: Swift.String? = nil,
        hostEnvironment: StorageGatewayClientTypes.HostEnvironment? = nil,
        lastSoftwareUpdate: Swift.String? = nil,
        nextUpdateAvailabilityDate: Swift.String? = nil,
        softwareUpdatesEndDate: Swift.String? = nil,
        supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        vPCEndpoint: Swift.String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.deprecationDate = deprecationDate
        self.ec2InstanceId = ec2InstanceId
        self.ec2InstanceRegion = ec2InstanceRegion
        self.endpointType = endpointType
        self.gatewayARN = gatewayARN
        self.gatewayCapacity = gatewayCapacity
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayNetworkInterfaces = gatewayNetworkInterfaces
        self.gatewayState = gatewayState
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.hostEnvironment = hostEnvironment
        self.lastSoftwareUpdate = lastSoftwareUpdate
        self.nextUpdateAvailabilityDate = nextUpdateAvailabilityDate
        self.softwareUpdatesEndDate = softwareUpdatesEndDate
        self.supportedGatewayCapacities = supportedGatewayCapacities
        self.tags = tags
        self.vPCEndpoint = vPCEndpoint
    }
}

struct DescribeGatewayInformationOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let gatewayId: Swift.String?
    public let gatewayName: Swift.String?
    public let gatewayTimezone: Swift.String?
    public let gatewayState: Swift.String?
    public let gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]?
    public let gatewayType: Swift.String?
    public let nextUpdateAvailabilityDate: Swift.String?
    public let lastSoftwareUpdate: Swift.String?
    public let ec2InstanceId: Swift.String?
    public let ec2InstanceRegion: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
    public let vPCEndpoint: Swift.String?
    public let cloudWatchLogGroupARN: Swift.String?
    public let hostEnvironment: StorageGatewayClientTypes.HostEnvironment?
    public let endpointType: Swift.String?
    public let softwareUpdatesEndDate: Swift.String?
    public let deprecationDate: Swift.String?
    public let gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    public let supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]?
}

extension DescribeGatewayInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case deprecationDate = "DeprecationDate"
        case ec2InstanceId = "Ec2InstanceId"
        case ec2InstanceRegion = "Ec2InstanceRegion"
        case endpointType = "EndpointType"
        case gatewayARN = "GatewayARN"
        case gatewayCapacity = "GatewayCapacity"
        case gatewayId = "GatewayId"
        case gatewayName = "GatewayName"
        case gatewayNetworkInterfaces = "GatewayNetworkInterfaces"
        case gatewayState = "GatewayState"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case hostEnvironment = "HostEnvironment"
        case lastSoftwareUpdate = "LastSoftwareUpdate"
        case nextUpdateAvailabilityDate = "NextUpdateAvailabilityDate"
        case softwareUpdatesEndDate = "SoftwareUpdatesEndDate"
        case supportedGatewayCapacities = "SupportedGatewayCapacities"
        case tags = "Tags"
        case vPCEndpoint = "VPCEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let gatewayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayState)
        gatewayState = gatewayStateDecoded
        let gatewayNetworkInterfacesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.NetworkInterface?].self, forKey: .gatewayNetworkInterfaces)
        var gatewayNetworkInterfacesDecoded0:[StorageGatewayClientTypes.NetworkInterface]? = nil
        if let gatewayNetworkInterfacesContainer = gatewayNetworkInterfacesContainer {
            gatewayNetworkInterfacesDecoded0 = [StorageGatewayClientTypes.NetworkInterface]()
            for structure0 in gatewayNetworkInterfacesContainer {
                if let structure0 = structure0 {
                    gatewayNetworkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        gatewayNetworkInterfaces = gatewayNetworkInterfacesDecoded0
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let nextUpdateAvailabilityDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextUpdateAvailabilityDate)
        nextUpdateAvailabilityDate = nextUpdateAvailabilityDateDecoded
        let lastSoftwareUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSoftwareUpdate)
        lastSoftwareUpdate = lastSoftwareUpdateDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ec2InstanceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceRegion)
        ec2InstanceRegion = ec2InstanceRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vPCEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCEndpoint)
        vPCEndpoint = vPCEndpointDecoded
        let cloudWatchLogGroupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupARN)
        cloudWatchLogGroupARN = cloudWatchLogGroupARNDecoded
        let hostEnvironmentDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.HostEnvironment.self, forKey: .hostEnvironment)
        hostEnvironment = hostEnvironmentDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let softwareUpdatesEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareUpdatesEndDate)
        softwareUpdatesEndDate = softwareUpdatesEndDateDecoded
        let deprecationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
        let gatewayCapacityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.GatewayCapacity.self, forKey: .gatewayCapacity)
        gatewayCapacity = gatewayCapacityDecoded
        let supportedGatewayCapacitiesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.GatewayCapacity?].self, forKey: .supportedGatewayCapacities)
        var supportedGatewayCapacitiesDecoded0:[StorageGatewayClientTypes.GatewayCapacity]? = nil
        if let supportedGatewayCapacitiesContainer = supportedGatewayCapacitiesContainer {
            supportedGatewayCapacitiesDecoded0 = [StorageGatewayClientTypes.GatewayCapacity]()
            for string0 in supportedGatewayCapacitiesContainer {
                if let string0 = string0 {
                    supportedGatewayCapacitiesDecoded0?.append(string0)
                }
            }
        }
        supportedGatewayCapacities = supportedGatewayCapacitiesDecoded0
    }
}

public struct DescribeMaintenanceStartTimeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceStartTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceStartTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceStartTimeOutputError>
}

extension DescribeMaintenanceStartTimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceStartTimeInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeMaintenanceStartTimeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeMaintenanceStartTimeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceStartTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceStartTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceStartTimeOutputError>
}

public struct DescribeMaintenanceStartTimeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceStartTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMaintenanceStartTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceStartTimeOutputError>
}

public struct DescribeMaintenanceStartTimeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMaintenanceStartTimeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeMaintenanceStartTimeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMaintenanceStartTimeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMaintenanceStartTimeOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeMaintenanceStartTimeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeMaintenanceStartTimeInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeMaintenanceStartTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeMaintenanceStartTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceStartTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceStartTimeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceStartTimeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMaintenanceStartTimeOutputResponse(dayOfMonth: \(Swift.String(describing: dayOfMonth)), dayOfWeek: \(Swift.String(describing: dayOfWeek)), gatewayARN: \(Swift.String(describing: gatewayARN)), hourOfDay: \(Swift.String(describing: hourOfDay)), minuteOfHour: \(Swift.String(describing: minuteOfHour)), timezone: \(Swift.String(describing: timezone)))"}
}

extension DescribeMaintenanceStartTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceStartTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dayOfMonth = output.dayOfMonth
            self.dayOfWeek = output.dayOfWeek
            self.gatewayARN = output.gatewayARN
            self.hourOfDay = output.hourOfDay
            self.minuteOfHour = output.minuteOfHour
            self.timezone = output.timezone
        } else {
            self.dayOfMonth = nil
            self.dayOfWeek = nil
            self.gatewayARN = nil
            self.hourOfDay = nil
            self.minuteOfHour = nil
            self.timezone = nil
        }
    }
}

/// A JSON object containing the following fields:
///
///
///
///
///                   DescribeMaintenanceStartTimeOutput$DayOfMonth
///
///
///
///
///                   DescribeMaintenanceStartTimeOutput$DayOfWeek
///
///
///
///
///                   DescribeMaintenanceStartTimeOutput$HourOfDay
///
///
///
///
///                   DescribeMaintenanceStartTimeOutput$MinuteOfHour
///
///
///
///
///                   DescribeMaintenanceStartTimeOutput$Timezone
///
///
///
public struct DescribeMaintenanceStartTimeOutputResponse: Swift.Equatable {
    /// The day of the month component of the maintenance start time represented as an ordinal
    ///          number from 1 to 28, where 1 represents the first day of the month and 28 represents the
    ///          last day of the month.
    public var dayOfMonth: Swift.Int?
    /// An ordinal number between 0 and 6 that represents the day of the week, where 0
    ///          represents Sunday and 6 represents Saturday. The day of week is in the time zone of the
    ///          gateway.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// The hour component of the maintenance start time represented as hh,
    ///          where hh is the hour (0 to 23). The hour of the day is in the time
    ///          zone of the gateway.
    public var hourOfDay: Swift.Int?
    /// The minute component of the maintenance start time represented as
    ///             mm, where mm is the minute (0 to 59). The
    ///          minute of the hour is in the time zone of the gateway.
    public var minuteOfHour: Swift.Int?
    /// A value that indicates the time zone that is set for the gateway. The start time and day
    ///          of week specified should be in the time zone of the gateway.
    public var timezone: Swift.String?

    public init (
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
        self.timezone = timezone
    }
}

struct DescribeMaintenanceStartTimeOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let hourOfDay: Swift.Int?
    public let minuteOfHour: Swift.Int?
    public let dayOfWeek: Swift.Int?
    public let dayOfMonth: Swift.Int?
    public let timezone: Swift.String?
}

extension DescribeMaintenanceStartTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
        case timezone = "Timezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

public struct DescribeNFSFileSharesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNFSFileSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNFSFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNFSFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNFSFileSharesOutputError>
}

extension DescribeNFSFileSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNFSFileSharesInput(fileShareARNList: \(Swift.String(describing: fileShareARNList)))"}
}

extension DescribeNFSFileSharesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARNList = fileShareARNList {
            var fileShareARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileShareARNList)
            for filesharearnlist0 in fileShareARNList {
                try fileShareARNListContainer.encode(filesharearnlist0)
            }
        }
    }
}

public struct DescribeNFSFileSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNFSFileSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNFSFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNFSFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNFSFileSharesOutputError>
}

public struct DescribeNFSFileSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNFSFileSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNFSFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNFSFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNFSFileSharesOutputError>
}

public struct DescribeNFSFileSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNFSFileSharesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeNFSFileSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeNFSFileSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNFSFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNFSFileSharesOutputError>
}

/// DescribeNFSFileSharesInput
public struct DescribeNFSFileSharesInput: Swift.Equatable {
    /// An array containing the Amazon Resource Name (ARN) of each file share to be
    ///          described.
    /// This member is required.
    public var fileShareARNList: [Swift.String]?

    public init (
        fileShareARNList: [Swift.String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

struct DescribeNFSFileSharesInputBody: Swift.Equatable {
    public let fileShareARNList: [Swift.String]?
}

extension DescribeNFSFileSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileShareARNList)
        var fileShareARNListDecoded0:[Swift.String]? = nil
        if let fileShareARNListContainer = fileShareARNListContainer {
            fileShareARNListDecoded0 = [Swift.String]()
            for string0 in fileShareARNListContainer {
                if let string0 = string0 {
                    fileShareARNListDecoded0?.append(string0)
                }
            }
        }
        fileShareARNList = fileShareARNListDecoded0
    }
}

extension DescribeNFSFileSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNFSFileSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNFSFileSharesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNFSFileSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNFSFileSharesOutputResponse(nFSFileShareInfoList: \(Swift.String(describing: nFSFileShareInfoList)))"}
}

extension DescribeNFSFileSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeNFSFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nFSFileShareInfoList = output.nFSFileShareInfoList
        } else {
            self.nFSFileShareInfoList = nil
        }
    }
}

/// DescribeNFSFileSharesOutput
public struct DescribeNFSFileSharesOutputResponse: Swift.Equatable {
    /// An array containing a description for each requested file share.
    public var nFSFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]?

    public init (
        nFSFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]? = nil
    )
    {
        self.nFSFileShareInfoList = nFSFileShareInfoList
    }
}

struct DescribeNFSFileSharesOutputResponseBody: Swift.Equatable {
    public let nFSFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]?
}

extension DescribeNFSFileSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nFSFileShareInfoList = "NFSFileShareInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nFSFileShareInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.NFSFileShareInfo?].self, forKey: .nFSFileShareInfoList)
        var nFSFileShareInfoListDecoded0:[StorageGatewayClientTypes.NFSFileShareInfo]? = nil
        if let nFSFileShareInfoListContainer = nFSFileShareInfoListContainer {
            nFSFileShareInfoListDecoded0 = [StorageGatewayClientTypes.NFSFileShareInfo]()
            for structure0 in nFSFileShareInfoListContainer {
                if let structure0 = structure0 {
                    nFSFileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        nFSFileShareInfoList = nFSFileShareInfoListDecoded0
    }
}

public struct DescribeSMBFileSharesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBFileSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSMBFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSMBFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBFileSharesOutputError>
}

extension DescribeSMBFileSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSMBFileSharesInput(fileShareARNList: \(Swift.String(describing: fileShareARNList)))"}
}

extension DescribeSMBFileSharesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARNList = fileShareARNList {
            var fileShareARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileShareARNList)
            for filesharearnlist0 in fileShareARNList {
                try fileShareARNListContainer.encode(filesharearnlist0)
            }
        }
    }
}

public struct DescribeSMBFileSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBFileSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSMBFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSMBFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBFileSharesOutputError>
}

public struct DescribeSMBFileSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBFileSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSMBFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSMBFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBFileSharesOutputError>
}

public struct DescribeSMBFileSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBFileSharesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSMBFileSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSMBFileSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBFileSharesOutputError>
}

/// DescribeSMBFileSharesInput
public struct DescribeSMBFileSharesInput: Swift.Equatable {
    /// An array containing the Amazon Resource Name (ARN) of each file share to be
    ///          described.
    /// This member is required.
    public var fileShareARNList: [Swift.String]?

    public init (
        fileShareARNList: [Swift.String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

struct DescribeSMBFileSharesInputBody: Swift.Equatable {
    public let fileShareARNList: [Swift.String]?
}

extension DescribeSMBFileSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileShareARNList)
        var fileShareARNListDecoded0:[Swift.String]? = nil
        if let fileShareARNListContainer = fileShareARNListContainer {
            fileShareARNListDecoded0 = [Swift.String]()
            for string0 in fileShareARNListContainer {
                if let string0 = string0 {
                    fileShareARNListDecoded0?.append(string0)
                }
            }
        }
        fileShareARNList = fileShareARNListDecoded0
    }
}

extension DescribeSMBFileSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSMBFileSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSMBFileSharesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSMBFileSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSMBFileSharesOutputResponse(sMBFileShareInfoList: \(Swift.String(describing: sMBFileShareInfoList)))"}
}

extension DescribeSMBFileSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSMBFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sMBFileShareInfoList = output.sMBFileShareInfoList
        } else {
            self.sMBFileShareInfoList = nil
        }
    }
}

/// DescribeSMBFileSharesOutput
public struct DescribeSMBFileSharesOutputResponse: Swift.Equatable {
    /// An array containing a description for each requested file share.
    public var sMBFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]?

    public init (
        sMBFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]? = nil
    )
    {
        self.sMBFileShareInfoList = sMBFileShareInfoList
    }
}

struct DescribeSMBFileSharesOutputResponseBody: Swift.Equatable {
    public let sMBFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]?
}

extension DescribeSMBFileSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sMBFileShareInfoList = "SMBFileShareInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMBFileShareInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.SMBFileShareInfo?].self, forKey: .sMBFileShareInfoList)
        var sMBFileShareInfoListDecoded0:[StorageGatewayClientTypes.SMBFileShareInfo]? = nil
        if let sMBFileShareInfoListContainer = sMBFileShareInfoListContainer {
            sMBFileShareInfoListDecoded0 = [StorageGatewayClientTypes.SMBFileShareInfo]()
            for structure0 in sMBFileShareInfoListContainer {
                if let structure0 = structure0 {
                    sMBFileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        sMBFileShareInfoList = sMBFileShareInfoListDecoded0
    }
}

public struct DescribeSMBSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSMBSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSMBSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBSettingsOutputError>
}

extension DescribeSMBSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSMBSettingsInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeSMBSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeSMBSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSMBSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSMBSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBSettingsOutputError>
}

public struct DescribeSMBSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSMBSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSMBSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBSettingsOutputError>
}

public struct DescribeSMBSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSMBSettingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSMBSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSMBSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSMBSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSMBSettingsOutputError>
}

public struct DescribeSMBSettingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeSMBSettingsInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeSMBSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeSMBSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSMBSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSMBSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSMBSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSMBSettingsOutputResponse(activeDirectoryStatus: \(Swift.String(describing: activeDirectoryStatus)), domainName: \(Swift.String(describing: domainName)), fileSharesVisible: \(Swift.String(describing: fileSharesVisible)), gatewayARN: \(Swift.String(describing: gatewayARN)), sMBGuestPasswordSet: \(Swift.String(describing: sMBGuestPasswordSet)), sMBSecurityStrategy: \(Swift.String(describing: sMBSecurityStrategy)))"}
}

extension DescribeSMBSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSMBSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeDirectoryStatus = output.activeDirectoryStatus
            self.domainName = output.domainName
            self.fileSharesVisible = output.fileSharesVisible
            self.gatewayARN = output.gatewayARN
            self.sMBGuestPasswordSet = output.sMBGuestPasswordSet
            self.sMBSecurityStrategy = output.sMBSecurityStrategy
        } else {
            self.activeDirectoryStatus = nil
            self.domainName = nil
            self.fileSharesVisible = nil
            self.gatewayARN = nil
            self.sMBGuestPasswordSet = nil
            self.sMBSecurityStrategy = nil
        }
    }
}

public struct DescribeSMBSettingsOutputResponse: Swift.Equatable {
    /// Indicates the status of a gateway that is a member of the Active Directory
    ///          domain.
    ///
    ///
    ///
    ///
    ///                   ACCESS_DENIED: Indicates that the JoinDomain operation
    ///                failed due to an authentication error.
    ///
    ///
    ///
    ///                   DETACHED: Indicates that gateway is not joined to a domain.
    ///
    ///
    ///
    ///                   JOINED: Indicates that the gateway has successfully joined a
    ///                domain.
    ///
    ///
    ///
    ///                   JOINING: Indicates that a JoinDomain operation is in
    ///                progress.
    ///
    ///
    ///
    ///                   NETWORK_ERROR: Indicates that JoinDomain operation
    ///                failed due to a network or connectivity error.
    ///
    ///
    ///
    ///                   TIMEOUT: Indicates that the JoinDomain operation failed
    ///                because the operation didn't complete within the allotted time.
    ///
    ///
    ///
    ///                   UNKNOWN_ERROR: Indicates that the JoinDomain operation
    ///                failed due to another type of error.
    ///
    ///
    public var activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    /// The name of the domain that the gateway is joined to.
    public var domainName: Swift.String?
    /// The shares on this gateway appear when listing shares. Only supported for S3 File Gateways.
    public var fileSharesVisible: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// This value is true if a password for the guest user smbguest
    ///          is set, otherwise false. Only supported for S3 File Gateways.
    ///
    ///          Valid Values: true | false
    ///
    public var sMBGuestPasswordSet: Swift.Bool?
    /// The type of security strategy that was specified for file gateway.
    ///
    ///
    ///
    ///
    ///                   ClientSpecified: If you use this option, requests are established
    ///                based on what is negotiated by the client. This option is recommended when you want
    ///                to maximize compatibility across different clients in your environment. Only supported for S3 File Gateways.
    ///
    ///
    ///
    ///                   MandatorySigning: If you use this option, file gateway only allows
    ///                connections from SMBv2 or SMBv3 clients that have signing enabled. This option works
    ///                with SMB clients on Microsoft Windows Vista, Windows Server 2008 or newer.
    ///
    ///
    ///
    ///                   MandatoryEncryption: If you use this option, file gateway only allows
    ///                connections from SMBv3 clients that have encryption enabled. This option is highly
    ///                recommended for environments that handle sensitive data. This option works with SMB
    ///                clients on Microsoft Windows 8, Windows Server 2012 or newer.
    ///
    ///
    public var sMBSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?

    public init (
        activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus? = nil,
        domainName: Swift.String? = nil,
        fileSharesVisible: Swift.Bool? = nil,
        gatewayARN: Swift.String? = nil,
        sMBGuestPasswordSet: Swift.Bool? = nil,
        sMBSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.domainName = domainName
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
        self.sMBGuestPasswordSet = sMBGuestPasswordSet
        self.sMBSecurityStrategy = sMBSecurityStrategy
    }
}

struct DescribeSMBSettingsOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let domainName: Swift.String?
    public let activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    public let sMBGuestPasswordSet: Swift.Bool?
    public let sMBSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?
    public let fileSharesVisible: Swift.Bool?
}

extension DescribeSMBSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryStatus = "ActiveDirectoryStatus"
        case domainName = "DomainName"
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
        case sMBGuestPasswordSet = "SMBGuestPasswordSet"
        case sMBSecurityStrategy = "SMBSecurityStrategy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeDirectoryStatusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ActiveDirectoryStatus.self, forKey: .activeDirectoryStatus)
        activeDirectoryStatus = activeDirectoryStatusDecoded
        let sMBGuestPasswordSetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sMBGuestPasswordSet)
        sMBGuestPasswordSet = sMBGuestPasswordSetDecoded
        let sMBSecurityStrategyDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.SMBSecurityStrategy.self, forKey: .sMBSecurityStrategy)
        sMBSecurityStrategy = sMBSecurityStrategyDecoded
        let fileSharesVisibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fileSharesVisible)
        fileSharesVisible = fileSharesVisibleDecoded
    }
}

public struct DescribeSnapshotScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotScheduleOutputError>
}

extension DescribeSnapshotScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSnapshotScheduleInput(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DescribeSnapshotScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DescribeSnapshotScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotScheduleOutputError>
}

public struct DescribeSnapshotScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotScheduleOutputError>
}

public struct DescribeSnapshotScheduleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSnapshotScheduleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSnapshotScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSnapshotScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSnapshotScheduleOutputError>
}

/// A JSON object containing the DescribeSnapshotScheduleInput$VolumeARN
///          of the volume.
public struct DescribeSnapshotScheduleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes
    ///          operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DescribeSnapshotScheduleInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension DescribeSnapshotScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DescribeSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSnapshotScheduleOutputResponse(description: \(Swift.String(describing: description)), recurrenceInHours: \(Swift.String(describing: recurrenceInHours)), startAt: \(Swift.String(describing: startAt)), tags: \(Swift.String(describing: tags)), timezone: \(Swift.String(describing: timezone)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DescribeSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.recurrenceInHours = output.recurrenceInHours
            self.startAt = output.startAt
            self.tags = output.tags
            self.timezone = output.timezone
            self.volumeARN = output.volumeARN
        } else {
            self.description = nil
            self.recurrenceInHours = nil
            self.startAt = nil
            self.tags = nil
            self.timezone = nil
            self.volumeARN = nil
        }
    }
}

public struct DescribeSnapshotScheduleOutputResponse: Swift.Equatable {
    /// The snapshot description.
    public var description: Swift.String?
    /// The number of hours between snapshots.
    public var recurrenceInHours: Swift.Int?
    /// The hour of the day at which the snapshot schedule begins represented as
    ///             hh, where hh is the hour (0 to 23). The hour
    ///          of the day is in the time zone of the gateway.
    public var startAt: Swift.Int?
    /// A list of up to 50 tags assigned to the snapshot schedule, sorted alphabetically by key
    ///          name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can
    ///          view all tags using the ListTagsForResource API operation.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A value that indicates the time zone of the gateway.
    public var timezone: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume that was specified in the request.
    public var volumeARN: Swift.String?

    public init (
        description: Swift.String? = nil,
        recurrenceInHours: Swift.Int? = nil,
        startAt: Swift.Int? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        timezone: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.timezone = timezone
        self.volumeARN = volumeARN
    }
}

struct DescribeSnapshotScheduleOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let startAt: Swift.Int?
    public let recurrenceInHours: Swift.Int?
    public let description: Swift.String?
    public let timezone: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension DescribeSnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case timezone = "Timezone"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let startAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startAt)
        startAt = startAtDecoded
        let recurrenceInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recurrenceInHours)
        recurrenceInHours = recurrenceInHoursDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeStorediSCSIVolumesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorediSCSIVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorediSCSIVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorediSCSIVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorediSCSIVolumesOutputError>
}

extension DescribeStorediSCSIVolumesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStorediSCSIVolumesInput(volumeARNs: \(Swift.String(describing: volumeARNs)))"}
}

extension DescribeStorediSCSIVolumesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARNs = volumeARNs {
            var volumeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeARNs)
            for volumearns0 in volumeARNs {
                try volumeARNsContainer.encode(volumearns0)
            }
        }
    }
}

public struct DescribeStorediSCSIVolumesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorediSCSIVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorediSCSIVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorediSCSIVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorediSCSIVolumesOutputError>
}

public struct DescribeStorediSCSIVolumesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorediSCSIVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorediSCSIVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorediSCSIVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorediSCSIVolumesOutputError>
}

public struct DescribeStorediSCSIVolumesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorediSCSIVolumesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeStorediSCSIVolumesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeStorediSCSIVolumesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorediSCSIVolumesOutputError>
}

/// A JSON object containing a list of DescribeStorediSCSIVolumesInput$VolumeARNs.
public struct DescribeStorediSCSIVolumesInput: Swift.Equatable {
    /// An array of strings where each string represents the Amazon Resource Name (ARN) of a
    ///          stored volume. All of the specified stored volumes must be from the same gateway. Use ListVolumes to get volume ARNs for a gateway.
    /// This member is required.
    public var volumeARNs: [Swift.String]?

    public init (
        volumeARNs: [Swift.String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

struct DescribeStorediSCSIVolumesInputBody: Swift.Equatable {
    public let volumeARNs: [Swift.String]?
}

extension DescribeStorediSCSIVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .volumeARNs)
        var volumeARNsDecoded0:[Swift.String]? = nil
        if let volumeARNsContainer = volumeARNsContainer {
            volumeARNsDecoded0 = [Swift.String]()
            for string0 in volumeARNsContainer {
                if let string0 = string0 {
                    volumeARNsDecoded0?.append(string0)
                }
            }
        }
        volumeARNs = volumeARNsDecoded0
    }
}

extension DescribeStorediSCSIVolumesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStorediSCSIVolumesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStorediSCSIVolumesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStorediSCSIVolumesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStorediSCSIVolumesOutputResponse(storediSCSIVolumes: \(Swift.String(describing: storediSCSIVolumes)))"}
}

extension DescribeStorediSCSIVolumesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStorediSCSIVolumesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.storediSCSIVolumes = output.storediSCSIVolumes
        } else {
            self.storediSCSIVolumes = nil
        }
    }
}

public struct DescribeStorediSCSIVolumesOutputResponse: Swift.Equatable {
    /// Describes a single unit of output from DescribeStorediSCSIVolumes. The
    ///          following fields are returned:
    ///
    ///
    ///
    ///
    ///                   ChapEnabled: Indicates whether mutual CHAP is enabled for the iSCSI
    ///                target.
    ///
    ///
    ///
    ///                   LunNumber: The logical disk number.
    ///
    ///
    ///
    ///                   NetworkInterfaceId: The network interface ID of the stored volume that
    ///                initiator use to map the stored volume as an iSCSI target.
    ///
    ///
    ///
    ///                   NetworkInterfacePort: The port used to communicate with iSCSI
    ///                targets.
    ///
    ///
    ///
    ///                   PreservedExistingData: Indicates when the stored volume was created,
    ///                existing data on the underlying local disk was preserved.
    ///
    ///
    ///
    ///                   SourceSnapshotId: If the stored volume was created from a snapshot, this
    ///                field contains the snapshot ID used, e.g. snap-1122aabb. Otherwise, this
    ///                field is not included.
    ///
    ///
    ///
    ///                   StorediSCSIVolumes: An array of StorediSCSIVolume objects where each
    ///                object contains metadata about one stored volume.
    ///
    ///
    ///
    ///                   TargetARN: The Amazon Resource Name (ARN) of the volume target.
    ///
    ///
    ///
    ///                   VolumeARN: The Amazon Resource Name (ARN) of the stored volume.
    ///
    ///
    ///
    ///                   VolumeDiskId: The disk ID of the local disk that was specified in the
    ///                   CreateStorediSCSIVolume operation.
    ///
    ///
    ///
    ///                   VolumeId: The unique identifier of the storage volume, e.g.
    ///                   vol-1122AABB.
    ///
    ///
    ///
    ///                   VolumeiSCSIAttributes: An VolumeiSCSIAttributes object
    ///                that represents a collection of iSCSI attributes for one stored volume.
    ///
    ///
    ///
    ///                   VolumeProgress: Represents the percentage complete if the volume is
    ///                restoring or bootstrapping that represents the percent of data transferred. This
    ///                field does not appear in the response if the stored volume is not restoring or
    ///                bootstrapping.
    ///
    ///
    ///
    ///                   VolumeSizeInBytes: The size of the volume in bytes.
    ///
    ///
    ///
    ///                   VolumeStatus: One of the VolumeStatus values that indicates
    ///                the state of the volume.
    ///
    ///
    ///
    ///                   VolumeType: One of the enumeration values describing the type of the
    ///                volume. Currently, only STORED volumes are supported.
    ///
    ///
    public var storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]?

    public init (
        storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]? = nil
    )
    {
        self.storediSCSIVolumes = storediSCSIVolumes
    }
}

struct DescribeStorediSCSIVolumesOutputResponseBody: Swift.Equatable {
    public let storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]?
}

extension DescribeStorediSCSIVolumesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storediSCSIVolumes = "StorediSCSIVolumes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storediSCSIVolumesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.StorediSCSIVolume?].self, forKey: .storediSCSIVolumes)
        var storediSCSIVolumesDecoded0:[StorageGatewayClientTypes.StorediSCSIVolume]? = nil
        if let storediSCSIVolumesContainer = storediSCSIVolumesContainer {
            storediSCSIVolumesDecoded0 = [StorageGatewayClientTypes.StorediSCSIVolume]()
            for structure0 in storediSCSIVolumesContainer {
                if let structure0 = structure0 {
                    storediSCSIVolumesDecoded0?.append(structure0)
                }
            }
        }
        storediSCSIVolumes = storediSCSIVolumesDecoded0
    }
}

public struct DescribeTapeArchivesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeArchivesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapeArchivesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapeArchivesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeArchivesOutputError>
}

extension DescribeTapeArchivesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTapeArchivesInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), tapeARNs: \(Swift.String(describing: tapeARNs)))"}
}

extension DescribeTapeArchivesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearns0 in tapeARNs {
                try tapeARNsContainer.encode(tapearns0)
            }
        }
    }
}

public struct DescribeTapeArchivesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeArchivesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapeArchivesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapeArchivesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeArchivesOutputError>
}

public struct DescribeTapeArchivesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeArchivesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapeArchivesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapeArchivesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeArchivesOutputError>
}

public struct DescribeTapeArchivesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeArchivesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeTapeArchivesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTapeArchivesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeArchivesOutputError>
}

/// DescribeTapeArchivesInput
public struct DescribeTapeArchivesInput: Swift.Equatable {
    /// Specifies that the number of virtual tapes described be limited to the specified
    ///          number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing virtual
    ///          tapes.
    public var marker: Swift.String?
    /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual
    ///          tapes you want to describe.
    public var tapeARNs: [Swift.String]?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct DescribeTapeArchivesInputBody: Swift.Equatable {
    public let tapeARNs: [Swift.String]?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension DescribeTapeArchivesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapeArchivesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapeArchivesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTapeArchivesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapeArchivesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTapeArchivesOutputResponse(marker: \(Swift.String(describing: marker)), tapeArchives: \(Swift.String(describing: tapeArchives)))"}
}

extension DescribeTapeArchivesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTapeArchivesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.tapeArchives = output.tapeArchives
        } else {
            self.marker = nil
            self.tapeArchives = nil
        }
    }
}

/// DescribeTapeArchivesOutput
public struct DescribeTapeArchivesOutputResponse: Swift.Equatable {
    /// An opaque string that indicates the position at which the virtual tapes that were
    ///          fetched for description ended. Use this marker in your next request to fetch the next set
    ///          of virtual tapes in the virtual tape shelf (VTS). If there are no more virtual tapes to
    ///          describe, this field does not appear in the response.
    public var marker: Swift.String?
    /// An array of virtual tape objects in the virtual tape shelf (VTS). The description
    ///          includes of the Amazon Resource Name (ARN) of the virtual tapes. The information returned
    ///          includes the Amazon Resource Names (ARNs) of the tapes, size of the tapes, status of the
    ///          tapes, progress of the description, and tape barcode.
    public var tapeArchives: [StorageGatewayClientTypes.TapeArchive]?

    public init (
        marker: Swift.String? = nil,
        tapeArchives: [StorageGatewayClientTypes.TapeArchive]? = nil
    )
    {
        self.marker = marker
        self.tapeArchives = tapeArchives
    }
}

struct DescribeTapeArchivesOutputResponseBody: Swift.Equatable {
    public let tapeArchives: [StorageGatewayClientTypes.TapeArchive]?
    public let marker: Swift.String?
}

extension DescribeTapeArchivesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case tapeArchives = "TapeArchives"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeArchivesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.TapeArchive?].self, forKey: .tapeArchives)
        var tapeArchivesDecoded0:[StorageGatewayClientTypes.TapeArchive]? = nil
        if let tapeArchivesContainer = tapeArchivesContainer {
            tapeArchivesDecoded0 = [StorageGatewayClientTypes.TapeArchive]()
            for structure0 in tapeArchivesContainer {
                if let structure0 = structure0 {
                    tapeArchivesDecoded0?.append(structure0)
                }
            }
        }
        tapeArchives = tapeArchivesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeTapeRecoveryPointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeRecoveryPointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapeRecoveryPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapeRecoveryPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeRecoveryPointsOutputError>
}

extension DescribeTapeRecoveryPointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTapeRecoveryPointsInput(gatewayARN: \(Swift.String(describing: gatewayARN)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeTapeRecoveryPointsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct DescribeTapeRecoveryPointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeRecoveryPointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapeRecoveryPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapeRecoveryPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeRecoveryPointsOutputError>
}

public struct DescribeTapeRecoveryPointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeRecoveryPointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapeRecoveryPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapeRecoveryPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeRecoveryPointsOutputError>
}

public struct DescribeTapeRecoveryPointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapeRecoveryPointsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeTapeRecoveryPointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTapeRecoveryPointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapeRecoveryPointsOutputError>
}

/// DescribeTapeRecoveryPointsInput
public struct DescribeTapeRecoveryPointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of virtual tape recovery points that are described be limited
    ///          to the specified number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing the virtual
    ///          tape recovery points.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeTapeRecoveryPointsInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension DescribeTapeRecoveryPointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapeRecoveryPointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapeRecoveryPointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTapeRecoveryPointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapeRecoveryPointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTapeRecoveryPointsOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)), marker: \(Swift.String(describing: marker)), tapeRecoveryPointInfos: \(Swift.String(describing: tapeRecoveryPointInfos)))"}
}

extension DescribeTapeRecoveryPointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTapeRecoveryPointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.tapeRecoveryPointInfos = output.tapeRecoveryPointInfos
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.tapeRecoveryPointInfos = nil
        }
    }
}

/// DescribeTapeRecoveryPointsOutput
public struct DescribeTapeRecoveryPointsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// An opaque string that indicates the position at which the virtual tape recovery points
    ///          that were listed for description ended.
    ///
    ///          Use this marker in your next request to list the next set of virtual tape recovery
    ///          points in the list. If there are no more recovery points to describe, this field does not
    ///          appear in the response.
    public var marker: Swift.String?
    /// An array of TapeRecoveryPointInfos that are available for the specified gateway.
    public var tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]?

    public init (
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.tapeRecoveryPointInfos = tapeRecoveryPointInfos
    }
}

struct DescribeTapeRecoveryPointsOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]?
    public let marker: Swift.String?
}

extension DescribeTapeRecoveryPointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case tapeRecoveryPointInfos = "TapeRecoveryPointInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeRecoveryPointInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.TapeRecoveryPointInfo?].self, forKey: .tapeRecoveryPointInfos)
        var tapeRecoveryPointInfosDecoded0:[StorageGatewayClientTypes.TapeRecoveryPointInfo]? = nil
        if let tapeRecoveryPointInfosContainer = tapeRecoveryPointInfosContainer {
            tapeRecoveryPointInfosDecoded0 = [StorageGatewayClientTypes.TapeRecoveryPointInfo]()
            for structure0 in tapeRecoveryPointInfosContainer {
                if let structure0 = structure0 {
                    tapeRecoveryPointInfosDecoded0?.append(structure0)
                }
            }
        }
        tapeRecoveryPointInfos = tapeRecoveryPointInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeTapesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapesOutputError>
}

extension DescribeTapesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTapesInput(gatewayARN: \(Swift.String(describing: gatewayARN)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), tapeARNs: \(Swift.String(describing: tapeARNs)))"}
}

extension DescribeTapesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearns0 in tapeARNs {
                try tapeARNsContainer.encode(tapearns0)
            }
        }
    }
}

public struct DescribeTapesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapesOutputError>
}

public struct DescribeTapesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapesOutputError>
}

public struct DescribeTapesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTapesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeTapesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTapesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTapesOutputError>
}

/// DescribeTapesInput
public struct DescribeTapesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of virtual tapes described be limited to the specified
    ///          number.
    ///
    ///
    ///             Amazon Web Services may impose its own limit, if this field is not set.
    ///
    public var limit: Swift.Int?
    /// A marker value, obtained in a previous call to DescribeTapes. This marker
    ///          indicates which page of results to retrieve.
    ///
    ///          If not specified, the first page of results is retrieved.
    public var marker: Swift.String?
    /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual
    ///          tapes you want to describe. If this parameter is not specified, Tape gateway returns a
    ///          description of all virtual tapes associated with the specified gateway.
    public var tapeARNs: [Swift.String]?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct DescribeTapesInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let tapeARNs: [Swift.String]?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension DescribeTapesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTapesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTapesOutputResponse(marker: \(Swift.String(describing: marker)), tapes: \(Swift.String(describing: tapes)))"}
}

extension DescribeTapesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTapesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.tapes = output.tapes
        } else {
            self.marker = nil
            self.tapes = nil
        }
    }
}

/// DescribeTapesOutput
public struct DescribeTapesOutputResponse: Swift.Equatable {
    /// An opaque string that can be used as part of a subsequent DescribeTapes
    ///          call to retrieve the next page of results.
    ///
    ///          If a response does not contain a marker, then there are no more results to be
    ///          retrieved.
    public var marker: Swift.String?
    /// An array of virtual tape descriptions.
    public var tapes: [StorageGatewayClientTypes.Tape]?

    public init (
        marker: Swift.String? = nil,
        tapes: [StorageGatewayClientTypes.Tape]? = nil
    )
    {
        self.marker = marker
        self.tapes = tapes
    }
}

struct DescribeTapesOutputResponseBody: Swift.Equatable {
    public let tapes: [StorageGatewayClientTypes.Tape]?
    public let marker: Swift.String?
}

extension DescribeTapesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case tapes = "Tapes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tape?].self, forKey: .tapes)
        var tapesDecoded0:[StorageGatewayClientTypes.Tape]? = nil
        if let tapesContainer = tapesContainer {
            tapesDecoded0 = [StorageGatewayClientTypes.Tape]()
            for structure0 in tapesContainer {
                if let structure0 = structure0 {
                    tapesDecoded0?.append(structure0)
                }
            }
        }
        tapes = tapesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeUploadBufferInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUploadBufferInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUploadBufferInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUploadBufferInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUploadBufferOutputError>
}

extension DescribeUploadBufferInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUploadBufferInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeUploadBufferInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeUploadBufferInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUploadBufferInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUploadBufferInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUploadBufferInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUploadBufferOutputError>
}

public struct DescribeUploadBufferInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUploadBufferInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUploadBufferInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUploadBufferInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUploadBufferOutputError>
}

public struct DescribeUploadBufferInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUploadBufferInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeUploadBufferInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUploadBufferInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUploadBufferOutputError>
}

public struct DescribeUploadBufferInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeUploadBufferInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeUploadBufferInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeUploadBufferOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUploadBufferOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUploadBufferOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUploadBufferOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUploadBufferOutputResponse(diskIds: \(Swift.String(describing: diskIds)), gatewayARN: \(Swift.String(describing: gatewayARN)), uploadBufferAllocatedInBytes: \(Swift.String(describing: uploadBufferAllocatedInBytes)), uploadBufferUsedInBytes: \(Swift.String(describing: uploadBufferUsedInBytes)))"}
}

extension DescribeUploadBufferOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUploadBufferOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
            self.uploadBufferAllocatedInBytes = output.uploadBufferAllocatedInBytes
            self.uploadBufferUsedInBytes = output.uploadBufferUsedInBytes
        } else {
            self.diskIds = nil
            self.gatewayARN = nil
            self.uploadBufferAllocatedInBytes = 0
            self.uploadBufferUsedInBytes = 0
        }
    }
}

public struct DescribeUploadBufferOutputResponse: Swift.Equatable {
    /// An array of the gateway's local disk IDs that are configured as working storage.
    ///          Each local disk ID is specified as a string (minimum length of 1 and maximum length of
    ///          300). If no local disks are configured as working storage, then the DiskIds array is
    ///          empty.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// The total number of bytes allocated in the gateway's as upload buffer.
    public var uploadBufferAllocatedInBytes: Swift.Int
    /// The total number of bytes being used in the gateway's upload buffer.
    public var uploadBufferUsedInBytes: Swift.Int

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil,
        uploadBufferAllocatedInBytes: Swift.Int = 0,
        uploadBufferUsedInBytes: Swift.Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytes
        self.uploadBufferUsedInBytes = uploadBufferUsedInBytes
    }
}

struct DescribeUploadBufferOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let diskIds: [Swift.String]?
    public let uploadBufferUsedInBytes: Swift.Int
    public let uploadBufferAllocatedInBytes: Swift.Int
}

extension DescribeUploadBufferOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
        case uploadBufferAllocatedInBytes = "UploadBufferAllocatedInBytes"
        case uploadBufferUsedInBytes = "UploadBufferUsedInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let uploadBufferUsedInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .uploadBufferUsedInBytes)
        uploadBufferUsedInBytes = uploadBufferUsedInBytesDecoded
        let uploadBufferAllocatedInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .uploadBufferAllocatedInBytes)
        uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytesDecoded
    }
}

public struct DescribeVTLDevicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVTLDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVTLDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVTLDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVTLDevicesOutputError>
}

extension DescribeVTLDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVTLDevicesInput(gatewayARN: \(Swift.String(describing: gatewayARN)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), vTLDeviceARNs: \(Swift.String(describing: vTLDeviceARNs)))"}
}

extension DescribeVTLDevicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case vTLDeviceARNs = "VTLDeviceARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let vTLDeviceARNs = vTLDeviceARNs {
            var vTLDeviceARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vTLDeviceARNs)
            for vtldevicearns0 in vTLDeviceARNs {
                try vTLDeviceARNsContainer.encode(vtldevicearns0)
            }
        }
    }
}

public struct DescribeVTLDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVTLDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVTLDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVTLDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVTLDevicesOutputError>
}

public struct DescribeVTLDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVTLDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVTLDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVTLDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVTLDevicesOutputError>
}

public struct DescribeVTLDevicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVTLDevicesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeVTLDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeVTLDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVTLDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVTLDevicesOutputError>
}

/// DescribeVTLDevicesInput
public struct DescribeVTLDevicesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of VTL devices described be limited to the specified
    ///          number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing the VTL
    ///          devices.
    public var marker: Swift.String?
    /// An array of strings, where each string represents the Amazon Resource Name (ARN) of a
    ///          VTL device.
    ///
    ///
    ///             All of the specified VTL devices must be from the same gateway. If no VTL devices are
    ///             specified, the result will contain all devices on the specified gateway.
    ///
    public var vTLDeviceARNs: [Swift.String]?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        vTLDeviceARNs: [Swift.String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.vTLDeviceARNs = vTLDeviceARNs
    }
}

struct DescribeVTLDevicesInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let vTLDeviceARNs: [Swift.String]?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension DescribeVTLDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case vTLDeviceARNs = "VTLDeviceARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let vTLDeviceARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vTLDeviceARNs)
        var vTLDeviceARNsDecoded0:[Swift.String]? = nil
        if let vTLDeviceARNsContainer = vTLDeviceARNsContainer {
            vTLDeviceARNsDecoded0 = [Swift.String]()
            for string0 in vTLDeviceARNsContainer {
                if let string0 = string0 {
                    vTLDeviceARNsDecoded0?.append(string0)
                }
            }
        }
        vTLDeviceARNs = vTLDeviceARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeVTLDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVTLDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVTLDevicesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVTLDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVTLDevicesOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)), marker: \(Swift.String(describing: marker)), vTLDevices: \(Swift.String(describing: vTLDevices)))"}
}

extension DescribeVTLDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVTLDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.vTLDevices = output.vTLDevices
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.vTLDevices = nil
        }
    }
}

/// DescribeVTLDevicesOutput
public struct DescribeVTLDevicesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// An opaque string that indicates the position at which the VTL devices that were fetched
    ///          for description ended. Use the marker in your next request to fetch the next set of VTL
    ///          devices in the list. If there are no more VTL devices to describe, this field does not
    ///          appear in the response.
    public var marker: Swift.String?
    /// An array of VTL device objects composed of the Amazon Resource Name (ARN) of the VTL
    ///          devices.
    public var vTLDevices: [StorageGatewayClientTypes.VTLDevice]?

    public init (
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        vTLDevices: [StorageGatewayClientTypes.VTLDevice]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.vTLDevices = vTLDevices
    }
}

struct DescribeVTLDevicesOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let vTLDevices: [StorageGatewayClientTypes.VTLDevice]?
    public let marker: Swift.String?
}

extension DescribeVTLDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case vTLDevices = "VTLDevices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let vTLDevicesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.VTLDevice?].self, forKey: .vTLDevices)
        var vTLDevicesDecoded0:[StorageGatewayClientTypes.VTLDevice]? = nil
        if let vTLDevicesContainer = vTLDevicesContainer {
            vTLDevicesDecoded0 = [StorageGatewayClientTypes.VTLDevice]()
            for structure0 in vTLDevicesContainer {
                if let structure0 = structure0 {
                    vTLDevicesDecoded0?.append(structure0)
                }
            }
        }
        vTLDevices = vTLDevicesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeWorkingStorageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorkingStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorkingStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorkingStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorkingStorageOutputError>
}

extension DescribeWorkingStorageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorkingStorageInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DescribeWorkingStorageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeWorkingStorageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorkingStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorkingStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorkingStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorkingStorageOutputError>
}

public struct DescribeWorkingStorageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorkingStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorkingStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorkingStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorkingStorageOutputError>
}

public struct DescribeWorkingStorageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorkingStorageInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeWorkingStorageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeWorkingStorageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorkingStorageOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeWorkingStorageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeWorkingStorageInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DescribeWorkingStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeWorkingStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkingStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkingStorageOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkingStorageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorkingStorageOutputResponse(diskIds: \(Swift.String(describing: diskIds)), gatewayARN: \(Swift.String(describing: gatewayARN)), workingStorageAllocatedInBytes: \(Swift.String(describing: workingStorageAllocatedInBytes)), workingStorageUsedInBytes: \(Swift.String(describing: workingStorageUsedInBytes)))"}
}

extension DescribeWorkingStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkingStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
            self.workingStorageAllocatedInBytes = output.workingStorageAllocatedInBytes
            self.workingStorageUsedInBytes = output.workingStorageUsedInBytes
        } else {
            self.diskIds = nil
            self.gatewayARN = nil
            self.workingStorageAllocatedInBytes = 0
            self.workingStorageUsedInBytes = 0
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeWorkingStorageOutputResponse: Swift.Equatable {
    /// An array of the gateway's local disk IDs that are configured as working storage.
    ///          Each local disk ID is specified as a string (minimum length of 1 and maximum length of
    ///          300). If no local disks are configured as working storage, then the DiskIds array is
    ///          empty.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// The total working storage in bytes allocated for the gateway. If no working storage is
    ///          configured for the gateway, this field returns 0.
    public var workingStorageAllocatedInBytes: Swift.Int
    /// The total working storage in bytes in use by the gateway. If no working storage is
    ///          configured for the gateway, this field returns 0.
    public var workingStorageUsedInBytes: Swift.Int

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil,
        workingStorageAllocatedInBytes: Swift.Int = 0,
        workingStorageUsedInBytes: Swift.Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.workingStorageAllocatedInBytes = workingStorageAllocatedInBytes
        self.workingStorageUsedInBytes = workingStorageUsedInBytes
    }
}

struct DescribeWorkingStorageOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let diskIds: [Swift.String]?
    public let workingStorageUsedInBytes: Swift.Int
    public let workingStorageAllocatedInBytes: Swift.Int
}

extension DescribeWorkingStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
        case workingStorageAllocatedInBytes = "WorkingStorageAllocatedInBytes"
        case workingStorageUsedInBytes = "WorkingStorageUsedInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let workingStorageUsedInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .workingStorageUsedInBytes)
        workingStorageUsedInBytes = workingStorageUsedInBytesDecoded
        let workingStorageAllocatedInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .workingStorageAllocatedInBytes)
        workingStorageAllocatedInBytes = workingStorageAllocatedInBytesDecoded
    }
}

public struct DetachVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachVolumeOutputError>
}

extension DetachVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachVolumeInput(forceDetach: \(Swift.String(describing: forceDetach)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DetachVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDetach = "ForceDetach"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceDetach = forceDetach {
            try encodeContainer.encode(forceDetach, forKey: .forceDetach)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DetachVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachVolumeOutputError>
}

public struct DetachVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachVolumeOutputError>
}

public struct DetachVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DetachVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachVolumeOutputError>
}

/// AttachVolumeInput
public struct DetachVolumeInput: Swift.Equatable {
    /// Set to true to forcibly remove the iSCSI connection of the target volume
    ///          and detach the volume. The default is false. If this value is set to
    ///             false, you must manually disconnect the iSCSI connection from the target
    ///          volume.
    ///
    ///          Valid Values: true | false
    ///
    public var forceDetach: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the volume to detach from the gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        forceDetach: Swift.Bool? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.forceDetach = forceDetach
        self.volumeARN = volumeARN
    }
}

struct DetachVolumeInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let forceDetach: Swift.Bool?
}

extension DetachVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDetach = "ForceDetach"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let forceDetachDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDetach)
        forceDetach = forceDetachDecoded
    }
}

extension DetachVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachVolumeOutputResponse(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension DetachVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetachVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// AttachVolumeOutput
public struct DetachVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume that was detached.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DetachVolumeOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension DetachVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension StorageGatewayClientTypes.DeviceiSCSIAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chapEnabled = "ChapEnabled"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfacePort = "NetworkInterfacePort"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if chapEnabled != false {
            try encodeContainer.encode(chapEnabled, forKey: .chapEnabled)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if networkInterfacePort != 0 {
            try encodeContainer.encode(networkInterfacePort, forKey: .networkInterfacePort)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfacePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .networkInterfacePort)
        networkInterfacePort = networkInterfacePortDecoded
        let chapEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .chapEnabled)
        chapEnabled = chapEnabledDecoded
    }
}

extension StorageGatewayClientTypes.DeviceiSCSIAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceiSCSIAttributes(chapEnabled: \(Swift.String(describing: chapEnabled)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), networkInterfacePort: \(Swift.String(describing: networkInterfacePort)), targetARN: \(Swift.String(describing: targetARN)))"}
}

extension StorageGatewayClientTypes {
    /// Lists iSCSI information about a VTL device.
    public struct DeviceiSCSIAttributes: Swift.Equatable {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public var chapEnabled: Swift.Bool
        /// The network interface identifier of the VTL device.
        public var networkInterfaceId: Swift.String?
        /// The port used to communicate with iSCSI VTL device targets.
        public var networkInterfacePort: Swift.Int
        /// Specifies the unique Amazon Resource Name (ARN) that encodes the iSCSI qualified
        ///          name(iqn) of a tape drive or media changer target.
        public var targetARN: Swift.String?

        public init (
            chapEnabled: Swift.Bool = false,
            networkInterfaceId: Swift.String? = nil,
            networkInterfacePort: Swift.Int = 0,
            targetARN: Swift.String? = nil
        )
        {
            self.chapEnabled = chapEnabled
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }
    }

}

public struct DisableGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableGatewayOutputError>
}

extension DisableGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableGatewayInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DisableGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DisableGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableGatewayOutputError>
}

public struct DisableGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableGatewayOutputError>
}

public struct DisableGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisableGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisableGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisableGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableGatewayOutputError>
}

/// DisableGatewayInput
public struct DisableGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DisableGatewayInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DisableGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DisableGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableGatewayOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension DisableGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisableGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// DisableGatewayOutput
public struct DisableGatewayOutputResponse: Swift.Equatable {
    /// The unique Amazon Resource Name (ARN) of the disabled gateway.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DisableGatewayOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension DisableGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DisassociateFileSystemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFileSystemOutputError>
}

extension DisassociateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFileSystemInput(fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)), forceDelete: \(Swift.String(describing: forceDelete)))"}
}

extension DisassociateFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case forceDelete = "ForceDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DisassociateFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFileSystemOutputError>
}

public struct DisassociateFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFileSystemOutputError>
}

public struct DisassociateFileSystemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFileSystemInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateFileSystemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateFileSystemInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFileSystemOutputError>
}

public struct DisassociateFileSystemInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file system association to be deleted.
    /// This member is required.
    public var fileSystemAssociationARN: Swift.String?
    /// If this value is set to true, the operation disassociates an Amazon FSx file system
    ///          immediately. It ends all data uploads to the file system, and the file system association
    ///          enters the FORCE_DELETING status. If this value is set to false, the Amazon FSx file system does not disassociate until all data is uploaded.
    public var forceDelete: Swift.Bool

    public init (
        fileSystemAssociationARN: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.forceDelete = forceDelete
    }
}

struct DisassociateFileSystemInputBody: Swift.Equatable {
    public let fileSystemAssociationARN: Swift.String?
    public let forceDelete: Swift.Bool
}

extension DisassociateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case forceDelete = "ForceDelete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let forceDeleteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DisassociateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFileSystemOutputResponse(fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)))"}
}

extension DisassociateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct DisassociateFileSystemOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init (
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct DisassociateFileSystemOutputResponseBody: Swift.Equatable {
    public let fileSystemAssociationARN: Swift.String?
}

extension DisassociateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

extension StorageGatewayClientTypes.Disk: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskAllocationResource = "DiskAllocationResource"
        case diskAllocationType = "DiskAllocationType"
        case diskAttributeList = "DiskAttributeList"
        case diskId = "DiskId"
        case diskNode = "DiskNode"
        case diskPath = "DiskPath"
        case diskSizeInBytes = "DiskSizeInBytes"
        case diskStatus = "DiskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskAllocationResource = diskAllocationResource {
            try encodeContainer.encode(diskAllocationResource, forKey: .diskAllocationResource)
        }
        if let diskAllocationType = diskAllocationType {
            try encodeContainer.encode(diskAllocationType, forKey: .diskAllocationType)
        }
        if let diskAttributeList = diskAttributeList {
            var diskAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskAttributeList)
            for diskattributelist0 in diskAttributeList {
                try diskAttributeListContainer.encode(diskattributelist0)
            }
        }
        if let diskId = diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let diskNode = diskNode {
            try encodeContainer.encode(diskNode, forKey: .diskNode)
        }
        if let diskPath = diskPath {
            try encodeContainer.encode(diskPath, forKey: .diskPath)
        }
        if diskSizeInBytes != 0 {
            try encodeContainer.encode(diskSizeInBytes, forKey: .diskSizeInBytes)
        }
        if let diskStatus = diskStatus {
            try encodeContainer.encode(diskStatus, forKey: .diskStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let diskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskId)
        diskId = diskIdDecoded
        let diskPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskPath)
        diskPath = diskPathDecoded
        let diskNodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskNode)
        diskNode = diskNodeDecoded
        let diskStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskStatus)
        diskStatus = diskStatusDecoded
        let diskSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .diskSizeInBytes)
        diskSizeInBytes = diskSizeInBytesDecoded
        let diskAllocationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskAllocationType)
        diskAllocationType = diskAllocationTypeDecoded
        let diskAllocationResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskAllocationResource)
        diskAllocationResource = diskAllocationResourceDecoded
        let diskAttributeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskAttributeList)
        var diskAttributeListDecoded0:[Swift.String]? = nil
        if let diskAttributeListContainer = diskAttributeListContainer {
            diskAttributeListDecoded0 = [Swift.String]()
            for string0 in diskAttributeListContainer {
                if let string0 = string0 {
                    diskAttributeListDecoded0?.append(string0)
                }
            }
        }
        diskAttributeList = diskAttributeListDecoded0
    }
}

extension StorageGatewayClientTypes.Disk: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Disk(diskAllocationResource: \(Swift.String(describing: diskAllocationResource)), diskAllocationType: \(Swift.String(describing: diskAllocationType)), diskAttributeList: \(Swift.String(describing: diskAttributeList)), diskId: \(Swift.String(describing: diskId)), diskNode: \(Swift.String(describing: diskNode)), diskPath: \(Swift.String(describing: diskPath)), diskSizeInBytes: \(Swift.String(describing: diskSizeInBytes)), diskStatus: \(Swift.String(describing: diskStatus)))"}
}

extension StorageGatewayClientTypes {
    /// Represents a gateway's local disk.
    public struct Disk: Swift.Equatable {
        /// The iSCSI qualified name (IQN) that is defined for a disk. This field is not included in
        ///          the response if the local disk is not defined as an iSCSI target. The format of this field
        ///          is targetIqn::LUNNumber::region-volumeId.
        public var diskAllocationResource: Swift.String?
        /// One of the DiskAllocationType enumeration values that identifies how a
        ///          local disk is used.
        ///
        ///          Valid Values: UPLOAD_BUFFER | CACHE_STORAGE
        ///
        public var diskAllocationType: Swift.String?
        /// A list of values that represents attributes of a local disk.
        public var diskAttributeList: [Swift.String]?
        /// The unique device ID or other distinguishing data that identifies a local disk.
        public var diskId: Swift.String?
        /// The device node of a local disk as assigned by the virtualization environment.
        public var diskNode: Swift.String?
        /// The path of a local disk in the gateway virtual machine (VM).
        public var diskPath: Swift.String?
        /// The local disk size in bytes.
        public var diskSizeInBytes: Swift.Int
        /// A value that represents the status of a local disk.
        public var diskStatus: Swift.String?

        public init (
            diskAllocationResource: Swift.String? = nil,
            diskAllocationType: Swift.String? = nil,
            diskAttributeList: [Swift.String]? = nil,
            diskId: Swift.String? = nil,
            diskNode: Swift.String? = nil,
            diskPath: Swift.String? = nil,
            diskSizeInBytes: Swift.Int = 0,
            diskStatus: Swift.String? = nil
        )
        {
            self.diskAllocationResource = diskAllocationResource
            self.diskAllocationType = diskAllocationType
            self.diskAttributeList = diskAttributeList
            self.diskId = diskId
            self.diskNode = diskNode
            self.diskPath = diskPath
            self.diskSizeInBytes = diskSizeInBytes
            self.diskStatus = diskStatus
        }
    }

}

extension StorageGatewayClientTypes.EndpointNetworkConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddresses = "IpAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddresslist0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddresslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
    }
}

extension StorageGatewayClientTypes.EndpointNetworkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointNetworkConfiguration(ipAddresses: \(Swift.String(describing: ipAddresses)))"}
}

extension StorageGatewayClientTypes {
    /// Specifies network configuration information for the gateway associated with the
    ///          Amazon FSx file system.
    public struct EndpointNetworkConfiguration: Swift.Equatable {
        /// A list of gateway IP addresses on which the associated Amazon FSx file system is available.
        ///
        ///             If multiple file systems are associated with this gateway, this field is required.
        ///
        public var ipAddresses: [Swift.String]?

        public init (
            ipAddresses: [Swift.String]? = nil
        )
        {
            self.ipAddresses = ipAddresses
        }
    }

}

extension StorageGatewayClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activationkeyexpired
        case activationkeyinvalid
        case activationkeynotfound
        case authenticationfailure
        case bandwidththrottleschedulenotfound
        case blocked
        case cannotexportsnapshot
        case chapcredentialnotfound
        case diskalreadyallocated
        case diskdoesnotexist
        case disksizegreaterthanvolumemaxsize
        case disksizelessthanvolumesize
        case disksizenotgigaligned
        case duplicatecertificateinfo
        case duplicateschedule
        case endpointnotfound
        case gatewayinternalerror
        case gatewaynotconnected
        case gatewaynotfound
        case gatewayproxynetworkconnectionbusy
        case iamnotsupported
        case initiatorinvalid
        case initiatornotfound
        case internalerror
        case invalidendpoint
        case invalidgateway
        case invalidparameters
        case invalidschedule
        case joindomaininprogress
        case localstoragelimitexceeded
        case lunalreadyallocated
        case luninvalid
        case maximumcontentlengthexceeded
        case maximumtapecartridgecountexceeded
        case maximumvolumecountexceeded
        case networkconfigurationchanged
        case nodisksavailable
        case notimplemented
        case notsupported
        case operationaborted
        case outdatedgateway
        case parametersnotimplemented
        case regioninvalid
        case requesttimeout
        case serviceunavailable
        case snapshotdeleted
        case snapshotidinvalid
        case snapshotinprogress
        case snapshotnotfound
        case snapshotschedulenotfound
        case stagingareafull
        case storagefailure
        case tapecartridgenotfound
        case targetalreadyexists
        case targetinvalid
        case targetnotfound
        case unauthorizedoperation
        case volumealreadyexists
        case volumeidinvalid
        case volumeinuse
        case volumenotfound
        case volumenotready
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .activationkeyexpired,
                .activationkeyinvalid,
                .activationkeynotfound,
                .authenticationfailure,
                .bandwidththrottleschedulenotfound,
                .blocked,
                .cannotexportsnapshot,
                .chapcredentialnotfound,
                .diskalreadyallocated,
                .diskdoesnotexist,
                .disksizegreaterthanvolumemaxsize,
                .disksizelessthanvolumesize,
                .disksizenotgigaligned,
                .duplicatecertificateinfo,
                .duplicateschedule,
                .endpointnotfound,
                .gatewayinternalerror,
                .gatewaynotconnected,
                .gatewaynotfound,
                .gatewayproxynetworkconnectionbusy,
                .iamnotsupported,
                .initiatorinvalid,
                .initiatornotfound,
                .internalerror,
                .invalidendpoint,
                .invalidgateway,
                .invalidparameters,
                .invalidschedule,
                .joindomaininprogress,
                .localstoragelimitexceeded,
                .lunalreadyallocated,
                .luninvalid,
                .maximumcontentlengthexceeded,
                .maximumtapecartridgecountexceeded,
                .maximumvolumecountexceeded,
                .networkconfigurationchanged,
                .nodisksavailable,
                .notimplemented,
                .notsupported,
                .operationaborted,
                .outdatedgateway,
                .parametersnotimplemented,
                .regioninvalid,
                .requesttimeout,
                .serviceunavailable,
                .snapshotdeleted,
                .snapshotidinvalid,
                .snapshotinprogress,
                .snapshotnotfound,
                .snapshotschedulenotfound,
                .stagingareafull,
                .storagefailure,
                .tapecartridgenotfound,
                .targetalreadyexists,
                .targetinvalid,
                .targetnotfound,
                .unauthorizedoperation,
                .volumealreadyexists,
                .volumeidinvalid,
                .volumeinuse,
                .volumenotfound,
                .volumenotready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activationkeyexpired: return "ActivationKeyExpired"
            case .activationkeyinvalid: return "ActivationKeyInvalid"
            case .activationkeynotfound: return "ActivationKeyNotFound"
            case .authenticationfailure: return "AuthenticationFailure"
            case .bandwidththrottleschedulenotfound: return "BandwidthThrottleScheduleNotFound"
            case .blocked: return "Blocked"
            case .cannotexportsnapshot: return "CannotExportSnapshot"
            case .chapcredentialnotfound: return "ChapCredentialNotFound"
            case .diskalreadyallocated: return "DiskAlreadyAllocated"
            case .diskdoesnotexist: return "DiskDoesNotExist"
            case .disksizegreaterthanvolumemaxsize: return "DiskSizeGreaterThanVolumeMaxSize"
            case .disksizelessthanvolumesize: return "DiskSizeLessThanVolumeSize"
            case .disksizenotgigaligned: return "DiskSizeNotGigAligned"
            case .duplicatecertificateinfo: return "DuplicateCertificateInfo"
            case .duplicateschedule: return "DuplicateSchedule"
            case .endpointnotfound: return "EndpointNotFound"
            case .gatewayinternalerror: return "GatewayInternalError"
            case .gatewaynotconnected: return "GatewayNotConnected"
            case .gatewaynotfound: return "GatewayNotFound"
            case .gatewayproxynetworkconnectionbusy: return "GatewayProxyNetworkConnectionBusy"
            case .iamnotsupported: return "IAMNotSupported"
            case .initiatorinvalid: return "InitiatorInvalid"
            case .initiatornotfound: return "InitiatorNotFound"
            case .internalerror: return "InternalError"
            case .invalidendpoint: return "InvalidEndpoint"
            case .invalidgateway: return "InvalidGateway"
            case .invalidparameters: return "InvalidParameters"
            case .invalidschedule: return "InvalidSchedule"
            case .joindomaininprogress: return "JoinDomainInProgress"
            case .localstoragelimitexceeded: return "LocalStorageLimitExceeded"
            case .lunalreadyallocated: return "LunAlreadyAllocated "
            case .luninvalid: return "LunInvalid"
            case .maximumcontentlengthexceeded: return "MaximumContentLengthExceeded"
            case .maximumtapecartridgecountexceeded: return "MaximumTapeCartridgeCountExceeded"
            case .maximumvolumecountexceeded: return "MaximumVolumeCountExceeded"
            case .networkconfigurationchanged: return "NetworkConfigurationChanged"
            case .nodisksavailable: return "NoDisksAvailable"
            case .notimplemented: return "NotImplemented"
            case .notsupported: return "NotSupported"
            case .operationaborted: return "OperationAborted"
            case .outdatedgateway: return "OutdatedGateway"
            case .parametersnotimplemented: return "ParametersNotImplemented"
            case .regioninvalid: return "RegionInvalid"
            case .requesttimeout: return "RequestTimeout"
            case .serviceunavailable: return "ServiceUnavailable"
            case .snapshotdeleted: return "SnapshotDeleted"
            case .snapshotidinvalid: return "SnapshotIdInvalid"
            case .snapshotinprogress: return "SnapshotInProgress"
            case .snapshotnotfound: return "SnapshotNotFound"
            case .snapshotschedulenotfound: return "SnapshotScheduleNotFound"
            case .stagingareafull: return "StagingAreaFull"
            case .storagefailure: return "StorageFailure"
            case .tapecartridgenotfound: return "TapeCartridgeNotFound"
            case .targetalreadyexists: return "TargetAlreadyExists"
            case .targetinvalid: return "TargetInvalid"
            case .targetnotfound: return "TargetNotFound"
            case .unauthorizedoperation: return "UnauthorizedOperation"
            case .volumealreadyexists: return "VolumeAlreadyExists"
            case .volumeidinvalid: return "VolumeIdInvalid"
            case .volumeinuse: return "VolumeInUse"
            case .volumenotfound: return "VolumeNotFound"
            case .volumenotready: return "VolumeNotReady"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.FileShareInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareStatus = "FileShareStatus"
        case fileShareType = "FileShareType"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareStatus = fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let fileShareType = fileShareType {
            try encodeContainer.encode(fileShareType.rawValue, forKey: .fileShareType)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareTypeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.FileShareType.self, forKey: .fileShareType)
        fileShareType = fileShareTypeDecoded
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes.FileShareInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileShareInfo(fileShareARN: \(Swift.String(describing: fileShareARN)), fileShareId: \(Swift.String(describing: fileShareId)), fileShareStatus: \(Swift.String(describing: fileShareStatus)), fileShareType: \(Swift.String(describing: fileShareType)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a file share. Only supported S3 File Gateway.
    public struct FileShareInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The status of the file share.
        ///
        ///          Valid Values: CREATING | UPDATING | AVAILABLE |
        ///             DELETING
        ///
        public var fileShareStatus: Swift.String?
        /// The type of the file share.
        public var fileShareType: StorageGatewayClientTypes.FileShareType?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?

        public init (
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            fileShareType: StorageGatewayClientTypes.FileShareType? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareStatus = fileShareStatus
            self.fileShareType = fileShareType
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes {
    /// The type of the file share.
    public enum FileShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nfs
        case smb
        case sdkUnknown(Swift.String)

        public static var allCases: [FileShareType] {
            return [
                .nfs,
                .smb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nfs: return "NFS"
            case .smb: return "SMB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileShareType(rawValue: rawValue) ?? FileShareType.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.FileSystemAssociationInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case fileSystemAssociationStatus = "FileSystemAssociationStatus"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let endpointNetworkConfiguration = endpointNetworkConfiguration {
            try encodeContainer.encode(endpointNetworkConfiguration, forKey: .endpointNetworkConfiguration)
        }
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let fileSystemAssociationStatus = fileSystemAssociationStatus {
            try encodeContainer.encode(fileSystemAssociationStatus, forKey: .fileSystemAssociationStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let fileSystemAssociationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationStatus)
        fileSystemAssociationStatus = fileSystemAssociationStatusDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let endpointNetworkConfigurationDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.EndpointNetworkConfiguration.self, forKey: .endpointNetworkConfiguration)
        endpointNetworkConfiguration = endpointNetworkConfigurationDecoded
    }
}

extension StorageGatewayClientTypes.FileSystemAssociationInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemAssociationInfo(auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), endpointNetworkConfiguration: \(Swift.String(describing: endpointNetworkConfiguration)), fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)), fileSystemAssociationStatus: \(Swift.String(describing: fileSystemAssociationStatus)), gatewayARN: \(Swift.String(describing: gatewayARN)), locationARN: \(Swift.String(describing: locationARN)), tags: \(Swift.String(describing: tags)))"}
}

extension StorageGatewayClientTypes {
    /// Describes the object returned by DescribeFileSystemAssociations that
    ///          describes a created file system association.
    public struct FileSystemAssociationInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
        public var auditDestinationARN: Swift.String?
        /// The refresh cache information for the file share or FSx file systems.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// Specifies network configuration information for the gateway associated with the
        ///          Amazon FSx file system.
        ///
        ///             If multiple file systems are associated with this gateway, this parameter's IpAddresses
        ///             field is required.
        ///
        public var endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
        /// The Amazon Resource Name (ARN) of the file system association.
        public var fileSystemAssociationARN: Swift.String?
        /// The status of the file system association.
        ///          Valid Values: AVAILABLE | CREATING | DELETING |
        ///          FORCE_DELETING | UPDATING | ERROR
        ///
        public var fileSystemAssociationStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?
        /// The ARN of the backend Amazon FSx file system used for storing file data. For
        ///          information, see <a href="https://docs.aws.amazon.com/fsx/latest/APIReference/API_FileSystem.html">FileSystem in the Amazon FSx
        ///                API Reference.
        public var locationARN: Swift.String?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair.
        public var tags: [StorageGatewayClientTypes.Tag]?

        public init (
            auditDestinationARN: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration? = nil,
            fileSystemAssociationARN: Swift.String? = nil,
            fileSystemAssociationStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil
        )
        {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.endpointNetworkConfiguration = endpointNetworkConfiguration
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.gatewayARN = gatewayARN
            self.locationARN = locationARN
            self.tags = tags
        }
    }

}

extension StorageGatewayClientTypes.FileSystemAssociationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case fileSystemAssociationId = "FileSystemAssociationId"
        case fileSystemAssociationStatus = "FileSystemAssociationStatus"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let fileSystemAssociationId = fileSystemAssociationId {
            try encodeContainer.encode(fileSystemAssociationId, forKey: .fileSystemAssociationId)
        }
        if let fileSystemAssociationStatus = fileSystemAssociationStatus {
            try encodeContainer.encode(fileSystemAssociationStatus, forKey: .fileSystemAssociationStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationId)
        fileSystemAssociationId = fileSystemAssociationIdDecoded
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let fileSystemAssociationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationStatus)
        fileSystemAssociationStatus = fileSystemAssociationStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes.FileSystemAssociationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemAssociationSummary(fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)), fileSystemAssociationId: \(Swift.String(describing: fileSystemAssociationId)), fileSystemAssociationStatus: \(Swift.String(describing: fileSystemAssociationStatus)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension StorageGatewayClientTypes {
    /// Gets the summary returned by ListFileSystemAssociation, which is a summary
    ///          of a created file system association.
    public struct FileSystemAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the file system association.
        public var fileSystemAssociationARN: Swift.String?
        /// The ID of the file system association.
        public var fileSystemAssociationId: Swift.String?
        /// The status of the file share. Valid Values: AVAILABLE | CREATING | DELETING |
        ///          FORCE_DELETING | UPDATING | ERROR
        ///
        public var fileSystemAssociationStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?

        public init (
            fileSystemAssociationARN: Swift.String? = nil,
            fileSystemAssociationId: Swift.String? = nil,
            fileSystemAssociationStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationId = fileSystemAssociationId
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes {
    public enum GatewayCapacity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayCapacity] {
            return [
                .large,
                .medium,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "Large"
            case .medium: return "Medium"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayCapacity(rawValue: rawValue) ?? GatewayCapacity.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.GatewayInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceId = "Ec2InstanceId"
        case ec2InstanceRegion = "Ec2InstanceRegion"
        case gatewayARN = "GatewayARN"
        case gatewayId = "GatewayId"
        case gatewayName = "GatewayName"
        case gatewayOperationalState = "GatewayOperationalState"
        case gatewayType = "GatewayType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceId = ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let ec2InstanceRegion = ec2InstanceRegion {
            try encodeContainer.encode(ec2InstanceRegion, forKey: .ec2InstanceRegion)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayOperationalState = gatewayOperationalState {
            try encodeContainer.encode(gatewayOperationalState, forKey: .gatewayOperationalState)
        }
        if let gatewayType = gatewayType {
            try encodeContainer.encode(gatewayType, forKey: .gatewayType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let gatewayOperationalStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayOperationalState)
        gatewayOperationalState = gatewayOperationalStateDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ec2InstanceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceRegion)
        ec2InstanceRegion = ec2InstanceRegionDecoded
    }
}

extension StorageGatewayClientTypes.GatewayInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GatewayInfo(ec2InstanceId: \(Swift.String(describing: ec2InstanceId)), ec2InstanceRegion: \(Swift.String(describing: ec2InstanceRegion)), gatewayARN: \(Swift.String(describing: gatewayARN)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayName: \(Swift.String(describing: gatewayName)), gatewayOperationalState: \(Swift.String(describing: gatewayOperationalState)), gatewayType: \(Swift.String(describing: gatewayType)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a gateway object.
    public struct GatewayInfo: Swift.Equatable {
        /// The ID of the Amazon EC2 instance that was used to launch the gateway.
        public var ec2InstanceId: Swift.String?
        /// The Region where the Amazon EC2 instance is located.
        public var ec2InstanceRegion: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part
        ///          of the gateway Amazon Resource Name (ARN), which you use as input for other
        ///          operations.
        public var gatewayId: Swift.String?
        /// The name of the gateway.
        public var gatewayName: Swift.String?
        /// The state of the gateway.
        ///
        ///          Valid Values: DISABLED | ACTIVE
        ///
        public var gatewayOperationalState: Swift.String?
        /// The type of the gateway.
        public var gatewayType: Swift.String?

        public init (
            ec2InstanceId: Swift.String? = nil,
            ec2InstanceRegion: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            gatewayName: Swift.String? = nil,
            gatewayOperationalState: Swift.String? = nil,
            gatewayType: Swift.String? = nil
        )
        {
            self.ec2InstanceId = ec2InstanceId
            self.ec2InstanceRegion = ec2InstanceRegion
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayOperationalState = gatewayOperationalState
            self.gatewayType = gatewayType
        }
    }

}

extension StorageGatewayClientTypes {
    public enum HostEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case hyperV
        case kvm
        case other
        case vmware
        case sdkUnknown(Swift.String)

        public static var allCases: [HostEnvironment] {
            return [
                .ec2,
                .hyperV,
                .kvm,
                .other,
                .vmware,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .hyperV: return "HYPER-V"
            case .kvm: return "KVM"
            case .other: return "OTHER"
            case .vmware: return "VMWARE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HostEnvironment(rawValue: rawValue) ?? HostEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(error: \(Swift.String(describing: error)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error has occurred during the request. For more information, see the
///          error and message fields.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A StorageGatewayError that provides more information about the cause
    ///          of the error.
    public var error: StorageGatewayClientTypes.StorageGatewayError?
    /// A human-readable message describing the error that occurred.
    public var message: Swift.String?

    public init (
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
    public let error: StorageGatewayClientTypes.StorageGatewayError?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

extension InvalidGatewayRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidGatewayRequestException(error: \(Swift.String(describing: error)), message: \(Swift.String(describing: message)))"}
}

extension InvalidGatewayRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidGatewayRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception occurred because an invalid gateway request was issued to the service. For
///          more information, see the error and message fields.
public struct InvalidGatewayRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A StorageGatewayError that provides more detail about the cause of the
    ///          error.
    public var error: StorageGatewayClientTypes.StorageGatewayError?
    /// A human-readable message describing the error that occurred.
    public var message: Swift.String?

    public init (
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct InvalidGatewayRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let error: StorageGatewayClientTypes.StorageGatewayError?
}

extension InvalidGatewayRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

public struct JoinDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "JoinDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<JoinDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<JoinDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<JoinDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<JoinDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<JoinDomainOutputError>
}

extension JoinDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JoinDomainInput(domainControllers: \(Swift.String(describing: domainControllers)), domainName: \(Swift.String(describing: domainName)), gatewayARN: \(Swift.String(describing: gatewayARN)), organizationalUnit: \(Swift.String(describing: organizationalUnit)), password: \(Swift.String(describing: password)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)), userName: \(Swift.String(describing: userName)))"}
}

extension JoinDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainControllers = "DomainControllers"
        case domainName = "DomainName"
        case gatewayARN = "GatewayARN"
        case organizationalUnit = "OrganizationalUnit"
        case password = "Password"
        case timeoutInSeconds = "TimeoutInSeconds"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainControllers = domainControllers {
            var domainControllersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainControllers)
            for hosts0 in domainControllers {
                try domainControllersContainer.encode(hosts0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let organizationalUnit = organizationalUnit {
            try encodeContainer.encode(organizationalUnit, forKey: .organizationalUnit)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct JoinDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "JoinDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<JoinDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<JoinDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<JoinDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<JoinDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<JoinDomainOutputError>
}

public struct JoinDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "JoinDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<JoinDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<JoinDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<JoinDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<JoinDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<JoinDomainOutputError>
}

public struct JoinDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "JoinDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: JoinDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<JoinDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = JoinDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<JoinDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<JoinDomainOutputError>
}

/// JoinDomainInput
public struct JoinDomainInput: Swift.Equatable {
    /// List of IPv4 addresses, NetBIOS names, or host names of your domain server. If you need
    ///          to specify the port number include it after the colon (“:”). For example,
    ///             mydc.mydomain.com:389.
    public var domainControllers: [Swift.String]?
    /// The name of the domain that you want the gateway to join.
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The organizational unit (OU) is a container in an Active Directory that can hold users,
    ///          groups, computers, and other OUs and this parameter specifies the OU that the gateway will
    ///          join within the AD domain.
    public var organizationalUnit: Swift.String?
    /// Sets the password of the user who has permission to add the gateway to the Active
    ///          Directory domain.
    /// This member is required.
    public var password: Swift.String?
    /// Specifies the time in seconds, in which the JoinDomain operation must
    ///          complete. The default is 20 seconds.
    public var timeoutInSeconds: Swift.Int?
    /// Sets the user name of user who has permission to add the gateway to the Active Directory
    ///          domain. The domain user account should be enabled to join computers to the domain. For
    ///          example, you can use the domain administrator account or an account with delegated
    ///          permissions to join computers to the domain.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        domainControllers: [Swift.String]? = nil,
        domainName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        organizationalUnit: Swift.String? = nil,
        password: Swift.String? = nil,
        timeoutInSeconds: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.domainControllers = domainControllers
        self.domainName = domainName
        self.gatewayARN = gatewayARN
        self.organizationalUnit = organizationalUnit
        self.password = password
        self.timeoutInSeconds = timeoutInSeconds
        self.userName = userName
    }
}

struct JoinDomainInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let domainName: Swift.String?
    public let organizationalUnit: Swift.String?
    public let domainControllers: [Swift.String]?
    public let timeoutInSeconds: Swift.Int?
    public let userName: Swift.String?
    public let password: Swift.String?
}

extension JoinDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainControllers = "DomainControllers"
        case domainName = "DomainName"
        case gatewayARN = "GatewayARN"
        case organizationalUnit = "OrganizationalUnit"
        case password = "Password"
        case timeoutInSeconds = "TimeoutInSeconds"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let organizationalUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnit)
        organizationalUnit = organizationalUnitDecoded
        let domainControllersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domainControllers)
        var domainControllersDecoded0:[Swift.String]? = nil
        if let domainControllersContainer = domainControllersContainer {
            domainControllersDecoded0 = [Swift.String]()
            for string0 in domainControllersContainer {
                if let string0 = string0 {
                    domainControllersDecoded0?.append(string0)
                }
            }
        }
        domainControllers = domainControllersDecoded0
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension JoinDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension JoinDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum JoinDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension JoinDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JoinDomainOutputResponse(activeDirectoryStatus: \(Swift.String(describing: activeDirectoryStatus)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension JoinDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: JoinDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeDirectoryStatus = output.activeDirectoryStatus
            self.gatewayARN = output.gatewayARN
        } else {
            self.activeDirectoryStatus = nil
            self.gatewayARN = nil
        }
    }
}

/// JoinDomainOutput
public struct JoinDomainOutputResponse: Swift.Equatable {
    /// Indicates the status of the gateway as a member of the Active Directory domain.
    ///
    ///
    ///
    ///
    ///                   ACCESS_DENIED: Indicates that the JoinDomain operation
    ///                failed due to an authentication error.
    ///
    ///
    ///
    ///                   DETACHED: Indicates that gateway is not joined to a domain.
    ///
    ///
    ///
    ///                   JOINED: Indicates that the gateway has successfully joined a
    ///                domain.
    ///
    ///
    ///
    ///                   JOINING: Indicates that a JoinDomain operation is in
    ///                progress.
    ///
    ///
    ///
    ///                   NETWORK_ERROR: Indicates that JoinDomain operation
    ///                failed due to a network or connectivity error.
    ///
    ///
    ///
    ///                   TIMEOUT: Indicates that the JoinDomain operation failed
    ///                because the operation didn't complete within the allotted time.
    ///
    ///
    ///
    ///                   UNKNOWN_ERROR: Indicates that the JoinDomain operation
    ///                failed due to another type of error.
    ///
    ///
    public var activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    /// The unique Amazon Resource Name (ARN) of the gateway that joined the domain.
    public var gatewayARN: Swift.String?

    public init (
        activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.gatewayARN = gatewayARN
    }
}

struct JoinDomainOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
}

extension JoinDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryStatus = "ActiveDirectoryStatus"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let activeDirectoryStatusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ActiveDirectoryStatus.self, forKey: .activeDirectoryStatus)
        activeDirectoryStatus = activeDirectoryStatusDecoded
    }
}

public struct ListAutomaticTapeCreationPoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutomaticTapeCreationPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutomaticTapeCreationPoliciesOutputError>
}

extension ListAutomaticTapeCreationPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAutomaticTapeCreationPoliciesInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ListAutomaticTapeCreationPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ListAutomaticTapeCreationPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutomaticTapeCreationPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutomaticTapeCreationPoliciesOutputError>
}

public struct ListAutomaticTapeCreationPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutomaticTapeCreationPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutomaticTapeCreationPoliciesOutputError>
}

public struct ListAutomaticTapeCreationPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutomaticTapeCreationPoliciesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAutomaticTapeCreationPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAutomaticTapeCreationPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutomaticTapeCreationPoliciesOutputError>
}

public struct ListAutomaticTapeCreationPoliciesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListAutomaticTapeCreationPoliciesInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ListAutomaticTapeCreationPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListAutomaticTapeCreationPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAutomaticTapeCreationPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAutomaticTapeCreationPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAutomaticTapeCreationPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAutomaticTapeCreationPoliciesOutputResponse(automaticTapeCreationPolicyInfos: \(Swift.String(describing: automaticTapeCreationPolicyInfos)))"}
}

extension ListAutomaticTapeCreationPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAutomaticTapeCreationPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automaticTapeCreationPolicyInfos = output.automaticTapeCreationPolicyInfos
        } else {
            self.automaticTapeCreationPolicyInfos = nil
        }
    }
}

public struct ListAutomaticTapeCreationPoliciesOutputResponse: Swift.Equatable {
    /// Gets a listing of information about the gateway's automatic tape creation policies,
    ///          including the automatic tape creation rules and the gateway that is using the
    ///          policies.
    public var automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]?

    public init (
        automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]? = nil
    )
    {
        self.automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfos
    }
}

struct ListAutomaticTapeCreationPoliciesOutputResponseBody: Swift.Equatable {
    public let automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]?
}

extension ListAutomaticTapeCreationPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationPolicyInfos = "AutomaticTapeCreationPolicyInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationPolicyInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo?].self, forKey: .automaticTapeCreationPolicyInfos)
        var automaticTapeCreationPolicyInfosDecoded0:[StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]? = nil
        if let automaticTapeCreationPolicyInfosContainer = automaticTapeCreationPolicyInfosContainer {
            automaticTapeCreationPolicyInfosDecoded0 = [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]()
            for structure0 in automaticTapeCreationPolicyInfosContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationPolicyInfosDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfosDecoded0
    }
}

public struct ListFileSharesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSharesOutputError>
}

extension ListFileSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFileSharesInput(gatewayARN: \(Swift.String(describing: gatewayARN)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)))"}
}

extension ListFileSharesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListFileSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSharesOutputError>
}

public struct ListFileSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFileSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFileSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSharesOutputError>
}

public struct ListFileSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSharesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFileSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFileSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSharesOutputError>
}

/// ListFileShareInput
public struct ListFileSharesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway whose file shares you want to list. If
    ///          this field is not present, all file shares under your account are listed.
    public var gatewayARN: Swift.String?
    /// The maximum number of file shares to return in the response. The value must be an
    ///          integer with a value greater than zero. Optional.
    public var limit: Swift.Int?
    /// Opaque pagination token returned from a previous ListFileShares operation. If present,
    ///             Marker specifies where to continue the list from after a previous call to
    ///          ListFileShares. Optional.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListFileSharesInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let limit: Swift.Int?
    public let marker: Swift.String?
}

extension ListFileSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListFileSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFileSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFileSharesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFileSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFileSharesOutputResponse(fileShareInfoList: \(Swift.String(describing: fileShareInfoList)), marker: \(Swift.String(describing: marker)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListFileSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareInfoList = output.fileShareInfoList
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileShareInfoList = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

/// ListFileShareOutput
public struct ListFileSharesOutputResponse: Swift.Equatable {
    /// An array of information about the S3 File Gateway's file shares.
    public var fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]?
    /// If the request includes Marker, the response returns that value in this
    ///          field.
    public var marker: Swift.String?
    /// If a value is present, there are more file shares to return. In a subsequent request,
    ///          use NextMarker as the value for Marker to retrieve the next set
    ///          of file shares.
    public var nextMarker: Swift.String?

    public init (
        fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileShareInfoList = fileShareInfoList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct ListFileSharesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let nextMarker: Swift.String?
    public let fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]?
}

extension ListFileSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareInfoList = "FileShareInfoList"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let fileShareInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.FileShareInfo?].self, forKey: .fileShareInfoList)
        var fileShareInfoListDecoded0:[StorageGatewayClientTypes.FileShareInfo]? = nil
        if let fileShareInfoListContainer = fileShareInfoListContainer {
            fileShareInfoListDecoded0 = [StorageGatewayClientTypes.FileShareInfo]()
            for structure0 in fileShareInfoListContainer {
                if let structure0 = structure0 {
                    fileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        fileShareInfoList = fileShareInfoListDecoded0
    }
}

public struct ListFileSystemAssociationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSystemAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFileSystemAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSystemAssociationsOutputError>
}

extension ListFileSystemAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFileSystemAssociationsInput(gatewayARN: \(Swift.String(describing: gatewayARN)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)))"}
}

extension ListFileSystemAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListFileSystemAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSystemAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFileSystemAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSystemAssociationsOutputError>
}

public struct ListFileSystemAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSystemAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFileSystemAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSystemAssociationsOutputError>
}

public struct ListFileSystemAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFileSystemAssociationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFileSystemAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFileSystemAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFileSystemAssociationsOutputError>
}

public struct ListFileSystemAssociationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// The maximum number of file system associations to return in the response. If present, Limit must be an integer with a value greater than zero. Optional.
    public var limit: Swift.Int?
    /// Opaque pagination token returned from a previous ListFileSystemAssociations operation. If present, Marker specifies where to continue the list from after a previous call to ListFileSystemAssociations. Optional.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListFileSystemAssociationsInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let limit: Swift.Int?
    public let marker: Swift.String?
}

extension ListFileSystemAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListFileSystemAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFileSystemAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFileSystemAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFileSystemAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFileSystemAssociationsOutputResponse(fileSystemAssociationSummaryList: \(Swift.String(describing: fileSystemAssociationSummaryList)), marker: \(Swift.String(describing: marker)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListFileSystemAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFileSystemAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationSummaryList = output.fileSystemAssociationSummaryList
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileSystemAssociationSummaryList = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFileSystemAssociationsOutputResponse: Swift.Equatable {
    /// An array of information about the Amazon FSx gateway's file system associations.
    public var fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]?
    /// If the request includes Marker, the response returns that value in this field.
    public var marker: Swift.String?
    /// If a value is present, there are more file system associations to return.
    ///          In a subsequent request, use NextMarker as the value for Marker to retrieve the next set of file system associations.
    public var nextMarker: Swift.String?

    public init (
        fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileSystemAssociationSummaryList = fileSystemAssociationSummaryList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct ListFileSystemAssociationsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let nextMarker: Swift.String?
    public let fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]?
}

extension ListFileSystemAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationSummaryList = "FileSystemAssociationSummaryList"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let fileSystemAssociationSummaryListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.FileSystemAssociationSummary?].self, forKey: .fileSystemAssociationSummaryList)
        var fileSystemAssociationSummaryListDecoded0:[StorageGatewayClientTypes.FileSystemAssociationSummary]? = nil
        if let fileSystemAssociationSummaryListContainer = fileSystemAssociationSummaryListContainer {
            fileSystemAssociationSummaryListDecoded0 = [StorageGatewayClientTypes.FileSystemAssociationSummary]()
            for structure0 in fileSystemAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    fileSystemAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        fileSystemAssociationSummaryList = fileSystemAssociationSummaryListDecoded0
    }
}

public struct ListGatewaysInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGatewaysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGatewaysOutputError>
}

extension ListGatewaysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGatewaysInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)))"}
}

extension ListGatewaysInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListGatewaysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGatewaysInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListGatewaysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGatewaysInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGatewaysOutputError>
}

/// A JSON object containing zero or more of the following fields:
///
///
///
///
///                   ListGatewaysInput$Limit
///
///
///
///
///                   ListGatewaysInput$Marker
///
///
///
public struct ListGatewaysInput: Swift.Equatable {
    /// Specifies that the list of gateways returned be limited to the specified number of
    ///          items.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin the returned list of
    ///          gateways.
    public var marker: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension ListGatewaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewaysOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGatewaysOutputResponse(gateways: \(Swift.String(describing: gateways)), marker: \(Swift.String(describing: marker)))"}
}

extension ListGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gateways = output.gateways
            self.marker = output.marker
        } else {
            self.gateways = nil
            self.marker = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Swift.Equatable {
    /// An array of GatewayInfo objects.
    public var gateways: [StorageGatewayClientTypes.GatewayInfo]?
    /// Use the marker in your next request to fetch the next set of gateways in the list. If
    ///          there are no more gateways to list, this field does not appear in the response.
    public var marker: Swift.String?

    public init (
        gateways: [StorageGatewayClientTypes.GatewayInfo]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.marker = marker
    }
}

struct ListGatewaysOutputResponseBody: Swift.Equatable {
    public let gateways: [StorageGatewayClientTypes.GatewayInfo]?
    public let marker: Swift.String?
}

extension ListGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateways = "Gateways"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.GatewayInfo?].self, forKey: .gateways)
        var gatewaysDecoded0:[StorageGatewayClientTypes.GatewayInfo]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [StorageGatewayClientTypes.GatewayInfo]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListLocalDisksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLocalDisksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLocalDisksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLocalDisksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLocalDisksOutputError>
}

extension ListLocalDisksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLocalDisksInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ListLocalDisksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ListLocalDisksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLocalDisksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLocalDisksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLocalDisksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLocalDisksOutputError>
}

public struct ListLocalDisksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLocalDisksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLocalDisksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLocalDisksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLocalDisksOutputError>
}

public struct ListLocalDisksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLocalDisksInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListLocalDisksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLocalDisksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLocalDisksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLocalDisksOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct ListLocalDisksInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListLocalDisksInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ListLocalDisksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListLocalDisksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLocalDisksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLocalDisksOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLocalDisksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLocalDisksOutputResponse(disks: \(Swift.String(describing: disks)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ListLocalDisksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLocalDisksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disks = output.disks
            self.gatewayARN = output.gatewayARN
        } else {
            self.disks = nil
            self.gatewayARN = nil
        }
    }
}

public struct ListLocalDisksOutputResponse: Swift.Equatable {
    /// A JSON object containing the following fields:
    ///
    ///
    ///
    ///
    ///                   ListLocalDisksOutput$Disks
    ///
    ///
    ///
    public var disks: [StorageGatewayClientTypes.Disk]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        disks: [StorageGatewayClientTypes.Disk]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.disks = disks
        self.gatewayARN = gatewayARN
    }
}

struct ListLocalDisksOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let disks: [StorageGatewayClientTypes.Disk]?
}

extension ListLocalDisksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disks = "Disks"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let disksContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Disk?].self, forKey: .disks)
        var disksDecoded0:[StorageGatewayClientTypes.Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [StorageGatewayClientTypes.Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

/// ListTagsForResourceInput
public struct ListTagsForResourceInput: Swift.Equatable {
    /// Specifies that the list of tags returned be limited to the specified number of
    ///          items.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin returning the list of
    ///          tags.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(marker: \(Swift.String(describing: marker)), resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.resourceARN = output.resourceARN
            self.tags = output.tags
        } else {
            self.marker = nil
            self.resourceARN = nil
            self.tags = nil
        }
    }
}

/// ListTagsForResourceOutput
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// An opaque string that indicates the position at which to stop returning the list of
    ///          tags.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    public var resourceARN: Swift.String?
    /// An array that contains the tags for the specified resource.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init (
        marker: Swift.String? = nil,
        resourceARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.marker = marker
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let marker: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTapePoolsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapePoolsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTapePoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTapePoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapePoolsOutputError>
}

extension ListTapePoolsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTapePoolsInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), poolARNs: \(Swift.String(describing: poolARNs)))"}
}

extension ListTapePoolsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case poolARNs = "PoolARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let poolARNs = poolARNs {
            var poolARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .poolARNs)
            for poolarns0 in poolARNs {
                try poolARNsContainer.encode(poolarns0)
            }
        }
    }
}

public struct ListTapePoolsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapePoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTapePoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTapePoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapePoolsOutputError>
}

public struct ListTapePoolsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapePoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTapePoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTapePoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapePoolsOutputError>
}

public struct ListTapePoolsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapePoolsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTapePoolsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTapePoolsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapePoolsOutputError>
}

public struct ListTapePoolsInput: Swift.Equatable {
    /// An optional number limit for the tape pools in the list returned by this call.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of tape
    ///          pools.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of each of the custom tape pools you want to list. If you
    ///          don't specify a custom tape pool ARN, the response lists all custom tape pools.
    public var poolARNs: [Swift.String]?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        poolARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.poolARNs = poolARNs
    }
}

struct ListTapePoolsInputBody: Swift.Equatable {
    public let poolARNs: [Swift.String]?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension ListTapePoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case poolARNs = "PoolARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .poolARNs)
        var poolARNsDecoded0:[Swift.String]? = nil
        if let poolARNsContainer = poolARNsContainer {
            poolARNsDecoded0 = [Swift.String]()
            for string0 in poolARNsContainer {
                if let string0 = string0 {
                    poolARNsDecoded0?.append(string0)
                }
            }
        }
        poolARNs = poolARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTapePoolsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTapePoolsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTapePoolsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTapePoolsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTapePoolsOutputResponse(marker: \(Swift.String(describing: marker)), poolInfos: \(Swift.String(describing: poolInfos)))"}
}

extension ListTapePoolsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTapePoolsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.poolInfos = output.poolInfos
        } else {
            self.marker = nil
            self.poolInfos = nil
        }
    }
}

public struct ListTapePoolsOutputResponse: Swift.Equatable {
    /// A string that indicates the position at which to begin the returned list of tape pools.
    ///          Use the marker in your next request to continue pagination of tape pools. If there are no
    ///          more tape pools to list, this element does not appear in the response body.
    public var marker: Swift.String?
    /// An array of PoolInfo objects, where each object describes a single custom
    ///          tape pool. If there are no custom tape pools, the PoolInfos is an empty array.
    ///
    public var poolInfos: [StorageGatewayClientTypes.PoolInfo]?

    public init (
        marker: Swift.String? = nil,
        poolInfos: [StorageGatewayClientTypes.PoolInfo]? = nil
    )
    {
        self.marker = marker
        self.poolInfos = poolInfos
    }
}

struct ListTapePoolsOutputResponseBody: Swift.Equatable {
    public let poolInfos: [StorageGatewayClientTypes.PoolInfo]?
    public let marker: Swift.String?
}

extension ListTapePoolsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case poolInfos = "PoolInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.PoolInfo?].self, forKey: .poolInfos)
        var poolInfosDecoded0:[StorageGatewayClientTypes.PoolInfo]? = nil
        if let poolInfosContainer = poolInfosContainer {
            poolInfosDecoded0 = [StorageGatewayClientTypes.PoolInfo]()
            for structure0 in poolInfosContainer {
                if let structure0 = structure0 {
                    poolInfosDecoded0?.append(structure0)
                }
            }
        }
        poolInfos = poolInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListTapesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapesOutputError>
}

extension ListTapesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTapesInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), tapeARNs: \(Swift.String(describing: tapeARNs)))"}
}

extension ListTapesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearns0 in tapeARNs {
                try tapeARNsContainer.encode(tapearns0)
            }
        }
    }
}

public struct ListTapesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapesOutputError>
}

public struct ListTapesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTapesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTapesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapesOutputError>
}

public struct ListTapesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTapesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTapesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTapesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTapesOutputError>
}

/// A JSON object that contains one or more of the following fields:
///
///
///
///
///                   ListTapesInput$Limit
///
///
///
///
///                   ListTapesInput$Marker
///
///
///
///
///                   ListTapesInput$TapeARNs
///
///
///
public struct ListTapesInput: Swift.Equatable {
    /// An optional number limit for the tapes in the list returned by this call.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of
    ///          tapes.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of each of the tapes you want to list. If you don't
    ///          specify a tape ARN, the response lists all tapes in both your VTL and VTS.
    public var tapeARNs: [Swift.String]?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct ListTapesInputBody: Swift.Equatable {
    public let tapeARNs: [Swift.String]?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension ListTapesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTapesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTapesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTapesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTapesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTapesOutputResponse(marker: \(Swift.String(describing: marker)), tapeInfos: \(Swift.String(describing: tapeInfos)))"}
}

extension ListTapesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTapesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.tapeInfos = output.tapeInfos
        } else {
            self.marker = nil
            self.tapeInfos = nil
        }
    }
}

/// A JSON object containing the following fields:
///
///
///
///
///                   ListTapesOutput$Marker
///
///
///
///
///                   ListTapesOutput$VolumeInfos
///
///
///
public struct ListTapesOutputResponse: Swift.Equatable {
    /// A string that indicates the position at which to begin returning the next list of tapes.
    ///          Use the marker in your next request to continue pagination of tapes. If there are no more
    ///          tapes to list, this element does not appear in the response body.
    public var marker: Swift.String?
    /// An array of TapeInfo objects, where each object describes a single
    ///          tape. If there are no tapes in the tape library or VTS, then the TapeInfos is
    ///          an empty array.
    public var tapeInfos: [StorageGatewayClientTypes.TapeInfo]?

    public init (
        marker: Swift.String? = nil,
        tapeInfos: [StorageGatewayClientTypes.TapeInfo]? = nil
    )
    {
        self.marker = marker
        self.tapeInfos = tapeInfos
    }
}

struct ListTapesOutputResponseBody: Swift.Equatable {
    public let tapeInfos: [StorageGatewayClientTypes.TapeInfo]?
    public let marker: Swift.String?
}

extension ListTapesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case tapeInfos = "TapeInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.TapeInfo?].self, forKey: .tapeInfos)
        var tapeInfosDecoded0:[StorageGatewayClientTypes.TapeInfo]? = nil
        if let tapeInfosContainer = tapeInfosContainer {
            tapeInfosDecoded0 = [StorageGatewayClientTypes.TapeInfo]()
            for structure0 in tapeInfosContainer {
                if let structure0 = structure0 {
                    tapeInfosDecoded0?.append(structure0)
                }
            }
        }
        tapeInfos = tapeInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListVolumeInitiatorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeInitiatorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumeInitiatorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumeInitiatorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeInitiatorsOutputError>
}

extension ListVolumeInitiatorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVolumeInitiatorsInput(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension ListVolumeInitiatorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct ListVolumeInitiatorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeInitiatorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumeInitiatorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumeInitiatorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeInitiatorsOutputError>
}

public struct ListVolumeInitiatorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeInitiatorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumeInitiatorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumeInitiatorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeInitiatorsOutputError>
}

public struct ListVolumeInitiatorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeInitiatorsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListVolumeInitiatorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVolumeInitiatorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeInitiatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeInitiatorsOutputError>
}

/// ListVolumeInitiatorsInput
public struct ListVolumeInitiatorsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes
    ///          operation to return a list of gateway volumes for the gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct ListVolumeInitiatorsInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension ListVolumeInitiatorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension ListVolumeInitiatorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumeInitiatorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVolumeInitiatorsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumeInitiatorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVolumeInitiatorsOutputResponse(initiators: \(Swift.String(describing: initiators)))"}
}

extension ListVolumeInitiatorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVolumeInitiatorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiators = output.initiators
        } else {
            self.initiators = nil
        }
    }
}

/// ListVolumeInitiatorsOutput
public struct ListVolumeInitiatorsOutputResponse: Swift.Equatable {
    /// The host names and port numbers of all iSCSI initiators that are connected to the
    ///          gateway.
    public var initiators: [Swift.String]?

    public init (
        initiators: [Swift.String]? = nil
    )
    {
        self.initiators = initiators
    }
}

struct ListVolumeInitiatorsOutputResponseBody: Swift.Equatable {
    public let initiators: [Swift.String]?
}

extension ListVolumeInitiatorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiators = "Initiators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .initiators)
        var initiatorsDecoded0:[Swift.String]? = nil
        if let initiatorsContainer = initiatorsContainer {
            initiatorsDecoded0 = [Swift.String]()
            for string0 in initiatorsContainer {
                if let string0 = string0 {
                    initiatorsDecoded0?.append(string0)
                }
            }
        }
        initiators = initiatorsDecoded0
    }
}

public struct ListVolumeRecoveryPointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeRecoveryPointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumeRecoveryPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumeRecoveryPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeRecoveryPointsOutputError>
}

extension ListVolumeRecoveryPointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVolumeRecoveryPointsInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ListVolumeRecoveryPointsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ListVolumeRecoveryPointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeRecoveryPointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumeRecoveryPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumeRecoveryPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeRecoveryPointsOutputError>
}

public struct ListVolumeRecoveryPointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeRecoveryPointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumeRecoveryPointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumeRecoveryPointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeRecoveryPointsOutputError>
}

public struct ListVolumeRecoveryPointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumeRecoveryPointsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListVolumeRecoveryPointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVolumeRecoveryPointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumeRecoveryPointsOutputError>
}

public struct ListVolumeRecoveryPointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListVolumeRecoveryPointsInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ListVolumeRecoveryPointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListVolumeRecoveryPointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumeRecoveryPointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVolumeRecoveryPointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumeRecoveryPointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVolumeRecoveryPointsOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)), volumeRecoveryPointInfos: \(Swift.String(describing: volumeRecoveryPointInfos)))"}
}

extension ListVolumeRecoveryPointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVolumeRecoveryPointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.volumeRecoveryPointInfos = output.volumeRecoveryPointInfos
        } else {
            self.gatewayARN = nil
            self.volumeRecoveryPointInfos = nil
        }
    }
}

public struct ListVolumeRecoveryPointsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// An array of VolumeRecoveryPointInfo objects.
    public var volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]?

    public init (
        gatewayARN: Swift.String? = nil,
        volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.volumeRecoveryPointInfos = volumeRecoveryPointInfos
    }
}

struct ListVolumeRecoveryPointsOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]?
}

extension ListVolumeRecoveryPointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case volumeRecoveryPointInfos = "VolumeRecoveryPointInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let volumeRecoveryPointInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.VolumeRecoveryPointInfo?].self, forKey: .volumeRecoveryPointInfos)
        var volumeRecoveryPointInfosDecoded0:[StorageGatewayClientTypes.VolumeRecoveryPointInfo]? = nil
        if let volumeRecoveryPointInfosContainer = volumeRecoveryPointInfosContainer {
            volumeRecoveryPointInfosDecoded0 = [StorageGatewayClientTypes.VolumeRecoveryPointInfo]()
            for structure0 in volumeRecoveryPointInfosContainer {
                if let structure0 = structure0 {
                    volumeRecoveryPointInfosDecoded0?.append(structure0)
                }
            }
        }
        volumeRecoveryPointInfos = volumeRecoveryPointInfosDecoded0
    }
}

public struct ListVolumesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumesOutputError>
}

extension ListVolumesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVolumesInput(gatewayARN: \(Swift.String(describing: gatewayARN)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)))"}
}

extension ListVolumesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListVolumesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumesOutputError>
}

public struct ListVolumesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumesOutputError>
}

public struct ListVolumesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVolumesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListVolumesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVolumesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVolumesOutputError>
}

/// A JSON object that contains one or more of the following fields:
///
///
///
///
///                   ListVolumesInput$Limit
///
///
///
///
///                   ListVolumesInput$Marker
///
///
///
public struct ListVolumesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// Specifies that the list of volumes returned be limited to the specified number of
    ///          items.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of volumes.
    ///          Obtain the marker from the response of a previous List iSCSI Volumes request.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListVolumesInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let marker: Swift.String?
    public let limit: Swift.Int?
}

extension ListVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListVolumesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVolumesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVolumesOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)), marker: \(Swift.String(describing: marker)), volumeInfos: \(Swift.String(describing: volumeInfos)))"}
}

extension ListVolumesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVolumesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.volumeInfos = output.volumeInfos
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.volumeInfos = nil
        }
    }
}

/// A JSON object containing the following fields:
///
///
///
///
///                   ListVolumesOutput$Marker
///
///
///
///
///                   ListVolumesOutput$VolumeInfos
///
///
///
public struct ListVolumesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// Use the marker in your next request to continue pagination of iSCSI volumes. If there
    ///          are no more volumes to list, this field does not appear in the response body.
    public var marker: Swift.String?
    /// An array of VolumeInfo objects, where each object describes an iSCSI
    ///          volume. If no volumes are defined for the gateway, then VolumeInfos is an
    ///          empty array "[]".
    public var volumeInfos: [StorageGatewayClientTypes.VolumeInfo]?

    public init (
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        volumeInfos: [StorageGatewayClientTypes.VolumeInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.volumeInfos = volumeInfos
    }
}

struct ListVolumesOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let marker: Swift.String?
    public let volumeInfos: [StorageGatewayClientTypes.VolumeInfo]?
}

extension ListVolumesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case volumeInfos = "VolumeInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let volumeInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.VolumeInfo?].self, forKey: .volumeInfos)
        var volumeInfosDecoded0:[StorageGatewayClientTypes.VolumeInfo]? = nil
        if let volumeInfosContainer = volumeInfosContainer {
            volumeInfosDecoded0 = [StorageGatewayClientTypes.VolumeInfo]()
            for structure0 in volumeInfosContainer {
                if let structure0 = structure0 {
                    volumeInfosDecoded0?.append(structure0)
                }
            }
        }
        volumeInfos = volumeInfosDecoded0
    }
}

extension StorageGatewayClientTypes.NFSFileShareDefaults: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryMode = "DirectoryMode"
        case fileMode = "FileMode"
        case groupId = "GroupId"
        case ownerId = "OwnerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryMode = directoryMode {
            try encodeContainer.encode(directoryMode, forKey: .directoryMode)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode, forKey: .fileMode)
        }
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let directoryModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryMode)
        directoryMode = directoryModeDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .groupId)
        groupId = groupIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
    }
}

extension StorageGatewayClientTypes.NFSFileShareDefaults: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NFSFileShareDefaults(directoryMode: \(Swift.String(describing: directoryMode)), fileMode: \(Swift.String(describing: fileMode)), groupId: \(Swift.String(describing: groupId)), ownerId: \(Swift.String(describing: ownerId)))"}
}

extension StorageGatewayClientTypes {
    /// Describes Network File System (NFS) file share default values. Files and folders stored
    ///          as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions
    ///          assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that
    ///          represent files and folders are assigned these default Unix permissions. This operation is
    ///          only supported for S3 File Gateways.
    public struct NFSFileShareDefaults: Swift.Equatable {
        /// The Unix directory mode in the form "nnnn". For example, 0666 represents
        ///          the default access mode for all directories inside the file share. The default value is
        ///             0777.
        public var directoryMode: Swift.String?
        /// The Unix file mode in the form "nnnn". For example, 0666 represents the
        ///          default file mode inside the file share. The default value is 0666.
        public var fileMode: Swift.String?
        /// The default group ID for the file share (unless the files have another group ID
        ///          specified). The default value is nfsnobody.
        public var groupId: Swift.Int?
        /// The default owner ID for files in the file share (unless the files have another owner ID
        ///          specified). The default value is nfsnobody.
        public var ownerId: Swift.Int?

        public init (
            directoryMode: Swift.String? = nil,
            fileMode: Swift.String? = nil,
            groupId: Swift.Int? = nil,
            ownerId: Swift.Int? = nil
        )
        {
            self.directoryMode = directoryMode
            self.fileMode = fileMode
            self.groupId = groupId
            self.ownerId = ownerId
        }
    }

}

extension StorageGatewayClientTypes.NFSFileShareInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareName = "FileShareName"
        case fileShareStatus = "FileShareStatus"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case path = "Path"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
        case vPCEndpointDNSName = "VPCEndpointDNSName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketRegion = bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for fileshareclientlist0 in clientList {
                try clientListContainer.encode(fileshareclientlist0)
            }
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let fileShareStatus = fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if kMSEncrypted != false {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let nFSFileShareDefaults = nFSFileShareDefaults {
            try encodeContainer.encode(nFSFileShareDefaults, forKey: .nFSFileShareDefaults)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let squash = squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vPCEndpointDNSName = vPCEndpointDNSName {
            try encodeContainer.encode(vPCEndpointDNSName, forKey: .vPCEndpointDNSName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nFSFileShareDefaultsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.NFSFileShareDefaults.self, forKey: .nFSFileShareDefaults)
        nFSFileShareDefaults = nFSFileShareDefaultsDecoded
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vPCEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCEndpointDNSName)
        vPCEndpointDNSName = vPCEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
    }
}

extension StorageGatewayClientTypes.NFSFileShareInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NFSFileShareInfo(bucketRegion: \(Swift.String(describing: bucketRegion)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), clientList: \(Swift.String(describing: clientList)), defaultStorageClass: \(Swift.String(describing: defaultStorageClass)), fileShareARN: \(Swift.String(describing: fileShareARN)), fileShareId: \(Swift.String(describing: fileShareId)), fileShareName: \(Swift.String(describing: fileShareName)), fileShareStatus: \(Swift.String(describing: fileShareStatus)), gatewayARN: \(Swift.String(describing: gatewayARN)), guessMIMETypeEnabled: \(Swift.String(describing: guessMIMETypeEnabled)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), locationARN: \(Swift.String(describing: locationARN)), nFSFileShareDefaults: \(Swift.String(describing: nFSFileShareDefaults)), notificationPolicy: \(Swift.String(describing: notificationPolicy)), objectACL: \(Swift.String(describing: objectACL)), path: \(Swift.String(describing: path)), readOnly: \(Swift.String(describing: readOnly)), requesterPays: \(Swift.String(describing: requesterPays)), role: \(Swift.String(describing: role)), squash: \(Swift.String(describing: squash)), tags: \(Swift.String(describing: tags)), vPCEndpointDNSName: \(Swift.String(describing: vPCEndpointDNSName)))"}
}

extension StorageGatewayClientTypes {
    /// The Unix file permissions and ownership information assigned, by default, to native S3
    ///          objects when an S3 File Gateway discovers them in S3 buckets. This operation is only supported in
    ///          S3 File Gateways.
    public struct NFSFileShareInfo: Swift.Equatable {
        /// Specifies the Region of the S3 bucket where the NFS file share stores files.
        ///
        ///             This parameter is required for NFS file shares that connect to Amazon S3
        ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a
        ///             VPC access point.
        ///
        public var bucketRegion: Swift.String?
        /// Refresh cache information for the file share.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// The list of clients that are allowed to access the S3 File Gateway. The list must contain
        ///          either valid IP addresses or valid CIDR blocks.
        public var clientList: [Swift.String]?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway.
        ///          The default value is S3_INTELLIGENT_TIERING. Optional.
        ///
        ///          Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING |
        ///             S3_STANDARD_IA | S3_ONEZONE_IA
        ///
        public var defaultStorageClass: Swift.String?
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The name of the file share. Optional.
        ///
        ///
        ///
        ///                FileShareName must be set if an S3 prefix name is set in
        ///                LocationARN.
        ///
        public var fileShareName: Swift.String?
        /// The status of the file share.
        ///
        ///          Valid Values: CREATING | UPDATING | AVAILABLE |
        ///             DELETING
        ///
        public var fileShareStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file
        ///          extensions. Set this value to true to enable MIME type guessing, otherwise set
        ///          to false. The default value is true.
        ///
        ///          Valid Values: true | false
        ///
        public var guessMIMETypeEnabled: Swift.Bool?
        /// Set to true to use Amazon S3 server-side encryption with your own KMS
        ///          key, or false to use a key managed by Amazon S3. Optional.
        ///
        ///          Valid Values: true | false
        ///
        public var kMSEncrypted: Swift.Bool
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        ///          only be set when KMSEncrypted is true. Optional.
        public var kMSKey: Swift.String?
        /// The ARN of the backend storage used for storing file data. A prefix name can be added to
        ///          the S3 bucket name. It must end with a "/".
        public var locationARN: Swift.String?
        /// Describes Network File System (NFS) file share default values. Files and folders stored
        ///          as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions
        ///          assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that
        ///          represent files and folders are assigned these default Unix permissions. This operation is
        ///          only supported for S3 File Gateways.
        public var nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
        /// The notification policy of the file share. SettlingTimeInSeconds controls
        ///          the number of seconds to wait after the last point in time a client wrote to a file before
        ///          generating an ObjectUploaded notification. Because clients can make many small
        ///          writes to files, it's best to set this parameter for as long as possible to avoid
        ///          generating multiple notifications for the same file in a small time period.
        ///
        ///
        ///
        ///                SettlingTimeInSeconds has no effect on the timing of the object
        ///             uploading to Amazon S3, only the timing of the notification.
        ///
        ///
        ///          The following example sets NotificationPolicy on with
        ///             SettlingTimeInSeconds set to 60.
        ///
        ///
        ///             {\"Upload\": {\"SettlingTimeInSeconds\": 60}}
        ///
        ///
        ///          The following example sets NotificationPolicy off.
        ///
        ///
        ///             {}
        ///
        public var notificationPolicy: Swift.String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket
        ///          that an S3 File Gateway puts objects into. The default value is private.
        public var objectACL: StorageGatewayClientTypes.ObjectACL?
        /// The file share path used by the NFS client to identify the mount point.
        public var path: Swift.String?
        /// A value that sets the write status of a file share. Set this value to true
        ///          to set the write status to read-only, otherwise set to false.
        ///
        ///          Valid Values: true | false
        ///
        public var readOnly: Swift.Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data
        ///          download from the S3 bucket. If this value is set to true, the requester pays
        ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
        ///          the cost of storing data.
        ///
        ///
        ///
        ///                RequesterPays is a configuration for the S3 bucket that backs the file
        ///             share, so make sure that the configuration on the file share is the same as the S3
        ///             bucket configuration.
        ///
        ///
        ///          Valid Values: true | false
        ///
        public var requesterPays: Swift.Bool?
        /// The ARN of the IAM role that an S3 File Gateway assumes when it accesses the underlying
        ///          storage.
        public var role: Swift.String?
        /// The user mapped to anonymous user. Valid options are the following:
        ///
        ///
        ///
        ///
        ///                   RootSquash: Only root is mapped to anonymous user.
        ///
        ///
        ///
        ///                   NoSquash: No one is mapped to anonymous user.
        ///
        ///
        ///
        ///                   AllSquash: Everyone is mapped to anonymous user.
        ///
        ///
        public var squash: Swift.String?
        /// A list of up to 50 tags assigned to the NFS file share, sorted alphabetically by key
        ///          name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can
        ///          view all tags using the ListTagsForResource API operation.
        public var tags: [StorageGatewayClientTypes.Tag]?
        /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to Amazon S3.
        ///
        ///             This parameter is required for NFS file shares that connect to Amazon S3
        ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a
        ///             VPC access point.
        ///
        public var vPCEndpointDNSName: Swift.String?

        public init (
            bucketRegion: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            clientList: [Swift.String]? = nil,
            defaultStorageClass: Swift.String? = nil,
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareName: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            guessMIMETypeEnabled: Swift.Bool? = nil,
            kMSEncrypted: Swift.Bool = false,
            kMSKey: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
            notificationPolicy: Swift.String? = nil,
            objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
            path: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            requesterPays: Swift.Bool? = nil,
            role: Swift.String? = nil,
            squash: Swift.String? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil,
            vPCEndpointDNSName: Swift.String? = nil
        )
        {
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.defaultStorageClass = defaultStorageClass
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kMSEncrypted = kMSEncrypted
            self.kMSKey = kMSKey
            self.locationARN = locationARN
            self.nFSFileShareDefaults = nFSFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.squash = squash
            self.tags = tags
            self.vPCEndpointDNSName = vPCEndpointDNSName
        }
    }

}

extension StorageGatewayClientTypes.NetworkInterface: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv4Address = "Ipv4Address"
        case ipv6Address = "Ipv6Address"
        case macAddress = "MacAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv4Address = ipv4Address {
            try encodeContainer.encode(ipv4Address, forKey: .ipv4Address)
        }
        if let ipv6Address = ipv6Address {
            try encodeContainer.encode(ipv6Address, forKey: .ipv6Address)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv4AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv4Address)
        ipv4Address = ipv4AddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipv6AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6Address)
        ipv6Address = ipv6AddressDecoded
    }
}

extension StorageGatewayClientTypes.NetworkInterface: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkInterface(ipv4Address: \(Swift.String(describing: ipv4Address)), ipv6Address: \(Swift.String(describing: ipv6Address)), macAddress: \(Swift.String(describing: macAddress)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a gateway's network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The Internet Protocol version 4 (IPv4) address of the interface.
        public var ipv4Address: Swift.String?
        /// The Internet Protocol version 6 (IPv6) address of the interface. Currently not
        ///             supported.
        public var ipv6Address: Swift.String?
        /// The Media Access Control (MAC) address of the interface.
        ///
        ///
        ///             This is currently unsupported and will not be returned in output.
        ///
        public var macAddress: Swift.String?

        public init (
            ipv4Address: Swift.String? = nil,
            ipv6Address: Swift.String? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ipv4Address = ipv4Address
            self.ipv6Address = ipv6Address
            self.macAddress = macAddress
        }
    }

}

public struct NotifyWhenUploadedInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyWhenUploadedInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyWhenUploadedInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyWhenUploadedInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyWhenUploadedOutputError>
}

extension NotifyWhenUploadedInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyWhenUploadedInput(fileShareARN: \(Swift.String(describing: fileShareARN)))"}
}

extension NotifyWhenUploadedInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
    }
}

public struct NotifyWhenUploadedInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyWhenUploadedInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyWhenUploadedInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyWhenUploadedInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyWhenUploadedOutputError>
}

public struct NotifyWhenUploadedInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyWhenUploadedInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyWhenUploadedInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyWhenUploadedInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyWhenUploadedOutputError>
}

public struct NotifyWhenUploadedInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyWhenUploadedInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: NotifyWhenUploadedInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyWhenUploadedInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyWhenUploadedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyWhenUploadedOutputError>
}

public struct NotifyWhenUploadedInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share.
    /// This member is required.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct NotifyWhenUploadedInputBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
}

extension NotifyWhenUploadedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension NotifyWhenUploadedOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyWhenUploadedOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyWhenUploadedOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyWhenUploadedOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyWhenUploadedOutputResponse(fileShareARN: \(Swift.String(describing: fileShareARN)), notificationId: \(Swift.String(describing: notificationId)))"}
}

extension NotifyWhenUploadedOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotifyWhenUploadedOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
            self.notificationId = output.notificationId
        } else {
            self.fileShareARN = nil
            self.notificationId = nil
        }
    }
}

public struct NotifyWhenUploadedOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share.
    public var fileShareARN: Swift.String?
    /// The randomly generated ID of the notification that was sent. This ID is in UUID
    ///          format.
    public var notificationId: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil,
        notificationId: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

struct NotifyWhenUploadedOutputResponseBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
    public let notificationId: Swift.String?
}

extension NotifyWhenUploadedOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case notificationId = "NotificationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let notificationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationId)
        notificationId = notificationIdDecoded
    }
}

extension StorageGatewayClientTypes {
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that an S3 File Gateway puts objects into. The default value is private.
    public enum ObjectACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectACL] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectACL(rawValue: rawValue) ?? ObjectACL.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.PoolInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
        case poolName = "PoolName"
        case poolStatus = "PoolStatus"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolARN = poolARN {
            try encodeContainer.encode(poolARN, forKey: .poolARN)
        }
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let poolStatus = poolStatus {
            try encodeContainer.encode(poolStatus.rawValue, forKey: .poolStatus)
        }
        if let retentionLockTimeInDays = retentionLockTimeInDays {
            try encodeContainer.encode(retentionLockTimeInDays, forKey: .retentionLockTimeInDays)
        }
        if let retentionLockType = retentionLockType {
            try encodeContainer.encode(retentionLockType.rawValue, forKey: .retentionLockType)
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.TapeStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let retentionLockTypeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.RetentionLockType.self, forKey: .retentionLockType)
        retentionLockType = retentionLockTypeDecoded
        let retentionLockTimeInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionLockTimeInDays)
        retentionLockTimeInDays = retentionLockTimeInDaysDecoded
        let poolStatusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.PoolStatus.self, forKey: .poolStatus)
        poolStatus = poolStatusDecoded
    }
}

extension StorageGatewayClientTypes.PoolInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PoolInfo(poolARN: \(Swift.String(describing: poolARN)), poolName: \(Swift.String(describing: poolName)), poolStatus: \(Swift.String(describing: poolStatus)), retentionLockTimeInDays: \(Swift.String(describing: retentionLockTimeInDays)), retentionLockType: \(Swift.String(describing: retentionLockType)), storageClass: \(Swift.String(describing: storageClass)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a custom tape pool.
    public struct PoolInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom tape pool. Use the ListTapePools operation to return a list of custom tape pools for your
        ///          account and Region.
        public var poolARN: Swift.String?
        /// The name of the custom tape pool. PoolName can use all ASCII characters,
        ///          except '/' and '\'.
        public var poolName: Swift.String?
        /// Status of the custom tape pool. Pool can be ACTIVE or
        ///          DELETED.
        public var poolStatus: StorageGatewayClientTypes.PoolStatus?
        /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to
        ///          100 years (36,500 days).
        public var retentionLockTimeInDays: Swift.Int?
        /// Tape retention lock type, which can be configured in two modes. When configured in
        ///          governance mode, accounts with specific IAM permissions are authorized to remove the
        ///          tape retention lock from archived virtual tapes. When configured in compliance mode, the
        ///          tape retention lock cannot be removed by any user, including the root account.
        public var retentionLockType: StorageGatewayClientTypes.RetentionLockType?
        /// The storage class that is associated with the custom pool. When you use your backup
        ///          application to eject the tape, the tape is archived directly into the storage class (S3
        ///          Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public var storageClass: StorageGatewayClientTypes.TapeStorageClass?

        public init (
            poolARN: Swift.String? = nil,
            poolName: Swift.String? = nil,
            poolStatus: StorageGatewayClientTypes.PoolStatus? = nil,
            retentionLockTimeInDays: Swift.Int? = nil,
            retentionLockType: StorageGatewayClientTypes.RetentionLockType? = nil,
            storageClass: StorageGatewayClientTypes.TapeStorageClass? = nil
        )
        {
            self.poolARN = poolARN
            self.poolName = poolName
            self.poolStatus = poolStatus
            self.retentionLockTimeInDays = retentionLockTimeInDays
            self.retentionLockType = retentionLockType
            self.storageClass = storageClass
        }
    }

}

extension StorageGatewayClientTypes {
    public enum PoolStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolStatus] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolStatus(rawValue: rawValue) ?? PoolStatus.sdkUnknown(rawValue)
        }
    }
}

public struct RefreshCacheInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshCacheOutputError>
}

extension RefreshCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshCacheInput(fileShareARN: \(Swift.String(describing: fileShareARN)), folderList: \(Swift.String(describing: folderList)), recursive: \(Swift.String(describing: recursive)))"}
}

extension RefreshCacheInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case folderList = "FolderList"
        case recursive = "Recursive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let folderList = folderList {
            var folderListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderList)
            for folderlist0 in folderList {
                try folderListContainer.encode(folderlist0)
            }
        }
        if let recursive = recursive {
            try encodeContainer.encode(recursive, forKey: .recursive)
        }
    }
}

public struct RefreshCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshCacheOutputError>
}

public struct RefreshCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshCacheOutputError>
}

public struct RefreshCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RefreshCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RefreshCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshCacheOutputError>
}

/// RefreshCacheInput
public struct RefreshCacheInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share you want to refresh.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// A comma-separated list of the paths of folders to refresh in the cache. The default is
    ///             ["/"]. The default refreshes objects and folders at the root of the Amazon S3 bucket. If Recursive is set to true, the entire S3 bucket that
    ///          the file share has access to is refreshed.
    public var folderList: [Swift.String]?
    /// A value that specifies whether to recursively refresh folders in the cache. The refresh
    ///          includes folders that were in the cache the last time the gateway listed the folder's
    ///          contents. If this value set to true, each folder that is listed in
    ///             FolderList is recursively updated. Otherwise, subfolders listed in
    ///             FolderList are not refreshed. Only objects that are in folders listed
    ///          directly under FolderList are found and used for the update. The default is
    ///             true.
    ///
    ///          Valid Values: true | false
    ///
    public var recursive: Swift.Bool?

    public init (
        fileShareARN: Swift.String? = nil,
        folderList: [Swift.String]? = nil,
        recursive: Swift.Bool? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.folderList = folderList
        self.recursive = recursive
    }
}

struct RefreshCacheInputBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
    public let folderList: [Swift.String]?
    public let recursive: Swift.Bool?
}

extension RefreshCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case folderList = "FolderList"
        case recursive = "Recursive"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let folderListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .folderList)
        var folderListDecoded0:[Swift.String]? = nil
        if let folderListContainer = folderListContainer {
            folderListDecoded0 = [Swift.String]()
            for string0 in folderListContainer {
                if let string0 = string0 {
                    folderListDecoded0?.append(string0)
                }
            }
        }
        folderList = folderListDecoded0
        let recursiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recursive)
        recursive = recursiveDecoded
    }
}

extension RefreshCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshCacheOutputResponse(fileShareARN: \(Swift.String(describing: fileShareARN)), notificationId: \(Swift.String(describing: notificationId)))"}
}

extension RefreshCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RefreshCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
            self.notificationId = output.notificationId
        } else {
            self.fileShareARN = nil
            self.notificationId = nil
        }
    }
}

/// RefreshCacheOutput
public struct RefreshCacheOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share.
    public var fileShareARN: Swift.String?
    /// The randomly generated ID of the notification that was sent. This ID is in UUID
    ///          format.
    public var notificationId: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil,
        notificationId: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

struct RefreshCacheOutputResponseBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
    public let notificationId: Swift.String?
}

extension RefreshCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case notificationId = "NotificationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let notificationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationId)
        notificationId = notificationIdDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveTagsFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveTagsFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

/// RemoveTagsFromResourceInput
public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to remove the tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags you want to remove from the specified resource. A tag is composed
    ///          of a key-value pair.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceOutputResponse(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveTagsFromResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

/// RemoveTagsFromResourceOutput
public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that the tags were removed from.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

public struct ResetCacheInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetCacheOutputError>
}

extension ResetCacheInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetCacheInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ResetCacheInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ResetCacheInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetCacheOutputError>
}

public struct ResetCacheInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetCacheInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetCacheInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetCacheOutputError>
}

public struct ResetCacheInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetCacheInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ResetCacheInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetCacheInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetCacheOutputError>
}

public struct ResetCacheInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ResetCacheInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ResetCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ResetCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetCacheOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetCacheOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ResetCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct ResetCacheOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ResetCacheOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ResetCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes {
    public enum RetentionLockType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionLockType] {
            return [
                .compliance,
                .governance,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionLockType(rawValue: rawValue) ?? RetentionLockType.sdkUnknown(rawValue)
        }
    }
}

public struct RetrieveTapeArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetrieveTapeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetrieveTapeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeArchiveOutputError>
}

extension RetrieveTapeArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveTapeArchiveInput(gatewayARN: \(Swift.String(describing: gatewayARN)), tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension RetrieveTapeArchiveInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct RetrieveTapeArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetrieveTapeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetrieveTapeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeArchiveOutputError>
}

public struct RetrieveTapeArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetrieveTapeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetrieveTapeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeArchiveOutputError>
}

public struct RetrieveTapeArchiveInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeArchiveInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RetrieveTapeArchiveInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RetrieveTapeArchiveInput
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeArchiveOutputError>
}

/// RetrieveTapeArchiveInput
public struct RetrieveTapeArchiveInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you want to retrieve the virtual tape to.
    ///          Use the ListGateways operation to return a list of gateways for your
    ///          account and Region.
    ///
    ///          You retrieve archived virtual tapes to only one gateway and the gateway must be a tape
    ///          gateway.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to retrieve from the virtual
    ///          tape shelf (VTS).
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeArchiveInputBody: Swift.Equatable {
    public let tapeARN: Swift.String?
    public let gatewayARN: Swift.String?
}

extension RetrieveTapeArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension RetrieveTapeArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveTapeArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetrieveTapeArchiveOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveTapeArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveTapeArchiveOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension RetrieveTapeArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RetrieveTapeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// RetrieveTapeArchiveOutput
public struct RetrieveTapeArchiveOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retrieved virtual tape.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeArchiveOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension RetrieveTapeArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct RetrieveTapeRecoveryPointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeRecoveryPointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetrieveTapeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetrieveTapeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeRecoveryPointOutputError>
}

extension RetrieveTapeRecoveryPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveTapeRecoveryPointInput(gatewayARN: \(Swift.String(describing: gatewayARN)), tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension RetrieveTapeRecoveryPointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct RetrieveTapeRecoveryPointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetrieveTapeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetrieveTapeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeRecoveryPointOutputError>
}

public struct RetrieveTapeRecoveryPointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetrieveTapeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetrieveTapeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeRecoveryPointOutputError>
}

public struct RetrieveTapeRecoveryPointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetrieveTapeRecoveryPointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RetrieveTapeRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RetrieveTapeRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<RetrieveTapeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetrieveTapeRecoveryPointOutputError>
}

/// RetrieveTapeRecoveryPointInput
public struct RetrieveTapeRecoveryPointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape for which you want to retrieve the
    ///          recovery point.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeRecoveryPointInputBody: Swift.Equatable {
    public let tapeARN: Swift.String?
    public let gatewayARN: Swift.String?
}

extension RetrieveTapeRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension RetrieveTapeRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveTapeRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetrieveTapeRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveTapeRecoveryPointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveTapeRecoveryPointOutputResponse(tapeARN: \(Swift.String(describing: tapeARN)))"}
}

extension RetrieveTapeRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RetrieveTapeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// RetrieveTapeRecoveryPointOutput
public struct RetrieveTapeRecoveryPointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape for which the recovery point was
    ///          retrieved.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeRecoveryPointOutputResponseBody: Swift.Equatable {
    public let tapeARN: Swift.String?
}

extension RetrieveTapeRecoveryPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension StorageGatewayClientTypes.SMBFileShareInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareName = "FileShareName"
        case fileShareStatus = "FileShareStatus"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case path = "Path"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case sMBACLEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case vPCEndpointDNSName = "VPCEndpointDNSName"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlist0 in adminUserList {
                try adminUserListContainer.encode(userlist0)
            }
        }
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let authentication = authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let bucketRegion = bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let fileShareStatus = fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlist0 in invalidUserList {
                try invalidUserListContainer.encode(userlist0)
            }
        }
        if kMSEncrypted != false {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let oplocksEnabled = oplocksEnabled {
            try encodeContainer.encode(oplocksEnabled, forKey: .oplocksEnabled)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sMBACLEnabled = sMBACLEnabled {
            try encodeContainer.encode(sMBACLEnabled, forKey: .sMBACLEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vPCEndpointDNSName = vPCEndpointDNSName {
            try encodeContainer.encode(vPCEndpointDNSName, forKey: .vPCEndpointDNSName)
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlist0 in validUserList {
                try validUserListContainer.encode(userlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let sMBACLEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sMBACLEnabled)
        sMBACLEnabled = sMBACLEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[Swift.String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [Swift.String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validUserList)
        var validUserListDecoded0:[Swift.String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [Swift.String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[Swift.String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [Swift.String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vPCEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCEndpointDNSName)
        vPCEndpointDNSName = vPCEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
        let oplocksEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .oplocksEnabled)
        oplocksEnabled = oplocksEnabledDecoded
    }
}

extension StorageGatewayClientTypes.SMBFileShareInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SMBFileShareInfo(accessBasedEnumeration: \(Swift.String(describing: accessBasedEnumeration)), adminUserList: \(Swift.String(describing: adminUserList)), auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), authentication: \(Swift.String(describing: authentication)), bucketRegion: \(Swift.String(describing: bucketRegion)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), caseSensitivity: \(Swift.String(describing: caseSensitivity)), defaultStorageClass: \(Swift.String(describing: defaultStorageClass)), fileShareARN: \(Swift.String(describing: fileShareARN)), fileShareId: \(Swift.String(describing: fileShareId)), fileShareName: \(Swift.String(describing: fileShareName)), fileShareStatus: \(Swift.String(describing: fileShareStatus)), gatewayARN: \(Swift.String(describing: gatewayARN)), guessMIMETypeEnabled: \(Swift.String(describing: guessMIMETypeEnabled)), invalidUserList: \(Swift.String(describing: invalidUserList)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), locationARN: \(Swift.String(describing: locationARN)), notificationPolicy: \(Swift.String(describing: notificationPolicy)), objectACL: \(Swift.String(describing: objectACL)), oplocksEnabled: \(Swift.String(describing: oplocksEnabled)), path: \(Swift.String(describing: path)), readOnly: \(Swift.String(describing: readOnly)), requesterPays: \(Swift.String(describing: requesterPays)), role: \(Swift.String(describing: role)), sMBACLEnabled: \(Swift.String(describing: sMBACLEnabled)), tags: \(Swift.String(describing: tags)), vPCEndpointDNSName: \(Swift.String(describing: vPCEndpointDNSName)), validUserList: \(Swift.String(describing: validUserList)))"}
}

extension StorageGatewayClientTypes {
    /// The Windows file permissions and ownership information assigned, by default, to native
    ///          S3 objects when S3 File Gateway discovers them in S3 buckets. This operation is only supported
    ///          for S3 File Gateways.
    public struct SMBFileShareInfo: Swift.Equatable {
        /// Indicates whether AccessBasedEnumeration is enabled.
        public var accessBasedEnumeration: Swift.Bool?
        /// A list of users or groups in the Active Directory that have administrator rights to the
        ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
        ///             DOMAIN\User1, user1, @group1, and
        ///             @DOMAIN\group1. Can only be set if Authentication is set to
        ///             ActiveDirectory.
        public var adminUserList: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public var auditDestinationARN: Swift.String?
        /// The authentication method of the file share. The default is
        ///          ActiveDirectory.
        ///
        ///          Valid Values: ActiveDirectory | GuestAccess
        ///
        public var authentication: Swift.String?
        /// Specifies the Region of the S3 bucket where the SMB file share stores files.
        ///
        ///             This parameter is required for SMB file shares that connect to Amazon S3
        ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        ///
        public var bucketRegion: Swift.String?
        /// Refresh cache information for the file share.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the
        ///          client determines the case sensitivity. For CaseSensitive, the gateway
        ///          determines the case sensitivity. The default value is ClientSpecified.
        public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway.
        ///          The default value is S3_INTELLIGENT_TIERING. Optional.
        ///
        ///          Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING |
        ///             S3_STANDARD_IA | S3_ONEZONE_IA
        ///
        public var defaultStorageClass: Swift.String?
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The name of the file share. Optional.
        ///
        ///
        ///
        ///                FileShareName must be set if an S3 prefix name is set in
        ///                LocationARN.
        ///
        public var fileShareName: Swift.String?
        /// The status of the file share.
        ///
        ///          Valid Values: CREATING | UPDATING | AVAILABLE |
        ///             DELETING
        ///
        public var fileShareStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file
        ///          extensions. Set this value to true to enable MIME type guessing, otherwise set
        ///          to false. The default value is true.
        ///
        ///          Valid Values: true | false
        ///
        public var guessMIMETypeEnabled: Swift.Bool?
        /// A list of users or groups in the Active Directory that are not allowed to access the
        ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
        ///             DOMAIN\User1, user1, @group1, and
        ///             @DOMAIN\group1. Can only be set if Authentication is set to
        ///             ActiveDirectory.
        public var invalidUserList: [Swift.String]?
        /// Set to true to use Amazon S3 server-side encryption with your own KMS
        ///          key, or false to use a key managed by Amazon S3. Optional.
        ///
        ///          Valid Values: true | false
        ///
        public var kMSEncrypted: Swift.Bool
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        ///          only be set when KMSEncrypted is true. Optional.
        public var kMSKey: Swift.String?
        /// The ARN of the backend storage used for storing file data. A prefix name can be added to
        ///          the S3 bucket name. It must end with a "/".
        public var locationARN: Swift.String?
        /// The notification policy of the file share. SettlingTimeInSeconds controls
        ///          the number of seconds to wait after the last point in time a client wrote to a file before
        ///          generating an ObjectUploaded notification. Because clients can make many small
        ///          writes to files, it's best to set this parameter for as long as possible to avoid
        ///          generating multiple notifications for the same file in a small time period.
        ///
        ///
        ///
        ///                SettlingTimeInSeconds has no effect on the timing of the object
        ///             uploading to Amazon S3, only the timing of the notification.
        ///
        ///
        ///          The following example sets NotificationPolicy on with
        ///             SettlingTimeInSeconds set to 60.
        ///
        ///
        ///             {\"Upload\": {\"SettlingTimeInSeconds\": 60}}
        ///
        ///
        ///          The following example sets NotificationPolicy off.
        ///
        ///
        ///             {}
        ///
        public var notificationPolicy: Swift.String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket
        ///          that an S3 File Gateway puts objects into. The default value is private.
        public var objectACL: StorageGatewayClientTypes.ObjectACL?
        /// Specifies whether opportunistic locking is enabled for the SMB file share.
        ///
        ///             Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve
        ///             access to files with the same name in different case.
        ///
        ///          Valid Values: true | false
        ///
        public var oplocksEnabled: Swift.Bool?
        /// The file share path used by the SMB client to identify the mount point.
        public var path: Swift.String?
        /// A value that sets the write status of a file share. Set this value to true
        ///          to set the write status to read-only, otherwise set to false.
        ///
        ///          Valid Values: true | false
        ///
        public var readOnly: Swift.Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data
        ///          download from the S3 bucket. If this value is set to true, the requester pays
        ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
        ///          the cost of storing data.
        ///
        ///
        ///
        ///                RequesterPays is a configuration for the S3 bucket that backs the file
        ///             share, so make sure that the configuration on the file share is the same as the S3
        ///             bucket configuration.
        ///
        ///
        ///          Valid Values: true | false
        ///
        public var requesterPays: Swift.Bool?
        /// The ARN of the IAM role that an S3 File Gateway assumes when it accesses the underlying
        ///          storage.
        public var role: Swift.String?
        /// If this value is set to true, it indicates that access control list (ACL)
        ///          is enabled on the SMB file share. If it is set to false, it indicates that
        ///          file and directory permissions are mapped to the POSIX permission.
        ///
        ///
        ///
        ///          For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
        ///             control access to an SMB file share in the Storage Gateway User
        ///             Guide.
        public var sMBACLEnabled: Swift.Bool?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key
        ///          name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can
        ///          view all tags using the ListTagsForResource API operation.
        public var tags: [StorageGatewayClientTypes.Tag]?
        /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3.
        ///
        ///             This parameter is required for SMB file shares that connect to Amazon S3
        ///             through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        ///
        public var vPCEndpointDNSName: Swift.String?
        /// A list of users or groups in the Active Directory that are allowed to access the file
        ///          share. A group must be prefixed with the @ character. Acceptable formats include:
        ///             DOMAIN\User1, user1, @group1, and
        ///             @DOMAIN\group1. Can only be set if Authentication is set to
        ///             ActiveDirectory.
        public var validUserList: [Swift.String]?

        public init (
            accessBasedEnumeration: Swift.Bool? = nil,
            adminUserList: [Swift.String]? = nil,
            auditDestinationARN: Swift.String? = nil,
            authentication: Swift.String? = nil,
            bucketRegion: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
            defaultStorageClass: Swift.String? = nil,
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareName: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            guessMIMETypeEnabled: Swift.Bool? = nil,
            invalidUserList: [Swift.String]? = nil,
            kMSEncrypted: Swift.Bool = false,
            kMSKey: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            notificationPolicy: Swift.String? = nil,
            objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
            oplocksEnabled: Swift.Bool? = nil,
            path: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            requesterPays: Swift.Bool? = nil,
            role: Swift.String? = nil,
            sMBACLEnabled: Swift.Bool? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil,
            vPCEndpointDNSName: Swift.String? = nil,
            validUserList: [Swift.String]? = nil
        )
        {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.authentication = authentication
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.defaultStorageClass = defaultStorageClass
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kMSEncrypted = kMSEncrypted
            self.kMSKey = kMSKey
            self.locationARN = locationARN
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.sMBACLEnabled = sMBACLEnabled
            self.tags = tags
            self.vPCEndpointDNSName = vPCEndpointDNSName
            self.validUserList = validUserList
        }
    }

}

extension StorageGatewayClientTypes {
    public enum SMBSecurityStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clientspecified
        case mandatoryencryption
        case mandatorysigning
        case sdkUnknown(Swift.String)

        public static var allCases: [SMBSecurityStrategy] {
            return [
                .clientspecified,
                .mandatoryencryption,
                .mandatorysigning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientspecified: return "ClientSpecified"
            case .mandatoryencryption: return "MandatoryEncryption"
            case .mandatorysigning: return "MandatorySigning"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SMBSecurityStrategy(rawValue: rawValue) ?? SMBSecurityStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableError(error: \(Swift.String(describing: error)), message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableErrorBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error has occurred because the service is unavailable. For more
///          information, see the error and message fields.
public struct ServiceUnavailableError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A StorageGatewayError that provides more information about the cause
    ///          of the error.
    public var error: StorageGatewayClientTypes.StorageGatewayError?
    /// A human-readable message describing the error that occurred.
    public var message: Swift.String?

    public init (
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct ServiceUnavailableErrorBody: Swift.Equatable {
    public let message: Swift.String?
    public let error: StorageGatewayClientTypes.StorageGatewayError?
}

extension ServiceUnavailableErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

public struct SetLocalConsolePasswordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLocalConsolePasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetLocalConsolePasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetLocalConsolePasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLocalConsolePasswordOutputError>
}

extension SetLocalConsolePasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetLocalConsolePasswordInput(gatewayARN: \(Swift.String(describing: gatewayARN)), localConsolePassword: \(Swift.String(describing: localConsolePassword)))"}
}

extension SetLocalConsolePasswordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case localConsolePassword = "LocalConsolePassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let localConsolePassword = localConsolePassword {
            try encodeContainer.encode(localConsolePassword, forKey: .localConsolePassword)
        }
    }
}

public struct SetLocalConsolePasswordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLocalConsolePasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetLocalConsolePasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetLocalConsolePasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLocalConsolePasswordOutputError>
}

public struct SetLocalConsolePasswordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLocalConsolePasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetLocalConsolePasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetLocalConsolePasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLocalConsolePasswordOutputError>
}

public struct SetLocalConsolePasswordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLocalConsolePasswordInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SetLocalConsolePasswordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetLocalConsolePasswordInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetLocalConsolePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLocalConsolePasswordOutputError>
}

/// SetLocalConsolePasswordInput
public struct SetLocalConsolePasswordInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The password you want to set for your VM local console.
    /// This member is required.
    public var localConsolePassword: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        localConsolePassword: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.localConsolePassword = localConsolePassword
    }
}

struct SetLocalConsolePasswordInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let localConsolePassword: Swift.String?
}

extension SetLocalConsolePasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case localConsolePassword = "LocalConsolePassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let localConsolePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localConsolePassword)
        localConsolePassword = localConsolePasswordDecoded
    }
}

extension SetLocalConsolePasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetLocalConsolePasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLocalConsolePasswordOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLocalConsolePasswordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetLocalConsolePasswordOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension SetLocalConsolePasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetLocalConsolePasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct SetLocalConsolePasswordOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct SetLocalConsolePasswordOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension SetLocalConsolePasswordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct SetSMBGuestPasswordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSMBGuestPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSMBGuestPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSMBGuestPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSMBGuestPasswordOutputError>
}

extension SetSMBGuestPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSMBGuestPasswordInput(gatewayARN: \(Swift.String(describing: gatewayARN)), password: \(Swift.String(describing: password)))"}
}

extension SetSMBGuestPasswordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case password = "Password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct SetSMBGuestPasswordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSMBGuestPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSMBGuestPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSMBGuestPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSMBGuestPasswordOutputError>
}

public struct SetSMBGuestPasswordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSMBGuestPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSMBGuestPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSMBGuestPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSMBGuestPasswordOutputError>
}

public struct SetSMBGuestPasswordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSMBGuestPasswordInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SetSMBGuestPasswordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetSMBGuestPasswordInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetSMBGuestPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSMBGuestPasswordOutputError>
}

/// SetSMBGuestPasswordInput
public struct SetSMBGuestPasswordInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 File Gateway the SMB file share is associated
    ///          with.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The password that you want to set for your SMB server.
    /// This member is required.
    public var password: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.password = password
    }
}

struct SetSMBGuestPasswordInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let password: Swift.String?
}

extension SetSMBGuestPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case password = "Password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension SetSMBGuestPasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetSMBGuestPasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSMBGuestPasswordOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSMBGuestPasswordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSMBGuestPasswordOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension SetSMBGuestPasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetSMBGuestPasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct SetSMBGuestPasswordOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct SetSMBGuestPasswordOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension SetSMBGuestPasswordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct ShutdownGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ShutdownGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ShutdownGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ShutdownGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ShutdownGatewayOutputError>
}

extension ShutdownGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShutdownGatewayInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ShutdownGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ShutdownGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ShutdownGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ShutdownGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ShutdownGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ShutdownGatewayOutputError>
}

public struct ShutdownGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ShutdownGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ShutdownGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ShutdownGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ShutdownGatewayOutputError>
}

public struct ShutdownGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ShutdownGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ShutdownGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ShutdownGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<ShutdownGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ShutdownGatewayOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to shut
///          down.
public struct ShutdownGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ShutdownGatewayInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ShutdownGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ShutdownGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ShutdownGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ShutdownGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ShutdownGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShutdownGatewayOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension ShutdownGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ShutdownGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was shut
///          down.
public struct ShutdownGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ShutdownGatewayOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension ShutdownGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct StartAvailabilityMonitorTestInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAvailabilityMonitorTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAvailabilityMonitorTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAvailabilityMonitorTestOutputError>
}

extension StartAvailabilityMonitorTestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAvailabilityMonitorTestInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension StartAvailabilityMonitorTestInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct StartAvailabilityMonitorTestInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAvailabilityMonitorTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAvailabilityMonitorTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAvailabilityMonitorTestOutputError>
}

public struct StartAvailabilityMonitorTestInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAvailabilityMonitorTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAvailabilityMonitorTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAvailabilityMonitorTestOutputError>
}

public struct StartAvailabilityMonitorTestInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAvailabilityMonitorTestInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartAvailabilityMonitorTestInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAvailabilityMonitorTestInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAvailabilityMonitorTestOutputError>
}

public struct StartAvailabilityMonitorTestInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartAvailabilityMonitorTestInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension StartAvailabilityMonitorTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartAvailabilityMonitorTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAvailabilityMonitorTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAvailabilityMonitorTestOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAvailabilityMonitorTestOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAvailabilityMonitorTestOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension StartAvailabilityMonitorTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAvailabilityMonitorTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct StartAvailabilityMonitorTestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartAvailabilityMonitorTestOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension StartAvailabilityMonitorTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct StartGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartGatewayOutputError>
}

extension StartGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartGatewayInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension StartGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct StartGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartGatewayOutputError>
}

public struct StartGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartGatewayOutputError>
}

public struct StartGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartGatewayOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to start.
public struct StartGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartGatewayInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension StartGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartGatewayOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension StartGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was
///          restarted.
public struct StartGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartGatewayOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension StartGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes.StorageGatewayError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorDetails = errorDetails {
            var errorDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .errorDetails)
            for (dictKey0, errordetails0) in errorDetails {
                try errorDetailsContainer.encode(errordetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .errorDetails)
        var errorDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in errorDetailsContainer {
                if let string0 = string0 {
                    errorDetailsDecoded0?[key0] = string0
                }
            }
        }
        errorDetails = errorDetailsDecoded0
    }
}

extension StorageGatewayClientTypes.StorageGatewayError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageGatewayError(errorCode: \(Swift.String(describing: errorCode)), errorDetails: \(Swift.String(describing: errorDetails)))"}
}

extension StorageGatewayClientTypes {
    /// Provides additional information about an error that was returned by the service. See the
    ///             errorCode and errorDetails members for more information about
    ///          the error.
    public struct StorageGatewayError: Swift.Equatable {
        /// Additional information about the error.
        public var errorCode: StorageGatewayClientTypes.ErrorCode?
        /// Human-readable text that provides detail about the error that occurred.
        public var errorDetails: [Swift.String:Swift.String]?

        public init (
            errorCode: StorageGatewayClientTypes.ErrorCode? = nil,
            errorDetails: [Swift.String:Swift.String]? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
        }
    }

}

extension StorageGatewayClientTypes.StorediSCSIVolume: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case kMSKey = "KMSKey"
        case preservedExistingData = "PreservedExistingData"
        case sourceSnapshotId = "SourceSnapshotId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeDiskId = "VolumeDiskId"
        case volumeId = "VolumeId"
        case volumeProgress = "VolumeProgress"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeStatus = "VolumeStatus"
        case volumeType = "VolumeType"
        case volumeUsedInBytes = "VolumeUsedInBytes"
        case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if preservedExistingData != false {
            try encodeContainer.encode(preservedExistingData, forKey: .preservedExistingData)
        }
        if let sourceSnapshotId = sourceSnapshotId {
            try encodeContainer.encode(sourceSnapshotId, forKey: .sourceSnapshotId)
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeDiskId = volumeDiskId {
            try encodeContainer.encode(volumeDiskId, forKey: .volumeDiskId)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeProgress = volumeProgress {
            try encodeContainer.encode(volumeProgress, forKey: .volumeProgress)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeStatus = volumeStatus {
            try encodeContainer.encode(volumeStatus, forKey: .volumeStatus)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
        if let volumeUsedInBytes = volumeUsedInBytes {
            try encodeContainer.encode(volumeUsedInBytes, forKey: .volumeUsedInBytes)
        }
        if let volumeiSCSIAttributes = volumeiSCSIAttributes {
            try encodeContainer.encode(volumeiSCSIAttributes, forKey: .volumeiSCSIAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeStatus)
        volumeStatus = volumeStatusDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeProgressDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .volumeProgress)
        volumeProgress = volumeProgressDecoded
        let volumeDiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeDiskId)
        volumeDiskId = volumeDiskIdDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let preservedExistingDataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .preservedExistingData)
        preservedExistingData = preservedExistingDataDecoded
        let volumeiSCSIAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.VolumeiSCSIAttributes.self, forKey: .volumeiSCSIAttributes)
        volumeiSCSIAttributes = volumeiSCSIAttributesDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let volumeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsedInBytes)
        volumeUsedInBytes = volumeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension StorageGatewayClientTypes.StorediSCSIVolume: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorediSCSIVolume(createdDate: \(Swift.String(describing: createdDate)), kMSKey: \(Swift.String(describing: kMSKey)), preservedExistingData: \(Swift.String(describing: preservedExistingData)), sourceSnapshotId: \(Swift.String(describing: sourceSnapshotId)), targetName: \(Swift.String(describing: targetName)), volumeARN: \(Swift.String(describing: volumeARN)), volumeAttachmentStatus: \(Swift.String(describing: volumeAttachmentStatus)), volumeDiskId: \(Swift.String(describing: volumeDiskId)), volumeId: \(Swift.String(describing: volumeId)), volumeProgress: \(Swift.String(describing: volumeProgress)), volumeSizeInBytes: \(Swift.String(describing: volumeSizeInBytes)), volumeStatus: \(Swift.String(describing: volumeStatus)), volumeType: \(Swift.String(describing: volumeType)), volumeUsedInBytes: \(Swift.String(describing: volumeUsedInBytes)), volumeiSCSIAttributes: \(Swift.String(describing: volumeiSCSIAttributes)))"}
}

extension StorageGatewayClientTypes {
    /// Describes an iSCSI stored volume.
    public struct StorediSCSIVolume: Swift.Equatable {
        /// The date the volume was created. Volumes created prior to March 28, 2017 don’t have this
        ///          timestamp.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        ///          only be set when KMSEncrypted is true. Optional.
        public var kMSKey: Swift.String?
        /// Indicates if when the stored volume was created, existing data on the underlying local
        ///          disk was preserved.
        ///
        ///          Valid Values: true | false
        ///
        public var preservedExistingData: Swift.Bool
        /// If the stored volume was created from a snapshot, this field contains the snapshot ID
        ///          used, e.g. snap-78e22663. Otherwise, this field is not included.
        public var sourceSnapshotId: Swift.String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a
        ///          suffix for the target ARN. For example, specifying TargetName as
        ///             myvolume results in the target ARN of
        ///             arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume.
        ///          The target name must be unique across all volumes on a gateway.
        ///
        ///          If you don't specify a value, Storage Gateway uses the value that was previously
        ///          used for this volume as the new target name.
        public var targetName: Swift.String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public var volumeARN: Swift.String?
        /// A value that indicates whether a storage volume is attached to, detached from, or is in
        ///          the process of detaching from a gateway. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume">Moving
        ///             your volumes to a different gateway.
        public var volumeAttachmentStatus: Swift.String?
        /// The ID of the local disk that was specified in the CreateStorediSCSIVolume operation.
        public var volumeDiskId: Swift.String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public var volumeId: Swift.String?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that
        ///          represents the percent of data transferred. This field does not appear in the response if
        ///          the stored volume is not restoring or bootstrapping.
        public var volumeProgress: Swift.Double?
        /// The size of the volume in bytes.
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeStatus: Swift.String?
        /// One of the VolumeType enumeration values describing the type of the volume.
        public var volumeType: Swift.String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on
        ///          the number of blocks that are touched, instead of the actual amount of data written. This
        ///          value can be useful for sequential write patterns but less accurate for random write
        ///          patterns. VolumeUsedInBytes is different from the compressed size of the
        ///          volume, which is the value that is used to calculate your bill.
        ///
        ///
        ///             This value is not available for volumes created prior to May 13, 2015, until you
        ///             store data on the volume.
        ///
        public var volumeUsedInBytes: Swift.Int?
        /// An VolumeiSCSIAttributes object that represents a collection of iSCSI
        ///          attributes for one stored volume.
        public var volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            kMSKey: Swift.String? = nil,
            preservedExistingData: Swift.Bool = false,
            sourceSnapshotId: Swift.String? = nil,
            targetName: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeDiskId: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeProgress: Swift.Double? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil,
            volumeUsedInBytes: Swift.Int? = nil,
            volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes? = nil
        )
        {
            self.createdDate = createdDate
            self.kMSKey = kMSKey
            self.preservedExistingData = preservedExistingData
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeDiskId = volumeDiskId
            self.volumeId = volumeId
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
        }
    }

}

extension StorageGatewayClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension StorageGatewayClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension StorageGatewayClientTypes {
    /// A key-value pair that helps you manage, filter, and search for your resource. Allowed
    ///          characters: letters, white space, and numbers, representable in UTF-8, and the following
    ///          characters: + - = . _ : /.
    public struct Tag: Swift.Equatable {
        /// Tag key. The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension StorageGatewayClientTypes.Tape: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kMSKey = "KMSKey"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case progress = "Progress"
        case retentionStartDate = "RetentionStartDate"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeCreatedDate = "TapeCreatedDate"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
        case tapeUsedInBytes = "TapeUsedInBytes"
        case vTLDevice = "VTLDevice"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let poolEntryDate = poolEntryDate {
            try encodeContainer.encode(poolEntryDate.timeIntervalSince1970, forKey: .poolEntryDate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let progress = progress {
            try encodeContainer.encode(progress, forKey: .progress)
        }
        if let retentionStartDate = retentionStartDate {
            try encodeContainer.encode(retentionStartDate.timeIntervalSince1970, forKey: .retentionStartDate)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeCreatedDate = tapeCreatedDate {
            try encodeContainer.encode(tapeCreatedDate.timeIntervalSince1970, forKey: .tapeCreatedDate)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
        if let tapeUsedInBytes = tapeUsedInBytes {
            try encodeContainer.encode(tapeUsedInBytes, forKey: .tapeUsedInBytes)
        }
        if let vTLDevice = vTLDevice {
            try encodeContainer.encode(vTLDevice, forKey: .vTLDevice)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeCreatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .tapeCreatedDate)
        tapeCreatedDate = tapeCreatedDateDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let vTLDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vTLDevice)
        vTLDevice = vTLDeviceDecoded
        let progressDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .progress)
        progress = progressDecoded
        let tapeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeUsedInBytes)
        tapeUsedInBytes = tapeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Swift.Bool.self, forKey: .worm)
        worm = wormDecoded
        let retentionStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension StorageGatewayClientTypes.Tape: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tape(kMSKey: \(Swift.String(describing: kMSKey)), poolEntryDate: \(Swift.String(describing: poolEntryDate)), poolId: \(Swift.String(describing: poolId)), progress: \(Swift.String(describing: progress)), retentionStartDate: \(Swift.String(describing: retentionStartDate)), tapeARN: \(Swift.String(describing: tapeARN)), tapeBarcode: \(Swift.String(describing: tapeBarcode)), tapeCreatedDate: \(Swift.String(describing: tapeCreatedDate)), tapeSizeInBytes: \(Swift.String(describing: tapeSizeInBytes)), tapeStatus: \(Swift.String(describing: tapeStatus)), tapeUsedInBytes: \(Swift.String(describing: tapeUsedInBytes)), vTLDevice: \(Swift.String(describing: vTLDevice)), worm: \(Swift.String(describing: worm)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a virtual tape object.
    public struct Tape: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        ///          only be set when KMSEncrypted is true. Optional.
        public var kMSKey: Swift.String?
        /// The date that the tape enters a custom tape pool.
        public var poolEntryDate: ClientRuntime.Date?
        /// The ID of the pool that contains tapes that will be archived. The tapes in this pool are
        ///          archived in the S3 storage class that is associated with the pool. When you use your backup
        ///          application to eject the tape, the tape is archived directly into the storage class (S3
        ///          Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        ///
        ///          Valid Values: GLACIER | DEEP_ARCHIVE
        ///
        public var poolId: Swift.String?
        /// For archiving virtual tapes, indicates how much data remains to be uploaded before
        ///          archiving is complete.
        ///
        ///          Range: 0 (not started) to 100 (complete).
        public var progress: Swift.Double?
        /// The date that the tape is first archived with tape retention lock enabled.
        public var retentionStartDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies a specific virtual tape.
        public var tapeBarcode: Swift.String?
        /// The date the virtual tape was created.
        public var tapeCreatedDate: ClientRuntime.Date?
        /// The size, in bytes, of the virtual tape capacity.
        public var tapeSizeInBytes: Swift.Int?
        /// The current state of the virtual tape.
        public var tapeStatus: Swift.String?
        /// The size, in bytes, of data stored on the virtual tape.
        ///
        ///
        ///             This value is not available for tapes created prior to May 13, 2015.
        ///
        public var tapeUsedInBytes: Swift.Int?
        /// The virtual tape library (VTL) device that the virtual tape is associated with.
        public var vTLDevice: Swift.String?
        /// If the tape is archived as write-once-read-many (WORM), this value is
        ///          true.
        public var worm: Swift.Bool

        public init (
            kMSKey: Swift.String? = nil,
            poolEntryDate: ClientRuntime.Date? = nil,
            poolId: Swift.String? = nil,
            progress: Swift.Double? = nil,
            retentionStartDate: ClientRuntime.Date? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeCreatedDate: ClientRuntime.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil,
            tapeUsedInBytes: Swift.Int? = nil,
            vTLDevice: Swift.String? = nil,
            worm: Swift.Bool = false
        )
        {
            self.kMSKey = kMSKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.progress = progress
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.vTLDevice = vTLDevice
            self.worm = worm
        }
    }

}

extension StorageGatewayClientTypes.TapeArchive: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case kMSKey = "KMSKey"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case retentionStartDate = "RetentionStartDate"
        case retrievedTo = "RetrievedTo"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeCreatedDate = "TapeCreatedDate"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
        case tapeUsedInBytes = "TapeUsedInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let poolEntryDate = poolEntryDate {
            try encodeContainer.encode(poolEntryDate.timeIntervalSince1970, forKey: .poolEntryDate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let retentionStartDate = retentionStartDate {
            try encodeContainer.encode(retentionStartDate.timeIntervalSince1970, forKey: .retentionStartDate)
        }
        if let retrievedTo = retrievedTo {
            try encodeContainer.encode(retrievedTo, forKey: .retrievedTo)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeCreatedDate = tapeCreatedDate {
            try encodeContainer.encode(tapeCreatedDate.timeIntervalSince1970, forKey: .tapeCreatedDate)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
        if let tapeUsedInBytes = tapeUsedInBytes {
            try encodeContainer.encode(tapeUsedInBytes, forKey: .tapeUsedInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeCreatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .tapeCreatedDate)
        tapeCreatedDate = tapeCreatedDateDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let retrievedToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievedTo)
        retrievedTo = retrievedToDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let tapeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeUsedInBytes)
        tapeUsedInBytes = tapeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Swift.Bool.self, forKey: .worm)
        worm = wormDecoded
        let retentionStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension StorageGatewayClientTypes.TapeArchive: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TapeArchive(completionTime: \(Swift.String(describing: completionTime)), kMSKey: \(Swift.String(describing: kMSKey)), poolEntryDate: \(Swift.String(describing: poolEntryDate)), poolId: \(Swift.String(describing: poolId)), retentionStartDate: \(Swift.String(describing: retentionStartDate)), retrievedTo: \(Swift.String(describing: retrievedTo)), tapeARN: \(Swift.String(describing: tapeARN)), tapeBarcode: \(Swift.String(describing: tapeBarcode)), tapeCreatedDate: \(Swift.String(describing: tapeCreatedDate)), tapeSizeInBytes: \(Swift.String(describing: tapeSizeInBytes)), tapeStatus: \(Swift.String(describing: tapeStatus)), tapeUsedInBytes: \(Swift.String(describing: tapeUsedInBytes)), worm: \(Swift.String(describing: worm)))"}
}

extension StorageGatewayClientTypes {
    /// Represents a virtual tape that is archived in the virtual tape shelf (VTS).
    public struct TapeArchive: Swift.Equatable {
        /// The time that the archiving of the virtual tape was completed.
        ///
        ///          The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z'
        ///          format.
        public var completionTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        ///          only be set when KMSEncrypted is true. Optional.
        public var kMSKey: Swift.String?
        /// The time that the tape entered the custom tape pool.
        ///
        ///          The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z'
        ///          format.
        public var poolEntryDate: ClientRuntime.Date?
        /// The ID of the pool that was used to archive the tape. The tapes in this pool are
        ///          archived in the S3 storage class that is associated with the pool.
        ///
        ///          Valid Values: GLACIER | DEEP_ARCHIVE
        ///
        public var poolId: Swift.String?
        /// If the archived tape is subject to tape retention lock, the date that the archived tape
        ///          started being retained.
        public var retentionStartDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the tape gateway that the virtual tape is being
        ///          retrieved to.
        ///
        ///          The virtual tape is retrieved from the virtual tape shelf (VTS).
        public var retrievedTo: Swift.String?
        /// The Amazon Resource Name (ARN) of an archived virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies the archived virtual tape.
        public var tapeBarcode: Swift.String?
        /// The date the virtual tape was created.
        public var tapeCreatedDate: ClientRuntime.Date?
        /// The size, in bytes, of the archived virtual tape.
        public var tapeSizeInBytes: Swift.Int?
        /// The current state of the archived virtual tape.
        public var tapeStatus: Swift.String?
        /// The size, in bytes, of data stored on the virtual tape.
        ///
        ///
        ///             This value is not available for tapes created prior to May 13, 2015.
        ///
        public var tapeUsedInBytes: Swift.Int?
        /// Set to true if the archived tape is stored as write-once-read-many
        ///          (WORM).
        public var worm: Swift.Bool

        public init (
            completionTime: ClientRuntime.Date? = nil,
            kMSKey: Swift.String? = nil,
            poolEntryDate: ClientRuntime.Date? = nil,
            poolId: Swift.String? = nil,
            retentionStartDate: ClientRuntime.Date? = nil,
            retrievedTo: Swift.String? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeCreatedDate: ClientRuntime.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil,
            tapeUsedInBytes: Swift.Int? = nil,
            worm: Swift.Bool = false
        )
        {
            self.completionTime = completionTime
            self.kMSKey = kMSKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.retrievedTo = retrievedTo
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.worm = worm
        }
    }

}

extension StorageGatewayClientTypes.TapeInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case retentionStartDate = "RetentionStartDate"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let poolEntryDate = poolEntryDate {
            try encodeContainer.encode(poolEntryDate.timeIntervalSince1970, forKey: .poolEntryDate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let retentionStartDate = retentionStartDate {
            try encodeContainer.encode(retentionStartDate.timeIntervalSince1970, forKey: .retentionStartDate)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let retentionStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension StorageGatewayClientTypes.TapeInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TapeInfo(gatewayARN: \(Swift.String(describing: gatewayARN)), poolEntryDate: \(Swift.String(describing: poolEntryDate)), poolId: \(Swift.String(describing: poolId)), retentionStartDate: \(Swift.String(describing: retentionStartDate)), tapeARN: \(Swift.String(describing: tapeARN)), tapeBarcode: \(Swift.String(describing: tapeBarcode)), tapeSizeInBytes: \(Swift.String(describing: tapeSizeInBytes)), tapeStatus: \(Swift.String(describing: tapeStatus)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a virtual tape.
    public struct TapeInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?
        /// The date that the tape entered the custom tape pool with tape retention lock
        ///          enabled.
        public var poolEntryDate: ClientRuntime.Date?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this
        ///          pool is archived in the S3 storage class that is associated with the pool. When you use
        ///          your backup application to eject the tape, the tape is archived directly into the storage
        ///          class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        ///
        ///          Valid Values: GLACIER | DEEP_ARCHIVE
        ///
        public var poolId: Swift.String?
        /// The date that the tape became subject to tape retention lock.
        public var retentionStartDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies a specific virtual tape.
        public var tapeBarcode: Swift.String?
        /// The size, in bytes, of a virtual tape.
        public var tapeSizeInBytes: Swift.Int?
        /// The status of the tape.
        public var tapeStatus: Swift.String?

        public init (
            gatewayARN: Swift.String? = nil,
            poolEntryDate: ClientRuntime.Date? = nil,
            poolId: Swift.String? = nil,
            retentionStartDate: ClientRuntime.Date? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil
        )
        {
            self.gatewayARN = gatewayARN
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }
    }

}

extension StorageGatewayClientTypes.TapeRecoveryPointInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
        case tapeRecoveryPointTime = "TapeRecoveryPointTime"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeRecoveryPointTime = tapeRecoveryPointTime {
            try encodeContainer.encode(tapeRecoveryPointTime.timeIntervalSince1970, forKey: .tapeRecoveryPointTime)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .tapeRecoveryPointTime)
        tapeRecoveryPointTime = tapeRecoveryPointTimeDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
    }
}

extension StorageGatewayClientTypes.TapeRecoveryPointInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TapeRecoveryPointInfo(tapeARN: \(Swift.String(describing: tapeARN)), tapeRecoveryPointTime: \(Swift.String(describing: tapeRecoveryPointTime)), tapeSizeInBytes: \(Swift.String(describing: tapeSizeInBytes)), tapeStatus: \(Swift.String(describing: tapeStatus)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a recovery point.
    public struct TapeRecoveryPointInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public var tapeARN: Swift.String?
        /// The time when the point-in-time view of the virtual tape was replicated for later
        ///          recovery.
        ///
        ///          The default timestamp format of the tape recovery point time is in the ISO8601 extended
        ///          YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public var tapeRecoveryPointTime: ClientRuntime.Date?
        /// The size, in bytes, of the virtual tapes to recover.
        public var tapeSizeInBytes: Swift.Int?
        /// The status of the virtual tapes.
        public var tapeStatus: Swift.String?

        public init (
            tapeARN: Swift.String? = nil,
            tapeRecoveryPointTime: ClientRuntime.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil
        )
        {
            self.tapeARN = tapeARN
            self.tapeRecoveryPointTime = tapeRecoveryPointTime
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }
    }

}

extension StorageGatewayClientTypes {
    public enum TapeStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case sdkUnknown(Swift.String)

        public static var allCases: [TapeStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TapeStorageClass(rawValue: rawValue) ?? TapeStorageClass.sdkUnknown(rawValue)
        }
    }
}

public struct UpdateAutomaticTapeCreationPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAutomaticTapeCreationPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAutomaticTapeCreationPolicyOutputError>
}

extension UpdateAutomaticTapeCreationPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAutomaticTapeCreationPolicyInput(automaticTapeCreationRules: \(Swift.String(describing: automaticTapeCreationRules)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateAutomaticTapeCreationPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTapeCreationRules = automaticTapeCreationRules {
            var automaticTapeCreationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automaticTapeCreationRules)
            for automatictapecreationrules0 in automaticTapeCreationRules {
                try automaticTapeCreationRulesContainer.encode(automatictapecreationrules0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateAutomaticTapeCreationPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAutomaticTapeCreationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAutomaticTapeCreationPolicyOutputError>
}

public struct UpdateAutomaticTapeCreationPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAutomaticTapeCreationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAutomaticTapeCreationPolicyOutputError>
}

public struct UpdateAutomaticTapeCreationPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAutomaticTapeCreationPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAutomaticTapeCreationPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAutomaticTapeCreationPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAutomaticTapeCreationPolicyOutputError>
}

public struct UpdateAutomaticTapeCreationPolicyInput: Swift.Equatable {
    /// An automatic tape creation policy consists of a list of automatic tape creation rules.
    ///          The rules determine when and how to automatically create new tapes.
    /// This member is required.
    public var automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.automaticTapeCreationRules = automaticTapeCreationRules
        self.gatewayARN = gatewayARN
    }
}

struct UpdateAutomaticTapeCreationPolicyInputBody: Swift.Equatable {
    public let automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
    public let gatewayARN: Swift.String?
}

extension UpdateAutomaticTapeCreationPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationRulesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.AutomaticTapeCreationRule?].self, forKey: .automaticTapeCreationRules)
        var automaticTapeCreationRulesDecoded0:[StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil
        if let automaticTapeCreationRulesContainer = automaticTapeCreationRulesContainer {
            automaticTapeCreationRulesDecoded0 = [StorageGatewayClientTypes.AutomaticTapeCreationRule]()
            for structure0 in automaticTapeCreationRulesContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationRulesDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationRules = automaticTapeCreationRulesDecoded0
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateAutomaticTapeCreationPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAutomaticTapeCreationPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAutomaticTapeCreationPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAutomaticTapeCreationPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAutomaticTapeCreationPolicyOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateAutomaticTapeCreationPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAutomaticTapeCreationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateAutomaticTapeCreationPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateAutomaticTapeCreationPolicyOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateAutomaticTapeCreationPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateBandwidthRateLimitInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitOutputError>
}

extension UpdateBandwidthRateLimitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBandwidthRateLimitInput(averageDownloadRateLimitInBitsPerSec: \(Swift.String(describing: averageDownloadRateLimitInBitsPerSec)), averageUploadRateLimitInBitsPerSec: \(Swift.String(describing: averageUploadRateLimitInBitsPerSec)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageDownloadRateLimitInBitsPerSec, forKey: .averageDownloadRateLimitInBitsPerSec)
        }
        if let averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateBandwidthRateLimitInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitOutputError>
}

public struct UpdateBandwidthRateLimitInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitOutputError>
}

public struct UpdateBandwidthRateLimitInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateBandwidthRateLimitInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBandwidthRateLimitInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   UpdateBandwidthRateLimitInput$AverageDownloadRateLimitInBitsPerSec
///
///
///
///
///                   UpdateBandwidthRateLimitInput$AverageUploadRateLimitInBitsPerSec
///
///
///
public struct UpdateBandwidthRateLimitInput: Swift.Equatable {
    /// The average download bandwidth rate limit in bits per second.
    public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
    /// The average upload bandwidth rate limit in bits per second.
    public var averageUploadRateLimitInBitsPerSec: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
        averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let averageUploadRateLimitInBitsPerSec: Swift.Int?
    public let averageDownloadRateLimitInBitsPerSec: Swift.Int?
}

extension UpdateBandwidthRateLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

extension UpdateBandwidthRateLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBandwidthRateLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBandwidthRateLimitOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBandwidthRateLimitOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBandwidthRateLimitOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose throttle
///          information was updated.
public struct UpdateBandwidthRateLimitOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateBandwidthRateLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateBandwidthRateLimitScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitScheduleOutputError>
}

extension UpdateBandwidthRateLimitScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBandwidthRateLimitScheduleInput(bandwidthRateLimitIntervals: \(Swift.String(describing: bandwidthRateLimitIntervals)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthRateLimitIntervals = bandwidthRateLimitIntervals {
            var bandwidthRateLimitIntervalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bandwidthRateLimitIntervals)
            for bandwidthratelimitintervals0 in bandwidthRateLimitIntervals {
                try bandwidthRateLimitIntervalsContainer.encode(bandwidthratelimitintervals0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateBandwidthRateLimitScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitScheduleOutputError>
}

public struct UpdateBandwidthRateLimitScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitScheduleOutputError>
}

public struct UpdateBandwidthRateLimitScheduleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBandwidthRateLimitScheduleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateBandwidthRateLimitScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBandwidthRateLimitScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBandwidthRateLimitScheduleOutputError>
}

public struct UpdateBandwidthRateLimitScheduleInput: Swift.Equatable {
    ///
    ///          An array containing bandwidth rate limit schedule intervals for a gateway.
    ///          When no bandwidth rate limit intervals have been scheduled, the array is empty.
    ///
    /// This member is required.
    public var bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension UpdateBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [StorageGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

extension UpdateBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBandwidthRateLimitScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBandwidthRateLimitScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBandwidthRateLimitScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBandwidthRateLimitScheduleOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateBandwidthRateLimitScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitScheduleOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateBandwidthRateLimitScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateChapCredentialsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChapCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChapCredentialsOutputError>
}

extension UpdateChapCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChapCredentialsInput(initiatorName: \(Swift.String(describing: initiatorName)), secretToAuthenticateInitiator: \(Swift.String(describing: secretToAuthenticateInitiator)), secretToAuthenticateTarget: \(Swift.String(describing: secretToAuthenticateTarget)), targetARN: \(Swift.String(describing: targetARN)))"}
}

extension UpdateChapCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let secretToAuthenticateInitiator = secretToAuthenticateInitiator {
            try encodeContainer.encode(secretToAuthenticateInitiator, forKey: .secretToAuthenticateInitiator)
        }
        if let secretToAuthenticateTarget = secretToAuthenticateTarget {
            try encodeContainer.encode(secretToAuthenticateTarget, forKey: .secretToAuthenticateTarget)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

public struct UpdateChapCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChapCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChapCredentialsOutputError>
}

public struct UpdateChapCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChapCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChapCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChapCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChapCredentialsOutputError>
}

public struct UpdateChapCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChapCredentialsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateChapCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChapCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChapCredentialsOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   UpdateChapCredentialsInput$InitiatorName
///
///
///
///
///                   UpdateChapCredentialsInput$SecretToAuthenticateInitiator
///
///
///
///
///                   UpdateChapCredentialsInput$SecretToAuthenticateTarget
///
///
///
///
///
///                   UpdateChapCredentialsInput$TargetARN
///
///
///
public struct UpdateChapCredentialsInput: Swift.Equatable {
    /// The iSCSI initiator that connects to the target.
    /// This member is required.
    public var initiatorName: Swift.String?
    /// The secret key that the initiator (for example, the Windows client) must provide to
    ///          participate in mutual CHAP with the target.
    ///
    ///
    ///             The secret key must be between 12 and 16 bytes when encoded in UTF-8.
    ///
    /// This member is required.
    public var secretToAuthenticateInitiator: Swift.String?
    /// The secret key that the target must provide to participate in mutual CHAP with the
    ///          initiator (e.g. Windows client).
    ///
    ///          Byte constraints: Minimum bytes of 12. Maximum bytes of 16.
    ///
    ///
    ///             The secret key must be between 12 and 16 bytes when encoded in UTF-8.
    ///
    public var secretToAuthenticateTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return the TargetARN for specified
    ///          VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        secretToAuthenticateInitiator: Swift.String? = nil,
        secretToAuthenticateTarget: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
        self.secretToAuthenticateTarget = secretToAuthenticateTarget
        self.targetARN = targetARN
    }
}

struct UpdateChapCredentialsInputBody: Swift.Equatable {
    public let targetARN: Swift.String?
    public let secretToAuthenticateInitiator: Swift.String?
    public let initiatorName: Swift.String?
    public let secretToAuthenticateTarget: Swift.String?
}

extension UpdateChapCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let secretToAuthenticateInitiatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateInitiator)
        secretToAuthenticateInitiator = secretToAuthenticateInitiatorDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
        let secretToAuthenticateTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateTarget)
        secretToAuthenticateTarget = secretToAuthenticateTargetDecoded
    }
}

extension UpdateChapCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChapCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChapCredentialsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChapCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChapCredentialsOutputResponse(initiatorName: \(Swift.String(describing: initiatorName)), targetARN: \(Swift.String(describing: targetARN)))"}
}

extension UpdateChapCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiatorName = output.initiatorName
            self.targetARN = output.targetARN
        } else {
            self.initiatorName = nil
            self.targetARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct UpdateChapCredentialsOutputResponse: Swift.Equatable {
    /// The iSCSI initiator that connects to the target. This is the same initiator name
    ///          specified in the request.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the target. This is the same target specified in the
    ///          request.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct UpdateChapCredentialsOutputResponseBody: Swift.Equatable {
    public let targetARN: Swift.String?
    public let initiatorName: Swift.String?
}

extension UpdateChapCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

public struct UpdateFileSystemAssociationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemAssociationOutputError>
}

extension UpdateFileSystemAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemAssociationInput(auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)), password: \(Swift.String(describing: password)), userName: \(Swift.String(describing: userName)))"}
}

extension UpdateFileSystemAssociationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct UpdateFileSystemAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemAssociationOutputError>
}

public struct UpdateFileSystemAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemAssociationOutputError>
}

public struct UpdateFileSystemAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemAssociationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateFileSystemAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFileSystemAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemAssociationOutputError>
}

public struct UpdateFileSystemAssociationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
    public var auditDestinationARN: Swift.String?
    /// The refresh cache information for the file share or FSx file systems.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The Amazon Resource Name (ARN) of the file system association that you want to update.
    /// This member is required.
    public var fileSystemAssociationARN: Swift.String?
    /// The password of the user credential.
    public var password: Swift.String?
    /// The user name of the user credential that has permission to access the root share D$ of
    ///          the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin
    ///          user group.
    public var userName: Swift.String?

    public init (
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        fileSystemAssociationARN: Swift.String? = nil,
        password: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.password = password
        self.userName = userName
    }
}

struct UpdateFileSystemAssociationInputBody: Swift.Equatable {
    public let fileSystemAssociationARN: Swift.String?
    public let userName: Swift.String?
    public let password: Swift.String?
    public let auditDestinationARN: Swift.String?
    public let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
}

extension UpdateFileSystemAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case password = "Password"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
    }
}

extension UpdateFileSystemAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFileSystemAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFileSystemAssociationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFileSystemAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemAssociationOutputResponse(fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)))"}
}

extension UpdateFileSystemAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFileSystemAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct UpdateFileSystemAssociationOutputResponse: Swift.Equatable {
    /// The ARN of the updated file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init (
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct UpdateFileSystemAssociationOutputResponseBody: Swift.Equatable {
    public let fileSystemAssociationARN: Swift.String?
}

extension UpdateFileSystemAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

public struct UpdateGatewayInformationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayInformationOutputError>
}

extension UpdateGatewayInformationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayInformationInput(cloudWatchLogGroupARN: \(Swift.String(describing: cloudWatchLogGroupARN)), gatewayARN: \(Swift.String(describing: gatewayARN)), gatewayCapacity: \(Swift.String(describing: gatewayCapacity)), gatewayName: \(Swift.String(describing: gatewayName)), gatewayTimezone: \(Swift.String(describing: gatewayTimezone)))"}
}

extension UpdateGatewayInformationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case gatewayARN = "GatewayARN"
        case gatewayCapacity = "GatewayCapacity"
        case gatewayName = "GatewayName"
        case gatewayTimezone = "GatewayTimezone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupARN = cloudWatchLogGroupARN {
            try encodeContainer.encode(cloudWatchLogGroupARN, forKey: .cloudWatchLogGroupARN)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayCapacity = gatewayCapacity {
            try encodeContainer.encode(gatewayCapacity.rawValue, forKey: .gatewayCapacity)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayTimezone = gatewayTimezone {
            try encodeContainer.encode(gatewayTimezone, forKey: .gatewayTimezone)
        }
    }
}

public struct UpdateGatewayInformationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayInformationOutputError>
}

public struct UpdateGatewayInformationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayInformationOutputError>
}

public struct UpdateGatewayInformationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInformationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateGatewayInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGatewayInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayInformationOutputError>
}

public struct UpdateGatewayInformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that you want to use
    ///          to monitor and log events in the gateway.
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html">What is Amazon CloudWatch
    ///             Logs?
    ///
    public var cloudWatchLogGroupARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies the size of the gateway's metadata cache.
    public var gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?
    /// A value that indicates the time zone of the gateway.
    public var gatewayTimezone: Swift.String?

    public init (
        cloudWatchLogGroupARN: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity? = nil,
        gatewayName: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.gatewayARN = gatewayARN
        self.gatewayCapacity = gatewayCapacity
        self.gatewayName = gatewayName
        self.gatewayTimezone = gatewayTimezone
    }
}

struct UpdateGatewayInformationInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let gatewayName: Swift.String?
    public let gatewayTimezone: Swift.String?
    public let cloudWatchLogGroupARN: Swift.String?
    public let gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
}

extension UpdateGatewayInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case gatewayARN = "GatewayARN"
        case gatewayCapacity = "GatewayCapacity"
        case gatewayName = "GatewayName"
        case gatewayTimezone = "GatewayTimezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let cloudWatchLogGroupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupARN)
        cloudWatchLogGroupARN = cloudWatchLogGroupARNDecoded
        let gatewayCapacityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.GatewayCapacity.self, forKey: .gatewayCapacity)
        gatewayCapacity = gatewayCapacityDecoded
    }
}

extension UpdateGatewayInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayInformationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayInformationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayInformationOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)), gatewayName: \(Swift.String(describing: gatewayName)))"}
}

extension UpdateGatewayInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGatewayInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.gatewayName = output.gatewayName
        } else {
            self.gatewayARN = nil
            self.gatewayName = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was
///          updated.
public struct UpdateGatewayInformationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        gatewayName: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.gatewayName = gatewayName
    }
}

struct UpdateGatewayInformationOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let gatewayName: Swift.String?
}

extension UpdateGatewayInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case gatewayName = "GatewayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
    }
}

public struct UpdateGatewaySoftwareNowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewaySoftwareNowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewaySoftwareNowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewaySoftwareNowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewaySoftwareNowOutputError>
}

extension UpdateGatewaySoftwareNowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewaySoftwareNowInput(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateGatewaySoftwareNowInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateGatewaySoftwareNowInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewaySoftwareNowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewaySoftwareNowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewaySoftwareNowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewaySoftwareNowOutputError>
}

public struct UpdateGatewaySoftwareNowInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewaySoftwareNowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewaySoftwareNowInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewaySoftwareNowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewaySoftwareNowOutputError>
}

public struct UpdateGatewaySoftwareNowInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewaySoftwareNowInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateGatewaySoftwareNowInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGatewaySoftwareNowInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewaySoftwareNowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewaySoftwareNowOutputError>
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to update.
public struct UpdateGatewaySoftwareNowInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateGatewaySoftwareNowInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateGatewaySoftwareNowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateGatewaySoftwareNowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewaySoftwareNowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewaySoftwareNowOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewaySoftwareNowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewaySoftwareNowOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateGatewaySoftwareNowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGatewaySoftwareNowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was
///          updated.
public struct UpdateGatewaySoftwareNowOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateGatewaySoftwareNowOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateGatewaySoftwareNowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateMaintenanceStartTimeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceStartTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceStartTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceStartTimeOutputError>
}

extension UpdateMaintenanceStartTimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceStartTimeInput(dayOfMonth: \(Swift.String(describing: dayOfMonth)), dayOfWeek: \(Swift.String(describing: dayOfWeek)), gatewayARN: \(Swift.String(describing: gatewayARN)), hourOfDay: \(Swift.String(describing: hourOfDay)), minuteOfHour: \(Swift.String(describing: minuteOfHour)))"}
}

extension UpdateMaintenanceStartTimeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek, forKey: .dayOfWeek)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let hourOfDay = hourOfDay {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if let minuteOfHour = minuteOfHour {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }
}

public struct UpdateMaintenanceStartTimeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceStartTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceStartTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceStartTimeOutputError>
}

public struct UpdateMaintenanceStartTimeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceStartTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMaintenanceStartTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceStartTimeOutputError>
}

public struct UpdateMaintenanceStartTimeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMaintenanceStartTimeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateMaintenanceStartTimeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMaintenanceStartTimeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMaintenanceStartTimeOutputError>
}

/// A JSON object containing the following fields:
///
///
///
///
///                   UpdateMaintenanceStartTimeInput$DayOfMonth
///
///
///
///
///                   UpdateMaintenanceStartTimeInput$DayOfWeek
///
///
///
///
///                   UpdateMaintenanceStartTimeInput$HourOfDay
///
///
///
///
///                   UpdateMaintenanceStartTimeInput$MinuteOfHour
///
///
///
public struct UpdateMaintenanceStartTimeInput: Swift.Equatable {
    /// The day of the month component of the maintenance start time represented as an ordinal
    ///          number from 1 to 28, where 1 represents the first day of the month and 28 represents the
    ///          last day of the month.
    public var dayOfMonth: Swift.Int?
    /// The day of the week component of the maintenance start time week represented as an
    ///          ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The hour component of the maintenance start time represented as hh,
    ///          where hh is the hour (00 to 23). The hour of the day is in the time
    ///          zone of the gateway.
    /// This member is required.
    public var hourOfDay: Swift.Int?
    /// The minute component of the maintenance start time represented as
    ///             mm, where mm is the minute (00 to 59). The
    ///          minute of the hour is in the time zone of the gateway.
    /// This member is required.
    public var minuteOfHour: Swift.Int?

    public init (
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
    }
}

struct UpdateMaintenanceStartTimeInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let hourOfDay: Swift.Int?
    public let minuteOfHour: Swift.Int?
    public let dayOfWeek: Swift.Int?
    public let dayOfMonth: Swift.Int?
}

extension UpdateMaintenanceStartTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
    }
}

extension UpdateMaintenanceStartTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceStartTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceStartTimeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceStartTimeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceStartTimeOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateMaintenanceStartTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMaintenanceStartTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose maintenance
///          start time is updated.
public struct UpdateMaintenanceStartTimeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateMaintenanceStartTimeOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateMaintenanceStartTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateNFSFileShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNFSFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNFSFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNFSFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNFSFileShareOutputError>
}

extension UpdateNFSFileShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNFSFileShareInput(cacheAttributes: \(Swift.String(describing: cacheAttributes)), clientList: \(Swift.String(describing: clientList)), defaultStorageClass: \(Swift.String(describing: defaultStorageClass)), fileShareARN: \(Swift.String(describing: fileShareARN)), fileShareName: \(Swift.String(describing: fileShareName)), guessMIMETypeEnabled: \(Swift.String(describing: guessMIMETypeEnabled)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), nFSFileShareDefaults: \(Swift.String(describing: nFSFileShareDefaults)), notificationPolicy: \(Swift.String(describing: notificationPolicy)), objectACL: \(Swift.String(describing: objectACL)), readOnly: \(Swift.String(describing: readOnly)), requesterPays: \(Swift.String(describing: requesterPays)), squash: \(Swift.String(describing: squash)))"}
}

extension UpdateNFSFileShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case squash = "Squash"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for fileshareclientlist0 in clientList {
                try clientListContainer.encode(fileshareclientlist0)
            }
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let nFSFileShareDefaults = nFSFileShareDefaults {
            try encodeContainer.encode(nFSFileShareDefaults, forKey: .nFSFileShareDefaults)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let squash = squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
    }
}

public struct UpdateNFSFileShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNFSFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNFSFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNFSFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNFSFileShareOutputError>
}

public struct UpdateNFSFileShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNFSFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNFSFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNFSFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNFSFileShareOutputError>
}

public struct UpdateNFSFileShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNFSFileShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateNFSFileShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateNFSFileShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNFSFileShareOutputError>
}

/// UpdateNFSFileShareInput
public struct UpdateNFSFileShareInput: Swift.Equatable {
    /// specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The list of clients that are allowed to access the S3 File Gateway. The list must contain
    ///          either valid IP addresses or valid CIDR blocks.
    public var clientList: [Swift.String]?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway.
    ///          The default value is S3_INTELLIGENT_TIERING. Optional.
    ///
    ///          Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING |
    ///             S3_STANDARD_IA | S3_ONEZONE_IA
    ///
    public var defaultStorageClass: Swift.String?
    /// The Amazon Resource Name (ARN) of the file share to be updated.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// The name of the file share. Optional.
    ///
    ///
    ///
    ///                FileShareName must be set if an S3 prefix name is set in
    ///                LocationARN.
    ///
    public var fileShareName: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to true to enable MIME type guessing, otherwise set
    ///          to false. The default value is true.
    ///
    ///          Valid Values: true | false
    ///
    public var guessMIMETypeEnabled: Swift.Bool?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The default values for the file share. Optional.
    public var nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    /// The notification policy of the file share. SettlingTimeInSeconds controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an ObjectUploaded notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.
    ///
    ///
    ///
    ///                SettlingTimeInSeconds has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.
    ///
    ///
    ///          The following example sets NotificationPolicy on with
    ///             SettlingTimeInSeconds set to 60.
    ///
    ///
    ///             {\"Upload\": {\"SettlingTimeInSeconds\": 60}}
    ///
    ///
    ///          The following example sets NotificationPolicy off.
    ///
    ///
    ///             {}
    ///
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// A value that sets the write status of a file share. Set this value to true
    ///          to set the write status to read-only, otherwise set to false.
    ///
    ///          Valid Values: true | false
    ///
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to true, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.
    ///
    ///
    ///
    ///                RequesterPays is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.
    ///
    ///
    ///          Valid Values: true | false
    ///
    public var requesterPays: Swift.Bool?
    /// The user mapped to anonymous user.
    ///
    ///          Valid values are the following:
    ///
    ///
    ///
    ///
    ///                   RootSquash: Only root is mapped to anonymous user.
    ///
    ///
    ///
    ///                   NoSquash: No one is mapped to anonymous user.
    ///
    ///
    ///
    ///                   AllSquash: Everyone is mapped to anonymous user.
    ///
    ///
    public var squash: Swift.String?

    public init (
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientList: [Swift.String]? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareARN: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        squash: Swift.String? = nil
    )
    {
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.nFSFileShareDefaults = nFSFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.squash = squash
    }
}

struct UpdateNFSFileShareInputBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let nFSFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    public let defaultStorageClass: Swift.String?
    public let objectACL: StorageGatewayClientTypes.ObjectACL?
    public let clientList: [Swift.String]?
    public let squash: Swift.String?
    public let readOnly: Swift.Bool?
    public let guessMIMETypeEnabled: Swift.Bool?
    public let requesterPays: Swift.Bool?
    public let fileShareName: Swift.String?
    public let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    public let notificationPolicy: Swift.String?
}

extension UpdateNFSFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case squash = "Squash"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let nFSFileShareDefaultsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.NFSFileShareDefaults.self, forKey: .nFSFileShareDefaults)
        nFSFileShareDefaults = nFSFileShareDefaultsDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
    }
}

extension UpdateNFSFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNFSFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNFSFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNFSFileShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNFSFileShareOutputResponse(fileShareARN: \(Swift.String(describing: fileShareARN)))"}
}

extension UpdateNFSFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateNFSFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// UpdateNFSFileShareOutput
public struct UpdateNFSFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct UpdateNFSFileShareOutputResponseBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
}

extension UpdateNFSFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct UpdateSMBFileShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareOutputError>
}

extension UpdateSMBFileShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSMBFileShareInput(accessBasedEnumeration: \(Swift.String(describing: accessBasedEnumeration)), adminUserList: \(Swift.String(describing: adminUserList)), auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), caseSensitivity: \(Swift.String(describing: caseSensitivity)), defaultStorageClass: \(Swift.String(describing: defaultStorageClass)), fileShareARN: \(Swift.String(describing: fileShareARN)), fileShareName: \(Swift.String(describing: fileShareName)), guessMIMETypeEnabled: \(Swift.String(describing: guessMIMETypeEnabled)), invalidUserList: \(Swift.String(describing: invalidUserList)), kMSEncrypted: \(Swift.String(describing: kMSEncrypted)), kMSKey: \(Swift.String(describing: kMSKey)), notificationPolicy: \(Swift.String(describing: notificationPolicy)), objectACL: \(Swift.String(describing: objectACL)), oplocksEnabled: \(Swift.String(describing: oplocksEnabled)), readOnly: \(Swift.String(describing: readOnly)), requesterPays: \(Swift.String(describing: requesterPays)), sMBACLEnabled: \(Swift.String(describing: sMBACLEnabled)), validUserList: \(Swift.String(describing: validUserList)))"}
}

extension UpdateSMBFileShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case sMBACLEnabled = "SMBACLEnabled"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlist0 in adminUserList {
                try adminUserListContainer.encode(userlist0)
            }
        }
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlist0 in invalidUserList {
                try invalidUserListContainer.encode(userlist0)
            }
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let oplocksEnabled = oplocksEnabled {
            try encodeContainer.encode(oplocksEnabled, forKey: .oplocksEnabled)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let sMBACLEnabled = sMBACLEnabled {
            try encodeContainer.encode(sMBACLEnabled, forKey: .sMBACLEnabled)
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlist0 in validUserList {
                try validUserListContainer.encode(userlist0)
            }
        }
    }
}

public struct UpdateSMBFileShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareOutputError>
}

public struct UpdateSMBFileShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBFileShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBFileShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareOutputError>
}

public struct UpdateSMBFileShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateSMBFileShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSMBFileShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareOutputError>
}

/// UpdateSMBFileShareInput
public struct UpdateSMBFileShareInput: Swift.Equatable {
    /// The files and folders on this share will only be visible to users with read
    ///          access.
    public var accessBasedEnumeration: Swift.Bool?
    /// A list of users or groups in the Active Directory that have administrator rights to the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             DOMAIN\User1, user1, @group1, and
    ///             @DOMAIN\group1. Can only be set if Authentication is set to
    ///             ActiveDirectory.
    public var adminUserList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the
    ///          client determines the case sensitivity. For CaseSensitive, the gateway
    ///          determines the case sensitivity. The default value is ClientSpecified.
    public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway.
    ///          The default value is S3_INTELLIGENT_TIERING. Optional.
    ///
    ///          Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING |
    ///             S3_STANDARD_IA | S3_ONEZONE_IA
    ///
    public var defaultStorageClass: Swift.String?
    /// The Amazon Resource Name (ARN) of the SMB file share that you want to update.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// The name of the file share. Optional.
    ///
    ///
    ///
    ///                FileShareName must be set if an S3 prefix name is set in
    ///                LocationARN.
    ///
    public var fileShareName: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to true to enable MIME type guessing, otherwise set
    ///          to false. The default value is true.
    ///
    ///          Valid Values: true | false
    ///
    public var guessMIMETypeEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are not allowed to access the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             DOMAIN\User1, user1, @group1, and
    ///             @DOMAIN\group1. Can only be set if Authentication is set to
    ///             ActiveDirectory.
    public var invalidUserList: [Swift.String]?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS
    ///          key, or false to use a key managed by Amazon S3. Optional.
    ///
    ///          Valid Values: true | false
    ///
    public var kMSEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when KMSEncrypted is true. Optional.
    public var kMSKey: Swift.String?
    /// The notification policy of the file share. SettlingTimeInSeconds controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an ObjectUploaded notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.
    ///
    ///
    ///
    ///                SettlingTimeInSeconds has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.
    ///
    ///
    ///          The following example sets NotificationPolicy on with
    ///             SettlingTimeInSeconds set to 60.
    ///
    ///
    ///             {\"Upload\": {\"SettlingTimeInSeconds\": 60}}
    ///
    ///
    ///          The following example sets NotificationPolicy off.
    ///
    ///
    ///             {}
    ///
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// Specifies whether opportunistic locking is enabled for the SMB file share.
    ///
    ///             Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve
    ///             access to files with the same name in different case.
    ///
    ///          Valid Values: true | false
    ///
    public var oplocksEnabled: Swift.Bool?
    /// A value that sets the write status of a file share. Set this value to true
    ///          to set write status to read-only, otherwise set to false.
    ///
    ///          Valid Values: true | false
    ///
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to true, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.
    ///
    ///
    ///
    ///                RequesterPays is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.
    ///
    ///
    ///          Valid Values: true | false
    ///
    public var requesterPays: Swift.Bool?
    /// Set this value to true to enable access control list (ACL) on the SMB file
    ///          share. Set it to false to map file and directory permissions to the POSIX
    ///          permissions.
    ///
    ///
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
    ///             control access to an SMB file share in the Storage Gateway User
    ///             Guide.
    ///
    ///          Valid Values: true | false
    ///
    public var sMBACLEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are allowed to access the file
    ///          share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             DOMAIN\User1, user1, @group1, and
    ///             @DOMAIN\group1. Can only be set if Authentication is set to
    ///             ActiveDirectory.
    public var validUserList: [Swift.String]?

    public init (
        accessBasedEnumeration: Swift.Bool? = nil,
        adminUserList: [Swift.String]? = nil,
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareARN: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        invalidUserList: [Swift.String]? = nil,
        kMSEncrypted: Swift.Bool? = nil,
        kMSKey: Swift.String? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        oplocksEnabled: Swift.Bool? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        sMBACLEnabled: Swift.Bool? = nil,
        validUserList: [Swift.String]? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.oplocksEnabled = oplocksEnabled
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.sMBACLEnabled = sMBACLEnabled
        self.validUserList = validUserList
    }
}

struct UpdateSMBFileShareInputBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
    public let kMSEncrypted: Swift.Bool?
    public let kMSKey: Swift.String?
    public let defaultStorageClass: Swift.String?
    public let objectACL: StorageGatewayClientTypes.ObjectACL?
    public let readOnly: Swift.Bool?
    public let guessMIMETypeEnabled: Swift.Bool?
    public let requesterPays: Swift.Bool?
    public let sMBACLEnabled: Swift.Bool?
    public let accessBasedEnumeration: Swift.Bool?
    public let adminUserList: [Swift.String]?
    public let validUserList: [Swift.String]?
    public let invalidUserList: [Swift.String]?
    public let auditDestinationARN: Swift.String?
    public let caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    public let fileShareName: Swift.String?
    public let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    public let notificationPolicy: Swift.String?
    public let oplocksEnabled: Swift.Bool?
}

extension UpdateSMBFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case sMBACLEnabled = "SMBACLEnabled"
        case validUserList = "ValidUserList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let sMBACLEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sMBACLEnabled)
        sMBACLEnabled = sMBACLEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[Swift.String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [Swift.String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validUserList)
        var validUserListDecoded0:[Swift.String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [Swift.String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[Swift.String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [Swift.String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let oplocksEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .oplocksEnabled)
        oplocksEnabled = oplocksEnabledDecoded
    }
}

extension UpdateSMBFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSMBFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBFileShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSMBFileShareOutputResponse(fileShareARN: \(Swift.String(describing: fileShareARN)))"}
}

extension UpdateSMBFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSMBFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// UpdateSMBFileShareOutput
public struct UpdateSMBFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated SMB file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct UpdateSMBFileShareOutputResponseBody: Swift.Equatable {
    public let fileShareARN: Swift.String?
}

extension UpdateSMBFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct UpdateSMBFileShareVisibilityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareVisibilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBFileShareVisibilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBFileShareVisibilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareVisibilityOutputError>
}

extension UpdateSMBFileShareVisibilityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSMBFileShareVisibilityInput(fileSharesVisible: \(Swift.String(describing: fileSharesVisible)), gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateSMBFileShareVisibilityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSharesVisible = fileSharesVisible {
            try encodeContainer.encode(fileSharesVisible, forKey: .fileSharesVisible)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateSMBFileShareVisibilityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareVisibilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBFileShareVisibilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBFileShareVisibilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareVisibilityOutputError>
}

public struct UpdateSMBFileShareVisibilityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareVisibilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBFileShareVisibilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBFileShareVisibilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareVisibilityOutputError>
}

public struct UpdateSMBFileShareVisibilityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBFileShareVisibilityInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateSMBFileShareVisibilityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSMBFileShareVisibilityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBFileShareVisibilityOutputError>
}

public struct UpdateSMBFileShareVisibilityInput: Swift.Equatable {
    /// The shares on this gateway appear when listing shares.
    /// This member is required.
    public var fileSharesVisible: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        fileSharesVisible: Swift.Bool? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBFileShareVisibilityInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let fileSharesVisible: Swift.Bool?
}

extension UpdateSMBFileShareVisibilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let fileSharesVisibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fileSharesVisible)
        fileSharesVisible = fileSharesVisibleDecoded
    }
}

extension UpdateSMBFileShareVisibilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBFileShareVisibilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSMBFileShareVisibilityOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBFileShareVisibilityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSMBFileShareVisibilityOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateSMBFileShareVisibilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSMBFileShareVisibilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateSMBFileShareVisibilityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBFileShareVisibilityOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateSMBFileShareVisibilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateSMBSecurityStrategyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBSecurityStrategyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBSecurityStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBSecurityStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBSecurityStrategyOutputError>
}

extension UpdateSMBSecurityStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSMBSecurityStrategyInput(gatewayARN: \(Swift.String(describing: gatewayARN)), sMBSecurityStrategy: \(Swift.String(describing: sMBSecurityStrategy)))"}
}

extension UpdateSMBSecurityStrategyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case sMBSecurityStrategy = "SMBSecurityStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let sMBSecurityStrategy = sMBSecurityStrategy {
            try encodeContainer.encode(sMBSecurityStrategy.rawValue, forKey: .sMBSecurityStrategy)
        }
    }
}

public struct UpdateSMBSecurityStrategyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBSecurityStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBSecurityStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBSecurityStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBSecurityStrategyOutputError>
}

public struct UpdateSMBSecurityStrategyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBSecurityStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSMBSecurityStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSMBSecurityStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBSecurityStrategyOutputError>
}

public struct UpdateSMBSecurityStrategyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSMBSecurityStrategyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateSMBSecurityStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSMBSecurityStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSMBSecurityStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSMBSecurityStrategyOutputError>
}

public struct UpdateSMBSecurityStrategyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies the type of security strategy.
    ///
    ///          ClientSpecified: if you use this option, requests are established based on what is
    ///          negotiated by the client. This option is recommended when you want to maximize
    ///          compatibility across different clients in your environment. Supported only in S3 File Gateway.
    ///
    ///          MandatorySigning: if you use this option, file gateway only allows connections from
    ///          SMBv2 or SMBv3 clients that have signing enabled. This option works with SMB clients on
    ///          Microsoft Windows Vista, Windows Server 2008 or newer.
    ///
    ///          MandatoryEncryption: if you use this option, file gateway only allows connections from
    ///          SMBv3 clients that have encryption enabled. This option is highly recommended for
    ///          environments that handle sensitive data. This option works with SMB clients on Microsoft
    ///          Windows 8, Windows Server 2012 or newer.
    /// This member is required.
    public var sMBSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?

    public init (
        gatewayARN: Swift.String? = nil,
        sMBSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.sMBSecurityStrategy = sMBSecurityStrategy
    }
}

struct UpdateSMBSecurityStrategyInputBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
    public let sMBSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?
}

extension UpdateSMBSecurityStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case sMBSecurityStrategy = "SMBSecurityStrategy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let sMBSecurityStrategyDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.SMBSecurityStrategy.self, forKey: .sMBSecurityStrategy)
        sMBSecurityStrategy = sMBSecurityStrategyDecoded
    }
}

extension UpdateSMBSecurityStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBSecurityStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSMBSecurityStrategyOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBSecurityStrategyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSMBSecurityStrategyOutputResponse(gatewayARN: \(Swift.String(describing: gatewayARN)))"}
}

extension UpdateSMBSecurityStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSMBSecurityStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateSMBSecurityStrategyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
    ///          operation to return a list of gateways for your account and Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBSecurityStrategyOutputResponseBody: Swift.Equatable {
    public let gatewayARN: Swift.String?
}

extension UpdateSMBSecurityStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateSnapshotScheduleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSnapshotScheduleOutputError>
}

extension UpdateSnapshotScheduleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSnapshotScheduleInput(description: \(Swift.String(describing: description)), recurrenceInHours: \(Swift.String(describing: recurrenceInHours)), startAt: \(Swift.String(describing: startAt)), tags: \(Swift.String(describing: tags)), volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension UpdateSnapshotScheduleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recurrenceInHours = recurrenceInHours {
            try encodeContainer.encode(recurrenceInHours, forKey: .recurrenceInHours)
        }
        if let startAt = startAt {
            try encodeContainer.encode(startAt, forKey: .startAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct UpdateSnapshotScheduleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSnapshotScheduleOutputError>
}

public struct UpdateSnapshotScheduleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSnapshotScheduleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSnapshotScheduleOutputError>
}

public struct UpdateSnapshotScheduleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSnapshotScheduleInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateSnapshotScheduleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSnapshotScheduleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSnapshotScheduleOutputError>
}

/// A JSON object containing one or more of the following fields:
///
///
///
///
///                   UpdateSnapshotScheduleInput$Description
///
///
///
///
///                   UpdateSnapshotScheduleInput$RecurrenceInHours
///
///
///
///
///                   UpdateSnapshotScheduleInput$StartAt
///
///
///
///
///                   UpdateSnapshotScheduleInput$VolumeARN
///
///
///
public struct UpdateSnapshotScheduleInput: Swift.Equatable {
    /// Optional description of the snapshot that overwrites the existing description.
    public var description: Swift.String?
    /// Frequency of snapshots. Specify the number of hours between snapshots.
    /// This member is required.
    public var recurrenceInHours: Swift.Int?
    /// The hour of the day at which the snapshot schedule begins represented as
    ///             hh, where hh is the hour (0 to 23). The hour
    ///          of the day is in the time zone of the gateway.
    /// This member is required.
    public var startAt: Swift.Int?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
    ///          pair.
    ///
    ///
    ///             Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.
    ///
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes
    ///          operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        description: Swift.String? = nil,
        recurrenceInHours: Swift.Int? = nil,
        startAt: Swift.Int? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct UpdateSnapshotScheduleInputBody: Swift.Equatable {
    public let volumeARN: Swift.String?
    public let startAt: Swift.Int?
    public let recurrenceInHours: Swift.Int?
    public let description: Swift.String?
    public let tags: [StorageGatewayClientTypes.Tag]?
}

extension UpdateSnapshotScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let startAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startAt)
        startAt = startAtDecoded
        let recurrenceInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recurrenceInHours)
        recurrenceInHours = recurrenceInHoursDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSnapshotScheduleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSnapshotScheduleOutputResponse(volumeARN: \(Swift.String(describing: volumeARN)))"}
}

extension UpdateSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the updated storage
///          volume.
public struct UpdateSnapshotScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes
    ///          operation to return a list of gateway volumes.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct UpdateSnapshotScheduleOutputResponseBody: Swift.Equatable {
    public let volumeARN: Swift.String?
}

extension UpdateSnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

public struct UpdateVTLDeviceTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVTLDeviceTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVTLDeviceTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVTLDeviceTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVTLDeviceTypeOutputError>
}

extension UpdateVTLDeviceTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVTLDeviceTypeInput(deviceType: \(Swift.String(describing: deviceType)), vTLDeviceARN: \(Swift.String(describing: vTLDeviceARN)))"}
}

extension UpdateVTLDeviceTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceType = "DeviceType"
        case vTLDeviceARN = "VTLDeviceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let vTLDeviceARN = vTLDeviceARN {
            try encodeContainer.encode(vTLDeviceARN, forKey: .vTLDeviceARN)
        }
    }
}

public struct UpdateVTLDeviceTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVTLDeviceTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVTLDeviceTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVTLDeviceTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVTLDeviceTypeOutputError>
}

public struct UpdateVTLDeviceTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVTLDeviceTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVTLDeviceTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVTLDeviceTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVTLDeviceTypeOutputError>
}

public struct UpdateVTLDeviceTypeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVTLDeviceTypeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateVTLDeviceTypeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVTLDeviceTypeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVTLDeviceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVTLDeviceTypeOutputError>
}

public struct UpdateVTLDeviceTypeInput: Swift.Equatable {
    /// The type of medium changer you want to select.
    ///
    ///          Valid Values: STK-L700 | AWS-Gateway-VTL |
    ///             IBM-03584L32-0402
    ///
    /// This member is required.
    public var deviceType: Swift.String?
    /// The Amazon Resource Name (ARN) of the medium changer you want to select.
    /// This member is required.
    public var vTLDeviceARN: Swift.String?

    public init (
        deviceType: Swift.String? = nil,
        vTLDeviceARN: Swift.String? = nil
    )
    {
        self.deviceType = deviceType
        self.vTLDeviceARN = vTLDeviceARN
    }
}

struct UpdateVTLDeviceTypeInputBody: Swift.Equatable {
    public let vTLDeviceARN: Swift.String?
    public let deviceType: Swift.String?
}

extension UpdateVTLDeviceTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceType = "DeviceType"
        case vTLDeviceARN = "VTLDeviceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vTLDeviceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vTLDeviceARN)
        vTLDeviceARN = vTLDeviceARNDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
    }
}

extension UpdateVTLDeviceTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVTLDeviceTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVTLDeviceTypeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVTLDeviceTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVTLDeviceTypeOutputResponse(vTLDeviceARN: \(Swift.String(describing: vTLDeviceARN)))"}
}

extension UpdateVTLDeviceTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVTLDeviceTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vTLDeviceARN = output.vTLDeviceARN
        } else {
            self.vTLDeviceARN = nil
        }
    }
}

/// UpdateVTLDeviceTypeOutput
public struct UpdateVTLDeviceTypeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the medium changer you have selected.
    public var vTLDeviceARN: Swift.String?

    public init (
        vTLDeviceARN: Swift.String? = nil
    )
    {
        self.vTLDeviceARN = vTLDeviceARN
    }
}

struct UpdateVTLDeviceTypeOutputResponseBody: Swift.Equatable {
    public let vTLDeviceARN: Swift.String?
}

extension UpdateVTLDeviceTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vTLDeviceARN = "VTLDeviceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vTLDeviceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vTLDeviceARN)
        vTLDeviceARN = vTLDeviceARNDecoded
    }
}

extension StorageGatewayClientTypes.VTLDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceiSCSIAttributes = "DeviceiSCSIAttributes"
        case vTLDeviceARN = "VTLDeviceARN"
        case vTLDeviceProductIdentifier = "VTLDeviceProductIdentifier"
        case vTLDeviceType = "VTLDeviceType"
        case vTLDeviceVendor = "VTLDeviceVendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceiSCSIAttributes = deviceiSCSIAttributes {
            try encodeContainer.encode(deviceiSCSIAttributes, forKey: .deviceiSCSIAttributes)
        }
        if let vTLDeviceARN = vTLDeviceARN {
            try encodeContainer.encode(vTLDeviceARN, forKey: .vTLDeviceARN)
        }
        if let vTLDeviceProductIdentifier = vTLDeviceProductIdentifier {
            try encodeContainer.encode(vTLDeviceProductIdentifier, forKey: .vTLDeviceProductIdentifier)
        }
        if let vTLDeviceType = vTLDeviceType {
            try encodeContainer.encode(vTLDeviceType, forKey: .vTLDeviceType)
        }
        if let vTLDeviceVendor = vTLDeviceVendor {
            try encodeContainer.encode(vTLDeviceVendor, forKey: .vTLDeviceVendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vTLDeviceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vTLDeviceARN)
        vTLDeviceARN = vTLDeviceARNDecoded
        let vTLDeviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vTLDeviceType)
        vTLDeviceType = vTLDeviceTypeDecoded
        let vTLDeviceVendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vTLDeviceVendor)
        vTLDeviceVendor = vTLDeviceVendorDecoded
        let vTLDeviceProductIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vTLDeviceProductIdentifier)
        vTLDeviceProductIdentifier = vTLDeviceProductIdentifierDecoded
        let deviceiSCSIAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.DeviceiSCSIAttributes.self, forKey: .deviceiSCSIAttributes)
        deviceiSCSIAttributes = deviceiSCSIAttributesDecoded
    }
}

extension StorageGatewayClientTypes.VTLDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VTLDevice(deviceiSCSIAttributes: \(Swift.String(describing: deviceiSCSIAttributes)), vTLDeviceARN: \(Swift.String(describing: vTLDeviceARN)), vTLDeviceProductIdentifier: \(Swift.String(describing: vTLDeviceProductIdentifier)), vTLDeviceType: \(Swift.String(describing: vTLDeviceType)), vTLDeviceVendor: \(Swift.String(describing: vTLDeviceVendor)))"}
}

extension StorageGatewayClientTypes {
    /// Represents a device object associated with a tape gateway.
    public struct VTLDevice: Swift.Equatable {
        /// A list of iSCSI information about a VTL device.
        public var deviceiSCSIAttributes: StorageGatewayClientTypes.DeviceiSCSIAttributes?
        /// Specifies the unique Amazon Resource Name (ARN) of the device (tape drive or media
        ///          changer).
        public var vTLDeviceARN: Swift.String?
        /// Specifies the model number of device that the VTL device emulates.
        public var vTLDeviceProductIdentifier: Swift.String?
        /// Specifies the type of device that the VTL device emulates.
        public var vTLDeviceType: Swift.String?
        /// Specifies the vendor of the device that the VTL device object emulates.
        public var vTLDeviceVendor: Swift.String?

        public init (
            deviceiSCSIAttributes: StorageGatewayClientTypes.DeviceiSCSIAttributes? = nil,
            vTLDeviceARN: Swift.String? = nil,
            vTLDeviceProductIdentifier: Swift.String? = nil,
            vTLDeviceType: Swift.String? = nil,
            vTLDeviceVendor: Swift.String? = nil
        )
        {
            self.deviceiSCSIAttributes = deviceiSCSIAttributes
            self.vTLDeviceARN = vTLDeviceARN
            self.vTLDeviceProductIdentifier = vTLDeviceProductIdentifier
            self.vTLDeviceType = vTLDeviceType
            self.vTLDeviceVendor = vTLDeviceVendor
        }
    }

}

extension StorageGatewayClientTypes.VolumeInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case gatewayId = "GatewayId"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeId = "VolumeId"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
    }
}

extension StorageGatewayClientTypes.VolumeInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VolumeInfo(gatewayARN: \(Swift.String(describing: gatewayARN)), gatewayId: \(Swift.String(describing: gatewayId)), volumeARN: \(Swift.String(describing: volumeARN)), volumeAttachmentStatus: \(Swift.String(describing: volumeAttachmentStatus)), volumeId: \(Swift.String(describing: volumeId)), volumeSizeInBytes: \(Swift.String(describing: volumeSizeInBytes)), volumeType: \(Swift.String(describing: volumeType)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a storage volume object.
    public struct VolumeInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
        ///          operation to return a list of gateways for your account and Region.
        public var gatewayARN: Swift.String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part
        ///          of the gateway Amazon Resource Name (ARN), which you use as input for other
        ///          operations.
        ///
        ///          Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var gatewayId: Swift.String?
        /// The Amazon Resource Name (ARN) for the storage volume. For example, the following is a
        ///          valid ARN:
        ///
        ///
        ///             arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/volume/vol-1122AABB
        ///
        ///
        ///          Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeARN: Swift.String?
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeAttachmentStatus: Swift.String?
        /// The unique identifier assigned to the volume. This ID becomes part of the volume Amazon
        ///          Resource Name (ARN), which you use as input for other operations.
        ///
        ///          Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeId: Swift.String?
        /// The size of the volume in bytes.
        ///
        ///          Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeType enumeration values describing the type of the volume.
        public var volumeType: Swift.String?

        public init (
            gatewayARN: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeType: Swift.String? = nil
        )
        {
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeType = volumeType
        }
    }

}

extension StorageGatewayClientTypes.VolumeRecoveryPointInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
        case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeUsageInBytes = "VolumeUsageInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeRecoveryPointTime = volumeRecoveryPointTime {
            try encodeContainer.encode(volumeRecoveryPointTime, forKey: .volumeRecoveryPointTime)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if volumeUsageInBytes != 0 {
            try encodeContainer.encode(volumeUsageInBytes, forKey: .volumeUsageInBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeUsageInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeUsageInBytes)
        volumeUsageInBytes = volumeUsageInBytesDecoded
        let volumeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeRecoveryPointTime)
        volumeRecoveryPointTime = volumeRecoveryPointTimeDecoded
    }
}

extension StorageGatewayClientTypes.VolumeRecoveryPointInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VolumeRecoveryPointInfo(volumeARN: \(Swift.String(describing: volumeARN)), volumeRecoveryPointTime: \(Swift.String(describing: volumeRecoveryPointTime)), volumeSizeInBytes: \(Swift.String(describing: volumeSizeInBytes)), volumeUsageInBytes: \(Swift.String(describing: volumeUsageInBytes)))"}
}

extension StorageGatewayClientTypes {
    /// Describes a storage volume recovery point object.
    public struct VolumeRecoveryPointInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the volume target.
        public var volumeARN: Swift.String?
        /// The time the recovery point was taken.
        public var volumeRecoveryPointTime: Swift.String?
        /// The size of the volume in bytes.
        public var volumeSizeInBytes: Swift.Int
        /// The size of the data stored on the volume in bytes.
        ///
        ///
        ///             This value is not available for volumes created prior to May 13, 2015, until you
        ///             store data on the volume.
        ///
        public var volumeUsageInBytes: Swift.Int

        public init (
            volumeARN: Swift.String? = nil,
            volumeRecoveryPointTime: Swift.String? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeUsageInBytes: Swift.Int = 0
        )
        {
            self.volumeARN = volumeARN
            self.volumeRecoveryPointTime = volumeRecoveryPointTime
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeUsageInBytes = volumeUsageInBytes
        }
    }

}

extension StorageGatewayClientTypes.VolumeiSCSIAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chapEnabled = "ChapEnabled"
        case lunNumber = "LunNumber"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfacePort = "NetworkInterfacePort"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if chapEnabled != false {
            try encodeContainer.encode(chapEnabled, forKey: .chapEnabled)
        }
        if let lunNumber = lunNumber {
            try encodeContainer.encode(lunNumber, forKey: .lunNumber)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if networkInterfacePort != 0 {
            try encodeContainer.encode(networkInterfacePort, forKey: .networkInterfacePort)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfacePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .networkInterfacePort)
        networkInterfacePort = networkInterfacePortDecoded
        let lunNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lunNumber)
        lunNumber = lunNumberDecoded
        let chapEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .chapEnabled)
        chapEnabled = chapEnabledDecoded
    }
}

extension StorageGatewayClientTypes.VolumeiSCSIAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VolumeiSCSIAttributes(chapEnabled: \(Swift.String(describing: chapEnabled)), lunNumber: \(Swift.String(describing: lunNumber)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), networkInterfacePort: \(Swift.String(describing: networkInterfacePort)), targetARN: \(Swift.String(describing: targetARN)))"}
}

extension StorageGatewayClientTypes {
    /// Lists iSCSI information about a volume.
    public struct VolumeiSCSIAttributes: Swift.Equatable {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public var chapEnabled: Swift.Bool
        /// The logical disk number.
        public var lunNumber: Swift.Int?
        /// The network interface identifier.
        public var networkInterfaceId: Swift.String?
        /// The port used to communicate with iSCSI targets.
        public var networkInterfacePort: Swift.Int
        /// The Amazon Resource Name (ARN) of the volume target.
        public var targetARN: Swift.String?

        public init (
            chapEnabled: Swift.Bool = false,
            lunNumber: Swift.Int? = nil,
            networkInterfaceId: Swift.String? = nil,
            networkInterfacePort: Swift.Int = 0,
            targetARN: Swift.String? = nil
        )
        {
            self.chapEnabled = chapEnabled
            self.lunNumber = lunNumber
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }
    }

}
