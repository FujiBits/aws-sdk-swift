// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct ActivateEventSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateEventSourceOutputError>
}

extension ActivateEventSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateEventSourceInput(name: \(Swift.String(describing: name)))"}
}

extension ActivateEventSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct ActivateEventSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateEventSourceOutputError>
}

public struct ActivateEventSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateEventSourceOutputError>
}

public struct ActivateEventSourceInput: Swift.Equatable {
    /// <p>The name of the partner event source to activate.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct ActivateEventSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension ActivateEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ActivateEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateEventSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateEventSourceOutputResponse()"}
}

extension ActivateEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ActivateEventSourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct ActivateEventSourceOutputResponseBody: Swift.Equatable {
}

extension ActivateEventSourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudWatchEventsClientTypes.ApiDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case connectionArn = "ConnectionArn"
        case creationTime = "CreationTime"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDestinationArn = apiDestinationArn {
            try encodeContainer.encode(apiDestinationArn, forKey: .apiDestinationArn)
        }
        if let apiDestinationState = apiDestinationState {
            try encodeContainer.encode(apiDestinationState.rawValue, forKey: .apiDestinationState)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension CloudWatchEventsClientTypes.ApiDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiDestination(apiDestinationArn: \(Swift.String(describing: apiDestinationArn)), apiDestinationState: \(Swift.String(describing: apiDestinationState)), connectionArn: \(Swift.String(describing: connectionArn)), creationTime: \(Swift.String(describing: creationTime)), httpMethod: \(Swift.String(describing: httpMethod)), invocationEndpoint: \(Swift.String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(Swift.String(describing: invocationRateLimitPerSecond)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains details about an API destination.</p>
    public struct ApiDestination: Swift.Equatable {
        /// <p>The ARN of the API destination.</p>
        public let apiDestinationArn: Swift.String?
        /// <p>The state of the API destination.</p>
        public let apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState?
        /// <p>The ARN of the connection specified for the API destination.</p>
        public let connectionArn: Swift.String?
        /// <p>A time stamp for the time that the API destination was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The method to use to connect to the HTTP endpoint.</p>
        public let httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod?
        /// <p>The URL to the endpoint for the API destination.</p>
        public let invocationEndpoint: Swift.String?
        /// <p>The maximum number of invocations per second to send to the HTTP endpoint.</p>
        public let invocationRateLimitPerSecond: Swift.Int?
        /// <p>A time stamp for the time that the API destination was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>The name of the API destination.</p>
        public let name: Swift.String?

        public init (
            apiDestinationArn: Swift.String? = nil,
            apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState? = nil,
            connectionArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod? = nil,
            invocationEndpoint: Swift.String? = nil,
            invocationRateLimitPerSecond: Swift.Int? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.apiDestinationArn = apiDestinationArn
            self.apiDestinationState = apiDestinationState
            self.connectionArn = connectionArn
            self.creationTime = creationTime
            self.httpMethod = httpMethod
            self.invocationEndpoint = invocationEndpoint
            self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum ApiDestinationHttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiDestinationHttpMethod] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiDestinationHttpMethod(rawValue: rawValue) ?? ApiDestinationHttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes {
    public enum ApiDestinationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiDestinationState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiDestinationState(rawValue: rawValue) ?? ApiDestinationState.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes.Archive: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case creationTime = "CreationTime"
        case eventCount = "EventCount"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
        case sizeBytes = "SizeBytes"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if eventCount != 0 {
            try encodeContainer.encode(eventCount, forKey: .eventCount)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
        if sizeBytes != 0 {
            try encodeContainer.encode(sizeBytes, forKey: .sizeBytes)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
        let sizeBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let eventCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .eventCount)
        eventCount = eventCountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CloudWatchEventsClientTypes.Archive: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Archive(archiveName: \(Swift.String(describing: archiveName)), creationTime: \(Swift.String(describing: creationTime)), eventCount: \(Swift.String(describing: eventCount)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), retentionDays: \(Swift.String(describing: retentionDays)), sizeBytes: \(Swift.String(describing: sizeBytes)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>An <code>Archive</code> object that contains details about an archive.</p>
    public struct Archive: Swift.Equatable {
        /// <p>The name of the archive.</p>
        public let archiveName: Swift.String?
        /// <p>The time stamp for the time that the archive was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The number of events in the archive.</p>
        public let eventCount: Swift.Int
        /// <p>The ARN of the event bus associated with the archive. Only events from this event bus are
        ///       sent to the archive.</p>
        public let eventSourceArn: Swift.String?
        /// <p>The number of days to retain events in the archive before they are deleted.</p>
        public let retentionDays: Swift.Int?
        /// <p>The size of the archive, in bytes.</p>
        public let sizeBytes: Swift.Int
        /// <p>The current state of the archive.</p>
        public let state: CloudWatchEventsClientTypes.ArchiveState?
        /// <p>A description for the reason that the archive is in the current state.</p>
        public let stateReason: Swift.String?

        public init (
            archiveName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            eventCount: Swift.Int = 0,
            eventSourceArn: Swift.String? = nil,
            retentionDays: Swift.Int? = nil,
            sizeBytes: Swift.Int = 0,
            state: CloudWatchEventsClientTypes.ArchiveState? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.archiveName = archiveName
            self.creationTime = creationTime
            self.eventCount = eventCount
            self.eventSourceArn = eventSourceArn
            self.retentionDays = retentionDays
            self.sizeBytes = sizeBytes
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum ArchiveState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case creating
        case disabled
        case enabled
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ArchiveState] {
            return [
                .createFailed,
                .creating,
                .disabled,
                .enabled,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArchiveState(rawValue: rawValue) ?? ArchiveState.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes {
    public enum AssignPublicIp: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignPublicIp] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignPublicIp(rawValue: rawValue) ?? AssignPublicIp.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes.AwsVpcConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp = "AssignPublicIp"
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignPublicIp = assignPublicIp {
            try encodeContainer.encode(assignPublicIp.rawValue, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for stringlist0 in securityGroups {
                try securityGroupsContainer.encode(stringlist0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for stringlist0 in subnets {
                try subnetsContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.AssignPublicIp.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension CloudWatchEventsClientTypes.AwsVpcConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsVpcConfiguration(assignPublicIp: \(Swift.String(describing: assignPublicIp)), securityGroups: \(Swift.String(describing: securityGroups)), subnets: \(Swift.String(describing: subnets)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>This structure specifies the VPC subnets and security groups for the task, and whether a
    ///       public IP address is to be used. This structure is relevant only for ECS tasks that use the
    ///         <code>awsvpc</code> network mode.</p>
    public struct AwsVpcConfiguration: Swift.Equatable {
        /// <p>Specifies whether the task's elastic network interface receives a public IP address. You
        ///       can specify <code>ENABLED</code> only when <code>LaunchType</code> in
        ///         <code>EcsParameters</code> is set to <code>FARGATE</code>.</p>
        public let assignPublicIp: CloudWatchEventsClientTypes.AssignPublicIp?
        /// <p>Specifies the security groups associated with the task. These security groups must all be
        ///       in the same VPC. You can specify as many as five security groups. If you do not specify a
        ///       security group, the default security group for the VPC is used.</p>
        public let securityGroups: [Swift.String]?
        /// <p>Specifies the subnets associated with the task. These subnets must all be in the same VPC.
        ///       You can specify as many as 16 subnets.</p>
        public let subnets: [Swift.String]?

        public init (
            assignPublicIp: CloudWatchEventsClientTypes.AssignPublicIp? = nil,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension CloudWatchEventsClientTypes.BatchArrayProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension CloudWatchEventsClientTypes.BatchArrayProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchArrayProperties(size: \(Swift.String(describing: size)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>The array properties for the submitted job, such as the size of the array. The array size
    ///       can be between 2 and 10,000. If you specify array properties for a job, it becomes an array
    ///       job. This parameter is used only if the target is an AWS Batch job.</p>
    public struct BatchArrayProperties: Swift.Equatable {
        /// <p>The size of the array, if this is an array batch job. Valid values are integers between 2
        ///       and 10,000.</p>
        public let size: Swift.Int

        public init (
            size: Swift.Int = 0
        )
        {
            self.size = size
        }
    }

}

extension CloudWatchEventsClientTypes.BatchParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayProperties = "ArrayProperties"
        case jobDefinition = "JobDefinition"
        case jobName = "JobName"
        case retryStrategy = "RetryStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayProperties = arrayProperties {
            try encodeContainer.encode(arrayProperties, forKey: .arrayProperties)
        }
        if let jobDefinition = jobDefinition {
            try encodeContainer.encode(jobDefinition, forKey: .jobDefinition)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let retryStrategy = retryStrategy {
            try encodeContainer.encode(retryStrategy, forKey: .retryStrategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobDefinition)
        jobDefinition = jobDefinitionDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let arrayPropertiesDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.BatchArrayProperties.self, forKey: .arrayProperties)
        arrayProperties = arrayPropertiesDecoded
        let retryStrategyDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.BatchRetryStrategy.self, forKey: .retryStrategy)
        retryStrategy = retryStrategyDecoded
    }
}

extension CloudWatchEventsClientTypes.BatchParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchParameters(arrayProperties: \(Swift.String(describing: arrayProperties)), jobDefinition: \(Swift.String(describing: jobDefinition)), jobName: \(Swift.String(describing: jobName)), retryStrategy: \(Swift.String(describing: retryStrategy)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>The custom parameters to be used when the target is an AWS Batch job.</p>
    public struct BatchParameters: Swift.Equatable {
        /// <p>The array properties for the submitted job, such as the size of the array. The array size
        ///       can be between 2 and 10,000. If you specify array properties for a job, it becomes an array
        ///       job. This parameter is used only if the target is an AWS Batch job.</p>
        public let arrayProperties: CloudWatchEventsClientTypes.BatchArrayProperties?
        /// <p>The ARN or name of the job definition to use if the event target is an AWS Batch job. This
        ///       job definition must already exist.</p>
        public let jobDefinition: Swift.String?
        /// <p>The name to use for this execution of the job, if the target is an AWS Batch job.</p>
        public let jobName: Swift.String?
        /// <p>The retry strategy to use for failed jobs, if the target is an AWS Batch job. The retry
        ///       strategy is the number of times to retry the failed job execution. Valid values are 1–10. When
        ///       you specify a retry strategy here, it overrides the retry strategy defined in the job
        ///       definition.</p>
        public let retryStrategy: CloudWatchEventsClientTypes.BatchRetryStrategy?

        public init (
            arrayProperties: CloudWatchEventsClientTypes.BatchArrayProperties? = nil,
            jobDefinition: Swift.String? = nil,
            jobName: Swift.String? = nil,
            retryStrategy: CloudWatchEventsClientTypes.BatchRetryStrategy? = nil
        )
        {
            self.arrayProperties = arrayProperties
            self.jobDefinition = jobDefinition
            self.jobName = jobName
            self.retryStrategy = retryStrategy
        }
    }

}

extension CloudWatchEventsClientTypes.BatchRetryStrategy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attempts = "Attempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attempts != 0 {
            try encodeContainer.encode(attempts, forKey: .attempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attemptsDecoded = try containerValues.decode(Swift.Int.self, forKey: .attempts)
        attempts = attemptsDecoded
    }
}

extension CloudWatchEventsClientTypes.BatchRetryStrategy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchRetryStrategy(attempts: \(Swift.String(describing: attempts)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>The retry strategy to use for failed jobs, if the target is an AWS Batch job. If you
    ///       specify a retry strategy here, it overrides the retry strategy defined in the job
    ///       definition.</p>
    public struct BatchRetryStrategy: Swift.Equatable {
        /// <p>The number of times to attempt to retry, if the job fails. Valid values are 1–10.</p>
        public let attempts: Swift.Int

        public init (
            attempts: Swift.Int = 0
        )
        {
            self.attempts = attempts
        }
    }

}

public struct CancelReplayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelReplayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelReplayOutputError>
}

extension CancelReplayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelReplayInput(replayName: \(Swift.String(describing: replayName)))"}
}

extension CancelReplayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

public struct CancelReplayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelReplayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelReplayOutputError>
}

public struct CancelReplayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelReplayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelReplayOutputError>
}

public struct CancelReplayInput: Swift.Equatable {
    /// <p>The name of the replay to cancel.</p>
    public let replayName: Swift.String?

    public init (
        replayName: Swift.String? = nil
    )
    {
        self.replayName = replayName
    }
}

struct CancelReplayInputBody: Swift.Equatable {
    public let replayName: Swift.String?
}

extension CancelReplayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
    }
}

extension CancelReplayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelReplayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalStatusException" : self = .illegalStatusException(try IllegalStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelReplayOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case illegalStatusException(IllegalStatusException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelReplayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelReplayOutputResponse(replayArn: \(Swift.String(describing: replayArn)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension CancelReplayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelReplayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replayArn = output.replayArn
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.replayArn = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct CancelReplayOutputResponse: Swift.Equatable {
    /// <p>The ARN of the replay to cancel.</p>
    public let replayArn: Swift.String?
    /// <p>The current state of the replay.</p>
    public let state: CloudWatchEventsClientTypes.ReplayState?
    /// <p>The reason that the replay is in the current state.</p>
    public let stateReason: Swift.String?

    public init (
        replayArn: Swift.String? = nil,
        state: CloudWatchEventsClientTypes.ReplayState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.replayArn = replayArn
        self.state = state
        self.stateReason = stateReason
    }
}

struct CancelReplayOutputResponseBody: Swift.Equatable {
    public let replayArn: Swift.String?
    public let state: CloudWatchEventsClientTypes.ReplayState?
    public let stateReason: Swift.String?
}

extension CancelReplayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayArn = "ReplayArn"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
    }
}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is concurrent modification on a rule, target, archive, or replay.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchEventsClientTypes.Condition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudWatchEventsClientTypes.Condition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Condition(key: \(Swift.String(describing: key)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A JSON string which you can use to limit the event bus permissions you are granting to
    ///       only accounts that fulfill the condition. Currently, the only supported condition is
    ///       membership in a certain AWS organization. The string must contain <code>Type</code>,
    ///         <code>Key</code>, and <code>Value</code> fields. The <code>Value</code> field specifies the
    ///       ID of the AWS organization. Following is an example value for <code>Condition</code>:</p>
    ///          <p>
    ///             <code>'{"Type" : "StringEquals", "Key": "aws:PrincipalOrgID", "Value":
    ///         "o-1234567890"}'</code>
    ///          </p>
    public struct Condition: Swift.Equatable {
        /// <p>Specifies the key for the condition. Currently the only supported key is
        ///         <code>aws:PrincipalOrgID</code>.</p>
        public let key: Swift.String?
        /// <p>Specifies the type of condition. Currently the only supported value is
        ///         <code>StringEquals</code>.</p>
        public let type: Swift.String?
        /// <p>Specifies the value for the key. Currently, this must be the ID of the
        ///       organization.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.type = type
            self.value = value
        }
    }

}

extension CloudWatchEventsClientTypes.Connection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationType = "AuthorizationType"
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastAuthorizedTime = lastAuthorizedTime {
            try encodeContainer.encode(lastAuthorizedTime.timeIntervalSince1970, forKey: .lastAuthorizedTime)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

extension CloudWatchEventsClientTypes.Connection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connection(authorizationType: \(Swift.String(describing: authorizationType)), connectionArn: \(Swift.String(describing: connectionArn)), connectionState: \(Swift.String(describing: connectionState)), creationTime: \(Swift.String(describing: creationTime)), lastAuthorizedTime: \(Swift.String(describing: lastAuthorizedTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains information about a connection.</p>
    public struct Connection: Swift.Equatable {
        /// <p>The authorization type specified for the connection.</p>
        public let authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType?
        /// <p>The ARN of the connection.</p>
        public let connectionArn: Swift.String?
        /// <p>The state of the connection.</p>
        public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
        /// <p>A time stamp for the time that the connection was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>A time stamp for the time that the connection was last authorized.</p>
        public let lastAuthorizedTime: ClientRuntime.Date?
        /// <p>A time stamp for the time that the connection was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>The name of the connection.</p>
        public let name: Swift.String?
        /// <p>The reason that the connection is in the connection state.</p>
        public let stateReason: Swift.String?

        public init (
            authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType? = nil,
            connectionArn: Swift.String? = nil,
            connectionState: CloudWatchEventsClientTypes.ConnectionState? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastAuthorizedTime: ClientRuntime.Date? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.authorizationType = authorizationType
            self.connectionArn = connectionArn
            self.connectionState = connectionState
            self.creationTime = creationTime
            self.lastAuthorizedTime = lastAuthorizedTime
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.stateReason = stateReason
        }
    }

}

extension CloudWatchEventsClientTypes.ConnectionApiKeyAuthResponseParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyName = "ApiKeyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionApiKeyAuthResponseParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionApiKeyAuthResponseParameters(apiKeyName: \(Swift.String(describing: apiKeyName)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the authorization parameters for the connection if API Key is specified as the
    ///       authorization type.</p>
    public struct ConnectionApiKeyAuthResponseParameters: Swift.Equatable {
        /// <p>The name of the header to use for the <code>APIKeyValue</code> used for authorization.</p>
        public let apiKeyName: Swift.String?

        public init (
            apiKeyName: Swift.String? = nil
        )
        {
            self.apiKeyName = apiKeyName
        }
    }

}

extension CloudWatchEventsClientTypes.ConnectionAuthResponseParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionBasicAuthResponseParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionOAuthResponseParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionApiKeyAuthResponseParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionAuthResponseParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionAuthResponseParameters(apiKeyAuthParameters: \(Swift.String(describing: apiKeyAuthParameters)), basicAuthParameters: \(Swift.String(describing: basicAuthParameters)), invocationHttpParameters: \(Swift.String(describing: invocationHttpParameters)), oAuthParameters: \(Swift.String(describing: oAuthParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the authorization parameters to use for the connection.</p>
    public struct ConnectionAuthResponseParameters: Swift.Equatable {
        /// <p>The API Key parameters to use for authorization.</p>
        public let apiKeyAuthParameters: CloudWatchEventsClientTypes.ConnectionApiKeyAuthResponseParameters?
        /// <p>The authorization parameters for Basic authorization.</p>
        public let basicAuthParameters: CloudWatchEventsClientTypes.ConnectionBasicAuthResponseParameters?
        /// <p>Additional parameters for the connection that are passed through with every invocation to
        ///       the HTTP endpoint.</p>
        public let invocationHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters?
        /// <p>The OAuth parameters to use for authorization.</p>
        public let oAuthParameters: CloudWatchEventsClientTypes.ConnectionOAuthResponseParameters?

        public init (
            apiKeyAuthParameters: CloudWatchEventsClientTypes.ConnectionApiKeyAuthResponseParameters? = nil,
            basicAuthParameters: CloudWatchEventsClientTypes.ConnectionBasicAuthResponseParameters? = nil,
            invocationHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters? = nil,
            oAuthParameters: CloudWatchEventsClientTypes.ConnectionOAuthResponseParameters? = nil
        )
        {
            self.apiKeyAuthParameters = apiKeyAuthParameters
            self.basicAuthParameters = basicAuthParameters
            self.invocationHttpParameters = invocationHttpParameters
            self.oAuthParameters = oAuthParameters
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum ConnectionAuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiKey
        case basic
        case oauthClientCredentials
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionAuthorizationType] {
            return [
                .apiKey,
                .basic,
                .oauthClientCredentials,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiKey: return "API_KEY"
            case .basic: return "BASIC"
            case .oauthClientCredentials: return "OAUTH_CLIENT_CREDENTIALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionAuthorizationType(rawValue: rawValue) ?? ConnectionAuthorizationType.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes.ConnectionBasicAuthResponseParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionBasicAuthResponseParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionBasicAuthResponseParameters(username: \(Swift.String(describing: username)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the authorization parameters for the connection if Basic is specified as the
    ///       authorization type.</p>
    public struct ConnectionBasicAuthResponseParameters: Swift.Equatable {
        /// <p>The user name to use for Basic authorization.</p>
        public let username: Swift.String?

        public init (
            username: Swift.String? = nil
        )
        {
            self.username = username
        }
    }

}

extension CloudWatchEventsClientTypes.ConnectionBodyParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isValueSecret)
        isValueSecret = isValueSecretDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionBodyParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionBodyParameter(isValueSecret: \(Swift.String(describing: isValueSecret)), key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Additional parameter included in the body. You can include up to 100 additional body
    ///       parameters per request. An event payload cannot exceed 64 KB.</p>
    public struct ConnectionBodyParameter: Swift.Equatable {
        /// <p>Specified whether the value is secret.</p>
        public let isValueSecret: Swift.Bool
        /// <p>The key for the parameter.</p>
        public let key: Swift.String?
        /// <p>The value associated with the key.</p>
        public let value: Swift.String?

        public init (
            isValueSecret: Swift.Bool = false,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.isValueSecret = isValueSecret
            self.key = key
            self.value = value
        }
    }

}

extension CloudWatchEventsClientTypes.ConnectionHeaderParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isValueSecret)
        isValueSecret = isValueSecretDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionHeaderParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionHeaderParameter(isValueSecret: \(Swift.String(describing: isValueSecret)), key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Additional parameter included in the header. You can include up to 100 additional header
    ///       parameters per request. An event payload cannot exceed 64 KB.</p>
    public struct ConnectionHeaderParameter: Swift.Equatable {
        /// <p>Specified whether the value is a secret.</p>
        public let isValueSecret: Swift.Bool
        /// <p>The key for the parameter.</p>
        public let key: Swift.String?
        /// <p>The value associated with the key.</p>
        public let value: Swift.String?

        public init (
            isValueSecret: Swift.Bool = false,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.isValueSecret = isValueSecret
            self.key = key
            self.value = value
        }
    }

}

extension CloudWatchEventsClientTypes.ConnectionHttpParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bodyParameters = "BodyParameters"
        case headerParameters = "HeaderParameters"
        case queryStringParameters = "QueryStringParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bodyParameters = bodyParameters {
            var bodyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bodyParameters)
            for connectionbodyparameterslist0 in bodyParameters {
                try bodyParametersContainer.encode(connectionbodyparameterslist0)
            }
        }
        if let headerParameters = headerParameters {
            var headerParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerParameters)
            for connectionheaderparameterslist0 in headerParameters {
                try headerParametersContainer.encode(connectionheaderparameterslist0)
            }
        }
        if let queryStringParameters = queryStringParameters {
            var queryStringParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryStringParameters)
            for connectionquerystringparameterslist0 in queryStringParameters {
                try queryStringParametersContainer.encode(connectionquerystringparameterslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerParametersContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.ConnectionHeaderParameter?].self, forKey: .headerParameters)
        var headerParametersDecoded0:[CloudWatchEventsClientTypes.ConnectionHeaderParameter]? = nil
        if let headerParametersContainer = headerParametersContainer {
            headerParametersDecoded0 = [CloudWatchEventsClientTypes.ConnectionHeaderParameter]()
            for structure0 in headerParametersContainer {
                if let structure0 = structure0 {
                    headerParametersDecoded0?.append(structure0)
                }
            }
        }
        headerParameters = headerParametersDecoded0
        let queryStringParametersContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.ConnectionQueryStringParameter?].self, forKey: .queryStringParameters)
        var queryStringParametersDecoded0:[CloudWatchEventsClientTypes.ConnectionQueryStringParameter]? = nil
        if let queryStringParametersContainer = queryStringParametersContainer {
            queryStringParametersDecoded0 = [CloudWatchEventsClientTypes.ConnectionQueryStringParameter]()
            for structure0 in queryStringParametersContainer {
                if let structure0 = structure0 {
                    queryStringParametersDecoded0?.append(structure0)
                }
            }
        }
        queryStringParameters = queryStringParametersDecoded0
        let bodyParametersContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.ConnectionBodyParameter?].self, forKey: .bodyParameters)
        var bodyParametersDecoded0:[CloudWatchEventsClientTypes.ConnectionBodyParameter]? = nil
        if let bodyParametersContainer = bodyParametersContainer {
            bodyParametersDecoded0 = [CloudWatchEventsClientTypes.ConnectionBodyParameter]()
            for structure0 in bodyParametersContainer {
                if let structure0 = structure0 {
                    bodyParametersDecoded0?.append(structure0)
                }
            }
        }
        bodyParameters = bodyParametersDecoded0
    }
}

extension CloudWatchEventsClientTypes.ConnectionHttpParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionHttpParameters(bodyParameters: \(Swift.String(describing: bodyParameters)), headerParameters: \(Swift.String(describing: headerParameters)), queryStringParameters: \(Swift.String(describing: queryStringParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains additional parameters for the connection.</p>
    public struct ConnectionHttpParameters: Swift.Equatable {
        /// <p>Contains additional body string parameters for the connection.</p>
        public let bodyParameters: [CloudWatchEventsClientTypes.ConnectionBodyParameter]?
        /// <p>Contains additional header parameters for the connection.</p>
        public let headerParameters: [CloudWatchEventsClientTypes.ConnectionHeaderParameter]?
        /// <p>Contains additional query string parameters for the connection.</p>
        public let queryStringParameters: [CloudWatchEventsClientTypes.ConnectionQueryStringParameter]?

        public init (
            bodyParameters: [CloudWatchEventsClientTypes.ConnectionBodyParameter]? = nil,
            headerParameters: [CloudWatchEventsClientTypes.ConnectionHeaderParameter]? = nil,
            queryStringParameters: [CloudWatchEventsClientTypes.ConnectionQueryStringParameter]? = nil
        )
        {
            self.bodyParameters = bodyParameters
            self.headerParameters = headerParameters
            self.queryStringParameters = queryStringParameters
        }
    }

}

extension CloudWatchEventsClientTypes.ConnectionOAuthClientResponseParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionOAuthClientResponseParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionOAuthClientResponseParameters(clientID: \(Swift.String(describing: clientID)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the client response parameters for the connection when OAuth is specified as the
    ///       authorization type.</p>
    public struct ConnectionOAuthClientResponseParameters: Swift.Equatable {
        /// <p>The client ID associated with the response to the connection request.</p>
        public let clientID: Swift.String?

        public init (
            clientID: Swift.String? = nil
        )
        {
            self.clientID = clientID
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum ConnectionOAuthHttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `get`
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionOAuthHttpMethod] {
            return [
                .get,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .get: return "GET"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionOAuthHttpMethod(rawValue: rawValue) ?? ConnectionOAuthHttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes.ConnectionOAuthResponseParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionOAuthClientResponseParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionOAuthResponseParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionOAuthResponseParameters(authorizationEndpoint: \(Swift.String(describing: authorizationEndpoint)), clientParameters: \(Swift.String(describing: clientParameters)), httpMethod: \(Swift.String(describing: httpMethod)), oAuthHttpParameters: \(Swift.String(describing: oAuthHttpParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the response parameters when OAuth is specified as the authorization type.</p>
    public struct ConnectionOAuthResponseParameters: Swift.Equatable {
        /// <p>The URL to the HTTP endpoint that authorized the request.</p>
        public let authorizationEndpoint: Swift.String?
        /// <p>A <code>ConnectionOAuthClientResponseParameters</code> object that contains details about
        ///       the client parameters returned when OAuth is specified as the authorization type.</p>
        public let clientParameters: CloudWatchEventsClientTypes.ConnectionOAuthClientResponseParameters?
        /// <p>The method used to connect to the HTTP endpoint.</p>
        public let httpMethod: CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod?
        /// <p>The additional HTTP parameters used for the OAuth authorization request.</p>
        public let oAuthHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters?

        public init (
            authorizationEndpoint: Swift.String? = nil,
            clientParameters: CloudWatchEventsClientTypes.ConnectionOAuthClientResponseParameters? = nil,
            httpMethod: CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod? = nil,
            oAuthHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters? = nil
        )
        {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientParameters = clientParameters
            self.httpMethod = httpMethod
            self.oAuthHttpParameters = oAuthHttpParameters
        }
    }

}

extension CloudWatchEventsClientTypes.ConnectionQueryStringParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isValueSecret)
        isValueSecret = isValueSecretDecoded
    }
}

extension CloudWatchEventsClientTypes.ConnectionQueryStringParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionQueryStringParameter(isValueSecret: \(Swift.String(describing: isValueSecret)), key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Additional query string parameter for the connection. You can include up to 100 additional
    ///       query string parameters per request. Each additional parameter counts towards the event
    ///       payload size, which cannot exceed 64 KB.</p>
    public struct ConnectionQueryStringParameter: Swift.Equatable {
        /// <p>Specifies whether the value is secret.</p>
        public let isValueSecret: Swift.Bool
        /// <p>The key for a query string parameter.</p>
        public let key: Swift.String?
        /// <p>The value associated with the key for the query string parameter.</p>
        public let value: Swift.String?

        public init (
            isValueSecret: Swift.Bool = false,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.isValueSecret = isValueSecret
            self.key = key
            self.value = value
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorized
        case authorizing
        case creating
        case deauthorized
        case deauthorizing
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .authorized,
                .authorizing,
                .creating,
                .deauthorized,
                .deauthorizing,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorized: return "AUTHORIZED"
            case .authorizing: return "AUTHORIZING"
            case .creating: return "CREATING"
            case .deauthorized: return "DEAUTHORIZED"
            case .deauthorizing: return "DEAUTHORIZING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

public struct CreateApiDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiDestinationOutputError>
}

extension CreateApiDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApiDestinationInput(connectionArn: \(Swift.String(describing: connectionArn)), description: \(Swift.String(describing: description)), httpMethod: \(Swift.String(describing: httpMethod)), invocationEndpoint: \(Swift.String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(Swift.String(describing: invocationRateLimitPerSecond)), name: \(Swift.String(describing: name)))"}
}

extension CreateApiDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateApiDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiDestinationOutputError>
}

public struct CreateApiDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApiDestinationOutputError>
}

public struct CreateApiDestinationInput: Swift.Equatable {
    /// <p>The ARN of the connection to use for the API destination. The destination endpoint must
    ///       support the authorization type specified for the connection.</p>
    public let connectionArn: Swift.String?
    /// <p>A description for the API destination to create.</p>
    public let description: Swift.String?
    /// <p>The method to use for the request to the HTTP invocation endpoint.</p>
    public let httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod?
    /// <p>The URL to the HTTP invocation endpoint for the API destination.</p>
    public let invocationEndpoint: Swift.String?
    /// <p>The maximum number of requests per second to send to the HTTP invocation endpoint.</p>
    public let invocationRateLimitPerSecond: Swift.Int?
    /// <p>The name for the API destination to create.</p>
    public let name: Swift.String?

    public init (
        connectionArn: Swift.String? = nil,
        description: Swift.String? = nil,
        httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod? = nil,
        invocationEndpoint: Swift.String? = nil,
        invocationRateLimitPerSecond: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.name = name
    }
}

struct CreateApiDestinationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let connectionArn: Swift.String?
    public let invocationEndpoint: Swift.String?
    public let httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod?
    public let invocationRateLimitPerSecond: Swift.Int?
}

extension CreateApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
    }
}

extension CreateApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApiDestinationOutputResponse(apiDestinationArn: \(Swift.String(describing: apiDestinationArn)), apiDestinationState: \(Swift.String(describing: apiDestinationState)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CreateApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct CreateApiDestinationOutputResponse: Swift.Equatable {
    /// <p>The ARN of the API destination that was created by the request.</p>
    public let apiDestinationArn: Swift.String?
    /// <p>The state of the API destination that was created by the request.</p>
    public let apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState?
    /// <p>A time stamp indicating the time that the API destination was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>A time stamp indicating the time that the API destination was last modified.</p>
    public let lastModifiedTime: ClientRuntime.Date?

    public init (
        apiDestinationArn: Swift.String? = nil,
        apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct CreateApiDestinationOutputResponseBody: Swift.Equatable {
    public let apiDestinationArn: Swift.String?
    public let apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
}

extension CreateApiDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct CreateArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateArchiveOutputError>
}

extension CreateArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateArchiveInput(archiveName: \(Swift.String(describing: archiveName)), description: \(Swift.String(describing: description)), eventPattern: \(Swift.String(describing: eventPattern)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), retentionDays: \(Swift.String(describing: retentionDays)))"}
}

extension CreateArchiveInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }
}

public struct CreateArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateArchiveOutputError>
}

public struct CreateArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateArchiveOutputError>
}

public struct CreateArchiveInput: Swift.Equatable {
    /// <p>The name for the archive to create.</p>
    public let archiveName: Swift.String?
    /// <p>A description for the archive.</p>
    public let description: Swift.String?
    /// <p>An event pattern to use to filter events sent to the archive.</p>
    public let eventPattern: Swift.String?
    /// <p>The ARN of the event source associated with the archive.</p>
    public let eventSourceArn: Swift.String?
    /// <p>The number of days to retain events for. Default value is 0. If set to 0, events are
    ///       retained indefinitely</p>
    public let retentionDays: Swift.Int?

    public init (
        archiveName: Swift.String? = nil,
        description: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        eventSourceArn: Swift.String? = nil,
        retentionDays: Swift.Int? = nil
    )
    {
        self.archiveName = archiveName
        self.description = description
        self.eventPattern = eventPattern
        self.eventSourceArn = eventSourceArn
        self.retentionDays = retentionDays
    }
}

struct CreateArchiveInputBody: Swift.Equatable {
    public let archiveName: Swift.String?
    public let eventSourceArn: Swift.String?
    public let description: Swift.String?
    public let eventPattern: Swift.String?
    public let retentionDays: Swift.Int?
}

extension CreateArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension CreateArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateArchiveOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateArchiveOutputResponse(archiveArn: \(Swift.String(describing: archiveArn)), creationTime: \(Swift.String(describing: creationTime)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension CreateArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveArn = output.archiveArn
            self.creationTime = output.creationTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.creationTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct CreateArchiveOutputResponse: Swift.Equatable {
    /// <p>The ARN of the archive that was created.</p>
    public let archiveArn: Swift.String?
    /// <p>The time at which the archive was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The state of the archive that was created.</p>
    public let state: CloudWatchEventsClientTypes.ArchiveState?
    /// <p>The reason that the archive is in the state.</p>
    public let stateReason: Swift.String?

    public init (
        archiveArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        state: CloudWatchEventsClientTypes.ArchiveState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.creationTime = creationTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct CreateArchiveOutputResponseBody: Swift.Equatable {
    public let archiveArn: Swift.String?
    public let state: CloudWatchEventsClientTypes.ArchiveState?
    public let stateReason: Swift.String?
    public let creationTime: ClientRuntime.Date?
}

extension CreateArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveArn = "ArchiveArn"
        case creationTime = "CreationTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CloudWatchEventsClientTypes.CreateConnectionApiKeyAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyName = "ApiKeyName"
        case apiKeyValue = "ApiKeyValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
        if let apiKeyValue = apiKeyValue {
            try encodeContainer.encode(apiKeyValue, forKey: .apiKeyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
        let apiKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyValue)
        apiKeyValue = apiKeyValueDecoded
    }
}

extension CloudWatchEventsClientTypes.CreateConnectionApiKeyAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionApiKeyAuthRequestParameters(apiKeyName: \(Swift.String(describing: apiKeyName)), apiKeyValue: \(Swift.String(describing: apiKeyValue)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the API key authorization parameters for the connection.</p>
    public struct CreateConnectionApiKeyAuthRequestParameters: Swift.Equatable {
        /// <p>The name of the API key to use for authorization.</p>
        public let apiKeyName: Swift.String?
        /// <p>The value for the API key to use for authorization.</p>
        public let apiKeyValue: Swift.String?

        public init (
            apiKeyName: Swift.String? = nil,
            apiKeyValue: Swift.String? = nil
        )
        {
            self.apiKeyName = apiKeyName
            self.apiKeyValue = apiKeyValue
        }
    }

}

extension CloudWatchEventsClientTypes.CreateConnectionAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.CreateConnectionBasicAuthRequestParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.CreateConnectionOAuthRequestParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.CreateConnectionApiKeyAuthRequestParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.CreateConnectionAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionAuthRequestParameters(apiKeyAuthParameters: \(Swift.String(describing: apiKeyAuthParameters)), basicAuthParameters: \(Swift.String(describing: basicAuthParameters)), invocationHttpParameters: \(Swift.String(describing: invocationHttpParameters)), oAuthParameters: \(Swift.String(describing: oAuthParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the authorization parameters for the connection.</p>
    public struct CreateConnectionAuthRequestParameters: Swift.Equatable {
        /// <p>A <code>CreateConnectionApiKeyAuthRequestParameters</code> object that contains the API
        ///       key authorization parameters to use for the connection.</p>
        public let apiKeyAuthParameters: CloudWatchEventsClientTypes.CreateConnectionApiKeyAuthRequestParameters?
        /// <p>A <code>CreateConnectionBasicAuthRequestParameters</code> object that contains the Basic
        ///       authorization parameters to use for the connection.</p>
        public let basicAuthParameters: CloudWatchEventsClientTypes.CreateConnectionBasicAuthRequestParameters?
        /// <p>A <code>ConnectionHttpParameters</code> object that contains the API key authorization
        ///       parameters to use for the connection. Note that if you include additional parameters for
        ///       the target of a rule via <code>HttpParameters</code>, including query strings, the parameters
        ///       added for the connection take precedence.</p>
        public let invocationHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters?
        /// <p>A <code>CreateConnectionOAuthRequestParameters</code> object that contains the OAuth
        ///       authorization parameters to use for the connection.</p>
        public let oAuthParameters: CloudWatchEventsClientTypes.CreateConnectionOAuthRequestParameters?

        public init (
            apiKeyAuthParameters: CloudWatchEventsClientTypes.CreateConnectionApiKeyAuthRequestParameters? = nil,
            basicAuthParameters: CloudWatchEventsClientTypes.CreateConnectionBasicAuthRequestParameters? = nil,
            invocationHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters? = nil,
            oAuthParameters: CloudWatchEventsClientTypes.CreateConnectionOAuthRequestParameters? = nil
        )
        {
            self.apiKeyAuthParameters = apiKeyAuthParameters
            self.basicAuthParameters = basicAuthParameters
            self.invocationHttpParameters = invocationHttpParameters
            self.oAuthParameters = oAuthParameters
        }
    }

}

extension CloudWatchEventsClientTypes.CreateConnectionBasicAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CloudWatchEventsClientTypes.CreateConnectionBasicAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionBasicAuthRequestParameters(password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the Basic authorization parameters to use for the connection.</p>
    public struct CreateConnectionBasicAuthRequestParameters: Swift.Equatable {
        /// <p>The password associated with the user name to use for Basic authorization.</p>
        public let password: Swift.String?
        /// <p>The user name to use for Basic authorization.</p>
        public let username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

public struct CreateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionInput(authParameters: \(Swift.String(describing: authParameters)), authorizationType: \(Swift.String(describing: authorizationType)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)))"}
}

extension CreateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authParameters = authParameters {
            try encodeContainer.encode(authParameters, forKey: .authParameters)
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Swift.Equatable {
    /// <p>A <code>CreateConnectionAuthRequestParameters</code> object that contains the
    ///       authorization parameters to use to authorize with the endpoint. </p>
    public let authParameters: CloudWatchEventsClientTypes.CreateConnectionAuthRequestParameters?
    /// <p>The type of authorization to use for the connection.</p>
    public let authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType?
    /// <p>A description for the connection to create.</p>
    public let description: Swift.String?
    /// <p>The name for the connection to create.</p>
    public let name: Swift.String?

    public init (
        authParameters: CloudWatchEventsClientTypes.CreateConnectionAuthRequestParameters? = nil,
        authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.description = description
        self.name = name
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType?
    public let authParameters: CloudWatchEventsClientTypes.CreateConnectionAuthRequestParameters?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.CreateConnectionAuthRequestParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.CreateConnectionOAuthClientRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case clientSecret = "ClientSecret"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension CloudWatchEventsClientTypes.CreateConnectionOAuthClientRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionOAuthClientRequestParameters(clientID: \(Swift.String(describing: clientID)), clientSecret: \(Swift.String(describing: clientSecret)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the Basic authorization parameters to use for the connection.</p>
    public struct CreateConnectionOAuthClientRequestParameters: Swift.Equatable {
        /// <p>The client ID to use for OAuth authorization for the connection.</p>
        public let clientID: Swift.String?
        /// <p>The client secret associated with the client ID to use for OAuth authorization for the
        ///       connection.</p>
        public let clientSecret: Swift.String?

        public init (
            clientID: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientID = clientID
            self.clientSecret = clientSecret
        }
    }

}

extension CloudWatchEventsClientTypes.CreateConnectionOAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.CreateConnectionOAuthClientRequestParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.CreateConnectionOAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionOAuthRequestParameters(authorizationEndpoint: \(Swift.String(describing: authorizationEndpoint)), clientParameters: \(Swift.String(describing: clientParameters)), httpMethod: \(Swift.String(describing: httpMethod)), oAuthHttpParameters: \(Swift.String(describing: oAuthHttpParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the OAuth authorization parameters to use for the connection.</p>
    public struct CreateConnectionOAuthRequestParameters: Swift.Equatable {
        /// <p>The URL to the authorization endpoint when OAuth is specified as the authorization
        ///       type.</p>
        public let authorizationEndpoint: Swift.String?
        /// <p>A <code>CreateConnectionOAuthClientRequestParameters</code> object that contains the
        ///       client parameters for OAuth authorization.</p>
        public let clientParameters: CloudWatchEventsClientTypes.CreateConnectionOAuthClientRequestParameters?
        /// <p>The method to use for the authorization request.</p>
        public let httpMethod: CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod?
        /// <p>A <code>ConnectionHttpParameters</code> object that contains details about the additional
        ///       parameters to use for the connection.</p>
        public let oAuthHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters?

        public init (
            authorizationEndpoint: Swift.String? = nil,
            clientParameters: CloudWatchEventsClientTypes.CreateConnectionOAuthClientRequestParameters? = nil,
            httpMethod: CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod? = nil,
            oAuthHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters? = nil
        )
        {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientParameters = clientParameters
            self.httpMethod = httpMethod
            self.oAuthHttpParameters = oAuthHttpParameters
        }
    }

}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionOutputResponse(connectionArn: \(Swift.String(describing: connectionArn)), connectionState: \(Swift.String(describing: connectionState)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// <p>The ARN of the connection that was created by the request.</p>
    public let connectionArn: Swift.String?
    /// <p>The state of the connection that was created by the request.</p>
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last updated.</p>
    public let lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: CloudWatchEventsClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    public let connectionArn: Swift.String?
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct CreateEventBusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventBusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventBusOutputError>
}

extension CreateEventBusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventBusInput(eventSourceName: \(Swift.String(describing: eventSourceName)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEventBusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceName = eventSourceName {
            try encodeContainer.encode(eventSourceName, forKey: .eventSourceName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEventBusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventBusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventBusOutputError>
}

public struct CreateEventBusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventBusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventBusOutputError>
}

public struct CreateEventBusInput: Swift.Equatable {
    /// <p>If you are creating a partner event bus, this specifies the partner event source that the
    ///       new event bus will be matched with.</p>
    public let eventSourceName: Swift.String?
    /// <p>The name of the new event bus. </p>
    ///          <p>Event bus names cannot contain the / character. You can't use the name
    ///         <code>default</code> for a custom event bus, as this name is already used for your account's
    ///       default event bus.</p>
    ///          <p>If this is a partner event bus, the name must exactly match the name of the partner event
    ///       source that this event bus is matched to.</p>
    public let name: Swift.String?
    /// <p>Tags to associate with the event bus.</p>
    public let tags: [CloudWatchEventsClientTypes.Tag]?

    public init (
        eventSourceName: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [CloudWatchEventsClientTypes.Tag]? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.name = name
        self.tags = tags
    }
}

struct CreateEventBusInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let eventSourceName: Swift.String?
    public let tags: [CloudWatchEventsClientTypes.Tag]?
}

extension CreateEventBusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudWatchEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudWatchEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventBusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventBusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventBusOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case operationDisabledException(OperationDisabledException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventBusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventBusOutputResponse(eventBusArn: \(Swift.String(describing: eventBusArn)))"}
}

extension CreateEventBusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventBusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventBusArn = output.eventBusArn
        } else {
            self.eventBusArn = nil
        }
    }
}

public struct CreateEventBusOutputResponse: Swift.Equatable {
    /// <p>The ARN of the new event bus.</p>
    public let eventBusArn: Swift.String?

    public init (
        eventBusArn: Swift.String? = nil
    )
    {
        self.eventBusArn = eventBusArn
    }
}

struct CreateEventBusOutputResponseBody: Swift.Equatable {
    public let eventBusArn: Swift.String?
}

extension CreateEventBusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusArn = "EventBusArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusArn)
        eventBusArn = eventBusArnDecoded
    }
}

public struct CreatePartnerEventSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePartnerEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePartnerEventSourceOutputError>
}

extension CreatePartnerEventSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnerEventSourceInput(account: \(Swift.String(describing: account)), name: \(Swift.String(describing: name)))"}
}

extension CreatePartnerEventSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreatePartnerEventSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePartnerEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePartnerEventSourceOutputError>
}

public struct CreatePartnerEventSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePartnerEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePartnerEventSourceOutputError>
}

public struct CreatePartnerEventSourceInput: Swift.Equatable {
    /// <p>The AWS account ID that is permitted to create a matching partner event bus for this
    ///       partner event source.</p>
    public let account: Swift.String?
    /// <p>The name of the partner event source. This name must be unique and must be in the format
    ///           <code>
    ///                <i>partner_name</i>/<i>event_namespace</i>/<i>event_name</i>
    ///             </code>.
    ///       The AWS account that wants to use this partner event source must create a partner event bus
    ///       with a name that matches the name of the partner event source.</p>
    public let name: Swift.String?

    public init (
        account: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.account = account
        self.name = name
    }
}

struct CreatePartnerEventSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let account: Swift.String?
}

extension CreatePartnerEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
    }
}

extension CreatePartnerEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePartnerEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePartnerEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case operationDisabledException(OperationDisabledException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePartnerEventSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnerEventSourceOutputResponse(eventSourceArn: \(Swift.String(describing: eventSourceArn)))"}
}

extension CreatePartnerEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePartnerEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSourceArn = output.eventSourceArn
        } else {
            self.eventSourceArn = nil
        }
    }
}

public struct CreatePartnerEventSourceOutputResponse: Swift.Equatable {
    /// <p>The ARN of the partner event source.</p>
    public let eventSourceArn: Swift.String?

    public init (
        eventSourceArn: Swift.String? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
    }
}

struct CreatePartnerEventSourceOutputResponseBody: Swift.Equatable {
    public let eventSourceArn: Swift.String?
}

extension CreatePartnerEventSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
    }
}

public struct DeactivateEventSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeactivateEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeactivateEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeactivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeactivateEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeactivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeactivateEventSourceOutputError>
}

extension DeactivateEventSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeactivateEventSourceInput(name: \(Swift.String(describing: name)))"}
}

extension DeactivateEventSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeactivateEventSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeactivateEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeactivateEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeactivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeactivateEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeactivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeactivateEventSourceOutputError>
}

public struct DeactivateEventSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeactivateEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeactivateEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeactivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeactivateEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeactivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeactivateEventSourceOutputError>
}

public struct DeactivateEventSourceInput: Swift.Equatable {
    /// <p>The name of the partner event source to deactivate.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeactivateEventSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeactivateEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeactivateEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateEventSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeactivateEventSourceOutputResponse()"}
}

extension DeactivateEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateEventSourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeactivateEventSourceOutputResponseBody: Swift.Equatable {
}

extension DeactivateEventSourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudWatchEventsClientTypes.DeadLetterConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CloudWatchEventsClientTypes.DeadLetterConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeadLetterConfig(arn: \(Swift.String(describing: arn)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A <code>DeadLetterConfig</code> object that contains information about a dead-letter queue
    ///       configuration.</p>
    public struct DeadLetterConfig: Swift.Equatable {
        /// <p>The ARN of the SQS queue specified as the target for the dead-letter queue.</p>
        public let arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

public struct DeauthorizeConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeauthorizeConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeauthorizeConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeauthorizeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeauthorizeConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeauthorizeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeauthorizeConnectionOutputError>
}

extension DeauthorizeConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeauthorizeConnectionInput(name: \(Swift.String(describing: name)))"}
}

extension DeauthorizeConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeauthorizeConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeauthorizeConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeauthorizeConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeauthorizeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeauthorizeConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeauthorizeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeauthorizeConnectionOutputError>
}

public struct DeauthorizeConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeauthorizeConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeauthorizeConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeauthorizeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeauthorizeConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeauthorizeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeauthorizeConnectionOutputError>
}

public struct DeauthorizeConnectionInput: Swift.Equatable {
    /// <p>The name of the connection to remove authorization from.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeauthorizeConnectionInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeauthorizeConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeauthorizeConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeauthorizeConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeauthorizeConnectionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeauthorizeConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeauthorizeConnectionOutputResponse(connectionArn: \(Swift.String(describing: connectionArn)), connectionState: \(Swift.String(describing: connectionState)), creationTime: \(Swift.String(describing: creationTime)), lastAuthorizedTime: \(Swift.String(describing: lastAuthorizedTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension DeauthorizeConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeauthorizeConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct DeauthorizeConnectionOutputResponse: Swift.Equatable {
    /// <p>The ARN of the connection that authorization was removed from.</p>
    public let connectionArn: Swift.String?
    /// <p>The state of the connection.</p>
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last authorized.</p>
    public let lastAuthorizedTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last updated.</p>
    public let lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: CloudWatchEventsClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct DeauthorizeConnectionOutputResponseBody: Swift.Equatable {
    public let connectionArn: Swift.String?
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
    public let lastAuthorizedTime: ClientRuntime.Date?
}

extension DeauthorizeConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

public struct DeleteApiDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiDestinationOutputError>
}

extension DeleteApiDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApiDestinationInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteApiDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteApiDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiDestinationOutputError>
}

public struct DeleteApiDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApiDestinationOutputError>
}

public struct DeleteApiDestinationInput: Swift.Equatable {
    /// <p>The name of the destination to delete.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteApiDestinationInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApiDestinationOutputResponse()"}
}

extension DeleteApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiDestinationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteApiDestinationOutputResponseBody: Swift.Equatable {
}

extension DeleteApiDestinationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveOutputError>
}

extension DeleteArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteArchiveInput(archiveName: \(Swift.String(describing: archiveName)))"}
}

extension DeleteArchiveInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
    }
}

public struct DeleteArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveOutputError>
}

public struct DeleteArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveOutputError>
}

public struct DeleteArchiveInput: Swift.Equatable {
    /// <p>The name of the archive to delete.</p>
    public let archiveName: Swift.String?

    public init (
        archiveName: Swift.String? = nil
    )
    {
        self.archiveName = archiveName
    }
}

struct DeleteArchiveInputBody: Swift.Equatable {
    public let archiveName: Swift.String?
}

extension DeleteArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
    }
}

extension DeleteArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteArchiveOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteArchiveOutputResponse()"}
}

extension DeleteArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteArchiveOutputResponseBody: Swift.Equatable {
}

extension DeleteArchiveOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// <p>The name of the connection to delete.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionOutputResponse(connectionArn: \(Swift.String(describing: connectionArn)), connectionState: \(Swift.String(describing: connectionState)), creationTime: \(Swift.String(describing: creationTime)), lastAuthorizedTime: \(Swift.String(describing: lastAuthorizedTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// <p>The ARN of the connection that was deleted.</p>
    public let connectionArn: Swift.String?
    /// <p>The state of the connection before it was deleted.</p>
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last authorized before it wa
    ///       deleted.</p>
    public let lastAuthorizedTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last modified before it was
    ///       deleted.</p>
    public let lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: CloudWatchEventsClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    public let connectionArn: Swift.String?
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
    public let lastAuthorizedTime: ClientRuntime.Date?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

public struct DeleteEventBusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventBusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventBusOutputError>
}

extension DeleteEventBusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventBusInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteEventBusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEventBusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventBusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventBusOutputError>
}

public struct DeleteEventBusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventBusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventBusOutputError>
}

public struct DeleteEventBusInput: Swift.Equatable {
    /// <p>The name of the event bus to delete.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventBusInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteEventBusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEventBusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventBusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventBusOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventBusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventBusOutputResponse()"}
}

extension DeleteEventBusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventBusOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEventBusOutputResponseBody: Swift.Equatable {
}

extension DeleteEventBusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePartnerEventSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePartnerEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePartnerEventSourceOutputError>
}

extension DeletePartnerEventSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePartnerEventSourceInput(account: \(Swift.String(describing: account)), name: \(Swift.String(describing: name)))"}
}

extension DeletePartnerEventSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeletePartnerEventSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePartnerEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePartnerEventSourceOutputError>
}

public struct DeletePartnerEventSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePartnerEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePartnerEventSourceOutputError>
}

public struct DeletePartnerEventSourceInput: Swift.Equatable {
    /// <p>The AWS account ID of the AWS customer that the event source was created for.</p>
    public let account: Swift.String?
    /// <p>The name of the event source to delete.</p>
    public let name: Swift.String?

    public init (
        account: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.account = account
        self.name = name
    }
}

struct DeletePartnerEventSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let account: Swift.String?
}

extension DeletePartnerEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
    }
}

extension DeletePartnerEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePartnerEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePartnerEventSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePartnerEventSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePartnerEventSourceOutputResponse()"}
}

extension DeletePartnerEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePartnerEventSourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePartnerEventSourceOutputResponseBody: Swift.Equatable {
}

extension DeletePartnerEventSourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

extension DeleteRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleInput(eventBusName: \(Swift.String(describing: eventBusName)), force: \(Swift.String(describing: force)), name: \(Swift.String(describing: name)))"}
}

extension DeleteRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>If this is a managed rule, created by an AWS service on your behalf, you must specify
    ///         <code>Force</code> as <code>True</code> to delete the rule. This parameter is ignored for
    ///       rules that are not managed rules. You can check whether a rule is a managed rule by using
    ///         <code>DescribeRule</code> or <code>ListRules</code> and checking the <code>ManagedBy</code>
    ///       field of the response.</p>
    public let force: Swift.Bool
    /// <p>The name of the rule.</p>
    public let name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        force: Swift.Bool = false,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.force = force
        self.name = name
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let eventBusName: Swift.String?
    public let force: Swift.Bool
}

extension DeleteRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleOutputResponse()"}
}

extension DeleteRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRuleOutputResponseBody: Swift.Equatable {
}

extension DeleteRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeApiDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApiDestinationOutputError>
}

extension DescribeApiDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeApiDestinationInput(name: \(Swift.String(describing: name)))"}
}

extension DescribeApiDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeApiDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApiDestinationOutputError>
}

public struct DescribeApiDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApiDestinationOutputError>
}

public struct DescribeApiDestinationInput: Swift.Equatable {
    /// <p>The name of the API destination to retrieve.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeApiDestinationInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DescribeApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApiDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeApiDestinationOutputResponse(apiDestinationArn: \(Swift.String(describing: apiDestinationArn)), apiDestinationState: \(Swift.String(describing: apiDestinationState)), connectionArn: \(Swift.String(describing: connectionArn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), httpMethod: \(Swift.String(describing: httpMethod)), invocationEndpoint: \(Swift.String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(Swift.String(describing: invocationRateLimitPerSecond)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)))"}
}

extension DescribeApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.connectionArn = output.connectionArn
            self.creationTime = output.creationTime
            self.description = output.description
            self.httpMethod = output.httpMethod
            self.invocationEndpoint = output.invocationEndpoint
            self.invocationRateLimitPerSecond = output.invocationRateLimitPerSecond
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.connectionArn = nil
            self.creationTime = nil
            self.description = nil
            self.httpMethod = nil
            self.invocationEndpoint = nil
            self.invocationRateLimitPerSecond = nil
            self.lastModifiedTime = nil
            self.name = nil
        }
    }
}

public struct DescribeApiDestinationOutputResponse: Swift.Equatable {
    /// <p>The ARN of the API destination retrieved.</p>
    public let apiDestinationArn: Swift.String?
    /// <p>The state of the API destination retrieved.</p>
    public let apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState?
    /// <p>The ARN of the connection specified for the API destination retrieved.</p>
    public let connectionArn: Swift.String?
    /// <p>A time stamp for the time that the API destination was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The description for the API destination retrieved.</p>
    public let description: Swift.String?
    /// <p>The method to use to connect to the HTTP endpoint.</p>
    public let httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod?
    /// <p>The URL to use to connect to the HTTP endpoint.</p>
    public let invocationEndpoint: Swift.String?
    /// <p>The maximum number of invocations per second to specified for the API destination. Note
    ///       that if you set the invocation rate maximum to a value lower the rate necessary to send all
    ///       events received on to the destination HTTP endpoint, some events may not be delivered within
    ///       the 24-hour retry window. If you plan to set the rate lower than the rate necessary to deliver
    ///       all events, consider using a dead-letter queue to catch events that are not delivered within
    ///       24 hours.</p>
    public let invocationRateLimitPerSecond: Swift.Int?
    /// <p>A time stamp for the time that the API destination was last modified.</p>
    public let lastModifiedTime: ClientRuntime.Date?
    /// <p>The name of the API destination retrieved.</p>
    public let name: Swift.String?

    public init (
        apiDestinationArn: Swift.String? = nil,
        apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState? = nil,
        connectionArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod? = nil,
        invocationEndpoint: Swift.String? = nil,
        invocationRateLimitPerSecond: Swift.Int? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.connectionArn = connectionArn
        self.creationTime = creationTime
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

struct DescribeApiDestinationOutputResponseBody: Swift.Equatable {
    public let apiDestinationArn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState?
    public let connectionArn: Swift.String?
    public let invocationEndpoint: Swift.String?
    public let httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod?
    public let invocationRateLimitPerSecond: Swift.Int?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
}

extension DescribeApiDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case connectionArn = "ConnectionArn"
        case creationTime = "CreationTime"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct DescribeArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeArchiveOutputError>
}

extension DescribeArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeArchiveInput(archiveName: \(Swift.String(describing: archiveName)))"}
}

extension DescribeArchiveInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
    }
}

public struct DescribeArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeArchiveOutputError>
}

public struct DescribeArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeArchiveOutputError>
}

public struct DescribeArchiveInput: Swift.Equatable {
    /// <p>The name of the archive to retrieve.</p>
    public let archiveName: Swift.String?

    public init (
        archiveName: Swift.String? = nil
    )
    {
        self.archiveName = archiveName
    }
}

struct DescribeArchiveInputBody: Swift.Equatable {
    public let archiveName: Swift.String?
}

extension DescribeArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
    }
}

extension DescribeArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeArchiveOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeArchiveOutputResponse(archiveArn: \(Swift.String(describing: archiveArn)), archiveName: \(Swift.String(describing: archiveName)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), eventCount: \(Swift.String(describing: eventCount)), eventPattern: \(Swift.String(describing: eventPattern)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), retentionDays: \(Swift.String(describing: retentionDays)), sizeBytes: \(Swift.String(describing: sizeBytes)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension DescribeArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveArn = output.archiveArn
            self.archiveName = output.archiveName
            self.creationTime = output.creationTime
            self.description = output.description
            self.eventCount = output.eventCount
            self.eventPattern = output.eventPattern
            self.eventSourceArn = output.eventSourceArn
            self.retentionDays = output.retentionDays
            self.sizeBytes = output.sizeBytes
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.archiveName = nil
            self.creationTime = nil
            self.description = nil
            self.eventCount = 0
            self.eventPattern = nil
            self.eventSourceArn = nil
            self.retentionDays = nil
            self.sizeBytes = 0
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeArchiveOutputResponse: Swift.Equatable {
    /// <p>The ARN of the archive.</p>
    public let archiveArn: Swift.String?
    /// <p>The name of the archive.</p>
    public let archiveName: Swift.String?
    /// <p>The time at which the archive was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The description of the archive.</p>
    public let description: Swift.String?
    /// <p>The number of events in the archive.</p>
    public let eventCount: Swift.Int
    /// <p>The event pattern used to filter events sent to the archive.</p>
    public let eventPattern: Swift.String?
    /// <p>The ARN of the event source associated with the archive.</p>
    public let eventSourceArn: Swift.String?
    /// <p>The number of days to retain events for in the archive.</p>
    public let retentionDays: Swift.Int?
    /// <p>The size of the archive in bytes.</p>
    public let sizeBytes: Swift.Int
    /// <p>The state of the archive.</p>
    public let state: CloudWatchEventsClientTypes.ArchiveState?
    /// <p>The reason that the archive is in the state.</p>
    public let stateReason: Swift.String?

    public init (
        archiveArn: Swift.String? = nil,
        archiveName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        eventCount: Swift.Int = 0,
        eventPattern: Swift.String? = nil,
        eventSourceArn: Swift.String? = nil,
        retentionDays: Swift.Int? = nil,
        sizeBytes: Swift.Int = 0,
        state: CloudWatchEventsClientTypes.ArchiveState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.archiveName = archiveName
        self.creationTime = creationTime
        self.description = description
        self.eventCount = eventCount
        self.eventPattern = eventPattern
        self.eventSourceArn = eventSourceArn
        self.retentionDays = retentionDays
        self.sizeBytes = sizeBytes
        self.state = state
        self.stateReason = stateReason
    }
}

struct DescribeArchiveOutputResponseBody: Swift.Equatable {
    public let archiveArn: Swift.String?
    public let archiveName: Swift.String?
    public let eventSourceArn: Swift.String?
    public let description: Swift.String?
    public let eventPattern: Swift.String?
    public let state: CloudWatchEventsClientTypes.ArchiveState?
    public let stateReason: Swift.String?
    public let retentionDays: Swift.Int?
    public let sizeBytes: Swift.Int
    public let eventCount: Swift.Int
    public let creationTime: ClientRuntime.Date?
}

extension DescribeArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveArn = "ArchiveArn"
        case archiveName = "ArchiveName"
        case creationTime = "CreationTime"
        case description = "Description"
        case eventCount = "EventCount"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
        case sizeBytes = "SizeBytes"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
        let sizeBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let eventCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .eventCount)
        eventCount = eventCountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct DescribeConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectionOutputError>
}

extension DescribeConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectionInput(name: \(Swift.String(describing: name)))"}
}

extension DescribeConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectionOutputError>
}

public struct DescribeConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConnectionOutputError>
}

public struct DescribeConnectionInput: Swift.Equatable {
    /// <p>The name of the connection to retrieve.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeConnectionInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DescribeConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectionOutputResponse(authParameters: \(Swift.String(describing: authParameters)), authorizationType: \(Swift.String(describing: authorizationType)), connectionArn: \(Swift.String(describing: connectionArn)), connectionState: \(Swift.String(describing: connectionState)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), lastAuthorizedTime: \(Swift.String(describing: lastAuthorizedTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), secretArn: \(Swift.String(describing: secretArn)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension DescribeConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authParameters = output.authParameters
            self.authorizationType = output.authorizationType
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.secretArn = output.secretArn
            self.stateReason = output.stateReason
        } else {
            self.authParameters = nil
            self.authorizationType = nil
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.description = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.secretArn = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeConnectionOutputResponse: Swift.Equatable {
    /// <p>The parameters to use for authorization for the connection.</p>
    public let authParameters: CloudWatchEventsClientTypes.ConnectionAuthResponseParameters?
    /// <p>The type of authorization specified for the connection.</p>
    public let authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType?
    /// <p>The ARN of the connection retrieved.</p>
    public let connectionArn: Swift.String?
    /// <p>The state of the connection retrieved.</p>
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The description for the connection retrieved.</p>
    public let description: Swift.String?
    /// <p>A time stamp for the time that the connection was last authorized.</p>
    public let lastAuthorizedTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last modified.</p>
    public let lastModifiedTime: ClientRuntime.Date?
    /// <p>The name of the connection retrieved.</p>
    public let name: Swift.String?
    /// <p>The ARN of the secret created from the authorization parameters specified for the
    ///       connection.</p>
    public let secretArn: Swift.String?
    /// <p>The reason that the connection is in the current connection state.</p>
    public let stateReason: Swift.String?

    public init (
        authParameters: CloudWatchEventsClientTypes.ConnectionAuthResponseParameters? = nil,
        authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType? = nil,
        connectionArn: Swift.String? = nil,
        connectionState: CloudWatchEventsClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.description = description
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.secretArn = secretArn
        self.stateReason = stateReason
    }
}

struct DescribeConnectionOutputResponseBody: Swift.Equatable {
    public let connectionArn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    public let stateReason: Swift.String?
    public let authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType?
    public let secretArn: Swift.String?
    public let authParameters: CloudWatchEventsClientTypes.ConnectionAuthResponseParameters?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
    public let lastAuthorizedTime: ClientRuntime.Date?
}

extension DescribeConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case secretArn = "SecretArn"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionAuthResponseParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

public struct DescribeEventBusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventBusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventBusOutputError>
}

extension DescribeEventBusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventBusInput(name: \(Swift.String(describing: name)))"}
}

extension DescribeEventBusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeEventBusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventBusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventBusOutputError>
}

public struct DescribeEventBusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventBusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventBusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventBusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventBusOutputError>
}

public struct DescribeEventBusInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus to show details for. If you omit this, the default event
    ///       bus is displayed.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeEventBusInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DescribeEventBusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeEventBusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventBusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventBusOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventBusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventBusOutputResponse(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)), policy: \(Swift.String(describing: policy)))"}
}

extension DescribeEventBusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventBusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.policy = output.policy
        } else {
            self.arn = nil
            self.name = nil
            self.policy = nil
        }
    }
}

public struct DescribeEventBusOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the account permitted to write events to the current
    ///       account.</p>
    public let arn: Swift.String?
    /// <p>The name of the event bus. Currently, this is always <code>default</code>.</p>
    public let name: Swift.String?
    /// <p>The policy that enables the external account to send events to your account.</p>
    public let policy: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.policy = policy
    }
}

struct DescribeEventBusOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let arn: Swift.String?
    public let policy: Swift.String?
}

extension DescribeEventBusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct DescribeEventSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSourceOutputError>
}

extension DescribeEventSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSourceInput(name: \(Swift.String(describing: name)))"}
}

extension DescribeEventSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeEventSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSourceOutputError>
}

public struct DescribeEventSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSourceOutputError>
}

public struct DescribeEventSourceInput: Swift.Equatable {
    /// <p>The name of the partner event source to display the details of.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeEventSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DescribeEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSourceOutputResponse(arn: \(Swift.String(describing: arn)), createdBy: \(Swift.String(describing: createdBy)), creationTime: \(Swift.String(describing: creationTime)), expirationTime: \(Swift.String(describing: expirationTime)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension DescribeEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.createdBy = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeEventSourceOutputResponse: Swift.Equatable {
    /// <p>The ARN of the partner event source.</p>
    public let arn: Swift.String?
    /// <p>The name of the SaaS partner that created the event source.</p>
    public let createdBy: Swift.String?
    /// <p>The date and time that the event source was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The date and time that the event source will expire if you do not create a matching event
    ///       bus.</p>
    public let expirationTime: ClientRuntime.Date?
    /// <p>The name of the partner event source.</p>
    public let name: Swift.String?
    /// <p>The state of the event source. If it is ACTIVE, you have already created a matching event
    ///       bus for this event source, and that event bus is active. If it is PENDING, either you haven't
    ///       yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have
    ///       created a matching event bus, but the event source has since been deleted.</p>
    public let state: CloudWatchEventsClientTypes.EventSourceState?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        expirationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: CloudWatchEventsClientTypes.EventSourceState? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.name = name
        self.state = state
    }
}

struct DescribeEventSourceOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let createdBy: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let expirationTime: ClientRuntime.Date?
    public let name: Swift.String?
    public let state: CloudWatchEventsClientTypes.EventSourceState?
}

extension DescribeEventSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

public struct DescribePartnerEventSourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePartnerEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePartnerEventSourceOutputError>
}

extension DescribePartnerEventSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePartnerEventSourceInput(name: \(Swift.String(describing: name)))"}
}

extension DescribePartnerEventSourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribePartnerEventSourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePartnerEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePartnerEventSourceOutputError>
}

public struct DescribePartnerEventSourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePartnerEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePartnerEventSourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePartnerEventSourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePartnerEventSourceOutputError>
}

public struct DescribePartnerEventSourceInput: Swift.Equatable {
    /// <p>The name of the event source to display.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribePartnerEventSourceInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DescribePartnerEventSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribePartnerEventSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePartnerEventSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePartnerEventSourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePartnerEventSourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePartnerEventSourceOutputResponse(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension DescribePartnerEventSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePartnerEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DescribePartnerEventSourceOutputResponse: Swift.Equatable {
    /// <p>The ARN of the event source.</p>
    public let arn: Swift.String?
    /// <p>The name of the event source.</p>
    public let name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DescribePartnerEventSourceOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
}

extension DescribePartnerEventSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct DescribeReplayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplayOutputError>
}

extension DescribeReplayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplayInput(replayName: \(Swift.String(describing: replayName)))"}
}

extension DescribeReplayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

public struct DescribeReplayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplayOutputError>
}

public struct DescribeReplayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReplayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReplayOutputError>
}

public struct DescribeReplayInput: Swift.Equatable {
    /// <p>The name of the replay to retrieve.</p>
    public let replayName: Swift.String?

    public init (
        replayName: Swift.String? = nil
    )
    {
        self.replayName = replayName
    }
}

struct DescribeReplayInputBody: Swift.Equatable {
    public let replayName: Swift.String?
}

extension DescribeReplayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayName = "ReplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
    }
}

extension DescribeReplayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplayOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReplayOutputResponse(description: \(Swift.String(describing: description)), destination: \(Swift.String(describing: destination)), eventEndTime: \(Swift.String(describing: eventEndTime)), eventLastReplayedTime: \(Swift.String(describing: eventLastReplayedTime)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), eventStartTime: \(Swift.String(describing: eventStartTime)), replayArn: \(Swift.String(describing: replayArn)), replayEndTime: \(Swift.String(describing: replayEndTime)), replayName: \(Swift.String(describing: replayName)), replayStartTime: \(Swift.String(describing: replayStartTime)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension DescribeReplayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.destination = output.destination
            self.eventEndTime = output.eventEndTime
            self.eventLastReplayedTime = output.eventLastReplayedTime
            self.eventSourceArn = output.eventSourceArn
            self.eventStartTime = output.eventStartTime
            self.replayArn = output.replayArn
            self.replayEndTime = output.replayEndTime
            self.replayName = output.replayName
            self.replayStartTime = output.replayStartTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.description = nil
            self.destination = nil
            self.eventEndTime = nil
            self.eventLastReplayedTime = nil
            self.eventSourceArn = nil
            self.eventStartTime = nil
            self.replayArn = nil
            self.replayEndTime = nil
            self.replayName = nil
            self.replayStartTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeReplayOutputResponse: Swift.Equatable {
    /// <p>The description of the replay.</p>
    public let description: Swift.String?
    /// <p>A <code>ReplayDestination</code> object that contains details about the replay.</p>
    public let destination: CloudWatchEventsClientTypes.ReplayDestination?
    /// <p>The time stamp for the last event that was replayed from the archive.</p>
    public let eventEndTime: ClientRuntime.Date?
    /// <p>The time that the event was last replayed.</p>
    public let eventLastReplayedTime: ClientRuntime.Date?
    /// <p>The ARN of the archive events were replayed from.</p>
    public let eventSourceArn: Swift.String?
    /// <p>The time stamp of the first event that was last replayed from the archive.</p>
    public let eventStartTime: ClientRuntime.Date?
    /// <p>The ARN of the replay.</p>
    public let replayArn: Swift.String?
    /// <p>A time stamp for the time that the replay stopped.</p>
    public let replayEndTime: ClientRuntime.Date?
    /// <p>The name of the replay.</p>
    public let replayName: Swift.String?
    /// <p>A time stamp for the time that the replay started.</p>
    public let replayStartTime: ClientRuntime.Date?
    /// <p>The current state of the replay.</p>
    public let state: CloudWatchEventsClientTypes.ReplayState?
    /// <p>The reason that the replay is in the current state.</p>
    public let stateReason: Swift.String?

    public init (
        description: Swift.String? = nil,
        destination: CloudWatchEventsClientTypes.ReplayDestination? = nil,
        eventEndTime: ClientRuntime.Date? = nil,
        eventLastReplayedTime: ClientRuntime.Date? = nil,
        eventSourceArn: Swift.String? = nil,
        eventStartTime: ClientRuntime.Date? = nil,
        replayArn: Swift.String? = nil,
        replayEndTime: ClientRuntime.Date? = nil,
        replayName: Swift.String? = nil,
        replayStartTime: ClientRuntime.Date? = nil,
        state: CloudWatchEventsClientTypes.ReplayState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.eventEndTime = eventEndTime
        self.eventLastReplayedTime = eventLastReplayedTime
        self.eventSourceArn = eventSourceArn
        self.eventStartTime = eventStartTime
        self.replayArn = replayArn
        self.replayEndTime = replayEndTime
        self.replayName = replayName
        self.replayStartTime = replayStartTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct DescribeReplayOutputResponseBody: Swift.Equatable {
    public let replayName: Swift.String?
    public let replayArn: Swift.String?
    public let description: Swift.String?
    public let state: CloudWatchEventsClientTypes.ReplayState?
    public let stateReason: Swift.String?
    public let eventSourceArn: Swift.String?
    public let destination: CloudWatchEventsClientTypes.ReplayDestination?
    public let eventStartTime: ClientRuntime.Date?
    public let eventEndTime: ClientRuntime.Date?
    public let eventLastReplayedTime: ClientRuntime.Date?
    public let replayStartTime: ClientRuntime.Date?
    public let replayEndTime: ClientRuntime.Date?
}

extension DescribeReplayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventLastReplayedTime = "EventLastReplayedTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayArn = "ReplayArn"
        case replayEndTime = "ReplayEndTime"
        case replayName = "ReplayName"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let replayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ReplayDestination.self, forKey: .destination)
        destination = destinationDecoded
        let eventStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let eventLastReplayedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventLastReplayedTime)
        eventLastReplayedTime = eventLastReplayedTimeDecoded
        let replayStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
        let replayEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replayEndTime)
        replayEndTime = replayEndTimeDecoded
    }
}

public struct DescribeRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuleOutputError>
}

extension DescribeRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRuleInput(eventBusName: \(Swift.String(describing: eventBusName)), name: \(Swift.String(describing: name)))"}
}

extension DescribeRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuleOutputError>
}

public struct DescribeRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuleOutputError>
}

public struct DescribeRuleInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The name of the rule.</p>
    public let name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct DescribeRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let eventBusName: Swift.String?
}

extension DescribeRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension DescribeRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRuleOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRuleOutputResponse(arn: \(Swift.String(describing: arn)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), eventBusName: \(Swift.String(describing: eventBusName)), eventPattern: \(Swift.String(describing: eventPattern)), managedBy: \(Swift.String(describing: managedBy)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), state: \(Swift.String(describing: state)))"}
}

extension DescribeRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.description = output.description
            self.eventBusName = output.eventBusName
            self.eventPattern = output.eventPattern
            self.managedBy = output.managedBy
            self.name = output.name
            self.roleArn = output.roleArn
            self.scheduleExpression = output.scheduleExpression
            self.state = output.state
        } else {
            self.arn = nil
            self.createdBy = nil
            self.description = nil
            self.eventBusName = nil
            self.eventPattern = nil
            self.managedBy = nil
            self.name = nil
            self.roleArn = nil
            self.scheduleExpression = nil
            self.state = nil
        }
    }
}

public struct DescribeRuleOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let arn: Swift.String?
    /// <p>The account ID of the user that created the rule. If you use <code>PutRule</code> to put a
    ///       rule on an event bus in another account, the other account is the owner of the rule, and the
    ///       rule ARN includes the account ID for that account. However, the value for
    ///         <code>CreatedBy</code> is the account ID as the account that created the rule in the other
    ///       account.</p>
    public let createdBy: Swift.String?
    /// <p>The description of the rule.</p>
    public let description: Swift.String?
    /// <p>The name of the event bus associated with the rule.</p>
    public let eventBusName: Swift.String?
    /// <p>The event pattern. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
    ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    public let eventPattern: Swift.String?
    /// <p>If this is a managed rule, created by an AWS service on your behalf, this field displays
    ///       the principal name of the AWS service that created the rule.</p>
    public let managedBy: Swift.String?
    /// <p>The name of the rule.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the rule.</p>
    public let roleArn: Swift.String?
    /// <p>The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".</p>
    public let scheduleExpression: Swift.String?
    /// <p>Specifies whether the rule is enabled or disabled.</p>
    public let state: CloudWatchEventsClientTypes.RuleState?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        eventBusName: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        managedBy: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        scheduleExpression: Swift.String? = nil,
        state: CloudWatchEventsClientTypes.RuleState? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.description = description
        self.eventBusName = eventBusName
        self.eventPattern = eventPattern
        self.managedBy = managedBy
        self.name = name
        self.roleArn = roleArn
        self.scheduleExpression = scheduleExpression
        self.state = state
    }
}

struct DescribeRuleOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let arn: Swift.String?
    public let eventPattern: Swift.String?
    public let scheduleExpression: Swift.String?
    public let state: CloudWatchEventsClientTypes.RuleState?
    public let description: Swift.String?
    public let roleArn: Swift.String?
    public let managedBy: Swift.String?
    public let eventBusName: Swift.String?
    public let createdBy: Swift.String?
}

extension DescribeRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case managedBy = "ManagedBy"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let managedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedBy)
        managedBy = managedByDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

public struct DisableRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableRuleOutputError>
}

extension DisableRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableRuleInput(eventBusName: \(Swift.String(describing: eventBusName)), name: \(Swift.String(describing: name)))"}
}

extension DisableRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DisableRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableRuleOutputError>
}

public struct DisableRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableRuleOutputError>
}

public struct DisableRuleInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The name of the rule.</p>
    public let name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct DisableRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let eventBusName: Swift.String?
}

extension DisableRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension DisableRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableRuleOutputResponse()"}
}

extension DisableRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisableRuleOutputResponseBody: Swift.Equatable {
}

extension DisableRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudWatchEventsClientTypes.EcsParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case launchType = "LaunchType"
        case networkConfiguration = "NetworkConfiguration"
        case platformVersion = "PlatformVersion"
        case taskCount = "TaskCount"
        case taskDefinitionArn = "TaskDefinitionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let launchType = launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let taskCount = taskCount {
            try encodeContainer.encode(taskCount, forKey: .taskCount)
        }
        if let taskDefinitionArn = taskDefinitionArn {
            try encodeContainer.encode(taskDefinitionArn, forKey: .taskDefinitionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskDefinitionArn)
        taskDefinitionArn = taskDefinitionArnDecoded
        let taskCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .taskCount)
        taskCount = taskCountDecoded
        let launchTypeDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.LaunchType.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
    }
}

extension CloudWatchEventsClientTypes.EcsParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EcsParameters(group: \(Swift.String(describing: group)), launchType: \(Swift.String(describing: launchType)), networkConfiguration: \(Swift.String(describing: networkConfiguration)), platformVersion: \(Swift.String(describing: platformVersion)), taskCount: \(Swift.String(describing: taskCount)), taskDefinitionArn: \(Swift.String(describing: taskDefinitionArn)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>The custom parameters to be used when the target is an Amazon ECS task.</p>
    public struct EcsParameters: Swift.Equatable {
        /// <p>Specifies an ECS task group for the task. The maximum length is 255 characters.</p>
        public let group: Swift.String?
        /// <p>Specifies the launch type on which your task is running. The launch type that you specify
        ///       here must match one of the launch type (compatibilities) of the target task. The
        ///         <code>FARGATE</code> value is supported only in the Regions where AWS Fargate with Amazon
        ///       ECS is supported. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS-Fargate.html">AWS Fargate on Amazon ECS</a> in
        ///       the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        public let launchType: CloudWatchEventsClientTypes.LaunchType?
        /// <p>Use this structure if the ECS task uses the <code>awsvpc</code> network mode. This
        ///       structure specifies the VPC subnets and security groups associated with the task, and whether
        ///       a public IP address is to be used. This structure is required if <code>LaunchType</code> is
        ///         <code>FARGATE</code> because the <code>awsvpc</code> mode is required for Fargate
        ///       tasks.</p>
        ///          <p>If you specify <code>NetworkConfiguration</code> when the target ECS task does not use the
        ///         <code>awsvpc</code> network mode, the task fails.</p>
        public let networkConfiguration: CloudWatchEventsClientTypes.NetworkConfiguration?
        /// <p>Specifies the platform version for the task. Specify only the numeric portion of the
        ///       platform version, such as <code>1.1.0</code>.</p>
        ///          <p>This structure is used only if <code>LaunchType</code> is <code>FARGATE</code>. For more
        ///       information about valid platform versions, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">AWS Fargate Platform
        ///         Versions</a> in the <i>Amazon Elastic Container Service Developer
        ///         Guide</i>.</p>
        public let platformVersion: Swift.String?
        /// <p>The number of tasks to create based on <code>TaskDefinition</code>. The default is
        ///       1.</p>
        public let taskCount: Swift.Int?
        /// <p>The ARN of the task definition to use if the event target is an Amazon ECS task. </p>
        public let taskDefinitionArn: Swift.String?

        public init (
            group: Swift.String? = nil,
            launchType: CloudWatchEventsClientTypes.LaunchType? = nil,
            networkConfiguration: CloudWatchEventsClientTypes.NetworkConfiguration? = nil,
            platformVersion: Swift.String? = nil,
            taskCount: Swift.Int? = nil,
            taskDefinitionArn: Swift.String? = nil
        )
        {
            self.group = group
            self.launchType = launchType
            self.networkConfiguration = networkConfiguration
            self.platformVersion = platformVersion
            self.taskCount = taskCount
            self.taskDefinitionArn = taskDefinitionArn
        }
    }

}

public struct EnableRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableRuleOutputError>
}

extension EnableRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableRuleInput(eventBusName: \(Swift.String(describing: eventBusName)), name: \(Swift.String(describing: name)))"}
}

extension EnableRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct EnableRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableRuleOutputError>
}

public struct EnableRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableRuleOutputError>
}

public struct EnableRuleInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The name of the rule.</p>
    public let name: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct EnableRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let eventBusName: Swift.String?
}

extension EnableRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension EnableRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableRuleOutputResponse()"}
}

extension EnableRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct EnableRuleOutputResponseBody: Swift.Equatable {
}

extension EnableRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudWatchEventsClientTypes.EventBus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CloudWatchEventsClientTypes.EventBus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventBus(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)), policy: \(Swift.String(describing: policy)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>An event bus receives events from a source and routes them to rules associated with that
    ///       event bus. Your account's default event bus receives rules from AWS services. A custom event
    ///       bus can receive rules from AWS services as well as your custom applications and services. A
    ///       partner event bus receives events from an event source created by an SaaS partner. These
    ///       events come from the partners services or applications.</p>
    public struct EventBus: Swift.Equatable {
        /// <p>The ARN of the event bus.</p>
        public let arn: Swift.String?
        /// <p>The name of the event bus.</p>
        public let name: Swift.String?
        /// <p>The permissions policy of the event bus, describing which other AWS accounts can write
        ///       events to this event bus.</p>
        public let policy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            policy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.policy = policy
        }
    }

}

extension CloudWatchEventsClientTypes.EventSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension CloudWatchEventsClientTypes.EventSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSource(arn: \(Swift.String(describing: arn)), createdBy: \(Swift.String(describing: createdBy)), creationTime: \(Swift.String(describing: creationTime)), expirationTime: \(Swift.String(describing: expirationTime)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A partner event source is created by an SaaS partner. If a customer creates a partner
    ///       event bus that matches this event source, that AWS account can receive events from the
    ///       partner's applications or services.</p>
    public struct EventSource: Swift.Equatable {
        /// <p>The ARN of the event source.</p>
        public let arn: Swift.String?
        /// <p>The name of the partner that created the event source.</p>
        public let createdBy: Swift.String?
        /// <p>The date and time the event source was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The date and time that the event source will expire, if the AWS account doesn't create a
        ///       matching event bus for it.</p>
        public let expirationTime: ClientRuntime.Date?
        /// <p>The name of the event source.</p>
        public let name: Swift.String?
        /// <p>The state of the event source. If it is ACTIVE, you have already created a matching event
        ///       bus for this event source, and that event bus is active. If it is PENDING, either you haven't
        ///       yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have
        ///       created a matching event bus, but the event source has since been deleted.</p>
        public let state: CloudWatchEventsClientTypes.EventSourceState?

        public init (
            arn: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: CloudWatchEventsClientTypes.EventSourceState? = nil
        )
        {
            self.arn = arn
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.name = name
            self.state = state
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum EventSourceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceState] {
            return [
                .active,
                .deleted,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourceState(rawValue: rawValue) ?? EventSourceState.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes.HttpParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerParameters = "HeaderParameters"
        case pathParameterValues = "PathParameterValues"
        case queryStringParameters = "QueryStringParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerParameters = headerParameters {
            var headerParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headerParameters)
            for (dictKey0, headerparametersmap0) in headerParameters {
                try headerParametersContainer.encode(headerparametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let pathParameterValues = pathParameterValues {
            var pathParameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathParameterValues)
            for pathparameterlist0 in pathParameterValues {
                try pathParameterValuesContainer.encode(pathparameterlist0)
            }
        }
        if let queryStringParameters = queryStringParameters {
            var queryStringParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .queryStringParameters)
            for (dictKey0, querystringparametersmap0) in queryStringParameters {
                try queryStringParametersContainer.encode(querystringparametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathParameterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pathParameterValues)
        var pathParameterValuesDecoded0:[Swift.String]? = nil
        if let pathParameterValuesContainer = pathParameterValuesContainer {
            pathParameterValuesDecoded0 = [Swift.String]()
            for string0 in pathParameterValuesContainer {
                if let string0 = string0 {
                    pathParameterValuesDecoded0?.append(string0)
                }
            }
        }
        pathParameterValues = pathParameterValuesDecoded0
        let headerParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headerParameters)
        var headerParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let headerParametersContainer = headerParametersContainer {
            headerParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, headervalue0) in headerParametersContainer {
                if let headervalue0 = headervalue0 {
                    headerParametersDecoded0?[key0] = headervalue0
                }
            }
        }
        headerParameters = headerParametersDecoded0
        let queryStringParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .queryStringParameters)
        var queryStringParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let queryStringParametersContainer = queryStringParametersContainer {
            queryStringParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, querystringvalue0) in queryStringParametersContainer {
                if let querystringvalue0 = querystringvalue0 {
                    queryStringParametersDecoded0?[key0] = querystringvalue0
                }
            }
        }
        queryStringParameters = queryStringParametersDecoded0
    }
}

extension CloudWatchEventsClientTypes.HttpParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpParameters(headerParameters: \(Swift.String(describing: headerParameters)), pathParameterValues: \(Swift.String(describing: pathParameterValues)), queryStringParameters: \(Swift.String(describing: queryStringParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>These are custom parameter to be used when the target is an API Gateway REST APIs
    ///       or EventBridge ApiDestinations. In the latter case, these are merged with any InvocationParameters
    ///       specified on the Connection, with any values from the Connection taking precedence.</p>
    public struct HttpParameters: Swift.Equatable {
        /// <p>The headers that need to be sent as part of request invoking the API Gateway REST
        ///       API or EventBridge ApiDestination.</p>
        public let headerParameters: [Swift.String:Swift.String]?
        /// <p>The path parameter values to be used to populate API Gateway REST API or
        ///       EventBridge ApiDestination path wildcards ("*").</p>
        public let pathParameterValues: [Swift.String]?
        /// <p>The query string keys/values that need to be sent as part of request invoking the API
        ///       Gateway REST API or EventBridge ApiDestination.</p>
        public let queryStringParameters: [Swift.String:Swift.String]?

        public init (
            headerParameters: [Swift.String:Swift.String]? = nil,
            pathParameterValues: [Swift.String]? = nil,
            queryStringParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.headerParameters = headerParameters
            self.pathParameterValues = pathParameterValues
            self.queryStringParameters = queryStringParameters
        }
    }

}

extension IllegalStatusException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalStatusException(message: \(Swift.String(describing: message)))"}
}

extension IllegalStatusException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IllegalStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred because a replay can be canceled only when the state is Running or
///       Starting.</p>
public struct IllegalStatusException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalStatusExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchEventsClientTypes.InputTransformer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputPathsMap = "InputPathsMap"
        case inputTemplate = "InputTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPathsMap = inputPathsMap {
            var inputPathsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputPathsMap)
            for (dictKey0, transformerpaths0) in inputPathsMap {
                try inputPathsMapContainer.encode(transformerpaths0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputTemplate = inputTemplate {
            try encodeContainer.encode(inputTemplate, forKey: .inputTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPathsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .inputPathsMap)
        var inputPathsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let inputPathsMapContainer = inputPathsMapContainer {
            inputPathsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, targetinputpath0) in inputPathsMapContainer {
                if let targetinputpath0 = targetinputpath0 {
                    inputPathsMapDecoded0?[key0] = targetinputpath0
                }
            }
        }
        inputPathsMap = inputPathsMapDecoded0
        let inputTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputTemplate)
        inputTemplate = inputTemplateDecoded
    }
}

extension CloudWatchEventsClientTypes.InputTransformer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputTransformer(inputPathsMap: \(Swift.String(describing: inputPathsMap)), inputTemplate: \(Swift.String(describing: inputTemplate)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the parameters needed for you to provide custom input to a target based on one or
    ///       more pieces of data extracted from the event.</p>
    public struct InputTransformer: Swift.Equatable {
        /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the
        ///       template in <code>InputTemplate</code> to produce the output you want to be sent to the
        ///       target.</p>
        ///          <p>
        ///             <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON
        ///       path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket
        ///       notation.</p>
        ///          <p>The keys cannot start with "AWS." </p>
        public let inputPathsMap: [Swift.String:Swift.String]?
        /// <p>Input template where you specify placeholders that will be filled with the values of the
        ///       keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each
        ///         <code>InputPathsMaps</code> value in brackets: <<i>value</i>> The
        ///       InputTemplate must be valid JSON.</p>
        ///
        ///          <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following
        ///       restrictions apply:</p>
        ///          <ul>
        ///             <li>
        ///                <p>The placeholder cannot be used as an object key.</p>
        ///             </li>
        ///          </ul>
        ///          <p>The following example shows the syntax for using <code>InputPathsMap</code> and
        ///         <code>InputTemplate</code>.</p>
        ///          <p>
        ///             <code> "InputTransformer":</code>
        ///          </p>
        ///          <p>
        ///             <code>{</code>
        ///          </p>
        ///          <p>
        ///             <code>"InputPathsMap": {"instance": "$.detail.instance","status":
        ///         "$.detail.status"},</code>
        ///          </p>
        ///          <p>
        ///             <code>"InputTemplate": "<instance> is in state <status>"</code>
        ///          </p>
        ///          <p>
        ///             <code>}</code>
        ///          </p>
        ///          <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape
        ///       each quote marks with a slash, as in the following example:</p>
        ///          <p>
        ///             <code> "InputTransformer":</code>
        ///          </p>
        ///          <p>
        ///             <code>{</code>
        ///          </p>
        ///          <p>
        ///             <code>"InputPathsMap": {"instance": "$.detail.instance","status":
        ///         "$.detail.status"},</code>
        ///          </p>
        ///          <p>
        ///             <code>"InputTemplate": "<instance> is in state \"<status>\""</code>
        ///          </p>
        ///          <p>
        ///             <code>}</code>
        ///          </p>
        ///          <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out,
        ///       as in the following example:</p>
        ///          <p>
        ///             <code> "InputTransformer":</code>
        ///          </p>
        ///          <p>
        ///             <code>{</code>
        ///          </p>
        ///          <p>
        ///             <code>"InputPathsMap": {"instance": "$.detail.instance","status":
        ///         "$.detail.status"},</code>
        ///          </p>
        ///          <p>
        ///             <code>"InputTemplate": '{"myInstance": <instance>,"myStatus":
        ///         "<instance> is in state \"<status>\""}'</code>
        ///          </p>
        ///          <p>
        ///             <code>}</code>
        ///          </p>
        public let inputTemplate: Swift.String?

        public init (
            inputPathsMap: [Swift.String:Swift.String]? = nil,
            inputTemplate: Swift.String? = nil
        )
        {
            self.inputPathsMap = inputPathsMap
            self.inputTemplate = inputTemplate
        }
    }

}

extension InternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalException(message: \(Swift.String(describing: message)))"}
}

extension InternalException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception occurs due to unexpected causes.</p>
public struct InternalException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventPatternException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEventPatternException(message: \(Swift.String(describing: message)))"}
}

extension InvalidEventPatternException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEventPatternExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The event pattern is not valid.</p>
public struct InvalidEventPatternException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventPatternExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEventPatternExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified state is not a valid state for an event source.</p>
public struct InvalidStateException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchEventsClientTypes.KinesisParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partitionKeyPath = "PartitionKeyPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partitionKeyPath = partitionKeyPath {
            try encodeContainer.encode(partitionKeyPath, forKey: .partitionKeyPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionKeyPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionKeyPath)
        partitionKeyPath = partitionKeyPathDecoded
    }
}

extension CloudWatchEventsClientTypes.KinesisParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisParameters(partitionKeyPath: \(Swift.String(describing: partitionKeyPath)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>This object enables you to specify a JSON path to extract from the event and use as the
    ///       partition key for the Amazon Kinesis data stream, so that you can control the shard to which
    ///       the event goes. If you do not include this parameter, the default is to use the
    ///         <code>eventId</code> as the partition key.</p>
    public struct KinesisParameters: Swift.Equatable {
        /// <p>The JSON path to be extracted from the event and used as the partition key. For more
        ///       information, see <a href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html#partition-key">Amazon Kinesis Streams Key
        ///         Concepts</a> in the <i>Amazon Kinesis Streams Developer Guide</i>.</p>
        public let partitionKeyPath: Swift.String?

        public init (
            partitionKeyPath: Swift.String? = nil
        )
        {
            self.partitionKeyPath = partitionKeyPath
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum LaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case fargate
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchType] {
            return [
                .ec2,
                .fargate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .fargate: return "FARGATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchType(rawValue: rawValue) ?? LaunchType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because it attempted to create resource beyond the allowed service
///       quota.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListApiDestinationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApiDestinationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApiDestinationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApiDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApiDestinationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApiDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApiDestinationsOutputError>
}

extension ListApiDestinationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApiDestinationsInput(connectionArn: \(Swift.String(describing: connectionArn)), limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApiDestinationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApiDestinationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApiDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApiDestinationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApiDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApiDestinationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApiDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApiDestinationsOutputError>
}

public struct ListApiDestinationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApiDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApiDestinationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApiDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApiDestinationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApiDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApiDestinationsOutputError>
}

public struct ListApiDestinationsInput: Swift.Equatable {
    /// <p>The ARN of the connection specified for the API destination.</p>
    public let connectionArn: Swift.String?
    /// <p>The maximum number of API destinations to include in the response.</p>
    public let limit: Swift.Int?
    /// <p>A name prefix to filter results returned. Only API destinations with a name that starts
    ///       with the prefix are returned.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        connectionArn: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListApiDestinationsInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let connectionArn: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListApiDestinationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListApiDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApiDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApiDestinationsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApiDestinationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApiDestinationsOutputResponse(apiDestinations: \(Swift.String(describing: apiDestinations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApiDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApiDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinations = output.apiDestinations
            self.nextToken = output.nextToken
        } else {
            self.apiDestinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListApiDestinationsOutputResponse: Swift.Equatable {
    /// <p>An array of <code>ApiDestination</code> objects that include information about an API
    ///       destination.</p>
    public let apiDestinations: [CloudWatchEventsClientTypes.ApiDestination]?
    /// <p>A token you can use in a subsequent request to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        apiDestinations: [CloudWatchEventsClientTypes.ApiDestination]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiDestinations = apiDestinations
        self.nextToken = nextToken
    }
}

struct ListApiDestinationsOutputResponseBody: Swift.Equatable {
    public let apiDestinations: [CloudWatchEventsClientTypes.ApiDestination]?
    public let nextToken: Swift.String?
}

extension ListApiDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinations = "ApiDestinations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.ApiDestination?].self, forKey: .apiDestinations)
        var apiDestinationsDecoded0:[CloudWatchEventsClientTypes.ApiDestination]? = nil
        if let apiDestinationsContainer = apiDestinationsContainer {
            apiDestinationsDecoded0 = [CloudWatchEventsClientTypes.ApiDestination]()
            for structure0 in apiDestinationsContainer {
                if let structure0 = structure0 {
                    apiDestinationsDecoded0?.append(structure0)
                }
            }
        }
        apiDestinations = apiDestinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListArchivesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArchivesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArchivesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArchivesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArchivesOutputError>
}

extension ListArchivesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListArchivesInput(eventSourceArn: \(Swift.String(describing: eventSourceArn)), limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)), state: \(Swift.String(describing: state)))"}
}

extension ListArchivesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct ListArchivesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArchivesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArchivesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArchivesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArchivesOutputError>
}

public struct ListArchivesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArchivesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArchivesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArchivesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArchivesOutputError>
}

public struct ListArchivesInput: Swift.Equatable {
    /// <p>The ARN of the event source associated with the archive.</p>
    public let eventSourceArn: Swift.String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Swift.Int?
    /// <p>A name prefix to filter the archives returned. Only archives with name that match the
    ///       prefix are returned.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>The state of the archive.</p>
    public let state: CloudWatchEventsClientTypes.ArchiveState?

    public init (
        eventSourceArn: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        state: CloudWatchEventsClientTypes.ArchiveState? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListArchivesInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let eventSourceArn: Swift.String?
    public let state: CloudWatchEventsClientTypes.ArchiveState?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListArchivesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListArchivesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArchivesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListArchivesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArchivesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListArchivesOutputResponse(archives: \(Swift.String(describing: archives)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListArchivesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListArchivesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archives = output.archives
            self.nextToken = output.nextToken
        } else {
            self.archives = nil
            self.nextToken = nil
        }
    }
}

public struct ListArchivesOutputResponse: Swift.Equatable {
    /// <p>An array of <code>Archive</code> objects that include details about an archive.</p>
    public let archives: [CloudWatchEventsClientTypes.Archive]?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        archives: [CloudWatchEventsClientTypes.Archive]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.archives = archives
        self.nextToken = nextToken
    }
}

struct ListArchivesOutputResponseBody: Swift.Equatable {
    public let archives: [CloudWatchEventsClientTypes.Archive]?
    public let nextToken: Swift.String?
}

extension ListArchivesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archives = "Archives"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archivesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Archive?].self, forKey: .archives)
        var archivesDecoded0:[CloudWatchEventsClientTypes.Archive]? = nil
        if let archivesContainer = archivesContainer {
            archivesDecoded0 = [CloudWatchEventsClientTypes.Archive]()
            for structure0 in archivesContainer {
                if let structure0 = structure0 {
                    archivesDecoded0?.append(structure0)
                }
            }
        }
        archives = archivesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListConnectionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

extension ListConnectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectionsInput(connectionState: \(Swift.String(describing: connectionState)), limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState = "ConnectionState"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListConnectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInput: Swift.Equatable {
    /// <p>The state of the connection.</p>
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    /// <p>The maximum number of connections to return.</p>
    public let limit: Swift.Int?
    /// <p>A name prefix to filter results returned. Only connections with a name that starts with
    ///       the prefix are returned.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        connectionState: CloudWatchEventsClientTypes.ConnectionState? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionState = connectionState
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListConnectionsInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState = "ConnectionState"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectionsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectionsOutputResponse(connections: \(Swift.String(describing: connections)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Swift.Equatable {
    /// <p>An array of connections objects that include details about the connections.</p>
    public let connections: [CloudWatchEventsClientTypes.Connection]?
    /// <p>A token you can use in a subsequent request to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        connections: [CloudWatchEventsClientTypes.Connection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Swift.Equatable {
    public let connections: [CloudWatchEventsClientTypes.Connection]?
    public let nextToken: Swift.String?
}

extension ListConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[CloudWatchEventsClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [CloudWatchEventsClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventBusesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventBusesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventBusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventBusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventBusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventBusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventBusesOutputError>
}

extension ListEventBusesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventBusesInput(limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventBusesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventBusesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventBusesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventBusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventBusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventBusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventBusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventBusesOutputError>
}

public struct ListEventBusesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventBusesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventBusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventBusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventBusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventBusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventBusesOutputError>
}

public struct ListEventBusesInput: Swift.Equatable {
    /// <p>Specifying this limits the number of results returned by this operation. The operation
    ///       also returns a NextToken which you can use in a subsequent operation to retrieve the next set
    ///       of results.</p>
    public let limit: Swift.Int?
    /// <p>Specifying this limits the results to only those event buses with names that start with
    ///       the specified prefix.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListEventBusesInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListEventBusesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListEventBusesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventBusesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventBusesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventBusesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventBusesOutputResponse(eventBuses: \(Swift.String(describing: eventBuses)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventBusesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventBusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventBuses = output.eventBuses
            self.nextToken = output.nextToken
        } else {
            self.eventBuses = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventBusesOutputResponse: Swift.Equatable {
    /// <p>This list of event buses.</p>
    public let eventBuses: [CloudWatchEventsClientTypes.EventBus]?
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        eventBuses: [CloudWatchEventsClientTypes.EventBus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventBuses = eventBuses
        self.nextToken = nextToken
    }
}

struct ListEventBusesOutputResponseBody: Swift.Equatable {
    public let eventBuses: [CloudWatchEventsClientTypes.EventBus]?
    public let nextToken: Swift.String?
}

extension ListEventBusesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBuses = "EventBuses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.EventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[CloudWatchEventsClientTypes.EventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [CloudWatchEventsClientTypes.EventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventSourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSourcesOutputError>
}

extension ListEventSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventSourcesInput(limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventSourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventSourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSourcesOutputError>
}

public struct ListEventSourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSourcesOutputError>
}

public struct ListEventSourcesInput: Swift.Equatable {
    /// <p>Specifying this limits the number of results returned by this operation. The operation
    ///       also returns a NextToken which you can use in a subsequent operation to retrieve the next set
    ///       of results.</p>
    public let limit: Swift.Int?
    /// <p>Specifying this limits the results to only those partner event sources with names that
    ///       start with the specified prefix.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListEventSourcesInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListEventSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListEventSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventSourcesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventSourcesOutputResponse(eventSources: \(Swift.String(describing: eventSources)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSources = output.eventSources
            self.nextToken = output.nextToken
        } else {
            self.eventSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventSourcesOutputResponse: Swift.Equatable {
    /// <p>The list of event sources.</p>
    public let eventSources: [CloudWatchEventsClientTypes.EventSource]?
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        eventSources: [CloudWatchEventsClientTypes.EventSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSources = eventSources
        self.nextToken = nextToken
    }
}

struct ListEventSourcesOutputResponseBody: Swift.Equatable {
    public let eventSources: [CloudWatchEventsClientTypes.EventSource]?
    public let nextToken: Swift.String?
}

extension ListEventSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSources = "EventSources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.EventSource?].self, forKey: .eventSources)
        var eventSourcesDecoded0:[CloudWatchEventsClientTypes.EventSource]? = nil
        if let eventSourcesContainer = eventSourcesContainer {
            eventSourcesDecoded0 = [CloudWatchEventsClientTypes.EventSource]()
            for structure0 in eventSourcesContainer {
                if let structure0 = structure0 {
                    eventSourcesDecoded0?.append(structure0)
                }
            }
        }
        eventSources = eventSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPartnerEventSourceAccountsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerEventSourceAccountsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerEventSourceAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerEventSourceAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerEventSourceAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerEventSourceAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerEventSourceAccountsOutputError>
}

extension ListPartnerEventSourceAccountsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartnerEventSourceAccountsInput(eventSourceName: \(Swift.String(describing: eventSourceName)), limit: \(Swift.String(describing: limit)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPartnerEventSourceAccountsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceName = eventSourceName {
            try encodeContainer.encode(eventSourceName, forKey: .eventSourceName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPartnerEventSourceAccountsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerEventSourceAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerEventSourceAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerEventSourceAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerEventSourceAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerEventSourceAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerEventSourceAccountsOutputError>
}

public struct ListPartnerEventSourceAccountsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerEventSourceAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerEventSourceAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerEventSourceAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerEventSourceAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerEventSourceAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerEventSourceAccountsOutputError>
}

public struct ListPartnerEventSourceAccountsInput: Swift.Equatable {
    /// <p>The name of the partner event source to display account information about.</p>
    public let eventSourceName: Swift.String?
    /// <p>Specifying this limits the number of results returned by this operation. The operation
    ///       also returns a NextToken which you can use in a subsequent operation to retrieve the next set
    ///       of results.</p>
    public let limit: Swift.Int?
    /// <p>The token returned by a previous call to this operation. Specifying this retrieves the
    ///       next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        eventSourceName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListPartnerEventSourceAccountsInputBody: Swift.Equatable {
    public let eventSourceName: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListPartnerEventSourceAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceName = "EventSourceName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListPartnerEventSourceAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerEventSourceAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartnerEventSourceAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerEventSourceAccountsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartnerEventSourceAccountsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), partnerEventSourceAccounts: \(Swift.String(describing: partnerEventSourceAccounts)))"}
}

extension ListPartnerEventSourceAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPartnerEventSourceAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.partnerEventSourceAccounts = output.partnerEventSourceAccounts
        } else {
            self.nextToken = nil
            self.partnerEventSourceAccounts = nil
        }
    }
}

public struct ListPartnerEventSourceAccountsOutputResponse: Swift.Equatable {
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>The list of partner event sources returned by the operation.</p>
    public let partnerEventSourceAccounts: [CloudWatchEventsClientTypes.PartnerEventSourceAccount]?

    public init (
        nextToken: Swift.String? = nil,
        partnerEventSourceAccounts: [CloudWatchEventsClientTypes.PartnerEventSourceAccount]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerEventSourceAccounts = partnerEventSourceAccounts
    }
}

struct ListPartnerEventSourceAccountsOutputResponseBody: Swift.Equatable {
    public let partnerEventSourceAccounts: [CloudWatchEventsClientTypes.PartnerEventSourceAccount]?
    public let nextToken: Swift.String?
}

extension ListPartnerEventSourceAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case partnerEventSourceAccounts = "PartnerEventSourceAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partnerEventSourceAccountsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.PartnerEventSourceAccount?].self, forKey: .partnerEventSourceAccounts)
        var partnerEventSourceAccountsDecoded0:[CloudWatchEventsClientTypes.PartnerEventSourceAccount]? = nil
        if let partnerEventSourceAccountsContainer = partnerEventSourceAccountsContainer {
            partnerEventSourceAccountsDecoded0 = [CloudWatchEventsClientTypes.PartnerEventSourceAccount]()
            for structure0 in partnerEventSourceAccountsContainer {
                if let structure0 = structure0 {
                    partnerEventSourceAccountsDecoded0?.append(structure0)
                }
            }
        }
        partnerEventSourceAccounts = partnerEventSourceAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPartnerEventSourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerEventSourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerEventSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerEventSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerEventSourcesOutputError>
}

extension ListPartnerEventSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartnerEventSourcesInput(limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPartnerEventSourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPartnerEventSourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerEventSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerEventSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerEventSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerEventSourcesOutputError>
}

public struct ListPartnerEventSourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerEventSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerEventSourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerEventSourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerEventSourcesOutputError>
}

public struct ListPartnerEventSourcesInput: Swift.Equatable {
    /// <p>pecifying this limits the number of results returned by this operation. The operation also
    ///       returns a NextToken which you can use in a subsequent operation to retrieve the next set of
    ///       results.</p>
    public let limit: Swift.Int?
    /// <p>If you specify this, the results are limited to only those partner event sources that
    ///       start with the string you specify.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to this operation. Specifying this retrieves the
    ///       next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListPartnerEventSourcesInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListPartnerEventSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListPartnerEventSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerEventSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartnerEventSourcesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerEventSourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartnerEventSourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), partnerEventSources: \(Swift.String(describing: partnerEventSources)))"}
}

extension ListPartnerEventSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPartnerEventSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.partnerEventSources = output.partnerEventSources
        } else {
            self.nextToken = nil
            self.partnerEventSources = nil
        }
    }
}

public struct ListPartnerEventSourcesOutputResponse: Swift.Equatable {
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>The list of partner event sources returned by the operation.</p>
    public let partnerEventSources: [CloudWatchEventsClientTypes.PartnerEventSource]?

    public init (
        nextToken: Swift.String? = nil,
        partnerEventSources: [CloudWatchEventsClientTypes.PartnerEventSource]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerEventSources = partnerEventSources
    }
}

struct ListPartnerEventSourcesOutputResponseBody: Swift.Equatable {
    public let partnerEventSources: [CloudWatchEventsClientTypes.PartnerEventSource]?
    public let nextToken: Swift.String?
}

extension ListPartnerEventSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case partnerEventSources = "PartnerEventSources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partnerEventSourcesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.PartnerEventSource?].self, forKey: .partnerEventSources)
        var partnerEventSourcesDecoded0:[CloudWatchEventsClientTypes.PartnerEventSource]? = nil
        if let partnerEventSourcesContainer = partnerEventSourcesContainer {
            partnerEventSourcesDecoded0 = [CloudWatchEventsClientTypes.PartnerEventSource]()
            for structure0 in partnerEventSourcesContainer {
                if let structure0 = structure0 {
                    partnerEventSourcesDecoded0?.append(structure0)
                }
            }
        }
        partnerEventSources = partnerEventSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReplaysInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReplaysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReplaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReplaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReplaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReplaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReplaysOutputError>
}

extension ListReplaysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReplaysInput(eventSourceArn: \(Swift.String(describing: eventSourceArn)), limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)), state: \(Swift.String(describing: state)))"}
}

extension ListReplaysInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct ListReplaysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReplaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReplaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReplaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReplaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReplaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReplaysOutputError>
}

public struct ListReplaysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReplaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReplaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReplaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReplaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReplaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReplaysOutputError>
}

public struct ListReplaysInput: Swift.Equatable {
    /// <p>The ARN of the event source associated with the replay.</p>
    public let eventSourceArn: Swift.String?
    /// <p>The maximum number of replays to retrieve.</p>
    public let limit: Swift.Int?
    /// <p>A name prefix to filter the replays returned. Only replays with name that match the prefix
    ///       are returned.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>The state of the replay.</p>
    public let state: CloudWatchEventsClientTypes.ReplayState?

    public init (
        eventSourceArn: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        state: CloudWatchEventsClientTypes.ReplayState? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListReplaysInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let state: CloudWatchEventsClientTypes.ReplayState?
    public let eventSourceArn: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListReplaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListReplaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReplaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReplaysOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReplaysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReplaysOutputResponse(nextToken: \(Swift.String(describing: nextToken)), replays: \(Swift.String(describing: replays)))"}
}

extension ListReplaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReplaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.replays = output.replays
        } else {
            self.nextToken = nil
            self.replays = nil
        }
    }
}

public struct ListReplaysOutputResponse: Swift.Equatable {
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>An array of <code>Replay</code> objects that contain information about the replay.</p>
    public let replays: [CloudWatchEventsClientTypes.Replay]?

    public init (
        nextToken: Swift.String? = nil,
        replays: [CloudWatchEventsClientTypes.Replay]? = nil
    )
    {
        self.nextToken = nextToken
        self.replays = replays
    }
}

struct ListReplaysOutputResponseBody: Swift.Equatable {
    public let replays: [CloudWatchEventsClientTypes.Replay]?
    public let nextToken: Swift.String?
}

extension ListReplaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case replays = "Replays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replaysContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Replay?].self, forKey: .replays)
        var replaysDecoded0:[CloudWatchEventsClientTypes.Replay]? = nil
        if let replaysContainer = replaysContainer {
            replaysDecoded0 = [CloudWatchEventsClientTypes.Replay]()
            for structure0 in replaysContainer {
                if let structure0 = structure0 {
                    replaysDecoded0?.append(structure0)
                }
            }
        }
        replays = replaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRuleNamesByTargetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRuleNamesByTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRuleNamesByTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRuleNamesByTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRuleNamesByTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRuleNamesByTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRuleNamesByTargetOutputError>
}

extension ListRuleNamesByTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRuleNamesByTargetInput(eventBusName: \(Swift.String(describing: eventBusName)), limit: \(Swift.String(describing: limit)), nextToken: \(Swift.String(describing: nextToken)), targetArn: \(Swift.String(describing: targetArn)))"}
}

extension ListRuleNamesByTargetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

public struct ListRuleNamesByTargetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRuleNamesByTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRuleNamesByTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRuleNamesByTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRuleNamesByTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRuleNamesByTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRuleNamesByTargetOutputError>
}

public struct ListRuleNamesByTargetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRuleNamesByTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRuleNamesByTargetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRuleNamesByTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRuleNamesByTargetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRuleNamesByTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRuleNamesByTargetOutputError>
}

public struct ListRuleNamesByTargetInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus to list rules for. If you omit this, the default event
    ///       bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Swift.Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the target resource.</p>
    public let targetArn: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.nextToken = nextToken
        self.targetArn = targetArn
    }
}

struct ListRuleNamesByTargetInputBody: Swift.Equatable {
    public let targetArn: Swift.String?
    public let eventBusName: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListRuleNamesByTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case targetArn = "TargetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRuleNamesByTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRuleNamesByTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRuleNamesByTargetOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRuleNamesByTargetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRuleNamesByTargetOutputResponse(nextToken: \(Swift.String(describing: nextToken)), ruleNames: \(Swift.String(describing: ruleNames)))"}
}

extension ListRuleNamesByTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRuleNamesByTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.ruleNames = output.ruleNames
        } else {
            self.nextToken = nil
            self.ruleNames = nil
        }
    }
}

public struct ListRuleNamesByTargetOutputResponse: Swift.Equatable {
    /// <p>Indicates whether there are additional results to retrieve. If there are no more results,
    ///       the value is null.</p>
    public let nextToken: Swift.String?
    /// <p>The names of the rules that can invoke the given target.</p>
    public let ruleNames: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        ruleNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleNames = ruleNames
    }
}

struct ListRuleNamesByTargetOutputResponseBody: Swift.Equatable {
    public let ruleNames: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListRuleNamesByTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case ruleNames = "RuleNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ruleNames)
        var ruleNamesDecoded0:[Swift.String]? = nil
        if let ruleNamesContainer = ruleNamesContainer {
            ruleNamesDecoded0 = [Swift.String]()
            for string0 in ruleNamesContainer {
                if let string0 = string0 {
                    ruleNamesDecoded0?.append(string0)
                }
            }
        }
        ruleNames = ruleNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRulesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesOutputError>
}

extension ListRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRulesInput(eventBusName: \(Swift.String(describing: eventBusName)), limit: \(Swift.String(describing: limit)), namePrefix: \(Swift.String(describing: namePrefix)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRulesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesOutputError>
}

public struct ListRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesOutputError>
}

public struct ListRulesInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus to list the rules for. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Swift.Int?
    /// <p>The prefix matching the rule name.</p>
    public let namePrefix: Swift.String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListRulesInputBody: Swift.Equatable {
    public let namePrefix: Swift.String?
    public let eventBusName: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRulesOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRulesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), rules: \(Swift.String(describing: rules)))"}
}

extension ListRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Swift.Equatable {
    /// <p>Indicates whether there are additional results to retrieve. If there are no more results,
    ///       the value is null.</p>
    public let nextToken: Swift.String?
    /// <p>The rules that match the specified criteria.</p>
    public let rules: [CloudWatchEventsClientTypes.Rule]?

    public init (
        nextToken: Swift.String? = nil,
        rules: [CloudWatchEventsClientTypes.Rule]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Swift.Equatable {
    public let rules: [CloudWatchEventsClientTypes.Rule]?
    public let nextToken: Swift.String?
}

extension ListRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[CloudWatchEventsClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CloudWatchEventsClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The ARN of the EventBridge resource for which you want to view tags.</p>
    public let resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The list of tag keys and values associated with the resource you specified</p>
    public let tags: [CloudWatchEventsClientTypes.Tag]?

    public init (
        tags: [CloudWatchEventsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [CloudWatchEventsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudWatchEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudWatchEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTargetsByRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTargetsByRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTargetsByRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTargetsByRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTargetsByRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTargetsByRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTargetsByRuleOutputError>
}

extension ListTargetsByRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTargetsByRuleInput(eventBusName: \(Swift.String(describing: eventBusName)), limit: \(Swift.String(describing: limit)), nextToken: \(Swift.String(describing: nextToken)), rule: \(Swift.String(describing: rule)))"}
}

extension ListTargetsByRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case rule = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct ListTargetsByRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTargetsByRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTargetsByRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTargetsByRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTargetsByRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTargetsByRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTargetsByRuleOutputError>
}

public struct ListTargetsByRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTargetsByRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTargetsByRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTargetsByRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTargetsByRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTargetsByRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTargetsByRuleOutputError>
}

public struct ListTargetsByRuleInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Swift.Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>The name of the rule.</p>
    public let rule: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rule: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.nextToken = nextToken
        self.rule = rule
    }
}

struct ListTargetsByRuleInputBody: Swift.Equatable {
    public let rule: Swift.String?
    public let eventBusName: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
}

extension ListTargetsByRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case rule = "Rule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTargetsByRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsByRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTargetsByRuleOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsByRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTargetsByRuleOutputResponse(nextToken: \(Swift.String(describing: nextToken)), targets: \(Swift.String(describing: targets)))"}
}

extension ListTargetsByRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTargetsByRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct ListTargetsByRuleOutputResponse: Swift.Equatable {
    /// <p>Indicates whether there are additional results to retrieve. If there are no more results,
    ///       the value is null.</p>
    public let nextToken: Swift.String?
    /// <p>The targets assigned to the rule.</p>
    public let targets: [CloudWatchEventsClientTypes.Target]?

    public init (
        nextToken: Swift.String? = nil,
        targets: [CloudWatchEventsClientTypes.Target]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct ListTargetsByRuleOutputResponseBody: Swift.Equatable {
    public let targets: [CloudWatchEventsClientTypes.Target]?
    public let nextToken: Swift.String?
}

extension ListTargetsByRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[CloudWatchEventsClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CloudWatchEventsClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ManagedRuleException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManagedRuleException(message: \(Swift.String(describing: message)))"}
}

extension ManagedRuleException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ManagedRuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This rule was created by an AWS service on behalf of your account. It is managed by that
///       service. If you see this error in response to <code>DeleteRule</code> or
///         <code>RemoveTargets</code>, you can use the <code>Force</code> parameter in those calls to
///       delete the rule or remove targets from the rule. You cannot modify these managed rules by
///       using <code>DisableRule</code>, <code>EnableRule</code>, <code>PutTargets</code>,
///         <code>PutRule</code>, <code>TagResource</code>, or <code>UntagResource</code>. </p>
public struct ManagedRuleException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ManagedRuleExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ManagedRuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchEventsClientTypes.NetworkConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsvpcConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsvpcConfiguration = awsvpcConfiguration {
            try encodeContainer.encode(awsvpcConfiguration, forKey: .awsvpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsvpcConfigurationDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.AwsVpcConfiguration.self, forKey: .awsvpcConfiguration)
        awsvpcConfiguration = awsvpcConfigurationDecoded
    }
}

extension CloudWatchEventsClientTypes.NetworkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkConfiguration(awsvpcConfiguration: \(Swift.String(describing: awsvpcConfiguration)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>This structure specifies the network configuration for an ECS task.</p>
    public struct NetworkConfiguration: Swift.Equatable {
        /// <p>Use this structure to specify the VPC subnets and security groups for the task, and
        ///       whether a public IP address is to be used. This structure is relevant only for ECS tasks that
        ///       use the <code>awsvpc</code> network mode.</p>
        public let awsvpcConfiguration: CloudWatchEventsClientTypes.AwsVpcConfiguration?

        public init (
            awsvpcConfiguration: CloudWatchEventsClientTypes.AwsVpcConfiguration? = nil
        )
        {
            self.awsvpcConfiguration = awsvpcConfiguration
        }
    }

}

extension OperationDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationDisabledException(message: \(Swift.String(describing: message)))"}
}

extension OperationDisabledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation you are attempting is not available in this region.</p>
public struct OperationDisabledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchEventsClientTypes.PartnerEventSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CloudWatchEventsClientTypes.PartnerEventSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PartnerEventSource(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A partner event source is created by an SaaS partner. If a customer creates a partner
    ///       event bus that matches this event source, that AWS account can receive events from the
    ///       partner's applications or services.</p>
    public struct PartnerEventSource: Swift.Equatable {
        /// <p>The ARN of the partner event source.</p>
        public let arn: Swift.String?
        /// <p>The name of the partner event source.</p>
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension CloudWatchEventsClientTypes.PartnerEventSourceAccount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension CloudWatchEventsClientTypes.PartnerEventSourceAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PartnerEventSourceAccount(account: \(Swift.String(describing: account)), creationTime: \(Swift.String(describing: creationTime)), expirationTime: \(Swift.String(describing: expirationTime)), state: \(Swift.String(describing: state)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>The AWS account that a partner event source has been offered to.</p>
    public struct PartnerEventSourceAccount: Swift.Equatable {
        /// <p>The AWS account ID that the partner event source was offered to.</p>
        public let account: Swift.String?
        /// <p>The date and time the event source was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The date and time that the event source will expire, if the AWS account doesn't create a
        ///       matching event bus for it.</p>
        public let expirationTime: ClientRuntime.Date?
        /// <p>The state of the event source. If it is ACTIVE, you have already created a matching event
        ///       bus for this event source, and that event bus is active. If it is PENDING, either you haven't
        ///       yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have
        ///       created a matching event bus, but the event source has since been deleted.</p>
        public let state: CloudWatchEventsClientTypes.EventSourceState?

        public init (
            account: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            state: CloudWatchEventsClientTypes.EventSourceState? = nil
        )
        {
            self.account = account
            self.creationTime = creationTime
            self.expirationTime = expirationTime
            self.state = state
        }
    }

}

extension PolicyLengthExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyLengthExceededException(message: \(Swift.String(describing: message)))"}
}

extension PolicyLengthExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PolicyLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The event bus policy is too long. For more information, see the limits.</p>
public struct PolicyLengthExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyLengthExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PolicyLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsOutputError>
}

extension PutEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsInput(entries: \(Swift.String(describing: entries)))"}
}

extension PutEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for puteventsrequestentrylist0 in entries {
                try entriesContainer.encode(puteventsrequestentrylist0)
            }
        }
    }
}

public struct PutEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsOutputError>
}

public struct PutEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsOutputError>
}

public struct PutEventsInput: Swift.Equatable {
    /// <p>The entry that defines an event in your system. You can specify several parameters for the
    ///       entry such as the source and type of the event, resources associated with the event, and so
    ///       on.</p>
    public let entries: [CloudWatchEventsClientTypes.PutEventsRequestEntry]?

    public init (
        entries: [CloudWatchEventsClientTypes.PutEventsRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct PutEventsInputBody: Swift.Equatable {
    public let entries: [CloudWatchEventsClientTypes.PutEventsRequestEntry]?
}

extension PutEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.PutEventsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[CloudWatchEventsClientTypes.PutEventsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [CloudWatchEventsClientTypes.PutEventsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension PutEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsOutputResponse(entries: \(Swift.String(describing: entries)), failedEntryCount: \(Swift.String(describing: failedEntryCount)))"}
}

extension PutEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.entries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutEventsOutputResponse: Swift.Equatable {
    /// <p>The successfully and unsuccessfully ingested events results. If the ingestion was
    ///       successful, the entry has the event ID in it. Otherwise, you can use the error code and error
    ///       message to identify the problem with the entry.</p>
    public let entries: [CloudWatchEventsClientTypes.PutEventsResultEntry]?
    /// <p>The number of failed entries.</p>
    public let failedEntryCount: Swift.Int

    public init (
        entries: [CloudWatchEventsClientTypes.PutEventsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.entries = entries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutEventsOutputResponseBody: Swift.Equatable {
    public let failedEntryCount: Swift.Int
    public let entries: [CloudWatchEventsClientTypes.PutEventsResultEntry]?
}

extension PutEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let entriesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.PutEventsResultEntry?].self, forKey: .entries)
        var entriesDecoded0:[CloudWatchEventsClientTypes.PutEventsResultEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [CloudWatchEventsClientTypes.PutEventsResultEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension CloudWatchEventsClientTypes.PutEventsRequestEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail = "Detail"
        case detailType = "DetailType"
        case eventBusName = "EventBusName"
        case resources = "Resources"
        case source = "Source"
        case time = "Time"
        case traceHeader = "TraceHeader"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresourcelist0 in resources {
                try resourcesContainer.encode(eventresourcelist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
        if let traceHeader = traceHeader {
            try encodeContainer.encode(traceHeader, forKey: .traceHeader)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .time)
        time = timeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension CloudWatchEventsClientTypes.PutEventsRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsRequestEntry(detail: \(Swift.String(describing: detail)), detailType: \(Swift.String(describing: detailType)), eventBusName: \(Swift.String(describing: eventBusName)), resources: \(Swift.String(describing: resources)), source: \(Swift.String(describing: source)), time: \(Swift.String(describing: time)), traceHeader: \(Swift.String(describing: traceHeader)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Represents an event to be submitted.</p>
    public struct PutEventsRequestEntry: Swift.Equatable {
        /// <p>A valid JSON string. There is no other schema imposed. The JSON string may contain fields
        ///       and nested subobjects.</p>
        public let detail: Swift.String?
        /// <p>Free-form string used to decide what fields to expect in the event detail.</p>
        public let detailType: Swift.String?
        /// <p>The name or ARN of the event bus to receive the event. Only the rules that are associated
        ///       with this event bus are used to match the event. If you omit this, the default event bus is
        ///       used.</p>
        public let eventBusName: Swift.String?
        /// <p>AWS resources, identified by Amazon Resource Name (ARN), which the event primarily
        ///       concerns. Any number, including zero, may be present.</p>
        public let resources: [Swift.String]?
        /// <p>The source of the event.</p>
        public let source: Swift.String?
        /// <p>The time stamp of the event, per <a href="https://www.rfc-editor.org/rfc/rfc3339.txt">RFC3339</a>. If no time stamp is provided, the time stamp of the <a>PutEvents</a> call is used.</p>
        public let time: ClientRuntime.Date?
        /// <p>An AWS X-Ray trade header, which is an http header (X-Amzn-Trace-Id) that contains the trace-id associated with the event.</p>
        ///          <p>To learn more about X-Ray trace headers, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader">Tracing header</a> in the AWS X-Ray Developer Guide.</p>
        public let traceHeader: Swift.String?

        public init (
            detail: Swift.String? = nil,
            detailType: Swift.String? = nil,
            eventBusName: Swift.String? = nil,
            resources: [Swift.String]? = nil,
            source: Swift.String? = nil,
            time: ClientRuntime.Date? = nil,
            traceHeader: Swift.String? = nil
        )
        {
            self.detail = detail
            self.detailType = detailType
            self.eventBusName = eventBusName
            self.resources = resources
            self.source = source
            self.time = time
            self.traceHeader = traceHeader
        }
    }

}

extension CloudWatchEventsClientTypes.PutEventsResultEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case eventId = "EventId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CloudWatchEventsClientTypes.PutEventsResultEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsResultEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), eventId: \(Swift.String(describing: eventId)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Represents an event that failed to be submitted.</p>
    public struct PutEventsResultEntry: Swift.Equatable {
        /// <p>The error code that indicates why the event submission failed.</p>
        public let errorCode: Swift.String?
        /// <p>The error message that explains why the event submission failed.</p>
        public let errorMessage: Swift.String?
        /// <p>The ID of the event.</p>
        public let eventId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.eventId = eventId
        }
    }

}

public struct PutPartnerEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPartnerEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPartnerEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPartnerEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPartnerEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPartnerEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPartnerEventsOutputError>
}

extension PutPartnerEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPartnerEventsInput(entries: \(Swift.String(describing: entries)))"}
}

extension PutPartnerEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for putpartnereventsrequestentrylist0 in entries {
                try entriesContainer.encode(putpartnereventsrequestentrylist0)
            }
        }
    }
}

public struct PutPartnerEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPartnerEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPartnerEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPartnerEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPartnerEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPartnerEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPartnerEventsOutputError>
}

public struct PutPartnerEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPartnerEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPartnerEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPartnerEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPartnerEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPartnerEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPartnerEventsOutputError>
}

public struct PutPartnerEventsInput: Swift.Equatable {
    /// <p>The list of events to write to the event bus.</p>
    public let entries: [CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry]?

    public init (
        entries: [CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct PutPartnerEventsInputBody: Swift.Equatable {
    public let entries: [CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry]?
}

extension PutPartnerEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension PutPartnerEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPartnerEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPartnerEventsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPartnerEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPartnerEventsOutputResponse(entries: \(Swift.String(describing: entries)), failedEntryCount: \(Swift.String(describing: failedEntryCount)))"}
}

extension PutPartnerEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutPartnerEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.entries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutPartnerEventsOutputResponse: Swift.Equatable {
    /// <p>The list of events from this operation that were successfully written to the partner event
    ///       bus.</p>
    public let entries: [CloudWatchEventsClientTypes.PutPartnerEventsResultEntry]?
    /// <p>The number of events from this operation that could not be written to the partner event
    ///       bus.</p>
    public let failedEntryCount: Swift.Int

    public init (
        entries: [CloudWatchEventsClientTypes.PutPartnerEventsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.entries = entries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutPartnerEventsOutputResponseBody: Swift.Equatable {
    public let failedEntryCount: Swift.Int
    public let entries: [CloudWatchEventsClientTypes.PutPartnerEventsResultEntry]?
}

extension PutPartnerEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let entriesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.PutPartnerEventsResultEntry?].self, forKey: .entries)
        var entriesDecoded0:[CloudWatchEventsClientTypes.PutPartnerEventsResultEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [CloudWatchEventsClientTypes.PutPartnerEventsResultEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail = "Detail"
        case detailType = "DetailType"
        case resources = "Resources"
        case source = "Source"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresourcelist0 in resources {
                try resourcesContainer.encode(eventresourcelist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .time)
        time = timeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension CloudWatchEventsClientTypes.PutPartnerEventsRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPartnerEventsRequestEntry(detail: \(Swift.String(describing: detail)), detailType: \(Swift.String(describing: detailType)), resources: \(Swift.String(describing: resources)), source: \(Swift.String(describing: source)), time: \(Swift.String(describing: time)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>The details about an event generated by an SaaS partner.</p>
    public struct PutPartnerEventsRequestEntry: Swift.Equatable {
        /// <p>A valid JSON string. There is no other schema imposed. The JSON string may contain fields
        ///       and nested subobjects.</p>
        public let detail: Swift.String?
        /// <p>A free-form string used to decide what fields to expect in the event detail.</p>
        public let detailType: Swift.String?
        /// <p>AWS resources, identified by Amazon Resource Name (ARN), which the event primarily
        ///       concerns. Any number, including zero, may be present.</p>
        public let resources: [Swift.String]?
        /// <p>The event source that is generating the evntry.</p>
        public let source: Swift.String?
        /// <p>The date and time of the event.</p>
        public let time: ClientRuntime.Date?

        public init (
            detail: Swift.String? = nil,
            detailType: Swift.String? = nil,
            resources: [Swift.String]? = nil,
            source: Swift.String? = nil,
            time: ClientRuntime.Date? = nil
        )
        {
            self.detail = detail
            self.detailType = detailType
            self.resources = resources
            self.source = source
            self.time = time
        }
    }

}

extension CloudWatchEventsClientTypes.PutPartnerEventsResultEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case eventId = "EventId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CloudWatchEventsClientTypes.PutPartnerEventsResultEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPartnerEventsResultEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), eventId: \(Swift.String(describing: eventId)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Represents an event that a partner tried to generate, but failed.</p>
    public struct PutPartnerEventsResultEntry: Swift.Equatable {
        /// <p>The error code that indicates why the event submission failed.</p>
        public let errorCode: Swift.String?
        /// <p>The error message that explains why the event submission failed.</p>
        public let errorMessage: Swift.String?
        /// <p>The ID of the event.</p>
        public let eventId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.eventId = eventId
        }
    }

}

public struct PutPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPermissionOutputError>
}

extension PutPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPermissionInput(action: \(Swift.String(describing: action)), condition: \(Swift.String(describing: condition)), eventBusName: \(Swift.String(describing: eventBusName)), policy: \(Swift.String(describing: policy)), principal: \(Swift.String(describing: principal)), statementId: \(Swift.String(describing: statementId)))"}
}

extension PutPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case condition = "Condition"
        case eventBusName = "EventBusName"
        case policy = "Policy"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct PutPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPermissionOutputError>
}

public struct PutPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPermissionOutputError>
}

public struct PutPermissionInput: Swift.Equatable {
    /// <p>The action that you are enabling the other account to perform. Currently, this must be
    ///         <code>events:PutEvents</code>.</p>
    public let action: Swift.String?
    /// <p>This parameter enables you to limit the permission to accounts that fulfill a certain
    ///       condition, such as being a member of a certain AWS organization. For more information about
    ///       AWS Organizations, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html">What Is AWS
    ///         Organizations</a> in the <i>AWS Organizations User Guide</i>.</p>
    ///          <p>If you specify <code>Condition</code> with an AWS organization ID, and specify "*" as the
    ///       value for <code>Principal</code>, you grant permission to all the accounts in the named
    ///       organization.</p>
    ///
    ///          <p>The <code>Condition</code> is a JSON string which must contain <code>Type</code>,
    ///         <code>Key</code>, and <code>Value</code> fields.</p>
    public let condition: CloudWatchEventsClientTypes.Condition?
    /// <p>The name of the event bus associated with the rule. If you omit this, the default event
    ///       bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>A JSON string that describes the permission policy statement. You can include a
    ///         <code>Policy</code> parameter in the request instead of using the <code>StatementId</code>,
    ///         <code>Action</code>, <code>Principal</code>, or <code>Condition</code> parameters.</p>
    public let policy: Swift.String?
    /// <p>The 12-digit AWS account ID that you are permitting to put events to your default event
    ///       bus. Specify "*" to permit any account to put events to your default event bus.</p>
    ///
    ///          <p>If you specify "*" without specifying <code>Condition</code>, avoid creating rules that
    ///       may match undesirable events. To create more secure rules, make sure that the event pattern
    ///       for each rule contains an <code>account</code> field with a specific account ID from which to
    ///       receive events. Rules with an account field do not match any events sent from other
    ///       accounts.</p>
    public let principal: Swift.String?
    /// <p>An identifier string for the external account that you are granting permissions to. If you
    ///       later want to revoke the permission for this external account, specify this
    ///         <code>StatementId</code> when you run <a>RemovePermission</a>.</p>
    public let statementId: Swift.String?

    public init (
        action: Swift.String? = nil,
        condition: CloudWatchEventsClientTypes.Condition? = nil,
        eventBusName: Swift.String? = nil,
        policy: Swift.String? = nil,
        principal: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.condition = condition
        self.eventBusName = eventBusName
        self.policy = policy
        self.principal = principal
        self.statementId = statementId
    }
}

struct PutPermissionInputBody: Swift.Equatable {
    public let eventBusName: Swift.String?
    public let action: Swift.String?
    public let principal: Swift.String?
    public let statementId: Swift.String?
    public let condition: CloudWatchEventsClientTypes.Condition?
    public let policy: Swift.String?
}

extension PutPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case condition = "Condition"
        case eventBusName = "EventBusName"
        case policy = "Policy"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPermissionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPermissionOutputResponse()"}
}

extension PutPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutPermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutPermissionOutputResponseBody: Swift.Equatable {
}

extension PutPermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRuleOutputError>
}

extension PutRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRuleInput(description: \(Swift.String(describing: description)), eventBusName: \(Swift.String(describing: eventBusName)), eventPattern: \(Swift.String(describing: eventPattern)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension PutRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRuleOutputError>
}

public struct PutRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRuleOutputError>
}

public struct PutRuleInput: Swift.Equatable {
    /// <p>A description of the rule.</p>
    public let description: Swift.String?
    /// <p>The name or ARN of the event bus to associate with this rule. If you omit this, the
    ///       default event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The event pattern. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
    ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    public let eventPattern: Swift.String?
    /// <p>The name of the rule that you are creating or updating.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the rule.</p>
    public let roleArn: Swift.String?
    /// <p>The scheduling expression. For example, "cron(0 20 * * ? *)" or "rate(5 minutes)".</p>
    public let scheduleExpression: Swift.String?
    /// <p>Indicates whether the rule is enabled or disabled.</p>
    public let state: CloudWatchEventsClientTypes.RuleState?
    /// <p>The list of key-value pairs to associate with the rule.</p>
    public let tags: [CloudWatchEventsClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        eventBusName: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        scheduleExpression: Swift.String? = nil,
        state: CloudWatchEventsClientTypes.RuleState? = nil,
        tags: [CloudWatchEventsClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.eventBusName = eventBusName
        self.eventPattern = eventPattern
        self.name = name
        self.roleArn = roleArn
        self.scheduleExpression = scheduleExpression
        self.state = state
        self.tags = tags
    }
}

struct PutRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let scheduleExpression: Swift.String?
    public let eventPattern: Swift.String?
    public let state: CloudWatchEventsClientTypes.RuleState?
    public let description: Swift.String?
    public let roleArn: Swift.String?
    public let tags: [CloudWatchEventsClientTypes.Tag]?
    public let eventBusName: Swift.String?
}

extension PutRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudWatchEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudWatchEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension PutRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRuleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRuleOutputResponse(ruleArn: \(Swift.String(describing: ruleArn)))"}
}

extension PutRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ruleArn = output.ruleArn
        } else {
            self.ruleArn = nil
        }
    }
}

public struct PutRuleOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: Swift.String?

    public init (
        ruleArn: Swift.String? = nil
    )
    {
        self.ruleArn = ruleArn
    }
}

struct PutRuleOutputResponseBody: Swift.Equatable {
    public let ruleArn: Swift.String?
}

extension PutRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleArn = "RuleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
    }
}

public struct PutTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutTargetsOutputError>
}

extension PutTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutTargetsInput(eventBusName: \(Swift.String(describing: eventBusName)), rule: \(Swift.String(describing: rule)), targets: \(Swift.String(describing: targets)))"}
}

extension PutTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case rule = "Rule"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetlist0 in targets {
                try targetsContainer.encode(targetlist0)
            }
        }
    }
}

public struct PutTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutTargetsOutputError>
}

public struct PutTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutTargetsOutputError>
}

public struct PutTargetsInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>The name of the rule.</p>
    public let rule: Swift.String?
    /// <p>The targets to update or add to the rule.</p>
    public let targets: [CloudWatchEventsClientTypes.Target]?

    public init (
        eventBusName: Swift.String? = nil,
        rule: Swift.String? = nil,
        targets: [CloudWatchEventsClientTypes.Target]? = nil
    )
    {
        self.eventBusName = eventBusName
        self.rule = rule
        self.targets = targets
    }
}

struct PutTargetsInputBody: Swift.Equatable {
    public let rule: Swift.String?
    public let eventBusName: Swift.String?
    public let targets: [CloudWatchEventsClientTypes.Target]?
}

extension PutTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case rule = "Rule"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[CloudWatchEventsClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CloudWatchEventsClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension PutTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutTargetsOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutTargetsOutputResponse(failedEntries: \(Swift.String(describing: failedEntries)), failedEntryCount: \(Swift.String(describing: failedEntryCount)))"}
}

extension PutTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedEntries = output.failedEntries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.failedEntries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutTargetsOutputResponse: Swift.Equatable {
    /// <p>The failed target entries.</p>
    public let failedEntries: [CloudWatchEventsClientTypes.PutTargetsResultEntry]?
    /// <p>The number of failed entries.</p>
    public let failedEntryCount: Swift.Int

    public init (
        failedEntries: [CloudWatchEventsClientTypes.PutTargetsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.failedEntries = failedEntries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutTargetsOutputResponseBody: Swift.Equatable {
    public let failedEntryCount: Swift.Int
    public let failedEntries: [CloudWatchEventsClientTypes.PutTargetsResultEntry]?
}

extension PutTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedEntries = "FailedEntries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let failedEntriesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.PutTargetsResultEntry?].self, forKey: .failedEntries)
        var failedEntriesDecoded0:[CloudWatchEventsClientTypes.PutTargetsResultEntry]? = nil
        if let failedEntriesContainer = failedEntriesContainer {
            failedEntriesDecoded0 = [CloudWatchEventsClientTypes.PutTargetsResultEntry]()
            for structure0 in failedEntriesContainer {
                if let structure0 = structure0 {
                    failedEntriesDecoded0?.append(structure0)
                }
            }
        }
        failedEntries = failedEntriesDecoded0
    }
}

extension CloudWatchEventsClientTypes.PutTargetsResultEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case targetId = "TargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CloudWatchEventsClientTypes.PutTargetsResultEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutTargetsResultEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), targetId: \(Swift.String(describing: targetId)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Represents a target that failed to be added to a rule.</p>
    public struct PutTargetsResultEntry: Swift.Equatable {
        /// <p>The error code that indicates why the target addition failed. If the value is
        ///         <code>ConcurrentModificationException</code>, too many requests were made at the same
        ///       time.</p>
        public let errorCode: Swift.String?
        /// <p>The error message that explains why the target addition failed.</p>
        public let errorMessage: Swift.String?
        /// <p>The ID of the target.</p>
        public let targetId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            targetId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.targetId = targetId
        }
    }

}

extension CloudWatchEventsClientTypes.RedshiftDataParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case dbUser = "DbUser"
        case secretManagerArn = "SecretManagerArn"
        case sql = "Sql"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if withEvent != false {
            try encodeContainer.encode(withEvent, forKey: .withEvent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let withEventDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withEvent)
        withEvent = withEventDecoded
    }
}

extension CloudWatchEventsClientTypes.RedshiftDataParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftDataParameters(database: \(Swift.String(describing: database)), dbUser: \(Swift.String(describing: dbUser)), secretManagerArn: \(Swift.String(describing: secretManagerArn)), sql: \(Swift.String(describing: sql)), statementName: \(Swift.String(describing: statementName)), withEvent: \(Swift.String(describing: withEvent)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>These are custom parameters to be used when the target is a Redshift cluster to invoke the
    ///       Redshift Data API ExecuteStatement based on EventBridge events.</p>
    public struct RedshiftDataParameters: Swift.Equatable {
        /// <p>The name of the database. Required when authenticating using temporary credentials.</p>
        public let database: Swift.String?
        /// <p>The database user name. Required when authenticating using temporary credentials.</p>
        public let dbUser: Swift.String?
        /// <p>The name or ARN of the secret that enables access to the database. Required when
        ///       authenticating using AWS Secrets Manager.</p>
        public let secretManagerArn: Swift.String?
        /// <p>The SQL statement text to run.</p>
        public let sql: Swift.String?
        /// <p>The name of the SQL statement. You can name the SQL statement when you create it to
        ///       identify the query.</p>
        public let statementName: Swift.String?
        /// <p>Indicates whether to send an event back to EventBridge after the SQL statement
        ///       runs.</p>
        public let withEvent: Swift.Bool

        public init (
            database: Swift.String? = nil,
            dbUser: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            sql: Swift.String? = nil,
            statementName: Swift.String? = nil,
            withEvent: Swift.Bool = false
        )
        {
            self.database = database
            self.dbUser = dbUser
            self.secretManagerArn = secretManagerArn
            self.sql = sql
            self.statementName = statementName
            self.withEvent = withEvent
        }
    }

}

public struct RemovePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

extension RemovePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionInput(eventBusName: \(Swift.String(describing: eventBusName)), removeAllPermissions: \(Swift.String(describing: removeAllPermissions)), statementId: \(Swift.String(describing: statementId)))"}
}

extension RemovePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case removeAllPermissions = "RemoveAllPermissions"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if removeAllPermissions != false {
            try encodeContainer.encode(removeAllPermissions, forKey: .removeAllPermissions)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct RemovePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInput: Swift.Equatable {
    /// <p>The name of the event bus to revoke permissions for. If you omit this, the default event
    ///       bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>Specifies whether to remove all permissions.</p>
    public let removeAllPermissions: Swift.Bool
    /// <p>The statement ID corresponding to the account that is no longer allowed to put events to
    ///       the default event bus.</p>
    public let statementId: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        removeAllPermissions: Swift.Bool = false,
        statementId: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.removeAllPermissions = removeAllPermissions
        self.statementId = statementId
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
    public let statementId: Swift.String?
    public let removeAllPermissions: Swift.Bool
    public let eventBusName: Swift.String?
}

extension RemovePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case removeAllPermissions = "RemoveAllPermissions"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let removeAllPermissionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .removeAllPermissions)
        removeAllPermissions = removeAllPermissionsDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension RemovePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionOutputResponse()"}
}

extension RemovePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemovePermissionOutputResponseBody: Swift.Equatable {
}

extension RemovePermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RemoveTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTargetsOutputError>
}

extension RemoveTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTargetsInput(eventBusName: \(Swift.String(describing: eventBusName)), force: \(Swift.String(describing: force)), ids: \(Swift.String(describing: ids)), rule: \(Swift.String(describing: rule)))"}
}

extension RemoveTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case ids = "Ids"
        case rule = "Rule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for targetidlist0 in ids {
                try idsContainer.encode(targetidlist0)
            }
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct RemoveTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTargetsOutputError>
}

public struct RemoveTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTargetsOutputError>
}

public struct RemoveTargetsInput: Swift.Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: Swift.String?
    /// <p>If this is a managed rule, created by an AWS service on your behalf, you must specify
    ///         <code>Force</code> as <code>True</code> to remove targets. This parameter is ignored for
    ///       rules that are not managed rules. You can check whether a rule is a managed rule by using
    ///         <code>DescribeRule</code> or <code>ListRules</code> and checking the <code>ManagedBy</code>
    ///       field of the response.</p>
    public let force: Swift.Bool
    /// <p>The IDs of the targets to remove from the rule.</p>
    public let ids: [Swift.String]?
    /// <p>The name of the rule.</p>
    public let rule: Swift.String?

    public init (
        eventBusName: Swift.String? = nil,
        force: Swift.Bool = false,
        ids: [Swift.String]? = nil,
        rule: Swift.String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.force = force
        self.ids = ids
        self.rule = rule
    }
}

struct RemoveTargetsInputBody: Swift.Equatable {
    public let rule: Swift.String?
    public let eventBusName: Swift.String?
    public let ids: [Swift.String]?
    public let force: Swift.Bool
}

extension RemoveTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case ids = "Ids"
        case rule = "Rule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension RemoveTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTargetsOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTargetsOutputResponse(failedEntries: \(Swift.String(describing: failedEntries)), failedEntryCount: \(Swift.String(describing: failedEntryCount)))"}
}

extension RemoveTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedEntries = output.failedEntries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.failedEntries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct RemoveTargetsOutputResponse: Swift.Equatable {
    /// <p>The failed target entries.</p>
    public let failedEntries: [CloudWatchEventsClientTypes.RemoveTargetsResultEntry]?
    /// <p>The number of failed entries.</p>
    public let failedEntryCount: Swift.Int

    public init (
        failedEntries: [CloudWatchEventsClientTypes.RemoveTargetsResultEntry]? = nil,
        failedEntryCount: Swift.Int = 0
    )
    {
        self.failedEntries = failedEntries
        self.failedEntryCount = failedEntryCount
    }
}

struct RemoveTargetsOutputResponseBody: Swift.Equatable {
    public let failedEntryCount: Swift.Int
    public let failedEntries: [CloudWatchEventsClientTypes.RemoveTargetsResultEntry]?
}

extension RemoveTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedEntries = "FailedEntries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let failedEntriesContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.RemoveTargetsResultEntry?].self, forKey: .failedEntries)
        var failedEntriesDecoded0:[CloudWatchEventsClientTypes.RemoveTargetsResultEntry]? = nil
        if let failedEntriesContainer = failedEntriesContainer {
            failedEntriesDecoded0 = [CloudWatchEventsClientTypes.RemoveTargetsResultEntry]()
            for structure0 in failedEntriesContainer {
                if let structure0 = structure0 {
                    failedEntriesDecoded0?.append(structure0)
                }
            }
        }
        failedEntries = failedEntriesDecoded0
    }
}

extension CloudWatchEventsClientTypes.RemoveTargetsResultEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case targetId = "TargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CloudWatchEventsClientTypes.RemoveTargetsResultEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTargetsResultEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), targetId: \(Swift.String(describing: targetId)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Represents a target that failed to be removed from a rule.</p>
    public struct RemoveTargetsResultEntry: Swift.Equatable {
        /// <p>The error code that indicates why the target removal failed. If the value is
        ///         <code>ConcurrentModificationException</code>, too many requests were made at the same
        ///       time.</p>
        public let errorCode: Swift.String?
        /// <p>The error message that explains why the target removal failed.</p>
        public let errorMessage: Swift.String?
        /// <p>The ID of the target.</p>
        public let targetId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            targetId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.targetId = targetId
        }
    }

}

extension CloudWatchEventsClientTypes.Replay: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventEndTime = "EventEndTime"
        case eventLastReplayedTime = "EventLastReplayedTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayEndTime = "ReplayEndTime"
        case replayName = "ReplayName"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventEndTime = eventEndTime {
            try encodeContainer.encode(eventEndTime.timeIntervalSince1970, forKey: .eventEndTime)
        }
        if let eventLastReplayedTime = eventLastReplayedTime {
            try encodeContainer.encode(eventLastReplayedTime.timeIntervalSince1970, forKey: .eventLastReplayedTime)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let eventStartTime = eventStartTime {
            try encodeContainer.encode(eventStartTime.timeIntervalSince1970, forKey: .eventStartTime)
        }
        if let replayEndTime = replayEndTime {
            try encodeContainer.encode(replayEndTime.timeIntervalSince1970, forKey: .replayEndTime)
        }
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
        if let replayStartTime = replayStartTime {
            try encodeContainer.encode(replayStartTime.timeIntervalSince1970, forKey: .replayStartTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let eventStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let eventLastReplayedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventLastReplayedTime)
        eventLastReplayedTime = eventLastReplayedTimeDecoded
        let replayStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
        let replayEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replayEndTime)
        replayEndTime = replayEndTimeDecoded
    }
}

extension CloudWatchEventsClientTypes.Replay: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Replay(eventEndTime: \(Swift.String(describing: eventEndTime)), eventLastReplayedTime: \(Swift.String(describing: eventLastReplayedTime)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), eventStartTime: \(Swift.String(describing: eventStartTime)), replayEndTime: \(Swift.String(describing: replayEndTime)), replayName: \(Swift.String(describing: replayName)), replayStartTime: \(Swift.String(describing: replayStartTime)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A <code>Replay</code> object that contains details about a replay.</p>
    public struct Replay: Swift.Equatable {
        /// <p>A time stamp for the time to start replaying events. Any event with a creation time prior
        ///       to the <code>EventEndTime</code> specified is replayed.</p>
        public let eventEndTime: ClientRuntime.Date?
        /// <p>A time stamp for the time that the last event was replayed.</p>
        public let eventLastReplayedTime: ClientRuntime.Date?
        /// <p>The ARN of the archive to replay event from.</p>
        public let eventSourceArn: Swift.String?
        /// <p>A time stamp for the time to start replaying events. This is determined by the time in the
        ///       event as described in <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html#eventbridge-Type-PutEventsRequestEntry-Time">Time</a>.</p>
        public let eventStartTime: ClientRuntime.Date?
        /// <p>A time stamp for the time that the replay completed.</p>
        public let replayEndTime: ClientRuntime.Date?
        /// <p>The name of the replay.</p>
        public let replayName: Swift.String?
        /// <p>A time stamp for the time that the replay started.</p>
        public let replayStartTime: ClientRuntime.Date?
        /// <p>The current state of the replay.</p>
        public let state: CloudWatchEventsClientTypes.ReplayState?
        /// <p>A description of why the replay is in the current state.</p>
        public let stateReason: Swift.String?

        public init (
            eventEndTime: ClientRuntime.Date? = nil,
            eventLastReplayedTime: ClientRuntime.Date? = nil,
            eventSourceArn: Swift.String? = nil,
            eventStartTime: ClientRuntime.Date? = nil,
            replayEndTime: ClientRuntime.Date? = nil,
            replayName: Swift.String? = nil,
            replayStartTime: ClientRuntime.Date? = nil,
            state: CloudWatchEventsClientTypes.ReplayState? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.eventEndTime = eventEndTime
            self.eventLastReplayedTime = eventLastReplayedTime
            self.eventSourceArn = eventSourceArn
            self.eventStartTime = eventStartTime
            self.replayEndTime = replayEndTime
            self.replayName = replayName
            self.replayStartTime = replayStartTime
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension CloudWatchEventsClientTypes.ReplayDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case filterArns = "FilterArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filterArns = filterArns {
            var filterArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterArns)
            for replaydestinationfilters0 in filterArns {
                try filterArnsContainer.encode(replaydestinationfilters0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let filterArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterArns)
        var filterArnsDecoded0:[Swift.String]? = nil
        if let filterArnsContainer = filterArnsContainer {
            filterArnsDecoded0 = [Swift.String]()
            for string0 in filterArnsContainer {
                if let string0 = string0 {
                    filterArnsDecoded0?.append(string0)
                }
            }
        }
        filterArns = filterArnsDecoded0
    }
}

extension CloudWatchEventsClientTypes.ReplayDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplayDestination(arn: \(Swift.String(describing: arn)), filterArns: \(Swift.String(describing: filterArns)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A <code>ReplayDestination</code> object that contains details about a replay.</p>
    public struct ReplayDestination: Swift.Equatable {
        /// <p>The ARN of the event bus to replay event to. You can replay events only to the event bus
        ///       specified to create the archive.</p>
        public let arn: Swift.String?
        /// <p>A list of ARNs for rules to replay events to.</p>
        public let filterArns: [Swift.String]?

        public init (
            arn: Swift.String? = nil,
            filterArns: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.filterArns = filterArns
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum ReplayState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case running
        case starting
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplayState] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .running,
                .starting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplayState(rawValue: rawValue) ?? ReplayState.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are trying to create already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An entity that you specified does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchEventsClientTypes.RetryPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
    }
}

extension CloudWatchEventsClientTypes.RetryPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryPolicy(maximumEventAgeInSeconds: \(Swift.String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A <code>RetryPolicy</code> object that includes information about the retry policy
    ///       settings.</p>
    public struct RetryPolicy: Swift.Equatable {
        /// <p>The maximum amount of time, in seconds, to continue to make retry attempts.</p>
        public let maximumEventAgeInSeconds: Swift.Int?
        /// <p>The maximum number of retry attempts to make before the request fails. Retry attempts
        ///       continue until either the maximum number of attempts is made or until the duration of the
        ///         <code>MaximumEventAgeInSeconds</code> is met.</p>
        public let maximumRetryAttempts: Swift.Int?

        public init (
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        )
        {
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }

}

extension CloudWatchEventsClientTypes.Rule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case managedBy = "ManagedBy"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let managedBy = managedBy {
            try encodeContainer.encode(managedBy, forKey: .managedBy)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let managedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedBy)
        managedBy = managedByDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension CloudWatchEventsClientTypes.Rule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Rule(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), eventBusName: \(Swift.String(describing: eventBusName)), eventPattern: \(Swift.String(describing: eventPattern)), managedBy: \(Swift.String(describing: managedBy)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), state: \(Swift.String(describing: state)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains information about a rule in Amazon EventBridge.</p>
    public struct Rule: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        public let arn: Swift.String?
        /// <p>The description of the rule.</p>
        public let description: Swift.String?
        /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
        ///       event bus is used.</p>
        public let eventBusName: Swift.String?
        /// <p>The event pattern of the rule. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
        ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
        public let eventPattern: Swift.String?
        /// <p>If the rule was created on behalf of your account by an AWS service, this field displays
        ///       the principal name of the service that created the rule.</p>
        public let managedBy: Swift.String?
        /// <p>The name of the rule.</p>
        public let name: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the role that is used for target invocation.</p>
        public let roleArn: Swift.String?
        /// <p>The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".</p>
        public let scheduleExpression: Swift.String?
        /// <p>The state of the rule.</p>
        public let state: CloudWatchEventsClientTypes.RuleState?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            eventBusName: Swift.String? = nil,
            eventPattern: Swift.String? = nil,
            managedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            state: CloudWatchEventsClientTypes.RuleState? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.eventBusName = eventBusName
            self.eventPattern = eventPattern
            self.managedBy = managedBy
            self.name = name
            self.roleArn = roleArn
            self.scheduleExpression = scheduleExpression
            self.state = state
        }
    }

}

extension CloudWatchEventsClientTypes {
    public enum RuleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleState(rawValue: rawValue) ?? RuleState.sdkUnknown(rawValue)
        }
    }
}

extension CloudWatchEventsClientTypes.RunCommandParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runCommandTargets = "RunCommandTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runCommandTargets = runCommandTargets {
            var runCommandTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runCommandTargets)
            for runcommandtargets0 in runCommandTargets {
                try runCommandTargetsContainer.encode(runcommandtargets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runCommandTargetsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.RunCommandTarget?].self, forKey: .runCommandTargets)
        var runCommandTargetsDecoded0:[CloudWatchEventsClientTypes.RunCommandTarget]? = nil
        if let runCommandTargetsContainer = runCommandTargetsContainer {
            runCommandTargetsDecoded0 = [CloudWatchEventsClientTypes.RunCommandTarget]()
            for structure0 in runCommandTargetsContainer {
                if let structure0 = structure0 {
                    runCommandTargetsDecoded0?.append(structure0)
                }
            }
        }
        runCommandTargets = runCommandTargetsDecoded0
    }
}

extension CloudWatchEventsClientTypes.RunCommandParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RunCommandParameters(runCommandTargets: \(Swift.String(describing: runCommandTargets)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>This parameter contains the criteria (either InstanceIds or a tag) used to specify which
    ///       EC2 instances are to be sent the command. </p>
    public struct RunCommandParameters: Swift.Equatable {
        /// <p>Currently, we support including only one RunCommandTarget block, which specifies either an
        ///       array of InstanceIds or a tag.</p>
        public let runCommandTargets: [CloudWatchEventsClientTypes.RunCommandTarget]?

        public init (
            runCommandTargets: [CloudWatchEventsClientTypes.RunCommandTarget]? = nil
        )
        {
            self.runCommandTargets = runCommandTargets
        }
    }

}

extension CloudWatchEventsClientTypes.RunCommandTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for runcommandtargetvalues0 in values {
                try valuesContainer.encode(runcommandtargetvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CloudWatchEventsClientTypes.RunCommandTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RunCommandTarget(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Information about the EC2 instances that are to be sent the command, specified as
    ///       key-value pairs. Each <code>RunCommandTarget</code> block can include only one key, but this
    ///       key may specify multiple values.</p>
    public struct RunCommandTarget: Swift.Equatable {
        /// <p>Can be either <code>tag:</code>
        ///             <i>tag-key</i> or
        ///       <code>InstanceIds</code>.</p>
        public let key: Swift.String?
        /// <p>If <code>Key</code> is <code>tag:</code>
        ///             <i>tag-key</i>, <code>Values</code>
        ///       is a list of tag values. If <code>Key</code> is <code>InstanceIds</code>, <code>Values</code>
        ///       is a list of Amazon EC2 instance IDs.</p>
        public let values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension CloudWatchEventsClientTypes.SageMakerPipelineParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudWatchEventsClientTypes.SageMakerPipelineParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SageMakerPipelineParameter(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Name/Value pair of a parameter to start execution of a SageMaker Model Building
    ///       Pipeline.</p>
    public struct SageMakerPipelineParameter: Swift.Equatable {
        /// <p>Name of parameter to start execution of a SageMaker Model Building Pipeline.</p>
        public let name: Swift.String?
        /// <p>Value of parameter to start execution of a SageMaker Model Building Pipeline.</p>
        public let value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CloudWatchEventsClientTypes.SageMakerPipelineParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineParameterList = "PipelineParameterList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineParameterList = pipelineParameterList {
            var pipelineParameterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineParameterList)
            for sagemakerpipelineparameterlist0 in pipelineParameterList {
                try pipelineParameterListContainer.encode(sagemakerpipelineparameterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineParameterListContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.SageMakerPipelineParameter?].self, forKey: .pipelineParameterList)
        var pipelineParameterListDecoded0:[CloudWatchEventsClientTypes.SageMakerPipelineParameter]? = nil
        if let pipelineParameterListContainer = pipelineParameterListContainer {
            pipelineParameterListDecoded0 = [CloudWatchEventsClientTypes.SageMakerPipelineParameter]()
            for structure0 in pipelineParameterListContainer {
                if let structure0 = structure0 {
                    pipelineParameterListDecoded0?.append(structure0)
                }
            }
        }
        pipelineParameterList = pipelineParameterListDecoded0
    }
}

extension CloudWatchEventsClientTypes.SageMakerPipelineParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SageMakerPipelineParameters(pipelineParameterList: \(Swift.String(describing: pipelineParameterList)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>These are custom parameters to use when the target is a SageMaker Model Building Pipeline
    ///       that starts based on EventBridge events.</p>
    public struct SageMakerPipelineParameters: Swift.Equatable {
        /// <p>List of Parameter names and values for SageMaker Model Building Pipeline execution.</p>
        public let pipelineParameterList: [CloudWatchEventsClientTypes.SageMakerPipelineParameter]?

        public init (
            pipelineParameterList: [CloudWatchEventsClientTypes.SageMakerPipelineParameter]? = nil
        )
        {
            self.pipelineParameterList = pipelineParameterList
        }
    }

}

extension CloudWatchEventsClientTypes.SqsParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageGroupId = "MessageGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageGroupId = messageGroupId {
            try encodeContainer.encode(messageGroupId, forKey: .messageGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageGroupId)
        messageGroupId = messageGroupIdDecoded
    }
}

extension CloudWatchEventsClientTypes.SqsParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqsParameters(messageGroupId: \(Swift.String(describing: messageGroupId)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>This structure includes the custom parameter to be used when the target is an SQS FIFO
    ///       queue.</p>
    public struct SqsParameters: Swift.Equatable {
        /// <p>The FIFO message group ID to use as the target.</p>
        public let messageGroupId: Swift.String?

        public init (
            messageGroupId: Swift.String? = nil
        )
        {
            self.messageGroupId = messageGroupId
        }
    }

}

public struct StartReplayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplayOutputError>
}

extension StartReplayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplayInput(description: \(Swift.String(describing: description)), destination: \(Swift.String(describing: destination)), eventEndTime: \(Swift.String(describing: eventEndTime)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), eventStartTime: \(Swift.String(describing: eventStartTime)), replayName: \(Swift.String(describing: replayName)))"}
}

extension StartReplayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let eventEndTime = eventEndTime {
            try encodeContainer.encode(eventEndTime.timeIntervalSince1970, forKey: .eventEndTime)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let eventStartTime = eventStartTime {
            try encodeContainer.encode(eventStartTime.timeIntervalSince1970, forKey: .eventStartTime)
        }
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

public struct StartReplayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplayOutputError>
}

public struct StartReplayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReplayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReplayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReplayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReplayOutputError>
}

public struct StartReplayInput: Swift.Equatable {
    /// <p>A description for the replay to start.</p>
    public let description: Swift.String?
    /// <p>A <code>ReplayDestination</code> object that includes details about the destination for
    ///       the replay.</p>
    public let destination: CloudWatchEventsClientTypes.ReplayDestination?
    /// <p>A time stamp for the time to stop replaying events. Only events that occurred between the
    ///         <code>EventStartTime</code> and <code>EventEndTime</code> are replayed.</p>
    public let eventEndTime: ClientRuntime.Date?
    /// <p>The ARN of the archive to replay events from.</p>
    public let eventSourceArn: Swift.String?
    /// <p>A time stamp for the time to start replaying events. Only events that occurred between the
    ///         <code>EventStartTime</code> and <code>EventEndTime</code> are replayed.</p>
    public let eventStartTime: ClientRuntime.Date?
    /// <p>The name of the replay to start.</p>
    public let replayName: Swift.String?

    public init (
        description: Swift.String? = nil,
        destination: CloudWatchEventsClientTypes.ReplayDestination? = nil,
        eventEndTime: ClientRuntime.Date? = nil,
        eventSourceArn: Swift.String? = nil,
        eventStartTime: ClientRuntime.Date? = nil,
        replayName: Swift.String? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.eventEndTime = eventEndTime
        self.eventSourceArn = eventSourceArn
        self.eventStartTime = eventStartTime
        self.replayName = replayName
    }
}

struct StartReplayInputBody: Swift.Equatable {
    public let replayName: Swift.String?
    public let description: Swift.String?
    public let eventSourceArn: Swift.String?
    public let eventStartTime: ClientRuntime.Date?
    public let eventEndTime: ClientRuntime.Date?
    public let destination: CloudWatchEventsClientTypes.ReplayDestination?
}

extension StartReplayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayName = "ReplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let eventStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ReplayDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension StartReplayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplayOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplayOutputResponse(replayArn: \(Swift.String(describing: replayArn)), replayStartTime: \(Swift.String(describing: replayStartTime)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension StartReplayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartReplayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replayArn = output.replayArn
            self.replayStartTime = output.replayStartTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.replayArn = nil
            self.replayStartTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct StartReplayOutputResponse: Swift.Equatable {
    /// <p>The ARN of the replay.</p>
    public let replayArn: Swift.String?
    /// <p>The time at which the replay started.</p>
    public let replayStartTime: ClientRuntime.Date?
    /// <p>The state of the replay.</p>
    public let state: CloudWatchEventsClientTypes.ReplayState?
    /// <p>The reason that the replay is in the state.</p>
    public let stateReason: Swift.String?

    public init (
        replayArn: Swift.String? = nil,
        replayStartTime: ClientRuntime.Date? = nil,
        state: CloudWatchEventsClientTypes.ReplayState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.replayArn = replayArn
        self.replayStartTime = replayStartTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct StartReplayOutputResponseBody: Swift.Equatable {
    public let replayArn: Swift.String?
    public let state: CloudWatchEventsClientTypes.ReplayState?
    public let stateReason: Swift.String?
    public let replayStartTime: ClientRuntime.Date?
}

extension StartReplayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replayArn = "ReplayArn"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let replayStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
    }
}

extension CloudWatchEventsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudWatchEventsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>A key-value pair associated with an AWS resource. In EventBridge, rules and event buses
    ///       support tagging.</p>
    public struct Tag: Swift.Equatable {
        /// <p>A string you can use to assign a value. The combination of tag keys and values can help
        ///       you organize and categorize your resources.</p>
        public let key: Swift.String?
        /// <p>The value for the specified tag key.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The ARN of the EventBridge resource that you're adding tags to.</p>
    public let resourceARN: Swift.String?
    /// <p>The list of key-value pairs to associate with the resource.</p>
    public let tags: [CloudWatchEventsClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [CloudWatchEventsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [CloudWatchEventsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CloudWatchEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudWatchEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudWatchEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudWatchEventsClientTypes.Target: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case batchParameters = "BatchParameters"
        case deadLetterConfig = "DeadLetterConfig"
        case ecsParameters = "EcsParameters"
        case httpParameters = "HttpParameters"
        case id = "Id"
        case input = "Input"
        case inputPath = "InputPath"
        case inputTransformer = "InputTransformer"
        case kinesisParameters = "KinesisParameters"
        case redshiftDataParameters = "RedshiftDataParameters"
        case retryPolicy = "RetryPolicy"
        case roleArn = "RoleArn"
        case runCommandParameters = "RunCommandParameters"
        case sageMakerPipelineParameters = "SageMakerPipelineParameters"
        case sqsParameters = "SqsParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let batchParameters = batchParameters {
            try encodeContainer.encode(batchParameters, forKey: .batchParameters)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let ecsParameters = ecsParameters {
            try encodeContainer.encode(ecsParameters, forKey: .ecsParameters)
        }
        if let httpParameters = httpParameters {
            try encodeContainer.encode(httpParameters, forKey: .httpParameters)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputPath = inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let inputTransformer = inputTransformer {
            try encodeContainer.encode(inputTransformer, forKey: .inputTransformer)
        }
        if let kinesisParameters = kinesisParameters {
            try encodeContainer.encode(kinesisParameters, forKey: .kinesisParameters)
        }
        if let redshiftDataParameters = redshiftDataParameters {
            try encodeContainer.encode(redshiftDataParameters, forKey: .redshiftDataParameters)
        }
        if let retryPolicy = retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runCommandParameters = runCommandParameters {
            try encodeContainer.encode(runCommandParameters, forKey: .runCommandParameters)
        }
        if let sageMakerPipelineParameters = sageMakerPipelineParameters {
            try encodeContainer.encode(sageMakerPipelineParameters, forKey: .sageMakerPipelineParameters)
        }
        if let sqsParameters = sqsParameters {
            try encodeContainer.encode(sqsParameters, forKey: .sqsParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let inputTransformerDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.InputTransformer.self, forKey: .inputTransformer)
        inputTransformer = inputTransformerDecoded
        let kinesisParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.KinesisParameters.self, forKey: .kinesisParameters)
        kinesisParameters = kinesisParametersDecoded
        let runCommandParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.RunCommandParameters.self, forKey: .runCommandParameters)
        runCommandParameters = runCommandParametersDecoded
        let ecsParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.EcsParameters.self, forKey: .ecsParameters)
        ecsParameters = ecsParametersDecoded
        let batchParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.BatchParameters.self, forKey: .batchParameters)
        batchParameters = batchParametersDecoded
        let sqsParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.SqsParameters.self, forKey: .sqsParameters)
        sqsParameters = sqsParametersDecoded
        let httpParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.HttpParameters.self, forKey: .httpParameters)
        httpParameters = httpParametersDecoded
        let redshiftDataParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.RedshiftDataParameters.self, forKey: .redshiftDataParameters)
        redshiftDataParameters = redshiftDataParametersDecoded
        let sageMakerPipelineParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.SageMakerPipelineParameters.self, forKey: .sageMakerPipelineParameters)
        sageMakerPipelineParameters = sageMakerPipelineParametersDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.RetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
    }
}

extension CloudWatchEventsClientTypes.Target: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Target(arn: \(Swift.String(describing: arn)), batchParameters: \(Swift.String(describing: batchParameters)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), ecsParameters: \(Swift.String(describing: ecsParameters)), httpParameters: \(Swift.String(describing: httpParameters)), id: \(Swift.String(describing: id)), input: \(Swift.String(describing: input)), inputPath: \(Swift.String(describing: inputPath)), inputTransformer: \(Swift.String(describing: inputTransformer)), kinesisParameters: \(Swift.String(describing: kinesisParameters)), redshiftDataParameters: \(Swift.String(describing: redshiftDataParameters)), retryPolicy: \(Swift.String(describing: retryPolicy)), roleArn: \(Swift.String(describing: roleArn)), runCommandParameters: \(Swift.String(describing: runCommandParameters)), sageMakerPipelineParameters: \(Swift.String(describing: sageMakerPipelineParameters)), sqsParameters: \(Swift.String(describing: sqsParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Targets are the resources to be invoked when a rule is triggered. For a complete list of
    ///       services and resources that can be set as a target, see <a>PutTargets</a>.</p>
    ///
    ///          <p>If you are setting the event bus of another account as the target, and that account
    ///       granted permission to your account through an organization instead of directly by the account
    ///       ID, then you must specify a <code>RoleArn</code> with proper permissions in the
    ///         <code>Target</code> structure. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html">Sending and
    ///         Receiving Events Between AWS Accounts</a> in the <i>Amazon EventBridge User
    ///         Guide</i>.</p>
    public struct Target: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the target.</p>
        public let arn: Swift.String?
        /// <p>If the event target is an AWS Batch job, this contains the job definition, job name, and
        ///       other parameters. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/jobs.html">Jobs</a> in the <i>AWS Batch User
        ///         Guide</i>.</p>
        public let batchParameters: CloudWatchEventsClientTypes.BatchParameters?
        /// <p>The <code>DeadLetterConfig</code> that defines the target queue to send dead-letter queue
        ///       events to.</p>
        public let deadLetterConfig: CloudWatchEventsClientTypes.DeadLetterConfig?
        /// <p>Contains the Amazon ECS task definition and task count to be used, if the event target is
        ///       an Amazon ECS task. For more information about Amazon ECS tasks, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html">Task
        ///         Definitions </a> in the <i>Amazon EC2 Container Service Developer
        ///         Guide</i>.</p>
        public let ecsParameters: CloudWatchEventsClientTypes.EcsParameters?
        /// <p>Contains the HTTP parameters to use when the target is a API Gateway REST endpoint
        ///       or EventBridge ApiDestination.</p>
        ///          <p>If you specify an API Gateway REST API or EventBridge ApiDestination as a target, you
        ///       can use this parameter to specify headers, path parameters, and query string keys/values
        ///       as part of your target invoking request. If you're using ApiDestinations, the corresponding
        ///       Connection can also have these values configured. In case of any conflicting keys, values
        ///       from the Connection take precedence.</p>
        public let httpParameters: CloudWatchEventsClientTypes.HttpParameters?
        /// <p>The ID of the target.</p>
        public let id: Swift.String?
        /// <p>Valid JSON text passed to the target. In this case, nothing from the event itself is
        ///       passed to the target. For more information, see <a href="http://www.rfc-editor.org/rfc/rfc7159.txt">The JavaScript Object Notation (JSON) Data
        ///         Interchange Format</a>.</p>
        public let input: Swift.String?
        /// <p>The value of the JSONPath that is used for extracting part of the matched event when
        ///       passing it to the target. You must use JSON dot notation, not bracket notation. For more
        ///       information about JSON paths, see <a href="http://goessner.net/articles/JsonPath/">JSONPath</a>.</p>
        public let inputPath: Swift.String?
        /// <p>Settings to enable you to provide custom input to a target based on certain event data.
        ///       You can extract one or more key-value pairs from the event and then use that data to send
        ///       customized input to the target.</p>
        public let inputTransformer: CloudWatchEventsClientTypes.InputTransformer?
        /// <p>The custom parameter you can use to control the shard assignment, when the target is a
        ///       Kinesis data stream. If you do not include this parameter, the default is to use the
        ///         <code>eventId</code> as the partition key.</p>
        public let kinesisParameters: CloudWatchEventsClientTypes.KinesisParameters?
        /// <p>Contains the Redshift Data API parameters to use when the target is a Redshift
        ///       cluster.</p>
        ///          <p>If you specify a Redshift Cluster as a Target, you can use this to specify parameters to
        ///       invoke the Redshift Data API ExecuteStatement based on EventBridge events.</p>
        public let redshiftDataParameters: CloudWatchEventsClientTypes.RedshiftDataParameters?
        /// <p>The <code>RetryPolicy</code> object that contains the retry policy configuration to use
        ///       for the dead-letter queue.</p>
        public let retryPolicy: CloudWatchEventsClientTypes.RetryPolicy?
        /// <p>The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is
        ///       triggered. If one rule triggers multiple targets, you can use a different IAM role for each
        ///       target.</p>
        public let roleArn: Swift.String?
        /// <p>Parameters used when you are using the rule to invoke Amazon EC2 Run Command.</p>
        public let runCommandParameters: CloudWatchEventsClientTypes.RunCommandParameters?
        /// <p>Contains the SageMaker Model Building Pipeline parameters to start execution of a
        ///       SageMaker Model Building Pipeline.</p>
        ///          <p>If you specify a SageMaker Model Building Pipeline as a target, you can use this to
        ///       specify parameters to start a pipeline execution based on EventBridge events.</p>
        public let sageMakerPipelineParameters: CloudWatchEventsClientTypes.SageMakerPipelineParameters?
        /// <p>Contains the message group ID to use when the target is a FIFO queue.</p>
        ///          <p>If you specify an SQS FIFO queue as a target, the queue must have content-based
        ///       deduplication enabled.</p>
        public let sqsParameters: CloudWatchEventsClientTypes.SqsParameters?

        public init (
            arn: Swift.String? = nil,
            batchParameters: CloudWatchEventsClientTypes.BatchParameters? = nil,
            deadLetterConfig: CloudWatchEventsClientTypes.DeadLetterConfig? = nil,
            ecsParameters: CloudWatchEventsClientTypes.EcsParameters? = nil,
            httpParameters: CloudWatchEventsClientTypes.HttpParameters? = nil,
            id: Swift.String? = nil,
            input: Swift.String? = nil,
            inputPath: Swift.String? = nil,
            inputTransformer: CloudWatchEventsClientTypes.InputTransformer? = nil,
            kinesisParameters: CloudWatchEventsClientTypes.KinesisParameters? = nil,
            redshiftDataParameters: CloudWatchEventsClientTypes.RedshiftDataParameters? = nil,
            retryPolicy: CloudWatchEventsClientTypes.RetryPolicy? = nil,
            roleArn: Swift.String? = nil,
            runCommandParameters: CloudWatchEventsClientTypes.RunCommandParameters? = nil,
            sageMakerPipelineParameters: CloudWatchEventsClientTypes.SageMakerPipelineParameters? = nil,
            sqsParameters: CloudWatchEventsClientTypes.SqsParameters? = nil
        )
        {
            self.arn = arn
            self.batchParameters = batchParameters
            self.deadLetterConfig = deadLetterConfig
            self.ecsParameters = ecsParameters
            self.httpParameters = httpParameters
            self.id = id
            self.input = input
            self.inputPath = inputPath
            self.inputTransformer = inputTransformer
            self.kinesisParameters = kinesisParameters
            self.redshiftDataParameters = redshiftDataParameters
            self.retryPolicy = retryPolicy
            self.roleArn = roleArn
            self.runCommandParameters = runCommandParameters
            self.sageMakerPipelineParameters = sageMakerPipelineParameters
            self.sqsParameters = sqsParameters
        }
    }

}

public struct TestEventPatternInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestEventPatternInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestEventPatternInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestEventPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestEventPatternInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestEventPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestEventPatternOutputError>
}

extension TestEventPatternInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestEventPatternInput(event: \(Swift.String(describing: event)), eventPattern: \(Swift.String(describing: eventPattern)))"}
}

extension TestEventPatternInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case eventPattern = "EventPattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
    }
}

public struct TestEventPatternInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestEventPatternInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestEventPatternInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestEventPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestEventPatternInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestEventPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestEventPatternOutputError>
}

public struct TestEventPatternInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestEventPatternInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestEventPatternInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestEventPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestEventPatternInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestEventPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestEventPatternOutputError>
}

public struct TestEventPatternInput: Swift.Equatable {
    /// <p>The event, in JSON format, to test against the event pattern. The JSON must follow the
    ///       format specified in <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/aws-events.html">AWS Events</a>, and the following
    ///       fields are mandatory:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>id</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>account</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>source</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>time</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>region</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>resources</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>detail-type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let event: Swift.String?
    /// <p>The event pattern. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
    ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    public let eventPattern: Swift.String?

    public init (
        event: Swift.String? = nil,
        eventPattern: Swift.String? = nil
    )
    {
        self.event = event
        self.eventPattern = eventPattern
    }
}

struct TestEventPatternInputBody: Swift.Equatable {
    public let eventPattern: Swift.String?
    public let event: Swift.String?
}

extension TestEventPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case eventPattern = "EventPattern"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
    }
}

extension TestEventPatternOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestEventPatternOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestEventPatternOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestEventPatternOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestEventPatternOutputResponse(result: \(Swift.String(describing: result)))"}
}

extension TestEventPatternOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestEventPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = false
        }
    }
}

public struct TestEventPatternOutputResponse: Swift.Equatable {
    /// <p>Indicates whether the event matches the event pattern.</p>
    public let result: Swift.Bool

    public init (
        result: Swift.Bool = false
    )
    {
        self.result = result
    }
}

struct TestEventPatternOutputResponseBody: Swift.Equatable {
    public let result: Swift.Bool
}

extension TestEventPatternOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .result)
        result = resultDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The ARN of the EventBridge resource from which you are removing tags.</p>
    public let resourceARN: Swift.String?
    /// <p>The list of tag keys to remove from the resource.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateApiDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiDestinationOutputError>
}

extension UpdateApiDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApiDestinationInput(connectionArn: \(Swift.String(describing: connectionArn)), description: \(Swift.String(describing: description)), httpMethod: \(Swift.String(describing: httpMethod)), invocationEndpoint: \(Swift.String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(Swift.String(describing: invocationRateLimitPerSecond)), name: \(Swift.String(describing: name)))"}
}

extension UpdateApiDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateApiDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiDestinationOutputError>
}

public struct UpdateApiDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApiDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApiDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApiDestinationOutputError>
}

public struct UpdateApiDestinationInput: Swift.Equatable {
    /// <p>The ARN of the connection to use for the API destination.</p>
    public let connectionArn: Swift.String?
    /// <p>The name of the API destination to update.</p>
    public let description: Swift.String?
    /// <p>The method to use for the API destination.</p>
    public let httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod?
    /// <p>The URL to the endpoint to use for the API destination.</p>
    public let invocationEndpoint: Swift.String?
    /// <p>The maximum number of invocations per second to send to the API destination.</p>
    public let invocationRateLimitPerSecond: Swift.Int?
    /// <p>The name of the API destination to update.</p>
    public let name: Swift.String?

    public init (
        connectionArn: Swift.String? = nil,
        description: Swift.String? = nil,
        httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod? = nil,
        invocationEndpoint: Swift.String? = nil,
        invocationRateLimitPerSecond: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.name = name
    }
}

struct UpdateApiDestinationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let connectionArn: Swift.String?
    public let invocationEndpoint: Swift.String?
    public let httpMethod: CloudWatchEventsClientTypes.ApiDestinationHttpMethod?
    public let invocationRateLimitPerSecond: Swift.Int?
}

extension UpdateApiDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
    }
}

extension UpdateApiDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiDestinationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApiDestinationOutputResponse(apiDestinationArn: \(Swift.String(describing: apiDestinationArn)), apiDestinationState: \(Swift.String(describing: apiDestinationState)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension UpdateApiDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct UpdateApiDestinationOutputResponse: Swift.Equatable {
    /// <p>The ARN of the API destination that was updated.</p>
    public let apiDestinationArn: Swift.String?
    /// <p>The state of the API destination that was updated.</p>
    public let apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState?
    /// <p>A time stamp for the time that the API destination was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the API destination was last modified.</p>
    public let lastModifiedTime: ClientRuntime.Date?

    public init (
        apiDestinationArn: Swift.String? = nil,
        apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct UpdateApiDestinationOutputResponseBody: Swift.Equatable {
    public let apiDestinationArn: Swift.String?
    public let apiDestinationState: CloudWatchEventsClientTypes.ApiDestinationState?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
}

extension UpdateApiDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct UpdateArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateArchiveOutputError>
}

extension UpdateArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateArchiveInput(archiveName: \(Swift.String(describing: archiveName)), description: \(Swift.String(describing: description)), eventPattern: \(Swift.String(describing: eventPattern)), retentionDays: \(Swift.String(describing: retentionDays)))"}
}

extension UpdateArchiveInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }
}

public struct UpdateArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateArchiveOutputError>
}

public struct UpdateArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateArchiveOutputError>
}

public struct UpdateArchiveInput: Swift.Equatable {
    /// <p>The name of the archive to update.</p>
    public let archiveName: Swift.String?
    /// <p>The description for the archive.</p>
    public let description: Swift.String?
    /// <p>The event pattern to use to filter events sent to the archive.</p>
    public let eventPattern: Swift.String?
    /// <p>The number of days to retain events in the archive.</p>
    public let retentionDays: Swift.Int?

    public init (
        archiveName: Swift.String? = nil,
        description: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        retentionDays: Swift.Int? = nil
    )
    {
        self.archiveName = archiveName
        self.description = description
        self.eventPattern = eventPattern
        self.retentionDays = retentionDays
    }
}

struct UpdateArchiveInputBody: Swift.Equatable {
    public let archiveName: Swift.String?
    public let description: Swift.String?
    public let eventPattern: Swift.String?
    public let retentionDays: Swift.Int?
}

extension UpdateArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case retentionDays = "RetentionDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension UpdateArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateArchiveOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateArchiveOutputResponse(archiveArn: \(Swift.String(describing: archiveArn)), creationTime: \(Swift.String(describing: creationTime)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension UpdateArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveArn = output.archiveArn
            self.creationTime = output.creationTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.creationTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct UpdateArchiveOutputResponse: Swift.Equatable {
    /// <p>The ARN of the archive.</p>
    public let archiveArn: Swift.String?
    /// <p>The time at which the archive was updated.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>The state of the archive.</p>
    public let state: CloudWatchEventsClientTypes.ArchiveState?
    /// <p>The reason that the archive is in the current state.</p>
    public let stateReason: Swift.String?

    public init (
        archiveArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        state: CloudWatchEventsClientTypes.ArchiveState? = nil,
        stateReason: Swift.String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.creationTime = creationTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct UpdateArchiveOutputResponseBody: Swift.Equatable {
    public let archiveArn: Swift.String?
    public let state: CloudWatchEventsClientTypes.ArchiveState?
    public let stateReason: Swift.String?
    public let creationTime: ClientRuntime.Date?
}

extension UpdateArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveArn = "ArchiveArn"
        case creationTime = "CreationTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CloudWatchEventsClientTypes.UpdateConnectionApiKeyAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyName = "ApiKeyName"
        case apiKeyValue = "ApiKeyValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
        if let apiKeyValue = apiKeyValue {
            try encodeContainer.encode(apiKeyValue, forKey: .apiKeyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
        let apiKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyValue)
        apiKeyValue = apiKeyValueDecoded
    }
}

extension CloudWatchEventsClientTypes.UpdateConnectionApiKeyAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionApiKeyAuthRequestParameters(apiKeyName: \(Swift.String(describing: apiKeyName)), apiKeyValue: \(Swift.String(describing: apiKeyValue)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the API key authorization parameters to use to update the connection.</p>
    public struct UpdateConnectionApiKeyAuthRequestParameters: Swift.Equatable {
        /// <p>The name of the API key to use for authorization.</p>
        public let apiKeyName: Swift.String?
        /// <p>The value associated with teh API key to use for authorization.</p>
        public let apiKeyValue: Swift.String?

        public init (
            apiKeyName: Swift.String? = nil,
            apiKeyValue: Swift.String? = nil
        )
        {
            self.apiKeyName = apiKeyName
            self.apiKeyValue = apiKeyValue
        }
    }

}

extension CloudWatchEventsClientTypes.UpdateConnectionAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.UpdateConnectionBasicAuthRequestParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.UpdateConnectionOAuthRequestParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.UpdateConnectionApiKeyAuthRequestParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.UpdateConnectionAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionAuthRequestParameters(apiKeyAuthParameters: \(Swift.String(describing: apiKeyAuthParameters)), basicAuthParameters: \(Swift.String(describing: basicAuthParameters)), invocationHttpParameters: \(Swift.String(describing: invocationHttpParameters)), oAuthParameters: \(Swift.String(describing: oAuthParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the additional parameters to use for the connection.</p>
    public struct UpdateConnectionAuthRequestParameters: Swift.Equatable {
        /// <p>A <code>UpdateConnectionApiKeyAuthRequestParameters</code> object that contains the
        ///       authorization parameters for API key authorization.</p>
        public let apiKeyAuthParameters: CloudWatchEventsClientTypes.UpdateConnectionApiKeyAuthRequestParameters?
        /// <p>A <code>UpdateConnectionBasicAuthRequestParameters</code> object that contains the
        ///       authorization parameters for Basic authorization.</p>
        public let basicAuthParameters: CloudWatchEventsClientTypes.UpdateConnectionBasicAuthRequestParameters?
        /// <p>A <code>ConnectionHttpParameters</code> object that contains the additional parameters to
        ///       use for the connection.</p>
        public let invocationHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters?
        /// <p>A <code>UpdateConnectionOAuthRequestParameters</code> object that contains the
        ///       authorization parameters for OAuth authorization.</p>
        public let oAuthParameters: CloudWatchEventsClientTypes.UpdateConnectionOAuthRequestParameters?

        public init (
            apiKeyAuthParameters: CloudWatchEventsClientTypes.UpdateConnectionApiKeyAuthRequestParameters? = nil,
            basicAuthParameters: CloudWatchEventsClientTypes.UpdateConnectionBasicAuthRequestParameters? = nil,
            invocationHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters? = nil,
            oAuthParameters: CloudWatchEventsClientTypes.UpdateConnectionOAuthRequestParameters? = nil
        )
        {
            self.apiKeyAuthParameters = apiKeyAuthParameters
            self.basicAuthParameters = basicAuthParameters
            self.invocationHttpParameters = invocationHttpParameters
            self.oAuthParameters = oAuthParameters
        }
    }

}

extension CloudWatchEventsClientTypes.UpdateConnectionBasicAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CloudWatchEventsClientTypes.UpdateConnectionBasicAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionBasicAuthRequestParameters(password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the Basic authorization parameters for the connection.</p>
    public struct UpdateConnectionBasicAuthRequestParameters: Swift.Equatable {
        /// <p>The password associated with the user name to use for Basic authorization.</p>
        public let password: Swift.String?
        /// <p>The user name to use for Basic authorization.</p>
        public let username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

public struct UpdateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

extension UpdateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionInput(authParameters: \(Swift.String(describing: authParameters)), authorizationType: \(Swift.String(describing: authorizationType)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)))"}
}

extension UpdateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authParameters = authParameters {
            try encodeContainer.encode(authParameters, forKey: .authParameters)
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInput: Swift.Equatable {
    /// <p>The authorization parameters to use for the connection.</p>
    public let authParameters: CloudWatchEventsClientTypes.UpdateConnectionAuthRequestParameters?
    /// <p>The type of authorization to use for the connection.</p>
    public let authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType?
    /// <p>A description for the connection.</p>
    public let description: Swift.String?
    /// <p>The name of the connection to update.</p>
    public let name: Swift.String?

    public init (
        authParameters: CloudWatchEventsClientTypes.UpdateConnectionAuthRequestParameters? = nil,
        authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.description = description
        self.name = name
    }
}

struct UpdateConnectionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let authorizationType: CloudWatchEventsClientTypes.ConnectionAuthorizationType?
    public let authParameters: CloudWatchEventsClientTypes.UpdateConnectionAuthRequestParameters?
}

extension UpdateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.UpdateConnectionAuthRequestParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.UpdateConnectionOAuthClientRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientID = "ClientID"
        case clientSecret = "ClientSecret"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension CloudWatchEventsClientTypes.UpdateConnectionOAuthClientRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionOAuthClientRequestParameters(clientID: \(Swift.String(describing: clientID)), clientSecret: \(Swift.String(describing: clientSecret)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the OAuth authorization parameters to use for the connection.</p>
    public struct UpdateConnectionOAuthClientRequestParameters: Swift.Equatable {
        /// <p>The client ID to use for OAuth authorization.</p>
        public let clientID: Swift.String?
        /// <p>The client secret assciated with the client ID to use for OAuth authorization.</p>
        public let clientSecret: Swift.String?

        public init (
            clientID: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientID = clientID
            self.clientSecret = clientSecret
        }
    }

}

extension CloudWatchEventsClientTypes.UpdateConnectionOAuthRequestParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.UpdateConnectionOAuthClientRequestParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension CloudWatchEventsClientTypes.UpdateConnectionOAuthRequestParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionOAuthRequestParameters(authorizationEndpoint: \(Swift.String(describing: authorizationEndpoint)), clientParameters: \(Swift.String(describing: clientParameters)), httpMethod: \(Swift.String(describing: httpMethod)), oAuthHttpParameters: \(Swift.String(describing: oAuthHttpParameters)))"}
}

extension CloudWatchEventsClientTypes {
    /// <p>Contains the OAuth request parameters to use for the connection.</p>
    public struct UpdateConnectionOAuthRequestParameters: Swift.Equatable {
        /// <p>The URL to the authorization endpoint when OAuth is specified as the authorization
        ///       type.</p>
        public let authorizationEndpoint: Swift.String?
        /// <p>A <code>UpdateConnectionOAuthClientRequestParameters</code> object that contains the
        ///       client parameters to use for the connection when OAuth is specified as the authorization
        ///       type.</p>
        public let clientParameters: CloudWatchEventsClientTypes.UpdateConnectionOAuthClientRequestParameters?
        /// <p>The method used to connect to the HTTP endpoint.</p>
        public let httpMethod: CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod?
        /// <p>The additional HTTP parameters used for the OAuth authorization request.</p>
        public let oAuthHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters?

        public init (
            authorizationEndpoint: Swift.String? = nil,
            clientParameters: CloudWatchEventsClientTypes.UpdateConnectionOAuthClientRequestParameters? = nil,
            httpMethod: CloudWatchEventsClientTypes.ConnectionOAuthHttpMethod? = nil,
            oAuthHttpParameters: CloudWatchEventsClientTypes.ConnectionHttpParameters? = nil
        )
        {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientParameters = clientParameters
            self.httpMethod = httpMethod
            self.oAuthHttpParameters = oAuthHttpParameters
        }
    }

}

extension UpdateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectionOutputResponse(connectionArn: \(Swift.String(describing: connectionArn)), connectionState: \(Swift.String(describing: connectionState)), creationTime: \(Swift.String(describing: creationTime)), lastAuthorizedTime: \(Swift.String(describing: lastAuthorizedTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension UpdateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct UpdateConnectionOutputResponse: Swift.Equatable {
    /// <p>The ARN of the connection that was updated.</p>
    public let connectionArn: Swift.String?
    /// <p>The state of the connection that was updated.</p>
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last authorized.</p>
    public let lastAuthorizedTime: ClientRuntime.Date?
    /// <p>A time stamp for the time that the connection was last modified.</p>
    public let lastModifiedTime: ClientRuntime.Date?

    public init (
        connectionArn: Swift.String? = nil,
        connectionState: CloudWatchEventsClientTypes.ConnectionState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastAuthorizedTime: ClientRuntime.Date? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct UpdateConnectionOutputResponseBody: Swift.Equatable {
    public let connectionArn: Swift.String?
    public let connectionState: CloudWatchEventsClientTypes.ConnectionState?
    public let creationTime: ClientRuntime.Date?
    public let lastModifiedTime: ClientRuntime.Date?
    public let lastAuthorizedTime: ClientRuntime.Date?
}

extension UpdateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(CloudWatchEventsClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}
