// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension CloudWatchEventsClient {
    /// <p>Activates a partner event source that has been deactivated. Once activated, your matching
    ///       event bus will start receiving events from the event source.</p>
    func activateEventSource(input: ActivateEventSourceInput) async throws -> ActivateEventSourceOutputResponse
    {
        typealias activateEventSourceContinuation = CheckedContinuation<ActivateEventSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: activateEventSourceContinuation) in
            activateEventSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Cancels the specified replay.</p>
    func cancelReplay(input: CancelReplayInput) async throws -> CancelReplayOutputResponse
    {
        typealias cancelReplayContinuation = CheckedContinuation<CancelReplayOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelReplayContinuation) in
            cancelReplay(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an API destination, which is an HTTP invocation endpoint configured as a target
    ///       for events.</p>
    func createApiDestination(input: CreateApiDestinationInput) async throws -> CreateApiDestinationOutputResponse
    {
        typealias createApiDestinationContinuation = CheckedContinuation<CreateApiDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createApiDestinationContinuation) in
            createApiDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an archive of events with the specified settings. When you create an archive,
    ///       incoming events might not immediately start being sent to the archive. Allow a short period of
    ///       time for changes to take effect. If you do not specify a pattern to filter events sent to the
    ///       archive, all events are sent to the archive except replayed events. Replayed events are not
    ///       sent to an archive.</p>
    func createArchive(input: CreateArchiveInput) async throws -> CreateArchiveOutputResponse
    {
        typealias createArchiveContinuation = CheckedContinuation<CreateArchiveOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createArchiveContinuation) in
            createArchive(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a connection. A connection defines the authorization type and credentials to use
    ///       for authorization with an API destination HTTP endpoint.</p>
    func createConnection(input: CreateConnectionInput) async throws -> CreateConnectionOutputResponse
    {
        typealias createConnectionContinuation = CheckedContinuation<CreateConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createConnectionContinuation) in
            createConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a new event bus within your account. This can be a custom event bus which you can
    ///       use to receive events from your custom applications and services, or it can be a partner event
    ///       bus which can be matched to a partner event source.</p>
    func createEventBus(input: CreateEventBusInput) async throws -> CreateEventBusOutputResponse
    {
        typealias createEventBusContinuation = CheckedContinuation<CreateEventBusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createEventBusContinuation) in
            createEventBus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Called by an SaaS partner to create a partner event source. This operation is not used by
    ///       AWS customers.</p>
    ///          <p>Each partner event source can be used by one AWS account to create a matching partner
    ///       event bus in that AWS account. A SaaS partner must create one partner event source for each
    ///       AWS account that wants to receive those event types. </p>
    ///          <p>A partner event source creates events based on resources within the SaaS partner's service
    ///       or application.</p>
    ///          <p>An AWS account that creates a partner event bus that matches the partner event source can
    ///       use that event bus to receive events from the partner, and then process them using AWS Events
    ///       rules and targets.</p>
    ///          <p>Partner event source names follow this format:</p>
    ///          <p>
    ///             <code>
    ///                <i>partner_name</i>/<i>event_namespace</i>/<i>event_name</i>
    ///             </code>
    ///          </p>
    ///          <p>
    ///             <i>partner_name</i> is determined during partner registration and identifies
    ///       the partner to AWS customers. <i>event_namespace</i> is determined by the
    ///       partner and is a way for the partner to categorize their events.
    ///         <i>event_name</i> is determined by the partner, and should uniquely identify
    ///       an event-generating resource within the partner system. The combination of
    ///         <i>event_namespace</i> and <i>event_name</i> should help AWS
    ///       customers decide whether to create an event bus to receive these events.</p>
    func createPartnerEventSource(input: CreatePartnerEventSourceInput) async throws -> CreatePartnerEventSourceOutputResponse
    {
        typealias createPartnerEventSourceContinuation = CheckedContinuation<CreatePartnerEventSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPartnerEventSourceContinuation) in
            createPartnerEventSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>You can use this operation to temporarily stop receiving events from the specified partner
    ///       event source. The matching event bus is not deleted. </p>
    ///          <p>When you deactivate a partner event source, the source goes into PENDING state. If it
    ///       remains in PENDING state for more than two weeks, it is deleted.</p>
    ///          <p>To activate a deactivated partner event source, use <a>ActivateEventSource</a>.</p>
    func deactivateEventSource(input: DeactivateEventSourceInput) async throws -> DeactivateEventSourceOutputResponse
    {
        typealias deactivateEventSourceContinuation = CheckedContinuation<DeactivateEventSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deactivateEventSourceContinuation) in
            deactivateEventSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes all authorization parameters from the connection. This lets you remove the secret
    ///       from the connection so you can reuse it without having to create a new connection.</p>
    func deauthorizeConnection(input: DeauthorizeConnectionInput) async throws -> DeauthorizeConnectionOutputResponse
    {
        typealias deauthorizeConnectionContinuation = CheckedContinuation<DeauthorizeConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deauthorizeConnectionContinuation) in
            deauthorizeConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified API destination.</p>
    func deleteApiDestination(input: DeleteApiDestinationInput) async throws -> DeleteApiDestinationOutputResponse
    {
        typealias deleteApiDestinationContinuation = CheckedContinuation<DeleteApiDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteApiDestinationContinuation) in
            deleteApiDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified archive.</p>
    func deleteArchive(input: DeleteArchiveInput) async throws -> DeleteArchiveOutputResponse
    {
        typealias deleteArchiveContinuation = CheckedContinuation<DeleteArchiveOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteArchiveContinuation) in
            deleteArchive(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a connection.</p>
    func deleteConnection(input: DeleteConnectionInput) async throws -> DeleteConnectionOutputResponse
    {
        typealias deleteConnectionContinuation = CheckedContinuation<DeleteConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConnectionContinuation) in
            deleteConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified custom event bus or partner event bus. All rules associated with
    ///       this event bus need to be deleted. You can't delete your account's default event bus.</p>
    func deleteEventBus(input: DeleteEventBusInput) async throws -> DeleteEventBusOutputResponse
    {
        typealias deleteEventBusContinuation = CheckedContinuation<DeleteEventBusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEventBusContinuation) in
            deleteEventBus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>This operation is used by SaaS partners to delete a partner event source. This operation
    ///       is not used by AWS customers.</p>
    ///          <p>When you delete an event source, the status of the corresponding partner event bus in the
    ///       AWS customer account becomes DELETED.</p>
    ///          <p></p>
    func deletePartnerEventSource(input: DeletePartnerEventSourceInput) async throws -> DeletePartnerEventSourceOutputResponse
    {
        typealias deletePartnerEventSourceContinuation = CheckedContinuation<DeletePartnerEventSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePartnerEventSourceContinuation) in
            deletePartnerEventSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified rule.</p>
    ///          <p>Before you can delete the rule, you must remove all targets, using <a>RemoveTargets</a>.</p>
    ///
    ///          <p>When you delete a rule, incoming events might continue to match to the deleted rule. Allow
    ///       a short period of time for changes to take effect.</p>
    ///
    ///          <p>Managed rules are rules created and managed by another AWS service on your behalf. These
    ///       rules are created by those other AWS services to support functionality in those services. You
    ///       can delete these rules using the <code>Force</code> option, but you should do so only if you
    ///       are sure the other service is not still using that rule.</p>
    func deleteRule(input: DeleteRuleInput) async throws -> DeleteRuleOutputResponse
    {
        typealias deleteRuleContinuation = CheckedContinuation<DeleteRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRuleContinuation) in
            deleteRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves details about an API destination.</p>
    func describeApiDestination(input: DescribeApiDestinationInput) async throws -> DescribeApiDestinationOutputResponse
    {
        typealias describeApiDestinationContinuation = CheckedContinuation<DescribeApiDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeApiDestinationContinuation) in
            describeApiDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves details about an archive.</p>
    func describeArchive(input: DescribeArchiveInput) async throws -> DescribeArchiveOutputResponse
    {
        typealias describeArchiveContinuation = CheckedContinuation<DescribeArchiveOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeArchiveContinuation) in
            describeArchive(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves details about a connection.</p>
    func describeConnection(input: DescribeConnectionInput) async throws -> DescribeConnectionOutputResponse
    {
        typealias describeConnectionContinuation = CheckedContinuation<DescribeConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeConnectionContinuation) in
            describeConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Displays details about an event bus in your account. This can include the external AWS
    ///       accounts that are permitted to write events to your default event bus, and the associated
    ///       policy. For custom event buses and partner event buses, it displays the name, ARN, policy,
    ///       state, and creation time.</p>
    ///          <p> To enable your account to receive events from other accounts on its default event bus,
    ///       use <a>PutPermission</a>.</p>
    ///          <p>For more information about partner event buses, see <a>CreateEventBus</a>.</p>
    func describeEventBus(input: DescribeEventBusInput) async throws -> DescribeEventBusOutputResponse
    {
        typealias describeEventBusContinuation = CheckedContinuation<DescribeEventBusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeEventBusContinuation) in
            describeEventBus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>This operation lists details about a partner event source that is shared with your
    ///       account.</p>
    func describeEventSource(input: DescribeEventSourceInput) async throws -> DescribeEventSourceOutputResponse
    {
        typealias describeEventSourceContinuation = CheckedContinuation<DescribeEventSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeEventSourceContinuation) in
            describeEventSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>An SaaS partner can use this operation to list details about a partner event source that
    ///       they have created. AWS customers do not use this operation. Instead, AWS customers can use
    ///         <a>DescribeEventSource</a> to see details about a partner event source that is
    ///       shared with them.</p>
    func describePartnerEventSource(input: DescribePartnerEventSourceInput) async throws -> DescribePartnerEventSourceOutputResponse
    {
        typealias describePartnerEventSourceContinuation = CheckedContinuation<DescribePartnerEventSourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describePartnerEventSourceContinuation) in
            describePartnerEventSource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves details about a replay. Use <code>DescribeReplay</code> to determine the
    ///       progress of a running replay. A replay processes events to replay based on the time in the
    ///       event, and replays them using 1 minute intervals. If you use <code>StartReplay</code> and
    ///       specify an <code>EventStartTime</code> and an <code>EventEndTime</code> that covers a 20
    ///       minute time range, the events are replayed from the first minute of that 20 minute range
    ///       first. Then the events from the second minute are replayed. You can use
    ///         <code>DescribeReplay</code> to determine the progress of a replay. The value returned for
    ///         <code>EventLastReplayedTime</code> indicates the time within the specified time range
    ///       associated with the last event replayed.</p>
    func describeReplay(input: DescribeReplayInput) async throws -> DescribeReplayOutputResponse
    {
        typealias describeReplayContinuation = CheckedContinuation<DescribeReplayOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeReplayContinuation) in
            describeReplay(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the specified rule.</p>
    ///          <p>DescribeRule does not list the targets of a rule. To see the targets associated with a
    ///       rule, use <a>ListTargetsByRule</a>.</p>
    func describeRule(input: DescribeRuleInput) async throws -> DescribeRuleOutputResponse
    {
        typealias describeRuleContinuation = CheckedContinuation<DescribeRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRuleContinuation) in
            describeRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Disables the specified rule. A disabled rule won't match any events, and won't
    ///       self-trigger if it has a schedule expression.</p>
    ///
    ///          <p>When you disable a rule, incoming events might continue to match to the disabled rule.
    ///       Allow a short period of time for changes to take effect.</p>
    func disableRule(input: DisableRuleInput) async throws -> DisableRuleOutputResponse
    {
        typealias disableRuleContinuation = CheckedContinuation<DisableRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disableRuleContinuation) in
            disableRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Enables the specified rule. If the rule does not exist, the operation fails.</p>
    ///
    ///          <p>When you enable a rule, incoming events might not immediately start matching to a newly
    ///       enabled rule. Allow a short period of time for changes to take effect.</p>
    func enableRule(input: EnableRuleInput) async throws -> EnableRuleOutputResponse
    {
        typealias enableRuleContinuation = CheckedContinuation<EnableRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: enableRuleContinuation) in
            enableRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves a list of API destination in the account in the current Region.</p>
    func listApiDestinations(input: ListApiDestinationsInput) async throws -> ListApiDestinationsOutputResponse
    {
        typealias listApiDestinationsContinuation = CheckedContinuation<ListApiDestinationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listApiDestinationsContinuation) in
            listApiDestinations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists your archives. You can either list all the archives or you can provide a prefix to
    ///       match to the archive names. Filter parameters are exclusive.</p>
    func listArchives(input: ListArchivesInput) async throws -> ListArchivesOutputResponse
    {
        typealias listArchivesContinuation = CheckedContinuation<ListArchivesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listArchivesContinuation) in
            listArchives(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves a list of connections from the account.</p>
    func listConnections(input: ListConnectionsInput) async throws -> ListConnectionsOutputResponse
    {
        typealias listConnectionsContinuation = CheckedContinuation<ListConnectionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listConnectionsContinuation) in
            listConnections(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists all the event buses in your account, including the default event bus, custom event
    ///       buses, and partner event buses.</p>
    func listEventBuses(input: ListEventBusesInput) async throws -> ListEventBusesOutputResponse
    {
        typealias listEventBusesContinuation = CheckedContinuation<ListEventBusesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEventBusesContinuation) in
            listEventBuses(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>You can use this to see all the partner event sources that have been shared with your AWS
    ///       account. For more information about partner event sources, see <a>CreateEventBus</a>.</p>
    func listEventSources(input: ListEventSourcesInput) async throws -> ListEventSourcesOutputResponse
    {
        typealias listEventSourcesContinuation = CheckedContinuation<ListEventSourcesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEventSourcesContinuation) in
            listEventSources(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>An SaaS partner can use this operation to display the AWS account ID that a particular
    ///       partner event source name is associated with. This operation is not used by AWS
    ///       customers.</p>
    func listPartnerEventSourceAccounts(input: ListPartnerEventSourceAccountsInput) async throws -> ListPartnerEventSourceAccountsOutputResponse
    {
        typealias listPartnerEventSourceAccountsContinuation = CheckedContinuation<ListPartnerEventSourceAccountsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listPartnerEventSourceAccountsContinuation) in
            listPartnerEventSourceAccounts(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>An SaaS partner can use this operation to list all the partner event source names that
    ///       they have created. This operation is not used by AWS customers.</p>
    func listPartnerEventSources(input: ListPartnerEventSourcesInput) async throws -> ListPartnerEventSourcesOutputResponse
    {
        typealias listPartnerEventSourcesContinuation = CheckedContinuation<ListPartnerEventSourcesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listPartnerEventSourcesContinuation) in
            listPartnerEventSources(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists your replays. You can either list all the replays or you can provide a prefix to
    ///       match to the replay names. Filter parameters are exclusive.</p>
    func listReplays(input: ListReplaysInput) async throws -> ListReplaysOutputResponse
    {
        typealias listReplaysContinuation = CheckedContinuation<ListReplaysOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listReplaysContinuation) in
            listReplays(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the rules for the specified target. You can see which of the rules in Amazon
    ///       EventBridge can invoke a specific target in your account.</p>
    func listRuleNamesByTarget(input: ListRuleNamesByTargetInput) async throws -> ListRuleNamesByTargetOutputResponse
    {
        typealias listRuleNamesByTargetContinuation = CheckedContinuation<ListRuleNamesByTargetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRuleNamesByTargetContinuation) in
            listRuleNamesByTarget(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists your Amazon EventBridge rules. You can either list all the rules or you can provide
    ///       a prefix to match to the rule names.</p>
    ///
    ///          <p>ListRules does not list the targets of a rule. To see the targets associated with a rule,
    ///       use <a>ListTargetsByRule</a>.</p>
    func listRules(input: ListRulesInput) async throws -> ListRulesOutputResponse
    {
        typealias listRulesContinuation = CheckedContinuation<ListRulesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRulesContinuation) in
            listRules(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Displays the tags associated with an EventBridge resource. In EventBridge, rules and event
    ///       buses can be tagged.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the targets assigned to the specified rule.</p>
    func listTargetsByRule(input: ListTargetsByRuleInput) async throws -> ListTargetsByRuleOutputResponse
    {
        typealias listTargetsByRuleContinuation = CheckedContinuation<ListTargetsByRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTargetsByRuleContinuation) in
            listTargetsByRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Sends custom events to Amazon EventBridge so that they can be matched to rules.</p>
    func putEvents(input: PutEventsInput) async throws -> PutEventsOutputResponse
    {
        typealias putEventsContinuation = CheckedContinuation<PutEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putEventsContinuation) in
            putEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>This is used by SaaS partners to write events to a customer's partner event bus. AWS
    ///       customers do not use this operation.</p>
    func putPartnerEvents(input: PutPartnerEventsInput) async throws -> PutPartnerEventsOutputResponse
    {
        typealias putPartnerEventsContinuation = CheckedContinuation<PutPartnerEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putPartnerEventsContinuation) in
            putPartnerEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Running <code>PutPermission</code> permits the specified AWS account or AWS organization
    ///       to put events to the specified <i>event bus</i>. Amazon EventBridge (CloudWatch
    ///       Events) rules in your account are triggered by these events arriving to an event bus in your
    ///       account. </p>
    ///          <p>For another account to send events to your account, that external account must have an
    ///       EventBridge rule with your account's event bus as a target.</p>
    ///
    ///          <p>To enable multiple AWS accounts to put events to your event bus, run
    ///         <code>PutPermission</code> once for each of these accounts. Or, if all the accounts are
    ///       members of the same AWS organization, you can run <code>PutPermission</code> once specifying
    ///         <code>Principal</code> as "*" and specifying the AWS organization ID in
    ///         <code>Condition</code>, to grant permissions to all accounts in that organization.</p>
    ///
    ///          <p>If you grant permissions using an organization, then accounts in that organization must
    ///       specify a <code>RoleArn</code> with proper permissions when they use <code>PutTarget</code> to
    ///       add your account's event bus as a target. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html">Sending and
    ///         Receiving Events Between AWS Accounts</a> in the <i>Amazon EventBridge User
    ///         Guide</i>.</p>
    ///
    ///          <p>The permission policy on the default event bus cannot exceed 10 KB in size.</p>
    func putPermission(input: PutPermissionInput) async throws -> PutPermissionOutputResponse
    {
        typealias putPermissionContinuation = CheckedContinuation<PutPermissionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putPermissionContinuation) in
            putPermission(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates the specified rule. Rules are enabled by default, or based on value of
    ///       the state. You can disable a rule using <a>DisableRule</a>.</p>
    ///
    ///          <p>A single rule watches for events from a single event bus. Events generated by AWS services
    ///       go to your account's default event bus. Events generated by SaaS partner services or
    ///       applications go to the matching partner event bus. If you have custom applications or
    ///       services, you can specify whether their events go to your default event bus or a custom event
    ///       bus that you have created. For more information, see <a>CreateEventBus</a>.</p>
    ///
    ///          <p>If you are updating an existing rule, the rule is replaced with what you specify in this
    ///         <code>PutRule</code> command. If you omit arguments in <code>PutRule</code>, the old values
    ///       for those arguments are not kept. Instead, they are replaced with null values.</p>
    ///
    ///          <p>When you create or update a rule, incoming events might not immediately start matching to
    ///       new or updated rules. Allow a short period of time for changes to take effect.</p>
    ///
    ///          <p>A rule must contain at least an EventPattern or ScheduleExpression. Rules with
    ///       EventPatterns are triggered when a matching event is observed. Rules with ScheduleExpressions
    ///       self-trigger based on the given schedule. A rule can have both an EventPattern and a
    ///       ScheduleExpression, in which case the rule triggers on matching events as well as on a
    ///       schedule.</p>
    ///
    ///          <p>When you initially create a rule, you can optionally assign one or more tags to the rule.
    ///       Tags can help you organize and categorize your resources. You can also use them to scope user
    ///       permissions, by granting a user permission to access or change only rules with certain tag
    ///       values. To use the <code>PutRule</code> operation and assign tags, you must have both the
    ///         <code>events:PutRule</code> and <code>events:TagResource</code> permissions.</p>
    ///          <p>If you are updating an existing rule, any tags you specify in the <code>PutRule</code>
    ///       operation are ignored. To update the tags of an existing rule, use <a>TagResource</a> and <a>UntagResource</a>.</p>
    ///
    ///          <p>Most services in AWS treat : or / as the same character in Amazon Resource Names (ARNs).
    ///       However, EventBridge uses an exact match in event patterns and rules. Be sure to use the
    ///       correct ARN characters when creating event patterns so that they match the ARN syntax in the
    ///       event you want to match.</p>
    ///
    ///          <p>In EventBridge, it is possible to create rules that lead to infinite loops, where a rule
    ///       is fired repeatedly. For example, a rule might detect that ACLs have changed on an S3 bucket,
    ///       and trigger software to change them to the desired state. If the rule is not written
    ///       carefully, the subsequent change to the ACLs fires the rule again, creating an infinite
    ///       loop.</p>
    ///          <p>To prevent this, write the rules so that the triggered actions do not re-fire the same
    ///       rule. For example, your rule could fire only if ACLs are found to be in a bad state, instead
    ///       of after any change. </p>
    ///          <p>An infinite loop can quickly cause higher than expected charges. We recommend that you use
    ///       budgeting, which alerts you when charges exceed your specified limit. For more information,
    ///       see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/budgets-managing-costs.html">Managing Your Costs with
    ///         Budgets</a>.</p>
    func putRule(input: PutRuleInput) async throws -> PutRuleOutputResponse
    {
        typealias putRuleContinuation = CheckedContinuation<PutRuleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRuleContinuation) in
            putRule(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds the specified targets to the specified rule, or updates the targets if they are
    ///       already associated with the rule.</p>
    ///          <p>Targets are the resources that are invoked when a rule is triggered.</p>
    ///          <p>You can configure the following as targets for Events:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>EC2 instances</p>
    ///             </li>
    ///             <li>
    ///                <p>SSM Run Command</p>
    ///             </li>
    ///             <li>
    ///                <p>SSM Automation</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS Lambda functions</p>
    ///             </li>
    ///             <li>
    ///                <p>Data streams in Amazon Kinesis Data Streams</p>
    ///             </li>
    ///             <li>
    ///                <p>Data delivery streams in Amazon Kinesis Data Firehose</p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon ECS tasks</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS Step Functions state machines</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS Batch jobs</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS CodeBuild projects</p>
    ///             </li>
    ///             <li>
    ///                <p>Pipelines in AWS CodePipeline</p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Inspector assessment templates</p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon SNS topics</p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon SQS queues, including FIFO queues</p>
    ///             </li>
    ///             <li>
    ///                <p>The default event bus of another AWS account</p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon API Gateway REST APIs</p>
    ///             </li>
    ///             <li>
    ///                <p>Redshift Clusters to invoke Data API ExecuteStatement on</p>
    ///             </li>
    ///             <li>
    ///                <p>Custom/SaaS HTTPS APIs via EventBridge API Destinations</p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon SageMaker Model Building Pipelines</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///
    ///          <p>Creating rules with built-in targets is supported only in the AWS Management Console. The
    ///       built-in targets are <code>EC2 CreateSnapshot API call</code>, <code>EC2 RebootInstances API
    ///         call</code>, <code>EC2 StopInstances API call</code>, and <code>EC2 TerminateInstances API
    ///         call</code>. </p>
    ///
    ///          <p>For some target types, <code>PutTargets</code> provides target-specific parameters. If the
    ///       target is a Kinesis data stream, you can optionally specify which shard the event goes to by
    ///       using the <code>KinesisParameters</code> argument. To invoke a command on multiple EC2
    ///       instances with one rule, you can use the <code>RunCommandParameters</code> field.</p>
    ///
    ///          <p>To be able to make API calls against the resources that you own, Amazon EventBridge
    ///       (CloudWatch Events) needs the appropriate permissions. For AWS Lambda and Amazon SNS
    ///       resources, EventBridge relies on resource-based policies. For EC2 instances, Kinesis data
    ///       streams, AWS Step Functions state machines and API Gateway REST APIs, EventBridge relies on
    ///       IAM roles that you specify in the <code>RoleARN</code> argument in <code>PutTargets</code>.
    ///       For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/auth-and-access-control-eventbridge.html">Authentication
    ///         and Access Control</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    ///
    ///          <p>If another AWS account is in the same region and has granted you permission (using
    ///         <code>PutPermission</code>), you can send events to that account. Set that account's event
    ///       bus as a target of the rules in your account. To send the matched events to the other account,
    ///       specify that account's event bus as the <code>Arn</code> value when you run
    ///         <code>PutTargets</code>. If your account sends events to another account, your account is
    ///       charged for each sent event. Each event sent to another account is charged as a custom event.
    ///       The account receiving the event is not charged. For more information, see <a href="https://aws.amazon.com/eventbridge/pricing/">Amazon EventBridge (CloudWatch Events)
    ///         Pricing</a>.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>Input</code>, <code>InputPath</code>, and <code>InputTransformer</code> are not
    ///         available with <code>PutTarget</code> if the target is an event bus of a different AWS
    ///         account.</p>
    ///          </note>
    ///
    ///          <p>If you are setting the event bus of another account as the target, and that account
    ///       granted permission to your account through an organization instead of directly by the account
    ///       ID, then you must specify a <code>RoleArn</code> with proper permissions in the
    ///         <code>Target</code> structure. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html">Sending and
    ///         Receiving Events Between AWS Accounts</a> in the <i>Amazon EventBridge User
    ///         Guide</i>.</p>
    ///
    ///          <p>For more information about enabling cross-account events, see <a>PutPermission</a>.</p>
    ///
    ///          <p>
    ///             <b>Input</b>, <b>InputPath</b>, and
    ///         <b>InputTransformer</b> are mutually exclusive and optional
    ///       parameters of a target. When a rule is triggered due to a matched event:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>If none of the following arguments are specified for a target, then the entire event
    ///           is passed to the target in JSON format (unless the target is Amazon EC2 Run Command or
    ///           Amazon ECS task, in which case nothing from the event is passed to the target).</p>
    ///             </li>
    ///             <li>
    ///                <p>If <b>Input</b> is specified in the form of valid JSON, then
    ///           the matched event is overridden with this constant.</p>
    ///             </li>
    ///             <li>
    ///                <p>If <b>InputPath</b> is specified in the form of JSONPath
    ///           (for example, <code>$.detail</code>), then only the part of the event specified in the
    ///           path is passed to the target (for example, only the detail part of the event is
    ///           passed).</p>
    ///             </li>
    ///             <li>
    ///                <p>If <b>InputTransformer</b> is specified, then one or more
    ///           specified JSONPaths are extracted from the event and used as values in a template that you
    ///           specify as the input to the target.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>When you specify <code>InputPath</code> or <code>InputTransformer</code>, you must use
    ///       JSON dot notation, not bracket notation.</p>
    ///
    ///          <p>When you add targets to a rule and the associated rule triggers soon after, new or updated
    ///       targets might not be immediately invoked. Allow a short period of time for changes to take
    ///       effect.</p>
    ///
    ///          <p>This action can partially fail if too many requests are made at the same time. If that
    ///       happens, <code>FailedEntryCount</code> is non-zero in the response and each entry in
    ///         <code>FailedEntries</code> provides the ID of the failed target and the error code.</p>
    func putTargets(input: PutTargetsInput) async throws -> PutTargetsOutputResponse
    {
        typealias putTargetsContinuation = CheckedContinuation<PutTargetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putTargetsContinuation) in
            putTargets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Revokes the permission of another AWS account to be able to put events to the specified
    ///       event bus. Specify the account to revoke by the <code>StatementId</code> value that you
    ///       associated with the account when you granted it permission with <code>PutPermission</code>.
    ///       You can find the <code>StatementId</code> by using <a>DescribeEventBus</a>.</p>
    func removePermission(input: RemovePermissionInput) async throws -> RemovePermissionOutputResponse
    {
        typealias removePermissionContinuation = CheckedContinuation<RemovePermissionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: removePermissionContinuation) in
            removePermission(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes the specified targets from the specified rule. When the rule is triggered, those
    ///       targets are no longer be invoked.</p>
    ///
    ///          <p>When you remove a target, when the associated rule triggers, removed targets might
    ///       continue to be invoked. Allow a short period of time for changes to take effect.</p>
    ///
    ///          <p>This action can partially fail if too many requests are made at the same time. If that
    ///       happens, <code>FailedEntryCount</code> is non-zero in the response and each entry in
    ///         <code>FailedEntries</code> provides the ID of the failed target and the error code.</p>
    func removeTargets(input: RemoveTargetsInput) async throws -> RemoveTargetsOutputResponse
    {
        typealias removeTargetsContinuation = CheckedContinuation<RemoveTargetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: removeTargetsContinuation) in
            removeTargets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Starts the specified replay. Events are not necessarily replayed in the exact same order
    ///       that they were added to the archive. A replay processes events to replay based on the time in
    ///       the event, and replays them using 1 minute intervals. If you specify an
    ///         <code>EventStartTime</code> and an <code>EventEndTime</code> that covers a 20 minute time
    ///       range, the events are replayed from the first minute of that 20 minute range first. Then the
    ///       events from the second minute are replayed. You can use <code>DescribeReplay</code> to
    ///       determine the progress of a replay. The value returned for <code>EventLastReplayedTime</code>
    ///       indicates the time within the specified time range associated with the last event
    ///       replayed.</p>
    func startReplay(input: StartReplayInput) async throws -> StartReplayOutputResponse
    {
        typealias startReplayContinuation = CheckedContinuation<StartReplayOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startReplayContinuation) in
            startReplay(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Assigns one or more tags (key-value pairs) to the specified EventBridge resource. Tags can
    ///       help you organize and categorize your resources. You can also use them to scope user
    ///       permissions by granting a user permission to access or change only resources with certain tag
    ///       values. In EventBridge, rules and event buses can be tagged.</p>
    ///          <p>Tags don't have any semantic meaning to AWS and are interpreted strictly as strings of
    ///       characters.</p>
    ///          <p>You can use the <code>TagResource</code> action with a resource that already has tags. If
    ///       you specify a new tag key, this tag is appended to the list of tags associated with the
    ///       resource. If you specify a tag key that is already associated with the resource, the new tag
    ///       value that you specify replaces the previous value for that tag.</p>
    ///          <p>You can associate as many as 50 tags with a resource.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Tests whether the specified event pattern matches the provided event.</p>
    ///          <p>Most services in AWS treat : or / as the same character in Amazon Resource Names (ARNs).
    ///       However, EventBridge uses an exact match in event patterns and rules. Be sure to use the
    ///       correct ARN characters when creating event patterns so that they match the ARN syntax in the
    ///       event you want to match.</p>
    func testEventPattern(input: TestEventPatternInput) async throws -> TestEventPatternOutputResponse
    {
        typealias testEventPatternContinuation = CheckedContinuation<TestEventPatternOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: testEventPatternContinuation) in
            testEventPattern(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes one or more tags from the specified EventBridge resource. In Amazon EventBridge
    ///       (CloudWatch Events, rules and event buses can be tagged.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an API destination.</p>
    func updateApiDestination(input: UpdateApiDestinationInput) async throws -> UpdateApiDestinationOutputResponse
    {
        typealias updateApiDestinationContinuation = CheckedContinuation<UpdateApiDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateApiDestinationContinuation) in
            updateApiDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the specified archive.</p>
    func updateArchive(input: UpdateArchiveInput) async throws -> UpdateArchiveOutputResponse
    {
        typealias updateArchiveContinuation = CheckedContinuation<UpdateArchiveOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateArchiveContinuation) in
            updateArchive(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates settings for a connection.</p>
    func updateConnection(input: UpdateConnectionInput) async throws -> UpdateConnectionOutputResponse
    {
        typealias updateConnectionContinuation = CheckedContinuation<UpdateConnectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateConnectionContinuation) in
            updateConnection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
