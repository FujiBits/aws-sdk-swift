// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension InstanceTypeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoRecoverySupported = "autoRecoverySupported"
        case bareMetal = "bareMetal"
        case burstablePerformanceSupported = "burstablePerformanceSupported"
        case currentGeneration = "currentGeneration"
        case dedicatedHostsSupported = "dedicatedHostsSupported"
        case ebsInfo = "ebsInfo"
        case fpgaInfo = "fpgaInfo"
        case freeTierEligible = "freeTierEligible"
        case gpuInfo = "gpuInfo"
        case hibernationSupported = "hibernationSupported"
        case hypervisor = "hypervisor"
        case inferenceAcceleratorInfo = "inferenceAcceleratorInfo"
        case instanceStorageInfo = "instanceStorageInfo"
        case instanceStorageSupported = "instanceStorageSupported"
        case instanceType = "instanceType"
        case memoryInfo = "memoryInfo"
        case networkInfo = "networkInfo"
        case placementGroupInfo = "placementGroupInfo"
        case processorInfo = "processorInfo"
        case supportedBootModes = "supportedBootModes"
        case supportedRootDeviceTypes = "supportedRootDeviceTypes"
        case supportedUsageClasses = "supportedUsageClasses"
        case supportedVirtualizationTypes = "supportedVirtualizationTypes"
        case vCpuInfo = "vCpuInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoRecoverySupported = autoRecoverySupported {
            try container.encode(autoRecoverySupported, forKey: Key("AutoRecoverySupported"))
        }
        if let bareMetal = bareMetal {
            try container.encode(bareMetal, forKey: Key("BareMetal"))
        }
        if let burstablePerformanceSupported = burstablePerformanceSupported {
            try container.encode(burstablePerformanceSupported, forKey: Key("BurstablePerformanceSupported"))
        }
        if let currentGeneration = currentGeneration {
            try container.encode(currentGeneration, forKey: Key("CurrentGeneration"))
        }
        if let dedicatedHostsSupported = dedicatedHostsSupported {
            try container.encode(dedicatedHostsSupported, forKey: Key("DedicatedHostsSupported"))
        }
        if let ebsInfo = ebsInfo {
            try container.encode(ebsInfo, forKey: Key("EbsInfo"))
        }
        if let fpgaInfo = fpgaInfo {
            try container.encode(fpgaInfo, forKey: Key("FpgaInfo"))
        }
        if let freeTierEligible = freeTierEligible {
            try container.encode(freeTierEligible, forKey: Key("FreeTierEligible"))
        }
        if let gpuInfo = gpuInfo {
            try container.encode(gpuInfo, forKey: Key("GpuInfo"))
        }
        if let hibernationSupported = hibernationSupported {
            try container.encode(hibernationSupported, forKey: Key("HibernationSupported"))
        }
        if let hypervisor = hypervisor {
            try container.encode(hypervisor, forKey: Key("Hypervisor"))
        }
        if let inferenceAcceleratorInfo = inferenceAcceleratorInfo {
            try container.encode(inferenceAcceleratorInfo, forKey: Key("InferenceAcceleratorInfo"))
        }
        if let instanceStorageInfo = instanceStorageInfo {
            try container.encode(instanceStorageInfo, forKey: Key("InstanceStorageInfo"))
        }
        if let instanceStorageSupported = instanceStorageSupported {
            try container.encode(instanceStorageSupported, forKey: Key("InstanceStorageSupported"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: Key("InstanceType"))
        }
        if let memoryInfo = memoryInfo {
            try container.encode(memoryInfo, forKey: Key("MemoryInfo"))
        }
        if let networkInfo = networkInfo {
            try container.encode(networkInfo, forKey: Key("NetworkInfo"))
        }
        if let placementGroupInfo = placementGroupInfo {
            try container.encode(placementGroupInfo, forKey: Key("PlacementGroupInfo"))
        }
        if let processorInfo = processorInfo {
            try container.encode(processorInfo, forKey: Key("ProcessorInfo"))
        }
        if let supportedBootModes = supportedBootModes {
            if !supportedBootModes.isEmpty {
                for (index0, bootmodetype0) in supportedBootModes.enumerated() {
                    var supportedBootModesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedBootModes.\(index0.advanced(by: 1))"))
                    try supportedBootModesContainer0.encode(bootmodetype0, forKey: Key(""))
                }
            }
        }
        if let supportedRootDeviceTypes = supportedRootDeviceTypes {
            if !supportedRootDeviceTypes.isEmpty {
                for (index0, rootdevicetype0) in supportedRootDeviceTypes.enumerated() {
                    var supportedRootDeviceTypesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedRootDeviceTypes.\(index0.advanced(by: 1))"))
                    try supportedRootDeviceTypesContainer0.encode(rootdevicetype0, forKey: Key(""))
                }
            }
        }
        if let supportedUsageClasses = supportedUsageClasses {
            if !supportedUsageClasses.isEmpty {
                for (index0, usageclasstype0) in supportedUsageClasses.enumerated() {
                    var supportedUsageClassesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedUsageClasses.\(index0.advanced(by: 1))"))
                    try supportedUsageClassesContainer0.encode(usageclasstype0, forKey: Key(""))
                }
            }
        }
        if let supportedVirtualizationTypes = supportedVirtualizationTypes {
            if !supportedVirtualizationTypes.isEmpty {
                for (index0, virtualizationtype0) in supportedVirtualizationTypes.enumerated() {
                    var supportedVirtualizationTypesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SupportedVirtualizationTypes.\(index0.advanced(by: 1))"))
                    try supportedVirtualizationTypesContainer0.encode(virtualizationtype0, forKey: Key(""))
                }
            }
        }
        if let vCpuInfo = vCpuInfo {
            try container.encode(vCpuInfo, forKey: Key("VCpuInfo"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let freeTierEligibleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .freeTierEligible)
        freeTierEligible = freeTierEligibleDecoded
        if containerValues.contains(.supportedUsageClasses) {
            struct KeyVal0{struct item{}}
            let supportedUsageClassesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedUsageClasses)
            if let supportedUsageClassesWrappedContainer = supportedUsageClassesWrappedContainer {
                let supportedUsageClassesContainer = try supportedUsageClassesWrappedContainer.decodeIfPresent([UsageClassType].self, forKey: .member)
                var supportedUsageClassesBuffer:[UsageClassType]? = nil
                if let supportedUsageClassesContainer = supportedUsageClassesContainer {
                    supportedUsageClassesBuffer = [UsageClassType]()
                    for stringContainer0 in supportedUsageClassesContainer {
                        supportedUsageClassesBuffer?.append(stringContainer0)
                    }
                }
                supportedUsageClasses = supportedUsageClassesBuffer
            } else {
                supportedUsageClasses = []
            }
        } else {
            supportedUsageClasses = nil
        }
        if containerValues.contains(.supportedRootDeviceTypes) {
            struct KeyVal0{struct item{}}
            let supportedRootDeviceTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedRootDeviceTypes)
            if let supportedRootDeviceTypesWrappedContainer = supportedRootDeviceTypesWrappedContainer {
                let supportedRootDeviceTypesContainer = try supportedRootDeviceTypesWrappedContainer.decodeIfPresent([RootDeviceType].self, forKey: .member)
                var supportedRootDeviceTypesBuffer:[RootDeviceType]? = nil
                if let supportedRootDeviceTypesContainer = supportedRootDeviceTypesContainer {
                    supportedRootDeviceTypesBuffer = [RootDeviceType]()
                    for stringContainer0 in supportedRootDeviceTypesContainer {
                        supportedRootDeviceTypesBuffer?.append(stringContainer0)
                    }
                }
                supportedRootDeviceTypes = supportedRootDeviceTypesBuffer
            } else {
                supportedRootDeviceTypes = []
            }
        } else {
            supportedRootDeviceTypes = nil
        }
        if containerValues.contains(.supportedVirtualizationTypes) {
            struct KeyVal0{struct item{}}
            let supportedVirtualizationTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedVirtualizationTypes)
            if let supportedVirtualizationTypesWrappedContainer = supportedVirtualizationTypesWrappedContainer {
                let supportedVirtualizationTypesContainer = try supportedVirtualizationTypesWrappedContainer.decodeIfPresent([VirtualizationType].self, forKey: .member)
                var supportedVirtualizationTypesBuffer:[VirtualizationType]? = nil
                if let supportedVirtualizationTypesContainer = supportedVirtualizationTypesContainer {
                    supportedVirtualizationTypesBuffer = [VirtualizationType]()
                    for stringContainer0 in supportedVirtualizationTypesContainer {
                        supportedVirtualizationTypesBuffer?.append(stringContainer0)
                    }
                }
                supportedVirtualizationTypes = supportedVirtualizationTypesBuffer
            } else {
                supportedVirtualizationTypes = []
            }
        } else {
            supportedVirtualizationTypes = nil
        }
        let bareMetalDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bareMetal)
        bareMetal = bareMetalDecoded
        let hypervisorDecoded = try containerValues.decodeIfPresent(InstanceTypeHypervisor.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
        let processorInfoDecoded = try containerValues.decodeIfPresent(ProcessorInfo.self, forKey: .processorInfo)
        processorInfo = processorInfoDecoded
        let vCpuInfoDecoded = try containerValues.decodeIfPresent(VCpuInfo.self, forKey: .vCpuInfo)
        vCpuInfo = vCpuInfoDecoded
        let memoryInfoDecoded = try containerValues.decodeIfPresent(MemoryInfo.self, forKey: .memoryInfo)
        memoryInfo = memoryInfoDecoded
        let instanceStorageSupportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .instanceStorageSupported)
        instanceStorageSupported = instanceStorageSupportedDecoded
        let instanceStorageInfoDecoded = try containerValues.decodeIfPresent(InstanceStorageInfo.self, forKey: .instanceStorageInfo)
        instanceStorageInfo = instanceStorageInfoDecoded
        let ebsInfoDecoded = try containerValues.decodeIfPresent(EbsInfo.self, forKey: .ebsInfo)
        ebsInfo = ebsInfoDecoded
        let networkInfoDecoded = try containerValues.decodeIfPresent(NetworkInfo.self, forKey: .networkInfo)
        networkInfo = networkInfoDecoded
        let gpuInfoDecoded = try containerValues.decodeIfPresent(GpuInfo.self, forKey: .gpuInfo)
        gpuInfo = gpuInfoDecoded
        let fpgaInfoDecoded = try containerValues.decodeIfPresent(FpgaInfo.self, forKey: .fpgaInfo)
        fpgaInfo = fpgaInfoDecoded
        let placementGroupInfoDecoded = try containerValues.decodeIfPresent(PlacementGroupInfo.self, forKey: .placementGroupInfo)
        placementGroupInfo = placementGroupInfoDecoded
        let inferenceAcceleratorInfoDecoded = try containerValues.decodeIfPresent(InferenceAcceleratorInfo.self, forKey: .inferenceAcceleratorInfo)
        inferenceAcceleratorInfo = inferenceAcceleratorInfoDecoded
        let hibernationSupportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hibernationSupported)
        hibernationSupported = hibernationSupportedDecoded
        let burstablePerformanceSupportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .burstablePerformanceSupported)
        burstablePerformanceSupported = burstablePerformanceSupportedDecoded
        let dedicatedHostsSupportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .dedicatedHostsSupported)
        dedicatedHostsSupported = dedicatedHostsSupportedDecoded
        let autoRecoverySupportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoRecoverySupported)
        autoRecoverySupported = autoRecoverySupportedDecoded
        if containerValues.contains(.supportedBootModes) {
            struct KeyVal0{struct item{}}
            let supportedBootModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedBootModes)
            if let supportedBootModesWrappedContainer = supportedBootModesWrappedContainer {
                let supportedBootModesContainer = try supportedBootModesWrappedContainer.decodeIfPresent([BootModeType].self, forKey: .member)
                var supportedBootModesBuffer:[BootModeType]? = nil
                if let supportedBootModesContainer = supportedBootModesContainer {
                    supportedBootModesBuffer = [BootModeType]()
                    for stringContainer0 in supportedBootModesContainer {
                        supportedBootModesBuffer?.append(stringContainer0)
                    }
                }
                supportedBootModes = supportedBootModesBuffer
            } else {
                supportedBootModes = []
            }
        } else {
            supportedBootModes = nil
        }
    }
}
