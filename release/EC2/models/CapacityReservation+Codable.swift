// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CapacityReservation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "availabilityZone"
        case availabilityZoneId = "availabilityZoneId"
        case availableInstanceCount = "availableInstanceCount"
        case capacityReservationArn = "capacityReservationArn"
        case capacityReservationId = "capacityReservationId"
        case createDate = "createDate"
        case ebsOptimized = "ebsOptimized"
        case endDate = "endDate"
        case endDateType = "endDateType"
        case ephemeralStorage = "ephemeralStorage"
        case instanceMatchCriteria = "instanceMatchCriteria"
        case instancePlatform = "instancePlatform"
        case instanceType = "instanceType"
        case outpostArn = "outpostArn"
        case ownerId = "ownerId"
        case startDate = "startDate"
        case state = "state"
        case tags = "tagSet"
        case tenancy = "tenancy"
        case totalInstanceCount = "totalInstanceCount"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let availabilityZoneId = availabilityZoneId {
            try container.encode(availabilityZoneId, forKey: Key("AvailabilityZoneId"))
        }
        if availableInstanceCount != 0 {
            try container.encode(availableInstanceCount, forKey: Key("AvailableInstanceCount"))
        }
        if let capacityReservationArn = capacityReservationArn {
            try container.encode(capacityReservationArn, forKey: Key("CapacityReservationArn"))
        }
        if let capacityReservationId = capacityReservationId {
            try container.encode(capacityReservationId, forKey: Key("CapacityReservationId"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("CreateDate"))
        }
        if ebsOptimized != false {
            try container.encode(ebsOptimized, forKey: Key("EbsOptimized"))
        }
        if let endDate = endDate {
            try container.encode(TimestampWrapper(endDate, format: .dateTime), forKey: Key("EndDate"))
        }
        if let endDateType = endDateType {
            try container.encode(endDateType, forKey: Key("EndDateType"))
        }
        if ephemeralStorage != false {
            try container.encode(ephemeralStorage, forKey: Key("EphemeralStorage"))
        }
        if let instanceMatchCriteria = instanceMatchCriteria {
            try container.encode(instanceMatchCriteria, forKey: Key("InstanceMatchCriteria"))
        }
        if let instancePlatform = instancePlatform {
            try container.encode(instancePlatform, forKey: Key("InstancePlatform"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: Key("InstanceType"))
        }
        if let outpostArn = outpostArn {
            try container.encode(outpostArn, forKey: Key("OutpostArn"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: Key("OwnerId"))
        }
        if let startDate = startDate {
            try container.encode(TimestampWrapper(startDate, format: .dateTime), forKey: Key("StartDate"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
        if let tenancy = tenancy {
            try container.encode(tenancy, forKey: Key("Tenancy"))
        }
        if totalInstanceCount != 0 {
            try container.encode(totalInstanceCount, forKey: Key("TotalInstanceCount"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacityReservationId)
        capacityReservationId = capacityReservationIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let capacityReservationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacityReservationArn)
        capacityReservationArn = capacityReservationArnDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let instancePlatformDecoded = try containerValues.decodeIfPresent(CapacityReservationInstancePlatform.self, forKey: .instancePlatform)
        instancePlatform = instancePlatformDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(CapacityReservationTenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let totalInstanceCountDecoded = try containerValues.decode(Int.self, forKey: .totalInstanceCount)
        totalInstanceCount = totalInstanceCountDecoded
        let availableInstanceCountDecoded = try containerValues.decode(Int.self, forKey: .availableInstanceCount)
        availableInstanceCount = availableInstanceCountDecoded
        let ebsOptimizedDecoded = try containerValues.decode(Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let ephemeralStorageDecoded = try containerValues.decode(Bool.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CapacityReservationState.self, forKey: .state)
        state = stateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        var startDateBuffer:Date? = nil
        if let startDateDecoded = startDateDecoded {
            startDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(startDateDecoded, format: .dateTime)
        }
        startDate = startDateBuffer
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        var endDateBuffer:Date? = nil
        if let endDateDecoded = endDateDecoded {
            endDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(endDateDecoded, format: .dateTime)
        }
        endDate = endDateBuffer
        let endDateTypeDecoded = try containerValues.decodeIfPresent(EndDateType.self, forKey: .endDateType)
        endDateType = endDateTypeDecoded
        let instanceMatchCriteriaDecoded = try containerValues.decodeIfPresent(InstanceMatchCriteria.self, forKey: .instanceMatchCriteria)
        instanceMatchCriteria = instanceMatchCriteriaDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let outpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
    }
}
