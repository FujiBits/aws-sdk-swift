// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SpotFleetRequestConfigData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocationStrategy = "allocationStrategy"
        case clientToken = "clientToken"
        case excessCapacityTerminationPolicy = "excessCapacityTerminationPolicy"
        case fulfilledCapacity = "fulfilledCapacity"
        case iamFleetRole = "iamFleetRole"
        case instanceInterruptionBehavior = "instanceInterruptionBehavior"
        case instancePoolsToUseCount = "instancePoolsToUseCount"
        case launchSpecifications = "launchSpecifications"
        case launchTemplateConfigs = "launchTemplateConfigs"
        case loadBalancersConfig = "loadBalancersConfig"
        case onDemandAllocationStrategy = "onDemandAllocationStrategy"
        case onDemandFulfilledCapacity = "onDemandFulfilledCapacity"
        case onDemandMaxTotalPrice = "onDemandMaxTotalPrice"
        case onDemandTargetCapacity = "onDemandTargetCapacity"
        case replaceUnhealthyInstances = "replaceUnhealthyInstances"
        case spotMaintenanceStrategies = "spotMaintenanceStrategies"
        case spotMaxTotalPrice = "spotMaxTotalPrice"
        case spotPrice = "spotPrice"
        case tagSpecifications = "TagSpecification"
        case targetCapacity = "targetCapacity"
        case terminateInstancesWithExpiration = "terminateInstancesWithExpiration"
        case type = "type"
        case validFrom = "validFrom"
        case validUntil = "validUntil"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocationStrategy = allocationStrategy {
            try container.encode(allocationStrategy, forKey: Key("AllocationStrategy"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: Key("ClientToken"))
        }
        if let excessCapacityTerminationPolicy = excessCapacityTerminationPolicy {
            try container.encode(excessCapacityTerminationPolicy, forKey: Key("ExcessCapacityTerminationPolicy"))
        }
        if fulfilledCapacity != 0.0 {
            try container.encode(String(fulfilledCapacity), forKey: Key("FulfilledCapacity"))
        }
        if let iamFleetRole = iamFleetRole {
            try container.encode(iamFleetRole, forKey: Key("IamFleetRole"))
        }
        if let instanceInterruptionBehavior = instanceInterruptionBehavior {
            try container.encode(instanceInterruptionBehavior, forKey: Key("InstanceInterruptionBehavior"))
        }
        if instancePoolsToUseCount != 0 {
            try container.encode(instancePoolsToUseCount, forKey: Key("InstancePoolsToUseCount"))
        }
        if let launchSpecifications = launchSpecifications {
            if !launchSpecifications.isEmpty {
                for (index0, spotfleetlaunchspecification0) in launchSpecifications.enumerated() {
                    var launchSpecificationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("LaunchSpecifications.\(index0.advanced(by: 1))"))
                    try launchSpecificationsContainer0.encode(spotfleetlaunchspecification0, forKey: Key(""))
                }
            }
        }
        if let launchTemplateConfigs = launchTemplateConfigs {
            if !launchTemplateConfigs.isEmpty {
                for (index0, launchtemplateconfig0) in launchTemplateConfigs.enumerated() {
                    var launchTemplateConfigsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("LaunchTemplateConfigs.\(index0.advanced(by: 1))"))
                    try launchTemplateConfigsContainer0.encode(launchtemplateconfig0, forKey: Key(""))
                }
            }
        }
        if let loadBalancersConfig = loadBalancersConfig {
            try container.encode(loadBalancersConfig, forKey: Key("LoadBalancersConfig"))
        }
        if let onDemandAllocationStrategy = onDemandAllocationStrategy {
            try container.encode(onDemandAllocationStrategy, forKey: Key("OnDemandAllocationStrategy"))
        }
        if onDemandFulfilledCapacity != 0.0 {
            try container.encode(String(onDemandFulfilledCapacity), forKey: Key("OnDemandFulfilledCapacity"))
        }
        if let onDemandMaxTotalPrice = onDemandMaxTotalPrice {
            try container.encode(onDemandMaxTotalPrice, forKey: Key("OnDemandMaxTotalPrice"))
        }
        if onDemandTargetCapacity != 0 {
            try container.encode(onDemandTargetCapacity, forKey: Key("OnDemandTargetCapacity"))
        }
        if replaceUnhealthyInstances != false {
            try container.encode(replaceUnhealthyInstances, forKey: Key("ReplaceUnhealthyInstances"))
        }
        if let spotMaintenanceStrategies = spotMaintenanceStrategies {
            try container.encode(spotMaintenanceStrategies, forKey: Key("SpotMaintenanceStrategies"))
        }
        if let spotMaxTotalPrice = spotMaxTotalPrice {
            try container.encode(spotMaxTotalPrice, forKey: Key("SpotMaxTotalPrice"))
        }
        if let spotPrice = spotPrice {
            try container.encode(spotPrice, forKey: Key("SpotPrice"))
        }
        if let tagSpecifications = tagSpecifications {
            if !tagSpecifications.isEmpty {
                for (index0, tagspecification0) in tagSpecifications.enumerated() {
                    var tagSpecificationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSpecification.\(index0.advanced(by: 1))"))
                    try tagSpecificationsContainer0.encode(tagspecification0, forKey: Key(""))
                }
            }
        }
        if targetCapacity != 0 {
            try container.encode(targetCapacity, forKey: Key("TargetCapacity"))
        }
        if terminateInstancesWithExpiration != false {
            try container.encode(terminateInstancesWithExpiration, forKey: Key("TerminateInstancesWithExpiration"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let validFrom = validFrom {
            try container.encode(TimestampWrapper(validFrom, format: .dateTime), forKey: Key("ValidFrom"))
        }
        if let validUntil = validUntil {
            try container.encode(TimestampWrapper(validUntil, format: .dateTime), forKey: Key("ValidUntil"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocationStrategyDecoded = try containerValues.decodeIfPresent(AllocationStrategy.self, forKey: .allocationStrategy)
        allocationStrategy = allocationStrategyDecoded
        let onDemandAllocationStrategyDecoded = try containerValues.decodeIfPresent(OnDemandAllocationStrategy.self, forKey: .onDemandAllocationStrategy)
        onDemandAllocationStrategy = onDemandAllocationStrategyDecoded
        let spotMaintenanceStrategiesDecoded = try containerValues.decodeIfPresent(SpotMaintenanceStrategies.self, forKey: .spotMaintenanceStrategies)
        spotMaintenanceStrategies = spotMaintenanceStrategiesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let excessCapacityTerminationPolicyDecoded = try containerValues.decodeIfPresent(ExcessCapacityTerminationPolicy.self, forKey: .excessCapacityTerminationPolicy)
        excessCapacityTerminationPolicy = excessCapacityTerminationPolicyDecoded
        let fulfilledCapacityDecoded = try containerValues.decode(Double.self, forKey: .fulfilledCapacity)
        fulfilledCapacity = fulfilledCapacityDecoded
        let onDemandFulfilledCapacityDecoded = try containerValues.decode(Double.self, forKey: .onDemandFulfilledCapacity)
        onDemandFulfilledCapacity = onDemandFulfilledCapacityDecoded
        let iamFleetRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamFleetRole)
        iamFleetRole = iamFleetRoleDecoded
        if containerValues.contains(.launchSpecifications) {
            struct KeyVal0{struct item{}}
            let launchSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .launchSpecifications)
            if let launchSpecificationsWrappedContainer = launchSpecificationsWrappedContainer {
                let launchSpecificationsContainer = try launchSpecificationsWrappedContainer.decodeIfPresent([SpotFleetLaunchSpecification].self, forKey: .member)
                var launchSpecificationsBuffer:[SpotFleetLaunchSpecification]? = nil
                if let launchSpecificationsContainer = launchSpecificationsContainer {
                    launchSpecificationsBuffer = [SpotFleetLaunchSpecification]()
                    for structureContainer0 in launchSpecificationsContainer {
                        launchSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                launchSpecifications = launchSpecificationsBuffer
            } else {
                launchSpecifications = []
            }
        } else {
            launchSpecifications = nil
        }
        if containerValues.contains(.launchTemplateConfigs) {
            struct KeyVal0{struct item{}}
            let launchTemplateConfigsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .launchTemplateConfigs)
            if let launchTemplateConfigsWrappedContainer = launchTemplateConfigsWrappedContainer {
                let launchTemplateConfigsContainer = try launchTemplateConfigsWrappedContainer.decodeIfPresent([LaunchTemplateConfig].self, forKey: .member)
                var launchTemplateConfigsBuffer:[LaunchTemplateConfig]? = nil
                if let launchTemplateConfigsContainer = launchTemplateConfigsContainer {
                    launchTemplateConfigsBuffer = [LaunchTemplateConfig]()
                    for structureContainer0 in launchTemplateConfigsContainer {
                        launchTemplateConfigsBuffer?.append(structureContainer0)
                    }
                }
                launchTemplateConfigs = launchTemplateConfigsBuffer
            } else {
                launchTemplateConfigs = []
            }
        } else {
            launchTemplateConfigs = nil
        }
        let spotPriceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spotPrice)
        spotPrice = spotPriceDecoded
        let targetCapacityDecoded = try containerValues.decode(Int.self, forKey: .targetCapacity)
        targetCapacity = targetCapacityDecoded
        let onDemandTargetCapacityDecoded = try containerValues.decode(Int.self, forKey: .onDemandTargetCapacity)
        onDemandTargetCapacity = onDemandTargetCapacityDecoded
        let onDemandMaxTotalPriceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandMaxTotalPrice)
        onDemandMaxTotalPrice = onDemandMaxTotalPriceDecoded
        let spotMaxTotalPriceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spotMaxTotalPrice)
        spotMaxTotalPrice = spotMaxTotalPriceDecoded
        let terminateInstancesWithExpirationDecoded = try containerValues.decode(Bool.self, forKey: .terminateInstancesWithExpiration)
        terminateInstancesWithExpiration = terminateInstancesWithExpirationDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FleetType.self, forKey: .type)
        type = typeDecoded
        let validFromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validFrom)
        var validFromBuffer:Date? = nil
        if let validFromDecoded = validFromDecoded {
            validFromBuffer = try TimestampWrapperDecoder.parseDateStringValue(validFromDecoded, format: .dateTime)
        }
        validFrom = validFromBuffer
        let validUntilDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validUntil)
        var validUntilBuffer:Date? = nil
        if let validUntilDecoded = validUntilDecoded {
            validUntilBuffer = try TimestampWrapperDecoder.parseDateStringValue(validUntilDecoded, format: .dateTime)
        }
        validUntil = validUntilBuffer
        let replaceUnhealthyInstancesDecoded = try containerValues.decode(Bool.self, forKey: .replaceUnhealthyInstances)
        replaceUnhealthyInstances = replaceUnhealthyInstancesDecoded
        let instanceInterruptionBehaviorDecoded = try containerValues.decodeIfPresent(InstanceInterruptionBehavior.self, forKey: .instanceInterruptionBehavior)
        instanceInterruptionBehavior = instanceInterruptionBehaviorDecoded
        let loadBalancersConfigDecoded = try containerValues.decodeIfPresent(LoadBalancersConfig.self, forKey: .loadBalancersConfig)
        loadBalancersConfig = loadBalancersConfigDecoded
        let instancePoolsToUseCountDecoded = try containerValues.decode(Int.self, forKey: .instancePoolsToUseCount)
        instancePoolsToUseCount = instancePoolsToUseCountDecoded
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct item{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([TagSpecification].self, forKey: .member)
                var tagSpecificationsBuffer:[TagSpecification]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [TagSpecification]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
    }
}
