// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ImportInstanceLaunchSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalInfo = "additionalInfo"
        case architecture = "architecture"
        case groupIds = "GroupId"
        case groupNames = "GroupName"
        case instanceInitiatedShutdownBehavior = "instanceInitiatedShutdownBehavior"
        case instanceType = "instanceType"
        case monitoring = "monitoring"
        case placement = "placement"
        case privateIpAddress = "privateIpAddress"
        case subnetId = "subnetId"
        case userData = "userData"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let additionalInfo = additionalInfo {
            try container.encode(additionalInfo, forKey: Key("AdditionalInfo"))
        }
        if let architecture = architecture {
            try container.encode(architecture, forKey: Key("Architecture"))
        }
        if let groupIds = groupIds {
            if !groupIds.isEmpty {
                for (index0, securitygroupid0) in groupIds.enumerated() {
                    var groupIdsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("GroupId.\(index0.advanced(by: 1))"))
                    try groupIdsContainer0.encode(securitygroupid0, forKey: Key(""))
                }
            }
        }
        if let groupNames = groupNames {
            if !groupNames.isEmpty {
                for (index0, securitygroupname0) in groupNames.enumerated() {
                    var groupNamesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("GroupName.\(index0.advanced(by: 1))"))
                    try groupNamesContainer0.encode(securitygroupname0, forKey: Key(""))
                }
            }
        }
        if let instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior {
            try container.encode(instanceInitiatedShutdownBehavior, forKey: Key("InstanceInitiatedShutdownBehavior"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: Key("InstanceType"))
        }
        if monitoring != false {
            try container.encode(monitoring, forKey: Key("Monitoring"))
        }
        if let placement = placement {
            try container.encode(placement, forKey: Key("Placement"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: Key("PrivateIpAddress"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
        if let userData = userData {
            try container.encode(userData, forKey: Key("UserData"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalInfo)
        additionalInfo = additionalInfoDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(ArchitectureValues.self, forKey: .architecture)
        architecture = architectureDecoded
        if containerValues.contains(.groupIds) {
            struct KeyVal0{struct SecurityGroupId{}}
            let groupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .groupIds)
            if let groupIdsWrappedContainer = groupIdsWrappedContainer {
                let groupIdsContainer = try groupIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var groupIdsBuffer:[String]? = nil
                if let groupIdsContainer = groupIdsContainer {
                    groupIdsBuffer = [String]()
                    for stringContainer0 in groupIdsContainer {
                        groupIdsBuffer?.append(stringContainer0)
                    }
                }
                groupIds = groupIdsBuffer
            } else {
                groupIds = []
            }
        } else {
            groupIds = nil
        }
        if containerValues.contains(.groupNames) {
            struct KeyVal0{struct SecurityGroup{}}
            let groupNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroup>.CodingKeys.self, forKey: .groupNames)
            if let groupNamesWrappedContainer = groupNamesWrappedContainer {
                let groupNamesContainer = try groupNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var groupNamesBuffer:[String]? = nil
                if let groupNamesContainer = groupNamesContainer {
                    groupNamesBuffer = [String]()
                    for stringContainer0 in groupNamesContainer {
                        groupNamesBuffer?.append(stringContainer0)
                    }
                }
                groupNames = groupNamesBuffer
            } else {
                groupNames = []
            }
        } else {
            groupNames = nil
        }
        let instanceInitiatedShutdownBehaviorDecoded = try containerValues.decodeIfPresent(ShutdownBehavior.self, forKey: .instanceInitiatedShutdownBehavior)
        instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehaviorDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let monitoringDecoded = try containerValues.decode(Bool.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let placementDecoded = try containerValues.decodeIfPresent(Placement.self, forKey: .placement)
        placement = placementDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(UserData.self, forKey: .userData)
        userData = userDataDecoded
    }
}
