// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RequestLaunchTemplateData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "BlockDeviceMapping"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiTermination = "DisableApiTermination"
        case ebsOptimized = "EbsOptimized"
        case elasticGpuSpecifications = "ElasticGpuSpecification"
        case elasticInferenceAccelerators = "ElasticInferenceAccelerator"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior = "InstanceInitiatedShutdownBehavior"
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case licenseSpecifications = "LicenseSpecification"
        case metadataOptions = "MetadataOptions"
        case monitoring = "Monitoring"
        case networkInterfaces = "NetworkInterface"
        case placement = "Placement"
        case ramDiskId = "RamDiskId"
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case tagSpecifications = "TagSpecification"
        case userData = "UserData"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, launchtemplateblockdevicemappingrequest0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("BlockDeviceMapping.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(launchtemplateblockdevicemappingrequest0, forKey: Key(""))
                }
            }
        }
        if let capacityReservationSpecification = capacityReservationSpecification {
            try container.encode(capacityReservationSpecification, forKey: Key("CapacityReservationSpecification"))
        }
        if let cpuOptions = cpuOptions {
            try container.encode(cpuOptions, forKey: Key("CpuOptions"))
        }
        if let creditSpecification = creditSpecification {
            try container.encode(creditSpecification, forKey: Key("CreditSpecification"))
        }
        if disableApiTermination != false {
            try container.encode(disableApiTermination, forKey: Key("DisableApiTermination"))
        }
        if ebsOptimized != false {
            try container.encode(ebsOptimized, forKey: Key("EbsOptimized"))
        }
        if let elasticGpuSpecifications = elasticGpuSpecifications {
            if !elasticGpuSpecifications.isEmpty {
                for (index0, elasticgpuspecification0) in elasticGpuSpecifications.enumerated() {
                    var elasticGpuSpecificationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ElasticGpuSpecification.\(index0.advanced(by: 1))"))
                    try elasticGpuSpecificationsContainer0.encode(elasticgpuspecification0, forKey: Key(""))
                }
            }
        }
        if let elasticInferenceAccelerators = elasticInferenceAccelerators {
            if !elasticInferenceAccelerators.isEmpty {
                for (index0, launchtemplateelasticinferenceaccelerator0) in elasticInferenceAccelerators.enumerated() {
                    var elasticInferenceAcceleratorsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ElasticInferenceAccelerator.\(index0.advanced(by: 1))"))
                    try elasticInferenceAcceleratorsContainer0.encode(launchtemplateelasticinferenceaccelerator0, forKey: Key(""))
                }
            }
        }
        if let enclaveOptions = enclaveOptions {
            try container.encode(enclaveOptions, forKey: Key("EnclaveOptions"))
        }
        if let hibernationOptions = hibernationOptions {
            try container.encode(hibernationOptions, forKey: Key("HibernationOptions"))
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try container.encode(iamInstanceProfile, forKey: Key("IamInstanceProfile"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: Key("ImageId"))
        }
        if let instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior {
            try container.encode(instanceInitiatedShutdownBehavior, forKey: Key("InstanceInitiatedShutdownBehavior"))
        }
        if let instanceMarketOptions = instanceMarketOptions {
            try container.encode(instanceMarketOptions, forKey: Key("InstanceMarketOptions"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: Key("InstanceType"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: Key("KernelId"))
        }
        if let keyName = keyName {
            try container.encode(keyName, forKey: Key("KeyName"))
        }
        if let licenseSpecifications = licenseSpecifications {
            if !licenseSpecifications.isEmpty {
                for (index0, launchtemplatelicenseconfigurationrequest0) in licenseSpecifications.enumerated() {
                    var licenseSpecificationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("LicenseSpecification.\(index0.advanced(by: 1))"))
                    try licenseSpecificationsContainer0.encode(launchtemplatelicenseconfigurationrequest0, forKey: Key(""))
                }
            }
        }
        if let metadataOptions = metadataOptions {
            try container.encode(metadataOptions, forKey: Key("MetadataOptions"))
        }
        if let monitoring = monitoring {
            try container.encode(monitoring, forKey: Key("Monitoring"))
        }
        if let networkInterfaces = networkInterfaces {
            if !networkInterfaces.isEmpty {
                for (index0, launchtemplateinstancenetworkinterfacespecificationrequest0) in networkInterfaces.enumerated() {
                    var networkInterfacesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("NetworkInterface.\(index0.advanced(by: 1))"))
                    try networkInterfacesContainer0.encode(launchtemplateinstancenetworkinterfacespecificationrequest0, forKey: Key(""))
                }
            }
        }
        if let placement = placement {
            try container.encode(placement, forKey: Key("Placement"))
        }
        if let ramDiskId = ramDiskId {
            try container.encode(ramDiskId, forKey: Key("RamDiskId"))
        }
        if let securityGroupIds = securityGroupIds {
            if !securityGroupIds.isEmpty {
                for (index0, securitygroupid0) in securityGroupIds.enumerated() {
                    var securityGroupIdsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroupId.\(index0.advanced(by: 1))"))
                    try securityGroupIdsContainer0.encode(securitygroupid0, forKey: Key(""))
                }
            }
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                for (index0, securitygroupname0) in securityGroups.enumerated() {
                    var securityGroupsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroup.\(index0.advanced(by: 1))"))
                    try securityGroupsContainer0.encode(securitygroupname0, forKey: Key(""))
                }
            }
        }
        if let tagSpecifications = tagSpecifications {
            if !tagSpecifications.isEmpty {
                for (index0, launchtemplatetagspecificationrequest0) in tagSpecifications.enumerated() {
                    var tagSpecificationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSpecification.\(index0.advanced(by: 1))"))
                    try tagSpecificationsContainer0.encode(launchtemplatetagspecificationrequest0, forKey: Key(""))
                }
            }
        }
        if let userData = userData {
            try container.encode(userData, forKey: Key("UserData"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kernelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let ebsOptimizedDecoded = try containerValues.decode(Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(LaunchTemplateIamInstanceProfileSpecificationRequest.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct BlockDeviceMapping{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.BlockDeviceMapping>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([LaunchTemplateBlockDeviceMappingRequest].self, forKey: .member)
                var blockDeviceMappingsBuffer:[LaunchTemplateBlockDeviceMappingRequest]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [LaunchTemplateBlockDeviceMappingRequest]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct InstanceNetworkInterfaceSpecification{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InstanceNetworkInterfaceSpecification>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([LaunchTemplateInstanceNetworkInterfaceSpecificationRequest].self, forKey: .member)
                var networkInterfacesBuffer:[LaunchTemplateInstanceNetworkInterfaceSpecificationRequest]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [LaunchTemplateInstanceNetworkInterfaceSpecificationRequest]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let monitoringDecoded = try containerValues.decodeIfPresent(LaunchTemplatesMonitoringRequest.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let placementDecoded = try containerValues.decodeIfPresent(LaunchTemplatePlacementRequest.self, forKey: .placement)
        placement = placementDecoded
        let ramDiskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ramDiskId)
        ramDiskId = ramDiskIdDecoded
        let disableApiTerminationDecoded = try containerValues.decode(Bool.self, forKey: .disableApiTermination)
        disableApiTermination = disableApiTerminationDecoded
        let instanceInitiatedShutdownBehaviorDecoded = try containerValues.decodeIfPresent(ShutdownBehavior.self, forKey: .instanceInitiatedShutdownBehavior)
        instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehaviorDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userData)
        userData = userDataDecoded
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct LaunchTemplateTagSpecificationRequest{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LaunchTemplateTagSpecificationRequest>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([LaunchTemplateTagSpecificationRequest].self, forKey: .member)
                var tagSpecificationsBuffer:[LaunchTemplateTagSpecificationRequest]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [LaunchTemplateTagSpecificationRequest]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
        if containerValues.contains(.elasticGpuSpecifications) {
            struct KeyVal0{struct ElasticGpuSpecification{}}
            let elasticGpuSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ElasticGpuSpecification>.CodingKeys.self, forKey: .elasticGpuSpecifications)
            if let elasticGpuSpecificationsWrappedContainer = elasticGpuSpecificationsWrappedContainer {
                let elasticGpuSpecificationsContainer = try elasticGpuSpecificationsWrappedContainer.decodeIfPresent([ElasticGpuSpecification].self, forKey: .member)
                var elasticGpuSpecificationsBuffer:[ElasticGpuSpecification]? = nil
                if let elasticGpuSpecificationsContainer = elasticGpuSpecificationsContainer {
                    elasticGpuSpecificationsBuffer = [ElasticGpuSpecification]()
                    for structureContainer0 in elasticGpuSpecificationsContainer {
                        elasticGpuSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                elasticGpuSpecifications = elasticGpuSpecificationsBuffer
            } else {
                elasticGpuSpecifications = []
            }
        } else {
            elasticGpuSpecifications = nil
        }
        if containerValues.contains(.elasticInferenceAccelerators) {
            struct KeyVal0{struct item{}}
            let elasticInferenceAcceleratorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticInferenceAccelerators)
            if let elasticInferenceAcceleratorsWrappedContainer = elasticInferenceAcceleratorsWrappedContainer {
                let elasticInferenceAcceleratorsContainer = try elasticInferenceAcceleratorsWrappedContainer.decodeIfPresent([LaunchTemplateElasticInferenceAccelerator].self, forKey: .member)
                var elasticInferenceAcceleratorsBuffer:[LaunchTemplateElasticInferenceAccelerator]? = nil
                if let elasticInferenceAcceleratorsContainer = elasticInferenceAcceleratorsContainer {
                    elasticInferenceAcceleratorsBuffer = [LaunchTemplateElasticInferenceAccelerator]()
                    for structureContainer0 in elasticInferenceAcceleratorsContainer {
                        elasticInferenceAcceleratorsBuffer?.append(structureContainer0)
                    }
                }
                elasticInferenceAccelerators = elasticInferenceAcceleratorsBuffer
            } else {
                elasticInferenceAccelerators = []
            }
        } else {
            elasticInferenceAccelerators = nil
        }
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct SecurityGroupId{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var securityGroupIdsBuffer:[String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct SecurityGroup{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroup>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var securityGroupsBuffer:[String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let instanceMarketOptionsDecoded = try containerValues.decodeIfPresent(LaunchTemplateInstanceMarketOptionsRequest.self, forKey: .instanceMarketOptions)
        instanceMarketOptions = instanceMarketOptionsDecoded
        let creditSpecificationDecoded = try containerValues.decodeIfPresent(CreditSpecificationRequest.self, forKey: .creditSpecification)
        creditSpecification = creditSpecificationDecoded
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(LaunchTemplateCpuOptionsRequest.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let capacityReservationSpecificationDecoded = try containerValues.decodeIfPresent(LaunchTemplateCapacityReservationSpecificationRequest.self, forKey: .capacityReservationSpecification)
        capacityReservationSpecification = capacityReservationSpecificationDecoded
        if containerValues.contains(.licenseSpecifications) {
            struct KeyVal0{struct item{}}
            let licenseSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .licenseSpecifications)
            if let licenseSpecificationsWrappedContainer = licenseSpecificationsWrappedContainer {
                let licenseSpecificationsContainer = try licenseSpecificationsWrappedContainer.decodeIfPresent([LaunchTemplateLicenseConfigurationRequest].self, forKey: .member)
                var licenseSpecificationsBuffer:[LaunchTemplateLicenseConfigurationRequest]? = nil
                if let licenseSpecificationsContainer = licenseSpecificationsContainer {
                    licenseSpecificationsBuffer = [LaunchTemplateLicenseConfigurationRequest]()
                    for structureContainer0 in licenseSpecificationsContainer {
                        licenseSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                licenseSpecifications = licenseSpecificationsBuffer
            } else {
                licenseSpecifications = []
            }
        } else {
            licenseSpecifications = nil
        }
        let hibernationOptionsDecoded = try containerValues.decodeIfPresent(LaunchTemplateHibernationOptionsRequest.self, forKey: .hibernationOptions)
        hibernationOptions = hibernationOptionsDecoded
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(LaunchTemplateInstanceMetadataOptionsRequest.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(LaunchTemplateEnclaveOptionsRequest.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
    }
}
