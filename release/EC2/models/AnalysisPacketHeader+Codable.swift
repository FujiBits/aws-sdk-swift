// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AnalysisPacketHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationAddresses = "destinationAddressSet"
        case destinationPortRanges = "destinationPortRangeSet"
        case `protocol` = "protocol"
        case sourceAddresses = "sourceAddressSet"
        case sourcePortRanges = "sourcePortRangeSet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let destinationAddresses = destinationAddresses {
            if !destinationAddresses.isEmpty {
                for (index0, ipaddress0) in destinationAddresses.enumerated() {
                    var destinationAddressesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("DestinationAddressSet.\(index0.advanced(by: 1))"))
                    try destinationAddressesContainer0.encode(ipaddress0, forKey: Key(""))
                }
            }
        }
        if let destinationPortRanges = destinationPortRanges {
            if !destinationPortRanges.isEmpty {
                for (index0, portrange0) in destinationPortRanges.enumerated() {
                    var destinationPortRangesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("DestinationPortRangeSet.\(index0.advanced(by: 1))"))
                    try destinationPortRangesContainer0.encode(portrange0, forKey: Key(""))
                }
            }
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let sourceAddresses = sourceAddresses {
            if !sourceAddresses.isEmpty {
                for (index0, ipaddress0) in sourceAddresses.enumerated() {
                    var sourceAddressesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourceAddressSet.\(index0.advanced(by: 1))"))
                    try sourceAddressesContainer0.encode(ipaddress0, forKey: Key(""))
                }
            }
        }
        if let sourcePortRanges = sourcePortRanges {
            if !sourcePortRanges.isEmpty {
                for (index0, portrange0) in sourcePortRanges.enumerated() {
                    var sourcePortRangesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SourcePortRangeSet.\(index0.advanced(by: 1))"))
                    try sourcePortRangesContainer0.encode(portrange0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.destinationAddresses) {
            struct KeyVal0{struct item{}}
            let destinationAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .destinationAddresses)
            if let destinationAddressesWrappedContainer = destinationAddressesWrappedContainer {
                let destinationAddressesContainer = try destinationAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var destinationAddressesBuffer:[String]? = nil
                if let destinationAddressesContainer = destinationAddressesContainer {
                    destinationAddressesBuffer = [String]()
                    for stringContainer0 in destinationAddressesContainer {
                        destinationAddressesBuffer?.append(stringContainer0)
                    }
                }
                destinationAddresses = destinationAddressesBuffer
            } else {
                destinationAddresses = []
            }
        } else {
            destinationAddresses = nil
        }
        if containerValues.contains(.destinationPortRanges) {
            struct KeyVal0{struct item{}}
            let destinationPortRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .destinationPortRanges)
            if let destinationPortRangesWrappedContainer = destinationPortRangesWrappedContainer {
                let destinationPortRangesContainer = try destinationPortRangesWrappedContainer.decodeIfPresent([PortRange].self, forKey: .member)
                var destinationPortRangesBuffer:[PortRange]? = nil
                if let destinationPortRangesContainer = destinationPortRangesContainer {
                    destinationPortRangesBuffer = [PortRange]()
                    for structureContainer0 in destinationPortRangesContainer {
                        destinationPortRangesBuffer?.append(structureContainer0)
                    }
                }
                destinationPortRanges = destinationPortRangesBuffer
            } else {
                destinationPortRanges = []
            }
        } else {
            destinationPortRanges = nil
        }
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        if containerValues.contains(.sourceAddresses) {
            struct KeyVal0{struct item{}}
            let sourceAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .sourceAddresses)
            if let sourceAddressesWrappedContainer = sourceAddressesWrappedContainer {
                let sourceAddressesContainer = try sourceAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sourceAddressesBuffer:[String]? = nil
                if let sourceAddressesContainer = sourceAddressesContainer {
                    sourceAddressesBuffer = [String]()
                    for stringContainer0 in sourceAddressesContainer {
                        sourceAddressesBuffer?.append(stringContainer0)
                    }
                }
                sourceAddresses = sourceAddressesBuffer
            } else {
                sourceAddresses = []
            }
        } else {
            sourceAddresses = nil
        }
        if containerValues.contains(.sourcePortRanges) {
            struct KeyVal0{struct item{}}
            let sourcePortRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .sourcePortRanges)
            if let sourcePortRangesWrappedContainer = sourcePortRangesWrappedContainer {
                let sourcePortRangesContainer = try sourcePortRangesWrappedContainer.decodeIfPresent([PortRange].self, forKey: .member)
                var sourcePortRangesBuffer:[PortRange]? = nil
                if let sourcePortRangesContainer = sourcePortRangesContainer {
                    sourcePortRangesBuffer = [PortRange]()
                    for structureContainer0 in sourcePortRangesContainer {
                        sourcePortRangesBuffer?.append(structureContainer0)
                    }
                }
                sourcePortRanges = sourcePortRangesBuffer
            } else {
                sourcePortRanges = []
            }
        } else {
            sourcePortRanges = nil
        }
    }
}
