// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension VpnConnectionOptionsSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enableAcceleration = "EnableAcceleration"
        case localIpv4NetworkCidr = "LocalIpv4NetworkCidr"
        case localIpv6NetworkCidr = "LocalIpv6NetworkCidr"
        case remoteIpv4NetworkCidr = "RemoteIpv4NetworkCidr"
        case remoteIpv6NetworkCidr = "RemoteIpv6NetworkCidr"
        case staticRoutesOnly = "staticRoutesOnly"
        case tunnelInsideIpVersion = "TunnelInsideIpVersion"
        case tunnelOptions = "TunnelOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if enableAcceleration != false {
            try container.encode(enableAcceleration, forKey: Key("EnableAcceleration"))
        }
        if let localIpv4NetworkCidr = localIpv4NetworkCidr {
            try container.encode(localIpv4NetworkCidr, forKey: Key("LocalIpv4NetworkCidr"))
        }
        if let localIpv6NetworkCidr = localIpv6NetworkCidr {
            try container.encode(localIpv6NetworkCidr, forKey: Key("LocalIpv6NetworkCidr"))
        }
        if let remoteIpv4NetworkCidr = remoteIpv4NetworkCidr {
            try container.encode(remoteIpv4NetworkCidr, forKey: Key("RemoteIpv4NetworkCidr"))
        }
        if let remoteIpv6NetworkCidr = remoteIpv6NetworkCidr {
            try container.encode(remoteIpv6NetworkCidr, forKey: Key("RemoteIpv6NetworkCidr"))
        }
        if staticRoutesOnly != false {
            try container.encode(staticRoutesOnly, forKey: Key("StaticRoutesOnly"))
        }
        if let tunnelInsideIpVersion = tunnelInsideIpVersion {
            try container.encode(tunnelInsideIpVersion, forKey: Key("TunnelInsideIpVersion"))
        }
        if let tunnelOptions = tunnelOptions {
            if !tunnelOptions.isEmpty {
                for (index0, vpntunneloptionsspecification0) in tunnelOptions.enumerated() {
                    var tunnelOptionsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TunnelOptions.\(index0.advanced(by: 1))"))
                    try tunnelOptionsContainer0.encode(vpntunneloptionsspecification0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAccelerationDecoded = try containerValues.decode(Bool.self, forKey: .enableAcceleration)
        enableAcceleration = enableAccelerationDecoded
        let staticRoutesOnlyDecoded = try containerValues.decode(Bool.self, forKey: .staticRoutesOnly)
        staticRoutesOnly = staticRoutesOnlyDecoded
        let tunnelInsideIpVersionDecoded = try containerValues.decodeIfPresent(TunnelInsideIpVersion.self, forKey: .tunnelInsideIpVersion)
        tunnelInsideIpVersion = tunnelInsideIpVersionDecoded
        if containerValues.contains(.tunnelOptions) {
            struct KeyVal0{struct member{}}
            let tunnelOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tunnelOptions)
            if let tunnelOptionsWrappedContainer = tunnelOptionsWrappedContainer {
                let tunnelOptionsContainer = try tunnelOptionsWrappedContainer.decodeIfPresent([VpnTunnelOptionsSpecification].self, forKey: .member)
                var tunnelOptionsBuffer:[VpnTunnelOptionsSpecification]? = nil
                if let tunnelOptionsContainer = tunnelOptionsContainer {
                    tunnelOptionsBuffer = [VpnTunnelOptionsSpecification]()
                    for structureContainer0 in tunnelOptionsContainer {
                        tunnelOptionsBuffer?.append(structureContainer0)
                    }
                }
                tunnelOptions = tunnelOptionsBuffer
            } else {
                tunnelOptions = []
            }
        } else {
            tunnelOptions = nil
        }
        let localIpv4NetworkCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localIpv4NetworkCidr)
        localIpv4NetworkCidr = localIpv4NetworkCidrDecoded
        let remoteIpv4NetworkCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteIpv4NetworkCidr)
        remoteIpv4NetworkCidr = remoteIpv4NetworkCidrDecoded
        let localIpv6NetworkCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localIpv6NetworkCidr)
        localIpv6NetworkCidr = localIpv6NetworkCidrDecoded
        let remoteIpv6NetworkCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteIpv6NetworkCidr)
        remoteIpv6NetworkCidr = remoteIpv6NetworkCidrDecoded
    }
}
