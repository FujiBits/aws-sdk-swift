// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Explanation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acl = "acl"
        case aclRule = "aclRule"
        case address = "address"
        case addresses = "addressSet"
        case attachedTo = "attachedTo"
        case availabilityZones = "availabilityZoneSet"
        case cidrs = "cidrSet"
        case classicLoadBalancerListener = "classicLoadBalancerListener"
        case component = "component"
        case customerGateway = "customerGateway"
        case destination = "destination"
        case destinationVpc = "destinationVpc"
        case direction = "direction"
        case elasticLoadBalancerListener = "elasticLoadBalancerListener"
        case explanationCode = "explanationCode"
        case ingressRouteTable = "ingressRouteTable"
        case internetGateway = "internetGateway"
        case loadBalancerArn = "loadBalancerArn"
        case loadBalancerListenerPort = "loadBalancerListenerPort"
        case loadBalancerTarget = "loadBalancerTarget"
        case loadBalancerTargetGroup = "loadBalancerTargetGroup"
        case loadBalancerTargetGroups = "loadBalancerTargetGroupSet"
        case loadBalancerTargetPort = "loadBalancerTargetPort"
        case missingComponent = "missingComponent"
        case natGateway = "natGateway"
        case networkInterface = "networkInterface"
        case packetField = "packetField"
        case port = "port"
        case portRanges = "portRangeSet"
        case prefixList = "prefixList"
        case protocols = "protocolSet"
        case routeTable = "routeTable"
        case routeTableRoute = "routeTableRoute"
        case securityGroup = "securityGroup"
        case securityGroupRule = "securityGroupRule"
        case securityGroups = "securityGroupSet"
        case sourceVpc = "sourceVpc"
        case state = "state"
        case subnet = "subnet"
        case subnetRouteTable = "subnetRouteTable"
        case vpc = "vpc"
        case vpcEndpoint = "vpcEndpoint"
        case vpcPeeringConnection = "vpcPeeringConnection"
        case vpnConnection = "vpnConnection"
        case vpnGateway = "vpnGateway"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let acl = acl {
            try container.encode(acl, forKey: Key("Acl"))
        }
        if let aclRule = aclRule {
            try container.encode(aclRule, forKey: Key("AclRule"))
        }
        if let address = address {
            try container.encode(address, forKey: Key("Address"))
        }
        if let addresses = addresses {
            if !addresses.isEmpty {
                for (index0, ipaddress0) in addresses.enumerated() {
                    var addressesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AddressSet.\(index0.advanced(by: 1))"))
                    try addressesContainer0.encode(ipaddress0, forKey: Key(""))
                }
            }
        }
        if let attachedTo = attachedTo {
            try container.encode(attachedTo, forKey: Key("AttachedTo"))
        }
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                for (index0, string0) in availabilityZones.enumerated() {
                    var availabilityZonesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZoneSet.\(index0.advanced(by: 1))"))
                    try availabilityZonesContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let cidrs = cidrs {
            if !cidrs.isEmpty {
                for (index0, string0) in cidrs.enumerated() {
                    var cidrsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("CidrSet.\(index0.advanced(by: 1))"))
                    try cidrsContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let classicLoadBalancerListener = classicLoadBalancerListener {
            try container.encode(classicLoadBalancerListener, forKey: Key("ClassicLoadBalancerListener"))
        }
        if let component = component {
            try container.encode(component, forKey: Key("Component"))
        }
        if let customerGateway = customerGateway {
            try container.encode(customerGateway, forKey: Key("CustomerGateway"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: Key("Destination"))
        }
        if let destinationVpc = destinationVpc {
            try container.encode(destinationVpc, forKey: Key("DestinationVpc"))
        }
        if let direction = direction {
            try container.encode(direction, forKey: Key("Direction"))
        }
        if let elasticLoadBalancerListener = elasticLoadBalancerListener {
            try container.encode(elasticLoadBalancerListener, forKey: Key("ElasticLoadBalancerListener"))
        }
        if let explanationCode = explanationCode {
            try container.encode(explanationCode, forKey: Key("ExplanationCode"))
        }
        if let ingressRouteTable = ingressRouteTable {
            try container.encode(ingressRouteTable, forKey: Key("IngressRouteTable"))
        }
        if let internetGateway = internetGateway {
            try container.encode(internetGateway, forKey: Key("InternetGateway"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if loadBalancerListenerPort != 0 {
            try container.encode(loadBalancerListenerPort, forKey: Key("LoadBalancerListenerPort"))
        }
        if let loadBalancerTarget = loadBalancerTarget {
            try container.encode(loadBalancerTarget, forKey: Key("LoadBalancerTarget"))
        }
        if let loadBalancerTargetGroup = loadBalancerTargetGroup {
            try container.encode(loadBalancerTargetGroup, forKey: Key("LoadBalancerTargetGroup"))
        }
        if let loadBalancerTargetGroups = loadBalancerTargetGroups {
            if !loadBalancerTargetGroups.isEmpty {
                for (index0, analysiscomponent0) in loadBalancerTargetGroups.enumerated() {
                    var loadBalancerTargetGroupsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerTargetGroupSet.\(index0.advanced(by: 1))"))
                    try loadBalancerTargetGroupsContainer0.encode(analysiscomponent0, forKey: Key(""))
                }
            }
        }
        if loadBalancerTargetPort != 0 {
            try container.encode(loadBalancerTargetPort, forKey: Key("LoadBalancerTargetPort"))
        }
        if let missingComponent = missingComponent {
            try container.encode(missingComponent, forKey: Key("MissingComponent"))
        }
        if let natGateway = natGateway {
            try container.encode(natGateway, forKey: Key("NatGateway"))
        }
        if let networkInterface = networkInterface {
            try container.encode(networkInterface, forKey: Key("NetworkInterface"))
        }
        if let packetField = packetField {
            try container.encode(packetField, forKey: Key("PacketField"))
        }
        if port != 0 {
            try container.encode(port, forKey: Key("Port"))
        }
        if let portRanges = portRanges {
            if !portRanges.isEmpty {
                for (index0, portrange0) in portRanges.enumerated() {
                    var portRangesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("PortRangeSet.\(index0.advanced(by: 1))"))
                    try portRangesContainer0.encode(portrange0, forKey: Key(""))
                }
            }
        }
        if let prefixList = prefixList {
            try container.encode(prefixList, forKey: Key("PrefixList"))
        }
        if let protocols = protocols {
            if !protocols.isEmpty {
                for (index0, string0) in protocols.enumerated() {
                    var protocolsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProtocolSet.\(index0.advanced(by: 1))"))
                    try protocolsContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let routeTable = routeTable {
            try container.encode(routeTable, forKey: Key("RouteTable"))
        }
        if let routeTableRoute = routeTableRoute {
            try container.encode(routeTableRoute, forKey: Key("RouteTableRoute"))
        }
        if let securityGroup = securityGroup {
            try container.encode(securityGroup, forKey: Key("SecurityGroup"))
        }
        if let securityGroupRule = securityGroupRule {
            try container.encode(securityGroupRule, forKey: Key("SecurityGroupRule"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                for (index0, analysiscomponent0) in securityGroups.enumerated() {
                    var securityGroupsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroupSet.\(index0.advanced(by: 1))"))
                    try securityGroupsContainer0.encode(analysiscomponent0, forKey: Key(""))
                }
            }
        }
        if let sourceVpc = sourceVpc {
            try container.encode(sourceVpc, forKey: Key("SourceVpc"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let subnet = subnet {
            try container.encode(subnet, forKey: Key("Subnet"))
        }
        if let subnetRouteTable = subnetRouteTable {
            try container.encode(subnetRouteTable, forKey: Key("SubnetRouteTable"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: Key("Vpc"))
        }
        if let vpcEndpoint = vpcEndpoint {
            try container.encode(vpcEndpoint, forKey: Key("VpcEndpoint"))
        }
        if let vpcPeeringConnection = vpcPeeringConnection {
            try container.encode(vpcPeeringConnection, forKey: Key("VpcPeeringConnection"))
        }
        if let vpnConnection = vpnConnection {
            try container.encode(vpnConnection, forKey: Key("VpnConnection"))
        }
        if let vpnGateway = vpnGateway {
            try container.encode(vpnGateway, forKey: Key("VpnGateway"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aclDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .acl)
        acl = aclDecoded
        let aclRuleDecoded = try containerValues.decodeIfPresent(AnalysisAclRule.self, forKey: .aclRule)
        aclRule = aclRuleDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        if containerValues.contains(.addresses) {
            struct KeyVal0{struct item{}}
            let addressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .addresses)
            if let addressesWrappedContainer = addressesWrappedContainer {
                let addressesContainer = try addressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var addressesBuffer:[String]? = nil
                if let addressesContainer = addressesContainer {
                    addressesBuffer = [String]()
                    for stringContainer0 in addressesContainer {
                        addressesBuffer?.append(stringContainer0)
                    }
                }
                addresses = addressesBuffer
            } else {
                addresses = []
            }
        } else {
            addresses = nil
        }
        let attachedToDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .attachedTo)
        attachedTo = attachedToDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct item{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.cidrs) {
            struct KeyVal0{struct item{}}
            let cidrsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .cidrs)
            if let cidrsWrappedContainer = cidrsWrappedContainer {
                let cidrsContainer = try cidrsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var cidrsBuffer:[String]? = nil
                if let cidrsContainer = cidrsContainer {
                    cidrsBuffer = [String]()
                    for stringContainer0 in cidrsContainer {
                        cidrsBuffer?.append(stringContainer0)
                    }
                }
                cidrs = cidrsBuffer
            } else {
                cidrs = []
            }
        } else {
            cidrs = nil
        }
        let componentDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .component)
        component = componentDecoded
        let customerGatewayDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .customerGateway)
        customerGateway = customerGatewayDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .destination)
        destination = destinationDecoded
        let destinationVpcDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .destinationVpc)
        destinationVpc = destinationVpcDecoded
        let directionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .direction)
        direction = directionDecoded
        let explanationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .explanationCode)
        explanationCode = explanationCodeDecoded
        let ingressRouteTableDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .ingressRouteTable)
        ingressRouteTable = ingressRouteTableDecoded
        let internetGatewayDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .internetGateway)
        internetGateway = internetGatewayDecoded
        let loadBalancerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerArn)
        loadBalancerArn = loadBalancerArnDecoded
        let classicLoadBalancerListenerDecoded = try containerValues.decodeIfPresent(AnalysisLoadBalancerListener.self, forKey: .classicLoadBalancerListener)
        classicLoadBalancerListener = classicLoadBalancerListenerDecoded
        let loadBalancerListenerPortDecoded = try containerValues.decode(Int.self, forKey: .loadBalancerListenerPort)
        loadBalancerListenerPort = loadBalancerListenerPortDecoded
        let loadBalancerTargetDecoded = try containerValues.decodeIfPresent(AnalysisLoadBalancerTarget.self, forKey: .loadBalancerTarget)
        loadBalancerTarget = loadBalancerTargetDecoded
        let loadBalancerTargetGroupDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .loadBalancerTargetGroup)
        loadBalancerTargetGroup = loadBalancerTargetGroupDecoded
        if containerValues.contains(.loadBalancerTargetGroups) {
            struct KeyVal0{struct item{}}
            let loadBalancerTargetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .loadBalancerTargetGroups)
            if let loadBalancerTargetGroupsWrappedContainer = loadBalancerTargetGroupsWrappedContainer {
                let loadBalancerTargetGroupsContainer = try loadBalancerTargetGroupsWrappedContainer.decodeIfPresent([AnalysisComponent].self, forKey: .member)
                var loadBalancerTargetGroupsBuffer:[AnalysisComponent]? = nil
                if let loadBalancerTargetGroupsContainer = loadBalancerTargetGroupsContainer {
                    loadBalancerTargetGroupsBuffer = [AnalysisComponent]()
                    for structureContainer0 in loadBalancerTargetGroupsContainer {
                        loadBalancerTargetGroupsBuffer?.append(structureContainer0)
                    }
                }
                loadBalancerTargetGroups = loadBalancerTargetGroupsBuffer
            } else {
                loadBalancerTargetGroups = []
            }
        } else {
            loadBalancerTargetGroups = nil
        }
        let loadBalancerTargetPortDecoded = try containerValues.decode(Int.self, forKey: .loadBalancerTargetPort)
        loadBalancerTargetPort = loadBalancerTargetPortDecoded
        let elasticLoadBalancerListenerDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .elasticLoadBalancerListener)
        elasticLoadBalancerListener = elasticLoadBalancerListenerDecoded
        let missingComponentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missingComponent)
        missingComponent = missingComponentDecoded
        let natGatewayDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .natGateway)
        natGateway = natGatewayDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let packetFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packetField)
        packetField = packetFieldDecoded
        let vpcPeeringConnectionDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .vpcPeeringConnection)
        vpcPeeringConnection = vpcPeeringConnectionDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        if containerValues.contains(.portRanges) {
            struct KeyVal0{struct item{}}
            let portRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .portRanges)
            if let portRangesWrappedContainer = portRangesWrappedContainer {
                let portRangesContainer = try portRangesWrappedContainer.decodeIfPresent([PortRange].self, forKey: .member)
                var portRangesBuffer:[PortRange]? = nil
                if let portRangesContainer = portRangesContainer {
                    portRangesBuffer = [PortRange]()
                    for structureContainer0 in portRangesContainer {
                        portRangesBuffer?.append(structureContainer0)
                    }
                }
                portRanges = portRangesBuffer
            } else {
                portRanges = []
            }
        } else {
            portRanges = nil
        }
        let prefixListDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .prefixList)
        prefixList = prefixListDecoded
        if containerValues.contains(.protocols) {
            struct KeyVal0{struct item{}}
            let protocolsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .protocols)
            if let protocolsWrappedContainer = protocolsWrappedContainer {
                let protocolsContainer = try protocolsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var protocolsBuffer:[String]? = nil
                if let protocolsContainer = protocolsContainer {
                    protocolsBuffer = [String]()
                    for stringContainer0 in protocolsContainer {
                        protocolsBuffer?.append(stringContainer0)
                    }
                }
                protocols = protocolsBuffer
            } else {
                protocols = []
            }
        } else {
            protocols = nil
        }
        let routeTableRouteDecoded = try containerValues.decodeIfPresent(AnalysisRouteTableRoute.self, forKey: .routeTableRoute)
        routeTableRoute = routeTableRouteDecoded
        let routeTableDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .routeTable)
        routeTable = routeTableDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let securityGroupRuleDecoded = try containerValues.decodeIfPresent(AnalysisSecurityGroupRule.self, forKey: .securityGroupRule)
        securityGroupRule = securityGroupRuleDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct item{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([AnalysisComponent].self, forKey: .member)
                var securityGroupsBuffer:[AnalysisComponent]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [AnalysisComponent]()
                    for structureContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(structureContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let sourceVpcDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .sourceVpc)
        sourceVpc = sourceVpcDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let subnetDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .subnet)
        subnet = subnetDecoded
        let subnetRouteTableDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .subnetRouteTable)
        subnetRouteTable = subnetRouteTableDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .vpc)
        vpc = vpcDecoded
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
        let vpnConnectionDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .vpnConnection)
        vpnConnection = vpnConnectionDecoded
        let vpnGatewayDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .vpnGateway)
        vpnGateway = vpnGatewayDecoded
    }
}
