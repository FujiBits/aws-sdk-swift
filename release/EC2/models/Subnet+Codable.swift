// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Subnet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignIpv6AddressOnCreation = "assignIpv6AddressOnCreation"
        case availabilityZone = "availabilityZone"
        case availabilityZoneId = "availabilityZoneId"
        case availableIpAddressCount = "availableIpAddressCount"
        case cidrBlock = "cidrBlock"
        case customerOwnedIpv4Pool = "customerOwnedIpv4Pool"
        case defaultForAz = "defaultForAz"
        case ipv6CidrBlockAssociationSet = "ipv6CidrBlockAssociationSet"
        case mapCustomerOwnedIpOnLaunch = "mapCustomerOwnedIpOnLaunch"
        case mapPublicIpOnLaunch = "mapPublicIpOnLaunch"
        case outpostArn = "outpostArn"
        case ownerId = "ownerId"
        case state = "state"
        case subnetArn = "subnetArn"
        case subnetId = "subnetId"
        case tags = "tagSet"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if assignIpv6AddressOnCreation != false {
            try container.encode(assignIpv6AddressOnCreation, forKey: Key("AssignIpv6AddressOnCreation"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let availabilityZoneId = availabilityZoneId {
            try container.encode(availabilityZoneId, forKey: Key("AvailabilityZoneId"))
        }
        if availableIpAddressCount != 0 {
            try container.encode(availableIpAddressCount, forKey: Key("AvailableIpAddressCount"))
        }
        if let cidrBlock = cidrBlock {
            try container.encode(cidrBlock, forKey: Key("CidrBlock"))
        }
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try container.encode(customerOwnedIpv4Pool, forKey: Key("CustomerOwnedIpv4Pool"))
        }
        if defaultForAz != false {
            try container.encode(defaultForAz, forKey: Key("DefaultForAz"))
        }
        if let ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet {
            if !ipv6CidrBlockAssociationSet.isEmpty {
                for (index0, subnetipv6cidrblockassociation0) in ipv6CidrBlockAssociationSet.enumerated() {
                    var ipv6CidrBlockAssociationSetContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Ipv6CidrBlockAssociationSet.\(index0.advanced(by: 1))"))
                    try ipv6CidrBlockAssociationSetContainer0.encode(subnetipv6cidrblockassociation0, forKey: Key(""))
                }
            }
        }
        if mapCustomerOwnedIpOnLaunch != false {
            try container.encode(mapCustomerOwnedIpOnLaunch, forKey: Key("MapCustomerOwnedIpOnLaunch"))
        }
        if mapPublicIpOnLaunch != false {
            try container.encode(mapPublicIpOnLaunch, forKey: Key("MapPublicIpOnLaunch"))
        }
        if let outpostArn = outpostArn {
            try container.encode(outpostArn, forKey: Key("OutpostArn"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: Key("OwnerId"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let subnetArn = subnetArn {
            try container.encode(subnetArn, forKey: Key("SubnetArn"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availableIpAddressCountDecoded = try containerValues.decode(Int.self, forKey: .availableIpAddressCount)
        availableIpAddressCount = availableIpAddressCountDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let defaultForAzDecoded = try containerValues.decode(Bool.self, forKey: .defaultForAz)
        defaultForAz = defaultForAzDecoded
        let mapPublicIpOnLaunchDecoded = try containerValues.decode(Bool.self, forKey: .mapPublicIpOnLaunch)
        mapPublicIpOnLaunch = mapPublicIpOnLaunchDecoded
        let mapCustomerOwnedIpOnLaunchDecoded = try containerValues.decode(Bool.self, forKey: .mapCustomerOwnedIpOnLaunch)
        mapCustomerOwnedIpOnLaunch = mapCustomerOwnedIpOnLaunchDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SubnetState.self, forKey: .state)
        state = stateDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let assignIpv6AddressOnCreationDecoded = try containerValues.decode(Bool.self, forKey: .assignIpv6AddressOnCreation)
        assignIpv6AddressOnCreation = assignIpv6AddressOnCreationDecoded
        if containerValues.contains(.ipv6CidrBlockAssociationSet) {
            struct KeyVal0{struct item{}}
            let ipv6CidrBlockAssociationSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6CidrBlockAssociationSet)
            if let ipv6CidrBlockAssociationSetWrappedContainer = ipv6CidrBlockAssociationSetWrappedContainer {
                let ipv6CidrBlockAssociationSetContainer = try ipv6CidrBlockAssociationSetWrappedContainer.decodeIfPresent([SubnetIpv6CidrBlockAssociation].self, forKey: .member)
                var ipv6CidrBlockAssociationSetBuffer:[SubnetIpv6CidrBlockAssociation]? = nil
                if let ipv6CidrBlockAssociationSetContainer = ipv6CidrBlockAssociationSetContainer {
                    ipv6CidrBlockAssociationSetBuffer = [SubnetIpv6CidrBlockAssociation]()
                    for structureContainer0 in ipv6CidrBlockAssociationSetContainer {
                        ipv6CidrBlockAssociationSetBuffer?.append(structureContainer0)
                    }
                }
                ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSetBuffer
            } else {
                ipv6CidrBlockAssociationSet = []
            }
        } else {
            ipv6CidrBlockAssociationSet = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let subnetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
    }
}
