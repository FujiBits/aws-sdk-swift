// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Image: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case architecture = "architecture"
        case blockDeviceMappings = "blockDeviceMapping"
        case bootMode = "bootMode"
        case creationDate = "creationDate"
        case description = "description"
        case enaSupport = "enaSupport"
        case hypervisor = "hypervisor"
        case imageId = "imageId"
        case imageLocation = "imageLocation"
        case imageOwnerAlias = "imageOwnerAlias"
        case imageType = "imageType"
        case kernelId = "kernelId"
        case name = "name"
        case ownerId = "imageOwnerId"
        case platform = "platform"
        case platformDetails = "platformDetails"
        case productCodes = "productCodes"
        case `public` = "isPublic"
        case ramdiskId = "ramdiskId"
        case rootDeviceName = "rootDeviceName"
        case rootDeviceType = "rootDeviceType"
        case sriovNetSupport = "sriovNetSupport"
        case state = "imageState"
        case stateReason = "stateReason"
        case tags = "tagSet"
        case usageOperation = "usageOperation"
        case virtualizationType = "virtualizationType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let architecture = architecture {
            try container.encode(architecture, forKey: Key("Architecture"))
        }
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, blockdevicemapping0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("BlockDeviceMapping.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(blockdevicemapping0, forKey: Key(""))
                }
            }
        }
        if let bootMode = bootMode {
            try container.encode(bootMode, forKey: Key("BootMode"))
        }
        if let creationDate = creationDate {
            try container.encode(creationDate, forKey: Key("CreationDate"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if enaSupport != false {
            try container.encode(enaSupport, forKey: Key("EnaSupport"))
        }
        if let hypervisor = hypervisor {
            try container.encode(hypervisor, forKey: Key("Hypervisor"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: Key("ImageId"))
        }
        if let imageLocation = imageLocation {
            try container.encode(imageLocation, forKey: Key("ImageLocation"))
        }
        if let imageOwnerAlias = imageOwnerAlias {
            try container.encode(imageOwnerAlias, forKey: Key("ImageOwnerAlias"))
        }
        if let imageType = imageType {
            try container.encode(imageType, forKey: Key("ImageType"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: Key("KernelId"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: Key("ImageOwnerId"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: Key("Platform"))
        }
        if let platformDetails = platformDetails {
            try container.encode(platformDetails, forKey: Key("PlatformDetails"))
        }
        if let productCodes = productCodes {
            if !productCodes.isEmpty {
                for (index0, productcode0) in productCodes.enumerated() {
                    var productCodesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProductCodes.\(index0.advanced(by: 1))"))
                    try productCodesContainer0.encode(productcode0, forKey: Key(""))
                }
            }
        }
        if `public` != false {
            try container.encode(`public`, forKey: Key("IsPublic"))
        }
        if let ramdiskId = ramdiskId {
            try container.encode(ramdiskId, forKey: Key("RamdiskId"))
        }
        if let rootDeviceName = rootDeviceName {
            try container.encode(rootDeviceName, forKey: Key("RootDeviceName"))
        }
        if let rootDeviceType = rootDeviceType {
            try container.encode(rootDeviceType, forKey: Key("RootDeviceType"))
        }
        if let sriovNetSupport = sriovNetSupport {
            try container.encode(sriovNetSupport, forKey: Key("SriovNetSupport"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("ImageState"))
        }
        if let stateReason = stateReason {
            try container.encode(stateReason, forKey: Key("StateReason"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
        if let usageOperation = usageOperation {
            try container.encode(usageOperation, forKey: Key("UsageOperation"))
        }
        if let virtualizationType = virtualizationType {
            try container.encode(virtualizationType, forKey: Key("VirtualizationType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let architectureDecoded = try containerValues.decodeIfPresent(ArchitectureValues.self, forKey: .architecture)
        architecture = architectureDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageLocation)
        imageLocation = imageLocationDecoded
        let imageTypeDecoded = try containerValues.decodeIfPresent(ImageTypeValues.self, forKey: .imageType)
        imageType = imageTypeDecoded
        let publicDecoded = try containerValues.decode(Bool.self, forKey: .public)
        `public` = publicDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let platformDecoded = try containerValues.decodeIfPresent(PlatformValues.self, forKey: .platform)
        platform = platformDecoded
        let platformDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformDetails)
        platformDetails = platformDetailsDecoded
        let usageOperationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageOperation)
        usageOperation = usageOperationDecoded
        if containerValues.contains(.productCodes) {
            struct KeyVal0{struct item{}}
            let productCodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .productCodes)
            if let productCodesWrappedContainer = productCodesWrappedContainer {
                let productCodesContainer = try productCodesWrappedContainer.decodeIfPresent([ProductCode].self, forKey: .member)
                var productCodesBuffer:[ProductCode]? = nil
                if let productCodesContainer = productCodesContainer {
                    productCodesBuffer = [ProductCode]()
                    for structureContainer0 in productCodesContainer {
                        productCodesBuffer?.append(structureContainer0)
                    }
                }
                productCodes = productCodesBuffer
            } else {
                productCodes = []
            }
        } else {
            productCodes = nil
        }
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImageState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct item{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([BlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[BlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [BlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enaSupportDecoded = try containerValues.decode(Bool.self, forKey: .enaSupport)
        enaSupport = enaSupportDecoded
        let hypervisorDecoded = try containerValues.decodeIfPresent(HypervisorType.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
        let imageOwnerAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageOwnerAlias)
        imageOwnerAlias = imageOwnerAliasDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let rootDeviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootDeviceName)
        rootDeviceName = rootDeviceNameDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(DeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let sriovNetSupportDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sriovNetSupport)
        sriovNetSupport = sriovNetSupportDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(StateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(VirtualizationType.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(BootModeValues.self, forKey: .bootMode)
        bootMode = bootModeDecoded
    }
}
