// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ScheduledInstancesNetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case deleteOnTermination = "DeleteOnTermination"
        case description = "Description"
        case deviceIndex = "DeviceIndex"
        case groups = "Group"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Address"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case privateIpAddressConfigs = "PrivateIpAddressConfig"
        case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if associatePublicIpAddress != false {
            try container.encode(associatePublicIpAddress, forKey: Key("AssociatePublicIpAddress"))
        }
        if deleteOnTermination != false {
            try container.encode(deleteOnTermination, forKey: Key("DeleteOnTermination"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if deviceIndex != 0 {
            try container.encode(deviceIndex, forKey: Key("DeviceIndex"))
        }
        if let groups = groups {
            if !groups.isEmpty {
                for (index0, securitygroupid0) in groups.enumerated() {
                    var groupsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Group.\(index0.advanced(by: 1))"))
                    try groupsContainer0.encode(securitygroupid0, forKey: Key(""))
                }
            }
        }
        if ipv6AddressCount != 0 {
            try container.encode(ipv6AddressCount, forKey: Key("Ipv6AddressCount"))
        }
        if let ipv6Addresses = ipv6Addresses {
            if !ipv6Addresses.isEmpty {
                for (index0, scheduledinstancesipv6address0) in ipv6Addresses.enumerated() {
                    var ipv6AddressesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Ipv6Address.\(index0.advanced(by: 1))"))
                    try ipv6AddressesContainer0.encode(scheduledinstancesipv6address0, forKey: Key(""))
                }
            }
        }
        if let networkInterfaceId = networkInterfaceId {
            try container.encode(networkInterfaceId, forKey: Key("NetworkInterfaceId"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: Key("PrivateIpAddress"))
        }
        if let privateIpAddressConfigs = privateIpAddressConfigs {
            if !privateIpAddressConfigs.isEmpty {
                for (index0, scheduledinstancesprivateipaddressconfig0) in privateIpAddressConfigs.enumerated() {
                    var privateIpAddressConfigsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("PrivateIpAddressConfig.\(index0.advanced(by: 1))"))
                    try privateIpAddressConfigsContainer0.encode(scheduledinstancesprivateipaddressconfig0, forKey: Key(""))
                }
            }
        }
        if secondaryPrivateIpAddressCount != 0 {
            try container.encode(secondaryPrivateIpAddressCount, forKey: Key("SecondaryPrivateIpAddressCount"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decode(Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let deleteOnTerminationDecoded = try containerValues.decode(Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deviceIndexDecoded = try containerValues.decode(Int.self, forKey: .deviceIndex)
        deviceIndex = deviceIndexDecoded
        if containerValues.contains(.groups) {
            struct KeyVal0{struct SecurityGroupId{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var groupsBuffer:[String]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [String]()
                    for stringContainer0 in groupsContainer {
                        groupsBuffer?.append(stringContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let ipv6AddressCountDecoded = try containerValues.decode(Int.self, forKey: .ipv6AddressCount)
        ipv6AddressCount = ipv6AddressCountDecoded
        if containerValues.contains(.ipv6Addresses) {
            struct KeyVal0{struct Ipv6Address{}}
            let ipv6AddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Ipv6Address>.CodingKeys.self, forKey: .ipv6Addresses)
            if let ipv6AddressesWrappedContainer = ipv6AddressesWrappedContainer {
                let ipv6AddressesContainer = try ipv6AddressesWrappedContainer.decodeIfPresent([ScheduledInstancesIpv6Address].self, forKey: .member)
                var ipv6AddressesBuffer:[ScheduledInstancesIpv6Address]? = nil
                if let ipv6AddressesContainer = ipv6AddressesContainer {
                    ipv6AddressesBuffer = [ScheduledInstancesIpv6Address]()
                    for structureContainer0 in ipv6AddressesContainer {
                        ipv6AddressesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Addresses = ipv6AddressesBuffer
            } else {
                ipv6Addresses = []
            }
        } else {
            ipv6Addresses = nil
        }
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        if containerValues.contains(.privateIpAddressConfigs) {
            struct KeyVal0{struct PrivateIpAddressConfigSet{}}
            let privateIpAddressConfigsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PrivateIpAddressConfigSet>.CodingKeys.self, forKey: .privateIpAddressConfigs)
            if let privateIpAddressConfigsWrappedContainer = privateIpAddressConfigsWrappedContainer {
                let privateIpAddressConfigsContainer = try privateIpAddressConfigsWrappedContainer.decodeIfPresent([ScheduledInstancesPrivateIpAddressConfig].self, forKey: .member)
                var privateIpAddressConfigsBuffer:[ScheduledInstancesPrivateIpAddressConfig]? = nil
                if let privateIpAddressConfigsContainer = privateIpAddressConfigsContainer {
                    privateIpAddressConfigsBuffer = [ScheduledInstancesPrivateIpAddressConfig]()
                    for structureContainer0 in privateIpAddressConfigsContainer {
                        privateIpAddressConfigsBuffer?.append(structureContainer0)
                    }
                }
                privateIpAddressConfigs = privateIpAddressConfigsBuffer
            } else {
                privateIpAddressConfigs = []
            }
        } else {
            privateIpAddressConfigs = nil
        }
        let secondaryPrivateIpAddressCountDecoded = try containerValues.decode(Int.self, forKey: .secondaryPrivateIpAddressCount)
        secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCountDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}
