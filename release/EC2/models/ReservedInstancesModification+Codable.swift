// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ReservedInstancesModification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case createDate = "createDate"
        case effectiveDate = "effectiveDate"
        case modificationResults = "modificationResultSet"
        case reservedInstancesIds = "reservedInstancesSet"
        case reservedInstancesModificationId = "reservedInstancesModificationId"
        case status = "status"
        case statusMessage = "statusMessage"
        case updateDate = "updateDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: Key("ClientToken"))
        }
        if let createDate = createDate {
            try container.encode(TimestampWrapper(createDate, format: .dateTime), forKey: Key("CreateDate"))
        }
        if let effectiveDate = effectiveDate {
            try container.encode(TimestampWrapper(effectiveDate, format: .dateTime), forKey: Key("EffectiveDate"))
        }
        if let modificationResults = modificationResults {
            if !modificationResults.isEmpty {
                for (index0, reservedinstancesmodificationresult0) in modificationResults.enumerated() {
                    var modificationResultsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ModificationResultSet.\(index0.advanced(by: 1))"))
                    try modificationResultsContainer0.encode(reservedinstancesmodificationresult0, forKey: Key(""))
                }
            }
        }
        if let reservedInstancesIds = reservedInstancesIds {
            if !reservedInstancesIds.isEmpty {
                for (index0, reservedinstancesid0) in reservedInstancesIds.enumerated() {
                    var reservedInstancesIdsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReservedInstancesSet.\(index0.advanced(by: 1))"))
                    try reservedInstancesIdsContainer0.encode(reservedinstancesid0, forKey: Key(""))
                }
            }
        }
        if let reservedInstancesModificationId = reservedInstancesModificationId {
            try container.encode(reservedInstancesModificationId, forKey: Key("ReservedInstancesModificationId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusMessage = statusMessage {
            try container.encode(statusMessage, forKey: Key("StatusMessage"))
        }
        if let updateDate = updateDate {
            try container.encode(TimestampWrapper(updateDate, format: .dateTime), forKey: Key("UpdateDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createDate)
        var createDateBuffer:Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        let effectiveDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveDate)
        var effectiveDateBuffer:Date? = nil
        if let effectiveDateDecoded = effectiveDateDecoded {
            effectiveDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(effectiveDateDecoded, format: .dateTime)
        }
        effectiveDate = effectiveDateBuffer
        if containerValues.contains(.modificationResults) {
            struct KeyVal0{struct item{}}
            let modificationResultsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .modificationResults)
            if let modificationResultsWrappedContainer = modificationResultsWrappedContainer {
                let modificationResultsContainer = try modificationResultsWrappedContainer.decodeIfPresent([ReservedInstancesModificationResult].self, forKey: .member)
                var modificationResultsBuffer:[ReservedInstancesModificationResult]? = nil
                if let modificationResultsContainer = modificationResultsContainer {
                    modificationResultsBuffer = [ReservedInstancesModificationResult]()
                    for structureContainer0 in modificationResultsContainer {
                        modificationResultsBuffer?.append(structureContainer0)
                    }
                }
                modificationResults = modificationResultsBuffer
            } else {
                modificationResults = []
            }
        } else {
            modificationResults = nil
        }
        if containerValues.contains(.reservedInstancesIds) {
            struct KeyVal0{struct item{}}
            let reservedInstancesIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .reservedInstancesIds)
            if let reservedInstancesIdsWrappedContainer = reservedInstancesIdsWrappedContainer {
                let reservedInstancesIdsContainer = try reservedInstancesIdsWrappedContainer.decodeIfPresent([ReservedInstancesId].self, forKey: .member)
                var reservedInstancesIdsBuffer:[ReservedInstancesId]? = nil
                if let reservedInstancesIdsContainer = reservedInstancesIdsContainer {
                    reservedInstancesIdsBuffer = [ReservedInstancesId]()
                    for structureContainer0 in reservedInstancesIdsContainer {
                        reservedInstancesIdsBuffer?.append(structureContainer0)
                    }
                }
                reservedInstancesIds = reservedInstancesIdsBuffer
            } else {
                reservedInstancesIds = []
            }
        } else {
            reservedInstancesIds = nil
        }
        let reservedInstancesModificationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedInstancesModificationId)
        reservedInstancesModificationId = reservedInstancesModificationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateDate)
        var updateDateBuffer:Date? = nil
        if let updateDateDecoded = updateDateDecoded {
            updateDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(updateDateDecoded, format: .dateTime)
        }
        updateDate = updateDateBuffer
    }
}
