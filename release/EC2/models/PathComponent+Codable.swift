// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PathComponent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aclRule = "aclRule"
        case component = "component"
        case destinationVpc = "destinationVpc"
        case inboundHeader = "inboundHeader"
        case outboundHeader = "outboundHeader"
        case routeTableRoute = "routeTableRoute"
        case securityGroupRule = "securityGroupRule"
        case sequenceNumber = "sequenceNumber"
        case sourceVpc = "sourceVpc"
        case subnet = "subnet"
        case vpc = "vpc"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let aclRule = aclRule {
            try container.encode(aclRule, forKey: Key("AclRule"))
        }
        if let component = component {
            try container.encode(component, forKey: Key("Component"))
        }
        if let destinationVpc = destinationVpc {
            try container.encode(destinationVpc, forKey: Key("DestinationVpc"))
        }
        if let inboundHeader = inboundHeader {
            try container.encode(inboundHeader, forKey: Key("InboundHeader"))
        }
        if let outboundHeader = outboundHeader {
            try container.encode(outboundHeader, forKey: Key("OutboundHeader"))
        }
        if let routeTableRoute = routeTableRoute {
            try container.encode(routeTableRoute, forKey: Key("RouteTableRoute"))
        }
        if let securityGroupRule = securityGroupRule {
            try container.encode(securityGroupRule, forKey: Key("SecurityGroupRule"))
        }
        if sequenceNumber != 0 {
            try container.encode(sequenceNumber, forKey: Key("SequenceNumber"))
        }
        if let sourceVpc = sourceVpc {
            try container.encode(sourceVpc, forKey: Key("SourceVpc"))
        }
        if let subnet = subnet {
            try container.encode(subnet, forKey: Key("Subnet"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: Key("Vpc"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceNumberDecoded = try containerValues.decode(Int.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let aclRuleDecoded = try containerValues.decodeIfPresent(AnalysisAclRule.self, forKey: .aclRule)
        aclRule = aclRuleDecoded
        let componentDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .component)
        component = componentDecoded
        let destinationVpcDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .destinationVpc)
        destinationVpc = destinationVpcDecoded
        let outboundHeaderDecoded = try containerValues.decodeIfPresent(AnalysisPacketHeader.self, forKey: .outboundHeader)
        outboundHeader = outboundHeaderDecoded
        let inboundHeaderDecoded = try containerValues.decodeIfPresent(AnalysisPacketHeader.self, forKey: .inboundHeader)
        inboundHeader = inboundHeaderDecoded
        let routeTableRouteDecoded = try containerValues.decodeIfPresent(AnalysisRouteTableRoute.self, forKey: .routeTableRoute)
        routeTableRoute = routeTableRouteDecoded
        let securityGroupRuleDecoded = try containerValues.decodeIfPresent(AnalysisSecurityGroupRule.self, forKey: .securityGroupRule)
        securityGroupRule = securityGroupRuleDecoded
        let sourceVpcDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .sourceVpc)
        sourceVpc = sourceVpcDecoded
        let subnetDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .subnet)
        subnet = subnetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(AnalysisComponent.self, forKey: .vpc)
        vpc = vpcDecoded
    }
}
