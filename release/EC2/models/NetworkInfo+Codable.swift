// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension NetworkInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultNetworkCardIndex = "defaultNetworkCardIndex"
        case efaInfo = "efaInfo"
        case efaSupported = "efaSupported"
        case enaSupport = "enaSupport"
        case ipv4AddressesPerInterface = "ipv4AddressesPerInterface"
        case ipv6AddressesPerInterface = "ipv6AddressesPerInterface"
        case ipv6Supported = "ipv6Supported"
        case maximumNetworkCards = "maximumNetworkCards"
        case maximumNetworkInterfaces = "maximumNetworkInterfaces"
        case networkCards = "networkCards"
        case networkPerformance = "networkPerformance"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultNetworkCardIndex = defaultNetworkCardIndex {
            try container.encode(defaultNetworkCardIndex, forKey: Key("DefaultNetworkCardIndex"))
        }
        if let efaInfo = efaInfo {
            try container.encode(efaInfo, forKey: Key("EfaInfo"))
        }
        if let efaSupported = efaSupported {
            try container.encode(efaSupported, forKey: Key("EfaSupported"))
        }
        if let enaSupport = enaSupport {
            try container.encode(enaSupport, forKey: Key("EnaSupport"))
        }
        if let ipv4AddressesPerInterface = ipv4AddressesPerInterface {
            try container.encode(ipv4AddressesPerInterface, forKey: Key("Ipv4AddressesPerInterface"))
        }
        if let ipv6AddressesPerInterface = ipv6AddressesPerInterface {
            try container.encode(ipv6AddressesPerInterface, forKey: Key("Ipv6AddressesPerInterface"))
        }
        if let ipv6Supported = ipv6Supported {
            try container.encode(ipv6Supported, forKey: Key("Ipv6Supported"))
        }
        if let maximumNetworkCards = maximumNetworkCards {
            try container.encode(maximumNetworkCards, forKey: Key("MaximumNetworkCards"))
        }
        if let maximumNetworkInterfaces = maximumNetworkInterfaces {
            try container.encode(maximumNetworkInterfaces, forKey: Key("MaximumNetworkInterfaces"))
        }
        if let networkCards = networkCards {
            if !networkCards.isEmpty {
                for (index0, networkcardinfo0) in networkCards.enumerated() {
                    var networkCardsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("NetworkCards.\(index0.advanced(by: 1))"))
                    try networkCardsContainer0.encode(networkcardinfo0, forKey: Key(""))
                }
            }
        }
        if let networkPerformance = networkPerformance {
            try container.encode(networkPerformance, forKey: Key("NetworkPerformance"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkPerformanceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkPerformance)
        networkPerformance = networkPerformanceDecoded
        let maximumNetworkInterfacesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumNetworkInterfaces)
        maximumNetworkInterfaces = maximumNetworkInterfacesDecoded
        let maximumNetworkCardsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumNetworkCards)
        maximumNetworkCards = maximumNetworkCardsDecoded
        let defaultNetworkCardIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultNetworkCardIndex)
        defaultNetworkCardIndex = defaultNetworkCardIndexDecoded
        if containerValues.contains(.networkCards) {
            struct KeyVal0{struct item{}}
            let networkCardsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkCards)
            if let networkCardsWrappedContainer = networkCardsWrappedContainer {
                let networkCardsContainer = try networkCardsWrappedContainer.decodeIfPresent([NetworkCardInfo].self, forKey: .member)
                var networkCardsBuffer:[NetworkCardInfo]? = nil
                if let networkCardsContainer = networkCardsContainer {
                    networkCardsBuffer = [NetworkCardInfo]()
                    for structureContainer0 in networkCardsContainer {
                        networkCardsBuffer?.append(structureContainer0)
                    }
                }
                networkCards = networkCardsBuffer
            } else {
                networkCards = []
            }
        } else {
            networkCards = nil
        }
        let ipv4AddressesPerInterfaceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ipv4AddressesPerInterface)
        ipv4AddressesPerInterface = ipv4AddressesPerInterfaceDecoded
        let ipv6AddressesPerInterfaceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ipv6AddressesPerInterface)
        ipv6AddressesPerInterface = ipv6AddressesPerInterfaceDecoded
        let ipv6SupportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ipv6Supported)
        ipv6Supported = ipv6SupportedDecoded
        let enaSupportDecoded = try containerValues.decodeIfPresent(EnaSupport.self, forKey: .enaSupport)
        enaSupport = enaSupportDecoded
        let efaSupportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .efaSupported)
        efaSupported = efaSupportedDecoded
        let efaInfoDecoded = try containerValues.decodeIfPresent(EfaInfo.self, forKey: .efaInfo)
        efaInfo = efaInfoDecoded
    }
}
