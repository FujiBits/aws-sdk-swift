// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SpotInstanceRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualBlockHourlyPrice = "actualBlockHourlyPrice"
        case availabilityZoneGroup = "availabilityZoneGroup"
        case blockDurationMinutes = "blockDurationMinutes"
        case createTime = "createTime"
        case fault = "fault"
        case instanceId = "instanceId"
        case instanceInterruptionBehavior = "instanceInterruptionBehavior"
        case launchGroup = "launchGroup"
        case launchSpecification = "launchSpecification"
        case launchedAvailabilityZone = "launchedAvailabilityZone"
        case productDescription = "productDescription"
        case spotInstanceRequestId = "spotInstanceRequestId"
        case spotPrice = "spotPrice"
        case state = "state"
        case status = "status"
        case tags = "tagSet"
        case type = "type"
        case validFrom = "validFrom"
        case validUntil = "validUntil"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actualBlockHourlyPrice = actualBlockHourlyPrice {
            try container.encode(actualBlockHourlyPrice, forKey: Key("ActualBlockHourlyPrice"))
        }
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: Key("AvailabilityZoneGroup"))
        }
        if blockDurationMinutes != 0 {
            try container.encode(blockDurationMinutes, forKey: Key("BlockDurationMinutes"))
        }
        if let createTime = createTime {
            try container.encode(TimestampWrapper(createTime, format: .dateTime), forKey: Key("CreateTime"))
        }
        if let fault = fault {
            try container.encode(fault, forKey: Key("Fault"))
        }
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: Key("InstanceId"))
        }
        if let instanceInterruptionBehavior = instanceInterruptionBehavior {
            try container.encode(instanceInterruptionBehavior, forKey: Key("InstanceInterruptionBehavior"))
        }
        if let launchGroup = launchGroup {
            try container.encode(launchGroup, forKey: Key("LaunchGroup"))
        }
        if let launchSpecification = launchSpecification {
            try container.encode(launchSpecification, forKey: Key("LaunchSpecification"))
        }
        if let launchedAvailabilityZone = launchedAvailabilityZone {
            try container.encode(launchedAvailabilityZone, forKey: Key("LaunchedAvailabilityZone"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: Key("ProductDescription"))
        }
        if let spotInstanceRequestId = spotInstanceRequestId {
            try container.encode(spotInstanceRequestId, forKey: Key("SpotInstanceRequestId"))
        }
        if let spotPrice = spotPrice {
            try container.encode(spotPrice, forKey: Key("SpotPrice"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let validFrom = validFrom {
            try container.encode(TimestampWrapper(validFrom, format: .dateTime), forKey: Key("ValidFrom"))
        }
        if let validUntil = validUntil {
            try container.encode(TimestampWrapper(validUntil, format: .dateTime), forKey: Key("ValidUntil"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actualBlockHourlyPriceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actualBlockHourlyPrice)
        actualBlockHourlyPrice = actualBlockHourlyPriceDecoded
        let availabilityZoneGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneGroup)
        availabilityZoneGroup = availabilityZoneGroupDecoded
        let blockDurationMinutesDecoded = try containerValues.decode(Int.self, forKey: .blockDurationMinutes)
        blockDurationMinutes = blockDurationMinutesDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        var createTimeBuffer:Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let faultDecoded = try containerValues.decodeIfPresent(SpotInstanceStateFault.self, forKey: .fault)
        fault = faultDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let launchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchGroup)
        launchGroup = launchGroupDecoded
        let launchSpecificationDecoded = try containerValues.decodeIfPresent(LaunchSpecification.self, forKey: .launchSpecification)
        launchSpecification = launchSpecificationDecoded
        let launchedAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchedAvailabilityZone)
        launchedAvailabilityZone = launchedAvailabilityZoneDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(RIProductDescription.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let spotInstanceRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spotInstanceRequestId)
        spotInstanceRequestId = spotInstanceRequestIdDecoded
        let spotPriceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spotPrice)
        spotPrice = spotPriceDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SpotInstanceState.self, forKey: .state)
        state = stateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SpotInstanceStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let typeDecoded = try containerValues.decodeIfPresent(SpotInstanceType.self, forKey: .type)
        type = typeDecoded
        let validFromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validFrom)
        var validFromBuffer:Date? = nil
        if let validFromDecoded = validFromDecoded {
            validFromBuffer = try TimestampWrapperDecoder.parseDateStringValue(validFromDecoded, format: .dateTime)
        }
        validFrom = validFromBuffer
        let validUntilDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validUntil)
        var validUntilBuffer:Date? = nil
        if let validUntilDecoded = validUntilDecoded {
            validUntilBuffer = try TimestampWrapperDecoder.parseDateStringValue(validUntilDecoded, format: .dateTime)
        }
        validUntil = validUntilBuffer
        let instanceInterruptionBehaviorDecoded = try containerValues.decodeIfPresent(InstanceInterruptionBehavior.self, forKey: .instanceInterruptionBehavior)
        instanceInterruptionBehavior = instanceInterruptionBehaviorDecoded
    }
}
