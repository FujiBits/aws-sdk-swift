// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SpotFleetLaunchSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressingType = "addressingType"
        case blockDeviceMappings = "blockDeviceMapping"
        case ebsOptimized = "ebsOptimized"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageId = "imageId"
        case instanceType = "instanceType"
        case kernelId = "kernelId"
        case keyName = "keyName"
        case monitoring = "monitoring"
        case networkInterfaces = "networkInterfaceSet"
        case placement = "placement"
        case ramdiskId = "ramdiskId"
        case securityGroups = "groupSet"
        case spotPrice = "spotPrice"
        case subnetId = "subnetId"
        case tagSpecifications = "tagSpecificationSet"
        case userData = "userData"
        case weightedCapacity = "weightedCapacity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let addressingType = addressingType {
            try container.encode(addressingType, forKey: Key("AddressingType"))
        }
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, blockdevicemapping0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("BlockDeviceMapping.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(blockdevicemapping0, forKey: Key(""))
                }
            }
        }
        if ebsOptimized != false {
            try container.encode(ebsOptimized, forKey: Key("EbsOptimized"))
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try container.encode(iamInstanceProfile, forKey: Key("IamInstanceProfile"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: Key("ImageId"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: Key("InstanceType"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: Key("KernelId"))
        }
        if let keyName = keyName {
            try container.encode(keyName, forKey: Key("KeyName"))
        }
        if let monitoring = monitoring {
            try container.encode(monitoring, forKey: Key("Monitoring"))
        }
        if let networkInterfaces = networkInterfaces {
            if !networkInterfaces.isEmpty {
                for (index0, instancenetworkinterfacespecification0) in networkInterfaces.enumerated() {
                    var networkInterfacesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("NetworkInterfaceSet.\(index0.advanced(by: 1))"))
                    try networkInterfacesContainer0.encode(instancenetworkinterfacespecification0, forKey: Key(""))
                }
            }
        }
        if let placement = placement {
            try container.encode(placement, forKey: Key("Placement"))
        }
        if let ramdiskId = ramdiskId {
            try container.encode(ramdiskId, forKey: Key("RamdiskId"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                for (index0, groupidentifier0) in securityGroups.enumerated() {
                    var securityGroupsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("GroupSet.\(index0.advanced(by: 1))"))
                    try securityGroupsContainer0.encode(groupidentifier0, forKey: Key(""))
                }
            }
        }
        if let spotPrice = spotPrice {
            try container.encode(spotPrice, forKey: Key("SpotPrice"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
        if let tagSpecifications = tagSpecifications {
            if !tagSpecifications.isEmpty {
                for (index0, spotfleettagspecification0) in tagSpecifications.enumerated() {
                    var tagSpecificationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSpecificationSet.\(index0.advanced(by: 1))"))
                    try tagSpecificationsContainer0.encode(spotfleettagspecification0, forKey: Key(""))
                }
            }
        }
        if let userData = userData {
            try container.encode(userData, forKey: Key("UserData"))
        }
        if weightedCapacity != 0.0 {
            try container.encode(String(weightedCapacity), forKey: Key("WeightedCapacity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct item{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([GroupIdentifier].self, forKey: .member)
                var securityGroupsBuffer:[GroupIdentifier]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [GroupIdentifier]()
                    for structureContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(structureContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let addressingTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressingType)
        addressingType = addressingTypeDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct item{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([BlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[BlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [BlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        let ebsOptimizedDecoded = try containerValues.decode(Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(IamInstanceProfileSpecification.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let monitoringDecoded = try containerValues.decodeIfPresent(SpotFleetMonitoring.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct item{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([InstanceNetworkInterfaceSpecification].self, forKey: .member)
                var networkInterfacesBuffer:[InstanceNetworkInterfaceSpecification]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [InstanceNetworkInterfaceSpecification]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
        let placementDecoded = try containerValues.decodeIfPresent(SpotPlacement.self, forKey: .placement)
        placement = placementDecoded
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        let spotPriceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spotPrice)
        spotPrice = spotPriceDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userData)
        userData = userDataDecoded
        let weightedCapacityDecoded = try containerValues.decode(Double.self, forKey: .weightedCapacity)
        weightedCapacity = weightedCapacityDecoded
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct item{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([SpotFleetTagSpecification].self, forKey: .member)
                var tagSpecificationsBuffer:[SpotFleetTagSpecification]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [SpotFleetTagSpecification]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
    }
}
