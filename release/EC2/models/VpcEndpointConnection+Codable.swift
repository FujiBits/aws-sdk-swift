// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension VpcEndpointConnection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp = "creationTimestamp"
        case dnsEntries = "dnsEntrySet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case serviceId = "serviceId"
        case vpcEndpointId = "vpcEndpointId"
        case vpcEndpointOwner = "vpcEndpointOwner"
        case vpcEndpointState = "vpcEndpointState"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let creationTimestamp = creationTimestamp {
            try container.encode(TimestampWrapper(creationTimestamp, format: .dateTime), forKey: Key("CreationTimestamp"))
        }
        if let dnsEntries = dnsEntries {
            if !dnsEntries.isEmpty {
                for (index0, dnsentry0) in dnsEntries.enumerated() {
                    var dnsEntriesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("DnsEntrySet.\(index0.advanced(by: 1))"))
                    try dnsEntriesContainer0.encode(dnsentry0, forKey: Key(""))
                }
            }
        }
        if let gatewayLoadBalancerArns = gatewayLoadBalancerArns {
            if !gatewayLoadBalancerArns.isEmpty {
                for (index0, string0) in gatewayLoadBalancerArns.enumerated() {
                    var gatewayLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("GatewayLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try gatewayLoadBalancerArnsContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let networkLoadBalancerArns = networkLoadBalancerArns {
            if !networkLoadBalancerArns.isEmpty {
                for (index0, string0) in networkLoadBalancerArns.enumerated() {
                    var networkLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("NetworkLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try networkLoadBalancerArnsContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let serviceId = serviceId {
            try container.encode(serviceId, forKey: Key("ServiceId"))
        }
        if let vpcEndpointId = vpcEndpointId {
            try container.encode(vpcEndpointId, forKey: Key("VpcEndpointId"))
        }
        if let vpcEndpointOwner = vpcEndpointOwner {
            try container.encode(vpcEndpointOwner, forKey: Key("VpcEndpointOwner"))
        }
        if let vpcEndpointState = vpcEndpointState {
            try container.encode(vpcEndpointState, forKey: Key("VpcEndpointState"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcEndpointOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcEndpointOwner)
        vpcEndpointOwner = vpcEndpointOwnerDecoded
        let vpcEndpointStateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .vpcEndpointState)
        vpcEndpointState = vpcEndpointStateDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        var creationTimestampBuffer:Date? = nil
        if let creationTimestampDecoded = creationTimestampDecoded {
            creationTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimestampDecoded, format: .dateTime)
        }
        creationTimestamp = creationTimestampBuffer
        if containerValues.contains(.dnsEntries) {
            struct KeyVal0{struct item{}}
            let dnsEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .dnsEntries)
            if let dnsEntriesWrappedContainer = dnsEntriesWrappedContainer {
                let dnsEntriesContainer = try dnsEntriesWrappedContainer.decodeIfPresent([DnsEntry].self, forKey: .member)
                var dnsEntriesBuffer:[DnsEntry]? = nil
                if let dnsEntriesContainer = dnsEntriesContainer {
                    dnsEntriesBuffer = [DnsEntry]()
                    for structureContainer0 in dnsEntriesContainer {
                        dnsEntriesBuffer?.append(structureContainer0)
                    }
                }
                dnsEntries = dnsEntriesBuffer
            } else {
                dnsEntries = []
            }
        } else {
            dnsEntries = nil
        }
        if containerValues.contains(.networkLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let networkLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkLoadBalancerArns)
            if let networkLoadBalancerArnsWrappedContainer = networkLoadBalancerArnsWrappedContainer {
                let networkLoadBalancerArnsContainer = try networkLoadBalancerArnsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var networkLoadBalancerArnsBuffer:[String]? = nil
                if let networkLoadBalancerArnsContainer = networkLoadBalancerArnsContainer {
                    networkLoadBalancerArnsBuffer = [String]()
                    for stringContainer0 in networkLoadBalancerArnsContainer {
                        networkLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                networkLoadBalancerArns = networkLoadBalancerArnsBuffer
            } else {
                networkLoadBalancerArns = []
            }
        } else {
            networkLoadBalancerArns = nil
        }
        if containerValues.contains(.gatewayLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let gatewayLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .gatewayLoadBalancerArns)
            if let gatewayLoadBalancerArnsWrappedContainer = gatewayLoadBalancerArnsWrappedContainer {
                let gatewayLoadBalancerArnsContainer = try gatewayLoadBalancerArnsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var gatewayLoadBalancerArnsBuffer:[String]? = nil
                if let gatewayLoadBalancerArnsContainer = gatewayLoadBalancerArnsContainer {
                    gatewayLoadBalancerArnsBuffer = [String]()
                    for stringContainer0 in gatewayLoadBalancerArnsContainer {
                        gatewayLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                gatewayLoadBalancerArns = gatewayLoadBalancerArnsBuffer
            } else {
                gatewayLoadBalancerArns = []
            }
        } else {
            gatewayLoadBalancerArns = nil
        }
    }
}
