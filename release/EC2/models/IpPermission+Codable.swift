// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension IpPermission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromPort = "fromPort"
        case ipProtocol = "ipProtocol"
        case ipRanges = "ipRanges"
        case ipv6Ranges = "ipv6Ranges"
        case prefixListIds = "prefixListIds"
        case toPort = "toPort"
        case userIdGroupPairs = "groups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if fromPort != 0 {
            try container.encode(fromPort, forKey: Key("FromPort"))
        }
        if let ipProtocol = ipProtocol {
            try container.encode(ipProtocol, forKey: Key("IpProtocol"))
        }
        if let ipRanges = ipRanges {
            if !ipRanges.isEmpty {
                for (index0, iprange0) in ipRanges.enumerated() {
                    var ipRangesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("IpRanges.\(index0.advanced(by: 1))"))
                    try ipRangesContainer0.encode(iprange0, forKey: Key(""))
                }
            }
        }
        if let ipv6Ranges = ipv6Ranges {
            if !ipv6Ranges.isEmpty {
                for (index0, ipv6range0) in ipv6Ranges.enumerated() {
                    var ipv6RangesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Ipv6Ranges.\(index0.advanced(by: 1))"))
                    try ipv6RangesContainer0.encode(ipv6range0, forKey: Key(""))
                }
            }
        }
        if let prefixListIds = prefixListIds {
            if !prefixListIds.isEmpty {
                for (index0, prefixlistid0) in prefixListIds.enumerated() {
                    var prefixListIdsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("PrefixListIds.\(index0.advanced(by: 1))"))
                    try prefixListIdsContainer0.encode(prefixlistid0, forKey: Key(""))
                }
            }
        }
        if toPort != 0 {
            try container.encode(toPort, forKey: Key("ToPort"))
        }
        if let userIdGroupPairs = userIdGroupPairs {
            if !userIdGroupPairs.isEmpty {
                for (index0, useridgrouppair0) in userIdGroupPairs.enumerated() {
                    var userIdGroupPairsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Groups.\(index0.advanced(by: 1))"))
                    try userIdGroupPairsContainer0.encode(useridgrouppair0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decode(Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let ipProtocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipProtocol)
        ipProtocol = ipProtocolDecoded
        if containerValues.contains(.ipRanges) {
            struct KeyVal0{struct item{}}
            let ipRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipRanges)
            if let ipRangesWrappedContainer = ipRangesWrappedContainer {
                let ipRangesContainer = try ipRangesWrappedContainer.decodeIfPresent([IpRange].self, forKey: .member)
                var ipRangesBuffer:[IpRange]? = nil
                if let ipRangesContainer = ipRangesContainer {
                    ipRangesBuffer = [IpRange]()
                    for structureContainer0 in ipRangesContainer {
                        ipRangesBuffer?.append(structureContainer0)
                    }
                }
                ipRanges = ipRangesBuffer
            } else {
                ipRanges = []
            }
        } else {
            ipRanges = nil
        }
        if containerValues.contains(.ipv6Ranges) {
            struct KeyVal0{struct item{}}
            let ipv6RangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6Ranges)
            if let ipv6RangesWrappedContainer = ipv6RangesWrappedContainer {
                let ipv6RangesContainer = try ipv6RangesWrappedContainer.decodeIfPresent([Ipv6Range].self, forKey: .member)
                var ipv6RangesBuffer:[Ipv6Range]? = nil
                if let ipv6RangesContainer = ipv6RangesContainer {
                    ipv6RangesBuffer = [Ipv6Range]()
                    for structureContainer0 in ipv6RangesContainer {
                        ipv6RangesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Ranges = ipv6RangesBuffer
            } else {
                ipv6Ranges = []
            }
        } else {
            ipv6Ranges = nil
        }
        if containerValues.contains(.prefixListIds) {
            struct KeyVal0{struct item{}}
            let prefixListIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .prefixListIds)
            if let prefixListIdsWrappedContainer = prefixListIdsWrappedContainer {
                let prefixListIdsContainer = try prefixListIdsWrappedContainer.decodeIfPresent([PrefixListId].self, forKey: .member)
                var prefixListIdsBuffer:[PrefixListId]? = nil
                if let prefixListIdsContainer = prefixListIdsContainer {
                    prefixListIdsBuffer = [PrefixListId]()
                    for structureContainer0 in prefixListIdsContainer {
                        prefixListIdsBuffer?.append(structureContainer0)
                    }
                }
                prefixListIds = prefixListIdsBuffer
            } else {
                prefixListIds = []
            }
        } else {
            prefixListIds = nil
        }
        let toPortDecoded = try containerValues.decode(Int.self, forKey: .toPort)
        toPort = toPortDecoded
        if containerValues.contains(.userIdGroupPairs) {
            struct KeyVal0{struct item{}}
            let userIdGroupPairsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .userIdGroupPairs)
            if let userIdGroupPairsWrappedContainer = userIdGroupPairsWrappedContainer {
                let userIdGroupPairsContainer = try userIdGroupPairsWrappedContainer.decodeIfPresent([UserIdGroupPair].self, forKey: .member)
                var userIdGroupPairsBuffer:[UserIdGroupPair]? = nil
                if let userIdGroupPairsContainer = userIdGroupPairsContainer {
                    userIdGroupPairsBuffer = [UserIdGroupPair]()
                    for structureContainer0 in userIdGroupPairsContainer {
                        userIdGroupPairsBuffer?.append(structureContainer0)
                    }
                }
                userIdGroupPairs = userIdGroupPairsBuffer
            } else {
                userIdGroupPairs = []
            }
        } else {
            userIdGroupPairs = nil
        }
    }
}
