// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Instance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiLaunchIndex = "amiLaunchIndex"
        case architecture = "architecture"
        case blockDeviceMappings = "blockDeviceMapping"
        case bootMode = "bootMode"
        case capacityReservationId = "capacityReservationId"
        case capacityReservationSpecification = "capacityReservationSpecification"
        case clientToken = "clientToken"
        case cpuOptions = "cpuOptions"
        case ebsOptimized = "ebsOptimized"
        case elasticGpuAssociations = "elasticGpuAssociationSet"
        case elasticInferenceAcceleratorAssociations = "elasticInferenceAcceleratorAssociationSet"
        case enaSupport = "enaSupport"
        case enclaveOptions = "enclaveOptions"
        case hibernationOptions = "hibernationOptions"
        case hypervisor = "hypervisor"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageId = "imageId"
        case instanceId = "instanceId"
        case instanceLifecycle = "instanceLifecycle"
        case instanceType = "instanceType"
        case kernelId = "kernelId"
        case keyName = "keyName"
        case launchTime = "launchTime"
        case licenses = "licenseSet"
        case metadataOptions = "metadataOptions"
        case monitoring = "monitoring"
        case networkInterfaces = "networkInterfaceSet"
        case outpostArn = "outpostArn"
        case placement = "placement"
        case platform = "platform"
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
        case productCodes = "productCodes"
        case publicDnsName = "dnsName"
        case publicIpAddress = "ipAddress"
        case ramdiskId = "ramdiskId"
        case rootDeviceName = "rootDeviceName"
        case rootDeviceType = "rootDeviceType"
        case securityGroups = "groupSet"
        case sourceDestCheck = "sourceDestCheck"
        case spotInstanceRequestId = "spotInstanceRequestId"
        case sriovNetSupport = "sriovNetSupport"
        case state = "instanceState"
        case stateReason = "stateReason"
        case stateTransitionReason = "reason"
        case subnetId = "subnetId"
        case tags = "tagSet"
        case virtualizationType = "virtualizationType"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if amiLaunchIndex != 0 {
            try container.encode(amiLaunchIndex, forKey: Key("AmiLaunchIndex"))
        }
        if let architecture = architecture {
            try container.encode(architecture, forKey: Key("Architecture"))
        }
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, instanceblockdevicemapping0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("BlockDeviceMapping.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(instanceblockdevicemapping0, forKey: Key(""))
                }
            }
        }
        if let bootMode = bootMode {
            try container.encode(bootMode, forKey: Key("BootMode"))
        }
        if let capacityReservationId = capacityReservationId {
            try container.encode(capacityReservationId, forKey: Key("CapacityReservationId"))
        }
        if let capacityReservationSpecification = capacityReservationSpecification {
            try container.encode(capacityReservationSpecification, forKey: Key("CapacityReservationSpecification"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: Key("ClientToken"))
        }
        if let cpuOptions = cpuOptions {
            try container.encode(cpuOptions, forKey: Key("CpuOptions"))
        }
        if ebsOptimized != false {
            try container.encode(ebsOptimized, forKey: Key("EbsOptimized"))
        }
        if let elasticGpuAssociations = elasticGpuAssociations {
            if !elasticGpuAssociations.isEmpty {
                for (index0, elasticgpuassociation0) in elasticGpuAssociations.enumerated() {
                    var elasticGpuAssociationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ElasticGpuAssociationSet.\(index0.advanced(by: 1))"))
                    try elasticGpuAssociationsContainer0.encode(elasticgpuassociation0, forKey: Key(""))
                }
            }
        }
        if let elasticInferenceAcceleratorAssociations = elasticInferenceAcceleratorAssociations {
            if !elasticInferenceAcceleratorAssociations.isEmpty {
                for (index0, elasticinferenceacceleratorassociation0) in elasticInferenceAcceleratorAssociations.enumerated() {
                    var elasticInferenceAcceleratorAssociationsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ElasticInferenceAcceleratorAssociationSet.\(index0.advanced(by: 1))"))
                    try elasticInferenceAcceleratorAssociationsContainer0.encode(elasticinferenceacceleratorassociation0, forKey: Key(""))
                }
            }
        }
        if enaSupport != false {
            try container.encode(enaSupport, forKey: Key("EnaSupport"))
        }
        if let enclaveOptions = enclaveOptions {
            try container.encode(enclaveOptions, forKey: Key("EnclaveOptions"))
        }
        if let hibernationOptions = hibernationOptions {
            try container.encode(hibernationOptions, forKey: Key("HibernationOptions"))
        }
        if let hypervisor = hypervisor {
            try container.encode(hypervisor, forKey: Key("Hypervisor"))
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try container.encode(iamInstanceProfile, forKey: Key("IamInstanceProfile"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: Key("ImageId"))
        }
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: Key("InstanceId"))
        }
        if let instanceLifecycle = instanceLifecycle {
            try container.encode(instanceLifecycle, forKey: Key("InstanceLifecycle"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: Key("InstanceType"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: Key("KernelId"))
        }
        if let keyName = keyName {
            try container.encode(keyName, forKey: Key("KeyName"))
        }
        if let launchTime = launchTime {
            try container.encode(TimestampWrapper(launchTime, format: .dateTime), forKey: Key("LaunchTime"))
        }
        if let licenses = licenses {
            if !licenses.isEmpty {
                for (index0, licenseconfiguration0) in licenses.enumerated() {
                    var licensesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("LicenseSet.\(index0.advanced(by: 1))"))
                    try licensesContainer0.encode(licenseconfiguration0, forKey: Key(""))
                }
            }
        }
        if let metadataOptions = metadataOptions {
            try container.encode(metadataOptions, forKey: Key("MetadataOptions"))
        }
        if let monitoring = monitoring {
            try container.encode(monitoring, forKey: Key("Monitoring"))
        }
        if let networkInterfaces = networkInterfaces {
            if !networkInterfaces.isEmpty {
                for (index0, instancenetworkinterface0) in networkInterfaces.enumerated() {
                    var networkInterfacesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("NetworkInterfaceSet.\(index0.advanced(by: 1))"))
                    try networkInterfacesContainer0.encode(instancenetworkinterface0, forKey: Key(""))
                }
            }
        }
        if let outpostArn = outpostArn {
            try container.encode(outpostArn, forKey: Key("OutpostArn"))
        }
        if let placement = placement {
            try container.encode(placement, forKey: Key("Placement"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: Key("Platform"))
        }
        if let privateDnsName = privateDnsName {
            try container.encode(privateDnsName, forKey: Key("PrivateDnsName"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: Key("PrivateIpAddress"))
        }
        if let productCodes = productCodes {
            if !productCodes.isEmpty {
                for (index0, productcode0) in productCodes.enumerated() {
                    var productCodesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ProductCodes.\(index0.advanced(by: 1))"))
                    try productCodesContainer0.encode(productcode0, forKey: Key(""))
                }
            }
        }
        if let publicDnsName = publicDnsName {
            try container.encode(publicDnsName, forKey: Key("DnsName"))
        }
        if let publicIpAddress = publicIpAddress {
            try container.encode(publicIpAddress, forKey: Key("IpAddress"))
        }
        if let ramdiskId = ramdiskId {
            try container.encode(ramdiskId, forKey: Key("RamdiskId"))
        }
        if let rootDeviceName = rootDeviceName {
            try container.encode(rootDeviceName, forKey: Key("RootDeviceName"))
        }
        if let rootDeviceType = rootDeviceType {
            try container.encode(rootDeviceType, forKey: Key("RootDeviceType"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                for (index0, groupidentifier0) in securityGroups.enumerated() {
                    var securityGroupsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("GroupSet.\(index0.advanced(by: 1))"))
                    try securityGroupsContainer0.encode(groupidentifier0, forKey: Key(""))
                }
            }
        }
        if sourceDestCheck != false {
            try container.encode(sourceDestCheck, forKey: Key("SourceDestCheck"))
        }
        if let spotInstanceRequestId = spotInstanceRequestId {
            try container.encode(spotInstanceRequestId, forKey: Key("SpotInstanceRequestId"))
        }
        if let sriovNetSupport = sriovNetSupport {
            try container.encode(sriovNetSupport, forKey: Key("SriovNetSupport"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("InstanceState"))
        }
        if let stateReason = stateReason {
            try container.encode(stateReason, forKey: Key("StateReason"))
        }
        if let stateTransitionReason = stateTransitionReason {
            try container.encode(stateTransitionReason, forKey: Key("Reason"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
        if let virtualizationType = virtualizationType {
            try container.encode(virtualizationType, forKey: Key("VirtualizationType"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiLaunchIndexDecoded = try containerValues.decode(Int.self, forKey: .amiLaunchIndex)
        amiLaunchIndex = amiLaunchIndexDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchTime)
        var launchTimeBuffer:Date? = nil
        if let launchTimeDecoded = launchTimeDecoded {
            launchTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(launchTimeDecoded, format: .dateTime)
        }
        launchTime = launchTimeBuffer
        let monitoringDecoded = try containerValues.decodeIfPresent(Monitoring.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let placementDecoded = try containerValues.decodeIfPresent(Placement.self, forKey: .placement)
        placement = placementDecoded
        let platformDecoded = try containerValues.decodeIfPresent(PlatformValues.self, forKey: .platform)
        platform = platformDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        if containerValues.contains(.productCodes) {
            struct KeyVal0{struct item{}}
            let productCodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .productCodes)
            if let productCodesWrappedContainer = productCodesWrappedContainer {
                let productCodesContainer = try productCodesWrappedContainer.decodeIfPresent([ProductCode].self, forKey: .member)
                var productCodesBuffer:[ProductCode]? = nil
                if let productCodesContainer = productCodesContainer {
                    productCodesBuffer = [ProductCode]()
                    for structureContainer0 in productCodesContainer {
                        productCodesBuffer?.append(structureContainer0)
                    }
                }
                productCodes = productCodesBuffer
            } else {
                productCodes = []
            }
        } else {
            productCodes = nil
        }
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(InstanceState.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(ArchitectureValues.self, forKey: .architecture)
        architecture = architectureDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct item{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([InstanceBlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[InstanceBlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [InstanceBlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let ebsOptimizedDecoded = try containerValues.decode(Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let enaSupportDecoded = try containerValues.decode(Bool.self, forKey: .enaSupport)
        enaSupport = enaSupportDecoded
        let hypervisorDecoded = try containerValues.decodeIfPresent(HypervisorType.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(IamInstanceProfile.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let instanceLifecycleDecoded = try containerValues.decodeIfPresent(InstanceLifecycleType.self, forKey: .instanceLifecycle)
        instanceLifecycle = instanceLifecycleDecoded
        if containerValues.contains(.elasticGpuAssociations) {
            struct KeyVal0{struct item{}}
            let elasticGpuAssociationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticGpuAssociations)
            if let elasticGpuAssociationsWrappedContainer = elasticGpuAssociationsWrappedContainer {
                let elasticGpuAssociationsContainer = try elasticGpuAssociationsWrappedContainer.decodeIfPresent([ElasticGpuAssociation].self, forKey: .member)
                var elasticGpuAssociationsBuffer:[ElasticGpuAssociation]? = nil
                if let elasticGpuAssociationsContainer = elasticGpuAssociationsContainer {
                    elasticGpuAssociationsBuffer = [ElasticGpuAssociation]()
                    for structureContainer0 in elasticGpuAssociationsContainer {
                        elasticGpuAssociationsBuffer?.append(structureContainer0)
                    }
                }
                elasticGpuAssociations = elasticGpuAssociationsBuffer
            } else {
                elasticGpuAssociations = []
            }
        } else {
            elasticGpuAssociations = nil
        }
        if containerValues.contains(.elasticInferenceAcceleratorAssociations) {
            struct KeyVal0{struct item{}}
            let elasticInferenceAcceleratorAssociationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticInferenceAcceleratorAssociations)
            if let elasticInferenceAcceleratorAssociationsWrappedContainer = elasticInferenceAcceleratorAssociationsWrappedContainer {
                let elasticInferenceAcceleratorAssociationsContainer = try elasticInferenceAcceleratorAssociationsWrappedContainer.decodeIfPresent([ElasticInferenceAcceleratorAssociation].self, forKey: .member)
                var elasticInferenceAcceleratorAssociationsBuffer:[ElasticInferenceAcceleratorAssociation]? = nil
                if let elasticInferenceAcceleratorAssociationsContainer = elasticInferenceAcceleratorAssociationsContainer {
                    elasticInferenceAcceleratorAssociationsBuffer = [ElasticInferenceAcceleratorAssociation]()
                    for structureContainer0 in elasticInferenceAcceleratorAssociationsContainer {
                        elasticInferenceAcceleratorAssociationsBuffer?.append(structureContainer0)
                    }
                }
                elasticInferenceAcceleratorAssociations = elasticInferenceAcceleratorAssociationsBuffer
            } else {
                elasticInferenceAcceleratorAssociations = []
            }
        } else {
            elasticInferenceAcceleratorAssociations = nil
        }
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct item{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([InstanceNetworkInterface].self, forKey: .member)
                var networkInterfacesBuffer:[InstanceNetworkInterface]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [InstanceNetworkInterface]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
        let outpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let rootDeviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootDeviceName)
        rootDeviceName = rootDeviceNameDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(DeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct item{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([GroupIdentifier].self, forKey: .member)
                var securityGroupsBuffer:[GroupIdentifier]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [GroupIdentifier]()
                    for structureContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(structureContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let sourceDestCheckDecoded = try containerValues.decode(Bool.self, forKey: .sourceDestCheck)
        sourceDestCheck = sourceDestCheckDecoded
        let spotInstanceRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spotInstanceRequestId)
        spotInstanceRequestId = spotInstanceRequestIdDecoded
        let sriovNetSupportDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sriovNetSupport)
        sriovNetSupport = sriovNetSupportDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(StateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(VirtualizationType.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(CpuOptions.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let capacityReservationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacityReservationId)
        capacityReservationId = capacityReservationIdDecoded
        let capacityReservationSpecificationDecoded = try containerValues.decodeIfPresent(CapacityReservationSpecificationResponse.self, forKey: .capacityReservationSpecification)
        capacityReservationSpecification = capacityReservationSpecificationDecoded
        let hibernationOptionsDecoded = try containerValues.decodeIfPresent(HibernationOptions.self, forKey: .hibernationOptions)
        hibernationOptions = hibernationOptionsDecoded
        if containerValues.contains(.licenses) {
            struct KeyVal0{struct item{}}
            let licensesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .licenses)
            if let licensesWrappedContainer = licensesWrappedContainer {
                let licensesContainer = try licensesWrappedContainer.decodeIfPresent([LicenseConfiguration].self, forKey: .member)
                var licensesBuffer:[LicenseConfiguration]? = nil
                if let licensesContainer = licensesContainer {
                    licensesBuffer = [LicenseConfiguration]()
                    for structureContainer0 in licensesContainer {
                        licensesBuffer?.append(structureContainer0)
                    }
                }
                licenses = licensesBuffer
            } else {
                licenses = []
            }
        } else {
            licenses = nil
        }
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(InstanceMetadataOptionsResponse.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(EnclaveOptions.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(BootModeValues.self, forKey: .bootMode)
        bootMode = bootModeDecoded
    }
}
