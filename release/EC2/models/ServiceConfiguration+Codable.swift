// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ServiceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptanceRequired = "acceptanceRequired"
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case managesVpcEndpoints = "managesVpcEndpoints"
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case privateDnsName = "privateDnsName"
        case privateDnsNameConfiguration = "privateDnsNameConfiguration"
        case serviceId = "serviceId"
        case serviceName = "serviceName"
        case serviceState = "serviceState"
        case serviceType = "serviceType"
        case tags = "tagSet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if acceptanceRequired != false {
            try container.encode(acceptanceRequired, forKey: Key("AcceptanceRequired"))
        }
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                for (index0, string0) in availabilityZones.enumerated() {
                    var availabilityZonesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZoneSet.\(index0.advanced(by: 1))"))
                    try availabilityZonesContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let baseEndpointDnsNames = baseEndpointDnsNames {
            if !baseEndpointDnsNames.isEmpty {
                for (index0, string0) in baseEndpointDnsNames.enumerated() {
                    var baseEndpointDnsNamesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("BaseEndpointDnsNameSet.\(index0.advanced(by: 1))"))
                    try baseEndpointDnsNamesContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let gatewayLoadBalancerArns = gatewayLoadBalancerArns {
            if !gatewayLoadBalancerArns.isEmpty {
                for (index0, string0) in gatewayLoadBalancerArns.enumerated() {
                    var gatewayLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("GatewayLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try gatewayLoadBalancerArnsContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if managesVpcEndpoints != false {
            try container.encode(managesVpcEndpoints, forKey: Key("ManagesVpcEndpoints"))
        }
        if let networkLoadBalancerArns = networkLoadBalancerArns {
            if !networkLoadBalancerArns.isEmpty {
                for (index0, string0) in networkLoadBalancerArns.enumerated() {
                    var networkLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("NetworkLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try networkLoadBalancerArnsContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let privateDnsName = privateDnsName {
            try container.encode(privateDnsName, forKey: Key("PrivateDnsName"))
        }
        if let privateDnsNameConfiguration = privateDnsNameConfiguration {
            try container.encode(privateDnsNameConfiguration, forKey: Key("PrivateDnsNameConfiguration"))
        }
        if let serviceId = serviceId {
            try container.encode(serviceId, forKey: Key("ServiceId"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let serviceState = serviceState {
            try container.encode(serviceState, forKey: Key("ServiceState"))
        }
        if let serviceType = serviceType {
            if !serviceType.isEmpty {
                for (index0, servicetypedetail0) in serviceType.enumerated() {
                    var serviceTypeContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ServiceType.\(index0.advanced(by: 1))"))
                    try serviceTypeContainer0.encode(servicetypedetail0, forKey: Key(""))
                }
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.serviceType) {
            struct KeyVal0{struct item{}}
            let serviceTypeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .serviceType)
            if let serviceTypeWrappedContainer = serviceTypeWrappedContainer {
                let serviceTypeContainer = try serviceTypeWrappedContainer.decodeIfPresent([ServiceTypeDetail].self, forKey: .member)
                var serviceTypeBuffer:[ServiceTypeDetail]? = nil
                if let serviceTypeContainer = serviceTypeContainer {
                    serviceTypeBuffer = [ServiceTypeDetail]()
                    for structureContainer0 in serviceTypeContainer {
                        serviceTypeBuffer?.append(structureContainer0)
                    }
                }
                serviceType = serviceTypeBuffer
            } else {
                serviceType = []
            }
        } else {
            serviceType = nil
        }
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceStateDecoded = try containerValues.decodeIfPresent(ServiceState.self, forKey: .serviceState)
        serviceState = serviceStateDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct item{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let acceptanceRequiredDecoded = try containerValues.decode(Bool.self, forKey: .acceptanceRequired)
        acceptanceRequired = acceptanceRequiredDecoded
        let managesVpcEndpointsDecoded = try containerValues.decode(Bool.self, forKey: .managesVpcEndpoints)
        managesVpcEndpoints = managesVpcEndpointsDecoded
        if containerValues.contains(.networkLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let networkLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkLoadBalancerArns)
            if let networkLoadBalancerArnsWrappedContainer = networkLoadBalancerArnsWrappedContainer {
                let networkLoadBalancerArnsContainer = try networkLoadBalancerArnsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var networkLoadBalancerArnsBuffer:[String]? = nil
                if let networkLoadBalancerArnsContainer = networkLoadBalancerArnsContainer {
                    networkLoadBalancerArnsBuffer = [String]()
                    for stringContainer0 in networkLoadBalancerArnsContainer {
                        networkLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                networkLoadBalancerArns = networkLoadBalancerArnsBuffer
            } else {
                networkLoadBalancerArns = []
            }
        } else {
            networkLoadBalancerArns = nil
        }
        if containerValues.contains(.gatewayLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let gatewayLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .gatewayLoadBalancerArns)
            if let gatewayLoadBalancerArnsWrappedContainer = gatewayLoadBalancerArnsWrappedContainer {
                let gatewayLoadBalancerArnsContainer = try gatewayLoadBalancerArnsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var gatewayLoadBalancerArnsBuffer:[String]? = nil
                if let gatewayLoadBalancerArnsContainer = gatewayLoadBalancerArnsContainer {
                    gatewayLoadBalancerArnsBuffer = [String]()
                    for stringContainer0 in gatewayLoadBalancerArnsContainer {
                        gatewayLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                gatewayLoadBalancerArns = gatewayLoadBalancerArnsBuffer
            } else {
                gatewayLoadBalancerArns = []
            }
        } else {
            gatewayLoadBalancerArns = nil
        }
        if containerValues.contains(.baseEndpointDnsNames) {
            struct KeyVal0{struct item{}}
            let baseEndpointDnsNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .baseEndpointDnsNames)
            if let baseEndpointDnsNamesWrappedContainer = baseEndpointDnsNamesWrappedContainer {
                let baseEndpointDnsNamesContainer = try baseEndpointDnsNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var baseEndpointDnsNamesBuffer:[String]? = nil
                if let baseEndpointDnsNamesContainer = baseEndpointDnsNamesContainer {
                    baseEndpointDnsNamesBuffer = [String]()
                    for stringContainer0 in baseEndpointDnsNamesContainer {
                        baseEndpointDnsNamesBuffer?.append(stringContainer0)
                    }
                }
                baseEndpointDnsNames = baseEndpointDnsNamesBuffer
            } else {
                baseEndpointDnsNames = []
            }
        } else {
            baseEndpointDnsNames = nil
        }
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateDnsNameConfigurationDecoded = try containerValues.decodeIfPresent(PrivateDnsNameConfiguration.self, forKey: .privateDnsNameConfiguration)
        privateDnsNameConfiguration = privateDnsNameConfigurationDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}
