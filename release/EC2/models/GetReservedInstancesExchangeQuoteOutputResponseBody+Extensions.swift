// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct GetReservedInstancesExchangeQuoteOutputResponseBody: Equatable {
    public let currencyCode: String?
    public let isValidExchange: Bool
    public let outputReservedInstancesWillExpireAt: Date?
    public let paymentDue: String?
    public let reservedInstanceValueRollup: ReservationValue?
    public let reservedInstanceValueSet: [ReservedInstanceReservationValue]?
    public let targetConfigurationValueRollup: ReservationValue?
    public let targetConfigurationValueSet: [TargetReservationValue]?
    public let validationFailureReason: String?
}

extension GetReservedInstancesExchangeQuoteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "currencyCode"
        case isValidExchange = "isValidExchange"
        case outputReservedInstancesWillExpireAt = "outputReservedInstancesWillExpireAt"
        case paymentDue = "paymentDue"
        case reservedInstanceValueRollup = "reservedInstanceValueRollup"
        case reservedInstanceValueSet = "reservedInstanceValueSet"
        case targetConfigurationValueRollup = "targetConfigurationValueRollup"
        case targetConfigurationValueSet = "targetConfigurationValueSet"
        case validationFailureReason = "validationFailureReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let isValidExchangeDecoded = try containerValues.decode(Bool.self, forKey: .isValidExchange)
        isValidExchange = isValidExchangeDecoded
        let outputReservedInstancesWillExpireAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputReservedInstancesWillExpireAt)
        var outputReservedInstancesWillExpireAtBuffer:Date? = nil
        if let outputReservedInstancesWillExpireAtDecoded = outputReservedInstancesWillExpireAtDecoded {
            outputReservedInstancesWillExpireAtBuffer = try TimestampWrapperDecoder.parseDateStringValue(outputReservedInstancesWillExpireAtDecoded, format: .dateTime)
        }
        outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAtBuffer
        let paymentDueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paymentDue)
        paymentDue = paymentDueDecoded
        let reservedInstanceValueRollupDecoded = try containerValues.decodeIfPresent(ReservationValue.self, forKey: .reservedInstanceValueRollup)
        reservedInstanceValueRollup = reservedInstanceValueRollupDecoded
        if containerValues.contains(.reservedInstanceValueSet) {
            struct KeyVal0{struct item{}}
            let reservedInstanceValueSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .reservedInstanceValueSet)
            if let reservedInstanceValueSetWrappedContainer = reservedInstanceValueSetWrappedContainer {
                let reservedInstanceValueSetContainer = try reservedInstanceValueSetWrappedContainer.decodeIfPresent([ReservedInstanceReservationValue].self, forKey: .member)
                var reservedInstanceValueSetBuffer:[ReservedInstanceReservationValue]? = nil
                if let reservedInstanceValueSetContainer = reservedInstanceValueSetContainer {
                    reservedInstanceValueSetBuffer = [ReservedInstanceReservationValue]()
                    for structureContainer0 in reservedInstanceValueSetContainer {
                        reservedInstanceValueSetBuffer?.append(structureContainer0)
                    }
                }
                reservedInstanceValueSet = reservedInstanceValueSetBuffer
            } else {
                reservedInstanceValueSet = []
            }
        } else {
            reservedInstanceValueSet = nil
        }
        let targetConfigurationValueRollupDecoded = try containerValues.decodeIfPresent(ReservationValue.self, forKey: .targetConfigurationValueRollup)
        targetConfigurationValueRollup = targetConfigurationValueRollupDecoded
        if containerValues.contains(.targetConfigurationValueSet) {
            struct KeyVal0{struct item{}}
            let targetConfigurationValueSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .targetConfigurationValueSet)
            if let targetConfigurationValueSetWrappedContainer = targetConfigurationValueSetWrappedContainer {
                let targetConfigurationValueSetContainer = try targetConfigurationValueSetWrappedContainer.decodeIfPresent([TargetReservationValue].self, forKey: .member)
                var targetConfigurationValueSetBuffer:[TargetReservationValue]? = nil
                if let targetConfigurationValueSetContainer = targetConfigurationValueSetContainer {
                    targetConfigurationValueSetBuffer = [TargetReservationValue]()
                    for structureContainer0 in targetConfigurationValueSetContainer {
                        targetConfigurationValueSetBuffer?.append(structureContainer0)
                    }
                }
                targetConfigurationValueSet = targetConfigurationValueSetBuffer
            } else {
                targetConfigurationValueSet = []
            }
        } else {
            targetConfigurationValueSet = nil
        }
        let validationFailureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationFailureReason)
        validationFailureReason = validationFailureReasonDecoded
    }
}
