// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ServiceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptanceRequired = "acceptanceRequired"
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case managesVpcEndpoints = "managesVpcEndpoints"
        case owner = "owner"
        case privateDnsName = "privateDnsName"
        case privateDnsNameVerificationState = "privateDnsNameVerificationState"
        case privateDnsNames = "privateDnsNameSet"
        case serviceId = "serviceId"
        case serviceName = "serviceName"
        case serviceType = "serviceType"
        case tags = "tagSet"
        case vpcEndpointPolicySupported = "vpcEndpointPolicySupported"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if acceptanceRequired != false {
            try container.encode(acceptanceRequired, forKey: Key("AcceptanceRequired"))
        }
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                for (index0, string0) in availabilityZones.enumerated() {
                    var availabilityZonesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZoneSet.\(index0.advanced(by: 1))"))
                    try availabilityZonesContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if let baseEndpointDnsNames = baseEndpointDnsNames {
            if !baseEndpointDnsNames.isEmpty {
                for (index0, string0) in baseEndpointDnsNames.enumerated() {
                    var baseEndpointDnsNamesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("BaseEndpointDnsNameSet.\(index0.advanced(by: 1))"))
                    try baseEndpointDnsNamesContainer0.encode(string0, forKey: Key(""))
                }
            }
        }
        if managesVpcEndpoints != false {
            try container.encode(managesVpcEndpoints, forKey: Key("ManagesVpcEndpoints"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("Owner"))
        }
        if let privateDnsName = privateDnsName {
            try container.encode(privateDnsName, forKey: Key("PrivateDnsName"))
        }
        if let privateDnsNameVerificationState = privateDnsNameVerificationState {
            try container.encode(privateDnsNameVerificationState, forKey: Key("PrivateDnsNameVerificationState"))
        }
        if let privateDnsNames = privateDnsNames {
            if !privateDnsNames.isEmpty {
                for (index0, privatednsdetails0) in privateDnsNames.enumerated() {
                    var privateDnsNamesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("PrivateDnsNameSet.\(index0.advanced(by: 1))"))
                    try privateDnsNamesContainer0.encode(privatednsdetails0, forKey: Key(""))
                }
            }
        }
        if let serviceId = serviceId {
            try container.encode(serviceId, forKey: Key("ServiceId"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: Key("ServiceName"))
        }
        if let serviceType = serviceType {
            if !serviceType.isEmpty {
                for (index0, servicetypedetail0) in serviceType.enumerated() {
                    var serviceTypeContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ServiceType.\(index0.advanced(by: 1))"))
                    try serviceTypeContainer0.encode(servicetypedetail0, forKey: Key(""))
                }
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
        if vpcEndpointPolicySupported != false {
            try container.encode(vpcEndpointPolicySupported, forKey: Key("VpcEndpointPolicySupported"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        if containerValues.contains(.serviceType) {
            struct KeyVal0{struct item{}}
            let serviceTypeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .serviceType)
            if let serviceTypeWrappedContainer = serviceTypeWrappedContainer {
                let serviceTypeContainer = try serviceTypeWrappedContainer.decodeIfPresent([ServiceTypeDetail].self, forKey: .member)
                var serviceTypeBuffer:[ServiceTypeDetail]? = nil
                if let serviceTypeContainer = serviceTypeContainer {
                    serviceTypeBuffer = [ServiceTypeDetail]()
                    for structureContainer0 in serviceTypeContainer {
                        serviceTypeBuffer?.append(structureContainer0)
                    }
                }
                serviceType = serviceTypeBuffer
            } else {
                serviceType = []
            }
        } else {
            serviceType = nil
        }
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct item{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.baseEndpointDnsNames) {
            struct KeyVal0{struct item{}}
            let baseEndpointDnsNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .baseEndpointDnsNames)
            if let baseEndpointDnsNamesWrappedContainer = baseEndpointDnsNamesWrappedContainer {
                let baseEndpointDnsNamesContainer = try baseEndpointDnsNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var baseEndpointDnsNamesBuffer:[String]? = nil
                if let baseEndpointDnsNamesContainer = baseEndpointDnsNamesContainer {
                    baseEndpointDnsNamesBuffer = [String]()
                    for stringContainer0 in baseEndpointDnsNamesContainer {
                        baseEndpointDnsNamesBuffer?.append(stringContainer0)
                    }
                }
                baseEndpointDnsNames = baseEndpointDnsNamesBuffer
            } else {
                baseEndpointDnsNames = []
            }
        } else {
            baseEndpointDnsNames = nil
        }
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        if containerValues.contains(.privateDnsNames) {
            struct KeyVal0{struct item{}}
            let privateDnsNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .privateDnsNames)
            if let privateDnsNamesWrappedContainer = privateDnsNamesWrappedContainer {
                let privateDnsNamesContainer = try privateDnsNamesWrappedContainer.decodeIfPresent([PrivateDnsDetails].self, forKey: .member)
                var privateDnsNamesBuffer:[PrivateDnsDetails]? = nil
                if let privateDnsNamesContainer = privateDnsNamesContainer {
                    privateDnsNamesBuffer = [PrivateDnsDetails]()
                    for structureContainer0 in privateDnsNamesContainer {
                        privateDnsNamesBuffer?.append(structureContainer0)
                    }
                }
                privateDnsNames = privateDnsNamesBuffer
            } else {
                privateDnsNames = []
            }
        } else {
            privateDnsNames = nil
        }
        let vpcEndpointPolicySupportedDecoded = try containerValues.decode(Bool.self, forKey: .vpcEndpointPolicySupported)
        vpcEndpointPolicySupported = vpcEndpointPolicySupportedDecoded
        let acceptanceRequiredDecoded = try containerValues.decode(Bool.self, forKey: .acceptanceRequired)
        acceptanceRequired = acceptanceRequiredDecoded
        let managesVpcEndpointsDecoded = try containerValues.decode(Bool.self, forKey: .managesVpcEndpoints)
        managesVpcEndpoints = managesVpcEndpointsDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let privateDnsNameVerificationStateDecoded = try containerValues.decodeIfPresent(DnsNameState.self, forKey: .privateDnsNameVerificationState)
        privateDnsNameVerificationState = privateDnsNameVerificationStateDecoded
    }
}
