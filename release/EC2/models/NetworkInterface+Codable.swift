// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case association = "association"
        case attachment = "attachment"
        case availabilityZone = "availabilityZone"
        case description = "description"
        case groups = "groupSet"
        case interfaceType = "interfaceType"
        case ipv6Addresses = "ipv6AddressesSet"
        case macAddress = "macAddress"
        case networkInterfaceId = "networkInterfaceId"
        case outpostArn = "outpostArn"
        case ownerId = "ownerId"
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
        case privateIpAddresses = "privateIpAddressesSet"
        case requesterId = "requesterId"
        case requesterManaged = "requesterManaged"
        case sourceDestCheck = "sourceDestCheck"
        case status = "status"
        case subnetId = "subnetId"
        case tagSet = "tagSet"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let association = association {
            try container.encode(association, forKey: Key("Association"))
        }
        if let attachment = attachment {
            try container.encode(attachment, forKey: Key("Attachment"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let groups = groups {
            if !groups.isEmpty {
                for (index0, groupidentifier0) in groups.enumerated() {
                    var groupsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("GroupSet.\(index0.advanced(by: 1))"))
                    try groupsContainer0.encode(groupidentifier0, forKey: Key(""))
                }
            }
        }
        if let interfaceType = interfaceType {
            try container.encode(interfaceType, forKey: Key("InterfaceType"))
        }
        if let ipv6Addresses = ipv6Addresses {
            if !ipv6Addresses.isEmpty {
                for (index0, networkinterfaceipv6address0) in ipv6Addresses.enumerated() {
                    var ipv6AddressesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Ipv6AddressesSet.\(index0.advanced(by: 1))"))
                    try ipv6AddressesContainer0.encode(networkinterfaceipv6address0, forKey: Key(""))
                }
            }
        }
        if let macAddress = macAddress {
            try container.encode(macAddress, forKey: Key("MacAddress"))
        }
        if let networkInterfaceId = networkInterfaceId {
            try container.encode(networkInterfaceId, forKey: Key("NetworkInterfaceId"))
        }
        if let outpostArn = outpostArn {
            try container.encode(outpostArn, forKey: Key("OutpostArn"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: Key("OwnerId"))
        }
        if let privateDnsName = privateDnsName {
            try container.encode(privateDnsName, forKey: Key("PrivateDnsName"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: Key("PrivateIpAddress"))
        }
        if let privateIpAddresses = privateIpAddresses {
            if !privateIpAddresses.isEmpty {
                for (index0, networkinterfaceprivateipaddress0) in privateIpAddresses.enumerated() {
                    var privateIpAddressesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("PrivateIpAddressesSet.\(index0.advanced(by: 1))"))
                    try privateIpAddressesContainer0.encode(networkinterfaceprivateipaddress0, forKey: Key(""))
                }
            }
        }
        if let requesterId = requesterId {
            try container.encode(requesterId, forKey: Key("RequesterId"))
        }
        if requesterManaged != false {
            try container.encode(requesterManaged, forKey: Key("RequesterManaged"))
        }
        if sourceDestCheck != false {
            try container.encode(sourceDestCheck, forKey: Key("SourceDestCheck"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
        if let tagSet = tagSet {
            if !tagSet.isEmpty {
                for (index0, tag0) in tagSet.enumerated() {
                    var tagSetContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagSetContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDecoded = try containerValues.decodeIfPresent(NetworkInterfaceAssociation.self, forKey: .association)
        association = associationDecoded
        let attachmentDecoded = try containerValues.decodeIfPresent(NetworkInterfaceAttachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.groups) {
            struct KeyVal0{struct item{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([GroupIdentifier].self, forKey: .member)
                var groupsBuffer:[GroupIdentifier]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [GroupIdentifier]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let interfaceTypeDecoded = try containerValues.decodeIfPresent(NetworkInterfaceType.self, forKey: .interfaceType)
        interfaceType = interfaceTypeDecoded
        if containerValues.contains(.ipv6Addresses) {
            struct KeyVal0{struct item{}}
            let ipv6AddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6Addresses)
            if let ipv6AddressesWrappedContainer = ipv6AddressesWrappedContainer {
                let ipv6AddressesContainer = try ipv6AddressesWrappedContainer.decodeIfPresent([NetworkInterfaceIpv6Address].self, forKey: .member)
                var ipv6AddressesBuffer:[NetworkInterfaceIpv6Address]? = nil
                if let ipv6AddressesContainer = ipv6AddressesContainer {
                    ipv6AddressesBuffer = [NetworkInterfaceIpv6Address]()
                    for structureContainer0 in ipv6AddressesContainer {
                        ipv6AddressesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Addresses = ipv6AddressesBuffer
            } else {
                ipv6Addresses = []
            }
        } else {
            ipv6Addresses = nil
        }
        let macAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        if containerValues.contains(.privateIpAddresses) {
            struct KeyVal0{struct item{}}
            let privateIpAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .privateIpAddresses)
            if let privateIpAddressesWrappedContainer = privateIpAddressesWrappedContainer {
                let privateIpAddressesContainer = try privateIpAddressesWrappedContainer.decodeIfPresent([NetworkInterfacePrivateIpAddress].self, forKey: .member)
                var privateIpAddressesBuffer:[NetworkInterfacePrivateIpAddress]? = nil
                if let privateIpAddressesContainer = privateIpAddressesContainer {
                    privateIpAddressesBuffer = [NetworkInterfacePrivateIpAddress]()
                    for structureContainer0 in privateIpAddressesContainer {
                        privateIpAddressesBuffer?.append(structureContainer0)
                    }
                }
                privateIpAddresses = privateIpAddressesBuffer
            } else {
                privateIpAddresses = []
            }
        } else {
            privateIpAddresses = nil
        }
        let requesterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterId)
        requesterId = requesterIdDecoded
        let requesterManagedDecoded = try containerValues.decode(Bool.self, forKey: .requesterManaged)
        requesterManaged = requesterManagedDecoded
        let sourceDestCheckDecoded = try containerValues.decode(Bool.self, forKey: .sourceDestCheck)
        sourceDestCheck = sourceDestCheckDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NetworkInterfaceStatus.self, forKey: .status)
        status = statusDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct item{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagSetBuffer:[Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}
