// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GlobalAcceleratorClientTypes.Accelerator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipsets0 in ipSets {
                try ipSetsContainer.encode(ipsets0)
            }
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[GlobalAcceleratorClientTypes.IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [GlobalAcceleratorClientTypes.IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension GlobalAcceleratorClientTypes.Accelerator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Accelerator(acceleratorArn: \(Swift.String(describing: acceleratorArn)), createdTime: \(Swift.String(describing: createdTime)), dnsName: \(Swift.String(describing: dnsName)), enabled: \(Swift.String(describing: enabled)), ipAddressType: \(Swift.String(describing: ipAddressType)), ipSets: \(Swift.String(describing: ipSets)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>An accelerator is a complex type that includes one or more listeners that process inbound connections and then direct
    /// 			traffic to one or more endpoint groups, each of which includes endpoints, such as load balancers.</p>
    public struct Accelerator: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the accelerator.</p>
        public let acceleratorArn: Swift.String?
        /// <p>The date and time that the accelerator was created.</p>
        public let createdTime: ClientRuntime.Date?
        /// <p>The Domain Name System (DNS) name that Global Accelerator creates that points to your accelerator's static IP addresses. </p>
        /// 		       <p>The naming convention for the DNS name is the following: A lowercase letter a,
        /// 			followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example:
        /// 			a1234567890abcdef.awsglobalaccelerator.com.</p>
        /// 		       <p>For more information about the default DNS name, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-accelerators.html#about-accelerators.dns-addressing">
        /// 			Support for DNS Addressing in Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
        public let dnsName: Swift.String?
        /// <p>Indicates whether the accelerator is enabled. The value is true or false. The default value is true. </p>
        /// 		       <p>If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.</p>
        public let enabled: Swift.Bool?
        /// <p>The value for the address type must be IPv4.
        /// 			</p>
        public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// <p>The static IP addresses that Global Accelerator associates with the accelerator.</p>
        public let ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// <p>The date and time that the accelerator was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>The name of the accelerator. The name must contain only alphanumeric characters or
        /// 			hyphens (-), and must not begin or end with a hyphen.</p>
        public let name: Swift.String?
        /// <p>Describes the deployment status of the accelerator.</p>
        public let status: GlobalAcceleratorClientTypes.AcceleratorStatus?

        public init (
            acceleratorArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.AcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension GlobalAcceleratorClientTypes.AcceleratorAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension GlobalAcceleratorClientTypes.AcceleratorAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceleratorAttributes(flowLogsEnabled: \(Swift.String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(Swift.String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(Swift.String(describing: flowLogsS3Prefix)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>Attributes of an accelerator.</p>
    public struct AcceleratorAttributes: Swift.Equatable {
        /// <p>Indicates whether flow logs are enabled. The default value is false. If the value is true,
        /// 				<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
        /// 			the <i>AWS Global Accelerator Developer Guide</i>.</p>
        public let flowLogsEnabled: Swift.Bool?
        /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
        /// 				<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
        /// 			bucket.</p>
        public let flowLogsS3Bucket: Swift.String?
        /// <p>The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
        /// 				<code>FlowLogsEnabled</code> is <code>true</code>.</p>
        /// 		       <p>If you don’t specify a prefix, the flow logs are stored in the
        /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
        /// 		       <p>s3-bucket_name//AWSLogs/aws_account_id</p>
        public let flowLogsS3Prefix: Swift.String?

        public init (
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }

}

extension AcceleratorNotDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceleratorNotDisabledException(message: \(Swift.String(describing: message)))"}
}

extension AcceleratorNotDisabledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceleratorNotDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The accelerator that you specified could not be disabled.</p>
public struct AcceleratorNotDisabledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AcceleratorNotDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AcceleratorNotDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcceleratorNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceleratorNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension AcceleratorNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceleratorNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The accelerator that you specified doesn't exist.</p>
public struct AcceleratorNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AcceleratorNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AcceleratorNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum AcceleratorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceleratorStatus] {
            return [
                .deployed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceleratorStatus(rawValue: rawValue) ?? AcceleratorStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have access permission.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddCustomRoutingEndpointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCustomRoutingEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCustomRoutingEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCustomRoutingEndpointsOutputError>
}

extension AddCustomRoutingEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCustomRoutingEndpointsInput(endpointConfigurations: \(Swift.String(describing: endpointConfigurations)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)))"}
}

extension AddCustomRoutingEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for customroutingendpointconfigurations0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(customroutingendpointconfigurations0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct AddCustomRoutingEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCustomRoutingEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCustomRoutingEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCustomRoutingEndpointsOutputError>
}

public struct AddCustomRoutingEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCustomRoutingEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCustomRoutingEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCustomRoutingEndpointsOutputError>
}

public struct AddCustomRoutingEndpointsInput: Swift.Equatable {
    /// <p>The list of endpoint objects to add to a custom routing accelerator.</p>
    public let endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.</p>
    public let endpointGroupArn: Swift.String?

    public init (
        endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsInputBody: Swift.Equatable {
    public let endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]?
    public let endpointGroupArn: Swift.String?
}

extension AddCustomRoutingEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AddCustomRoutingEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCustomRoutingEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAlreadyExistsException" : self = .endpointAlreadyExistsException(try EndpointAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCustomRoutingEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointAlreadyExistsException(EndpointAlreadyExistsException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCustomRoutingEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCustomRoutingEndpointsOutputResponse(endpointDescriptions: \(Swift.String(describing: endpointDescriptions)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)))"}
}

extension AddCustomRoutingEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddCustomRoutingEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointDescriptions = output.endpointDescriptions
            self.endpointGroupArn = output.endpointGroupArn
        } else {
            self.endpointDescriptions = nil
            self.endpointGroupArn = nil
        }
    }
}

public struct AddCustomRoutingEndpointsOutputResponse: Swift.Equatable {
    /// <p>The endpoint objects added to the custom routing accelerator.</p>
    public let endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.</p>
    public let endpointGroupArn: Swift.String?

    public init (
        endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsOutputResponseBody: Swift.Equatable {
    public let endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
    public let endpointGroupArn: Swift.String?
}

extension AddCustomRoutingEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

public struct AdvertiseByoipCidrInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AdvertiseByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AdvertiseByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AdvertiseByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AdvertiseByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AdvertiseByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AdvertiseByoipCidrOutputError>
}

extension AdvertiseByoipCidrInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdvertiseByoipCidrInput(cidr: \(Swift.String(describing: cidr)))"}
}

extension AdvertiseByoipCidrInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

public struct AdvertiseByoipCidrInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AdvertiseByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AdvertiseByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AdvertiseByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AdvertiseByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AdvertiseByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AdvertiseByoipCidrOutputError>
}

public struct AdvertiseByoipCidrInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AdvertiseByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AdvertiseByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AdvertiseByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AdvertiseByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AdvertiseByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AdvertiseByoipCidrOutputError>
}

public struct AdvertiseByoipCidrInput: Swift.Equatable {
    /// <p>The address range, in CIDR notation. This must be the exact range that you provisioned.
    /// 			You can't advertise only a portion of the provisioned range.</p>
    public let cidr: Swift.String?

    public init (
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct AdvertiseByoipCidrInputBody: Swift.Equatable {
    public let cidr: Swift.String?
}

extension AdvertiseByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension AdvertiseByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdvertiseByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdvertiseByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdvertiseByoipCidrOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdvertiseByoipCidrOutputResponse(byoipCidr: \(Swift.String(describing: byoipCidr)))"}
}

extension AdvertiseByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AdvertiseByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct AdvertiseByoipCidrOutputResponse: Swift.Equatable {
    /// <p>Information about the address range.</p>
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct AdvertiseByoipCidrOutputResponseBody: Swift.Equatable {
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension AdvertiseByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

public struct AllowCustomRoutingTrafficInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AllowCustomRoutingTrafficInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AllowCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AllowCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AllowCustomRoutingTrafficInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AllowCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AllowCustomRoutingTrafficOutputError>
}

extension AllowCustomRoutingTrafficInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AllowCustomRoutingTrafficInput(allowAllTrafficToEndpoint: \(Swift.String(describing: allowAllTrafficToEndpoint)), destinationAddresses: \(Swift.String(describing: destinationAddresses)), destinationPorts: \(Swift.String(describing: destinationPorts)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), endpointId: \(Swift.String(describing: endpointId)))"}
}

extension AllowCustomRoutingTrafficInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAllTrafficToEndpoint = allowAllTrafficToEndpoint {
            try encodeContainer.encode(allowAllTrafficToEndpoint, forKey: .allowAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for destinationaddresses0 in destinationAddresses {
                try destinationAddressesContainer.encode(destinationaddresses0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for destinationports0 in destinationPorts {
                try destinationPortsContainer.encode(destinationports0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

public struct AllowCustomRoutingTrafficInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AllowCustomRoutingTrafficInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AllowCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AllowCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AllowCustomRoutingTrafficInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AllowCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AllowCustomRoutingTrafficOutputError>
}

public struct AllowCustomRoutingTrafficInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AllowCustomRoutingTrafficInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AllowCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AllowCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AllowCustomRoutingTrafficInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AllowCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AllowCustomRoutingTrafficOutputError>
}

public struct AllowCustomRoutingTrafficInput: Swift.Equatable {
    /// <p>Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint can receive traffic
    /// 			from a custom routing accelerator. The value is TRUE or FALSE. </p>
    /// 		       <p>When set to TRUE, <i>all</i> destinations in the custom routing VPC subnet can receive traffic. Note
    /// 			that you cannot specify destination IP addresses and ports when the value is set to TRUE.</p>
    /// 		       <p>When set to FALSE (or not specified), you <i>must</i> specify a list of destination IP addresses that are allowed
    /// 			to receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is
    /// 			the same as the ports configured for the endpoint group.</p>
    /// 		       <p>The default value is FALSE.</p>
    public let allowAllTrafficToEndpoint: Swift.Bool?
    /// <p>A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to allow to receive
    /// 			traffic. The IP addresses must be a subset of the IP addresses that you specified for the endpoint group.</p>
    /// 		       <p>
    ///             <code>DestinationAddresses</code> is required if <code>AllowAllTrafficToEndpoint</code> is <code>FALSE</code> or is
    /// 		not specified.</p>
    public let destinationAddresses: [Swift.String]?
    /// <p>A list of specific Amazon EC2 instance ports (destination ports) that you want to allow to receive traffic.</p>
    public let destinationPorts: [Swift.Int]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: Swift.String?
    /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.</p>
    public let endpointId: Swift.String?

    public init (
        allowAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.allowAllTrafficToEndpoint = allowAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct AllowCustomRoutingTrafficInputBody: Swift.Equatable {
    public let endpointGroupArn: Swift.String?
    public let endpointId: Swift.String?
    public let destinationAddresses: [Swift.String]?
    public let destinationPorts: [Swift.Int]?
    public let allowAllTrafficToEndpoint: Swift.Bool?
}

extension AllowCustomRoutingTrafficInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[Swift.String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [Swift.String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Swift.Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Swift.Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let allowAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAllTrafficToEndpoint)
        allowAllTrafficToEndpoint = allowAllTrafficToEndpointDecoded
    }
}

extension AllowCustomRoutingTrafficOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllowCustomRoutingTrafficOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AllowCustomRoutingTrafficOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllowCustomRoutingTrafficOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AllowCustomRoutingTrafficOutputResponse()"}
}

extension AllowCustomRoutingTrafficOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AllowCustomRoutingTrafficOutputResponse: Swift.Equatable {

    public init() {}
}

struct AllowCustomRoutingTrafficOutputResponseBody: Swift.Equatable {
}

extension AllowCustomRoutingTrafficOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociatedEndpointGroupFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatedEndpointGroupFoundException(message: \(Swift.String(describing: message)))"}
}

extension AssociatedEndpointGroupFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociatedEndpointGroupFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The listener that you specified has an endpoint group associated with it. You must remove all dependent resources
/// 			from a listener before you can delete it.</p>
public struct AssociatedEndpointGroupFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociatedEndpointGroupFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AssociatedEndpointGroupFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociatedListenerFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatedListenerFoundException(message: \(Swift.String(describing: message)))"}
}

extension AssociatedListenerFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociatedListenerFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The accelerator that you specified has a listener associated with it. You must remove all dependent resources from an
/// 			accelerator before you can delete it.</p>
public struct AssociatedListenerFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociatedListenerFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AssociatedListenerFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.ByoipCidr: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case events = "Events"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for byoipcidrevents0 in events {
                try eventsContainer.encode(byoipcidrevents0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidrState.self, forKey: .state)
        state = stateDecoded
        let eventsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ByoipCidrEvent?].self, forKey: .events)
        var eventsDecoded0:[GlobalAcceleratorClientTypes.ByoipCidrEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [GlobalAcceleratorClientTypes.ByoipCidrEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GlobalAcceleratorClientTypes.ByoipCidr: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByoipCidr(cidr: \(Swift.String(describing: cidr)), events: \(Swift.String(describing: events)), state: \(Swift.String(describing: state)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>Information about an IP address range that is provisioned for use with your AWS resources through
    /// 			bring your own IP address (BYOIP).</p>
    /// 		       <p>The following describes each BYOIP <code>State</code> that your IP address range can be in.</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <b>PENDING_PROVISIONING</b> —
    /// 				You’ve submitted a request to provision an IP address range but it is not yet provisioned with
    /// 				AWS Global Accelerator.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>READY</b> — The address range is provisioned
    /// 				with AWS Global Accelerator and can be advertised.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PENDING_ADVERTISING</b> — You’ve submitted a
    /// 				request for AWS Global Accelerator to advertise an address range but it is not yet being advertised.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ADVERTISING</b> — The address range is
    /// 				being advertised by AWS Global Accelerator.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PENDING_WITHDRAWING</b> — You’ve submitted
    /// 				a request to withdraw an address range from being advertised but it is still being advertised
    /// 				by AWS Global Accelerator.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PENDING_DEPROVISIONING</b> — You’ve submitted a
    /// 				request to deprovision an address range from AWS Global Accelerator but it is still provisioned.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>DEPROVISIONED</b> — The address range is deprovisioned
    /// 				from AWS Global Accelerator.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>FAILED_PROVISION </b> — The request to
    /// 				provision the address range from AWS Global Accelerator was not successful. Please make sure that
    /// 				you provide all of the correct information, and try again. If the request fails
    /// 				a second time, contact AWS support.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>FAILED_ADVERTISING</b> — The request for AWS Global Accelerator
    /// 				to advertise the address range was not successful. Please make sure that
    /// 				you provide all of the correct information, and try again. If the request fails
    /// 				a second time, contact AWS support.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>FAILED_WITHDRAW</b> — The request to withdraw
    /// 				the address range from advertising by AWS Global Accelerator was not successful. Please make sure that
    /// 				you provide all of the correct information, and try again. If the request fails
    /// 				a second time, contact AWS support.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>FAILED_DEPROVISION </b> — The request to
    /// 				deprovision the address range from AWS Global Accelerator was not successful. Please make sure that
    /// 				you provide all of the correct information, and try again. If the request fails
    /// 				a second time, contact AWS support.</p>
    ///             </li>
    ///          </ul>
    public struct ByoipCidr: Swift.Equatable {
        /// <p>The address range, in CIDR notation.</p>
        public let cidr: Swift.String?
        /// <p>A history of status changes for an IP address range that you bring to AWS Global Accelerator
        /// 			through bring your own IP address (BYOIP).</p>
        public let events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]?
        /// <p>The state of the address pool.</p>
        public let state: GlobalAcceleratorClientTypes.ByoipCidrState?

        public init (
            cidr: Swift.String? = nil,
            events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]? = nil,
            state: GlobalAcceleratorClientTypes.ByoipCidrState? = nil
        )
        {
            self.cidr = cidr
            self.events = events
            self.state = state
        }
    }

}

extension GlobalAcceleratorClientTypes.ByoipCidrEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GlobalAcceleratorClientTypes.ByoipCidrEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByoipCidrEvent(message: \(Swift.String(describing: message)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type that contains a <code>Message</code> and a <code>Timestamp</code> value for changes
    /// 			that you make in the status an IP address range that you bring to AWS Global Accelerator through bring your own IP
    /// 			address (BYOIP).</p>
    public struct ByoipCidrEvent: Swift.Equatable {
        /// <p>A string that contains an <code>Event</code> message describing changes that you make in the status
        /// 			of an IP address range that you bring to AWS Global Accelerator through bring your own IP address (BYOIP).</p>
        public let message: Swift.String?
        /// <p>A timestamp when you make a status change for an IP address range that you bring to AWS Global Accelerator through
        /// 			bring your own IP address (BYOIP).</p>
        public let timestamp: ClientRuntime.Date?

        public init (
            message: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.timestamp = timestamp
        }
    }

}

extension ByoipCidrNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByoipCidrNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ByoipCidrNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ByoipCidrNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CIDR that you specified was not found or is incorrect.</p>
public struct ByoipCidrNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ByoipCidrNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ByoipCidrNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum ByoipCidrState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advertising
        case deprovisioned
        case failedAdvertising
        case failedDeprovision
        case failedProvision
        case failedWithdraw
        case pendingAdvertising
        case pendingDeprovisioning
        case pendingProvisioning
        case pendingWithdrawing
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ByoipCidrState] {
            return [
                .advertising,
                .deprovisioned,
                .failedAdvertising,
                .failedDeprovision,
                .failedProvision,
                .failedWithdraw,
                .pendingAdvertising,
                .pendingDeprovisioning,
                .pendingProvisioning,
                .pendingWithdrawing,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advertising: return "ADVERTISING"
            case .deprovisioned: return "DEPROVISIONED"
            case .failedAdvertising: return "FAILED_ADVERTISING"
            case .failedDeprovision: return "FAILED_DEPROVISION"
            case .failedProvision: return "FAILED_PROVISION"
            case .failedWithdraw: return "FAILED_WITHDRAW"
            case .pendingAdvertising: return "PENDING_ADVERTISING"
            case .pendingDeprovisioning: return "PENDING_DEPROVISIONING"
            case .pendingProvisioning: return "PENDING_PROVISIONING"
            case .pendingWithdrawing: return "PENDING_WITHDRAWING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ByoipCidrState(rawValue: rawValue) ?? ByoipCidrState.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CidrAuthorizationContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case signature = "Signature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension GlobalAcceleratorClientTypes.CidrAuthorizationContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CidrAuthorizationContext(message: \(Swift.String(describing: message)), signature: \(Swift.String(describing: signature)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>Provides authorization for Amazon to bring a specific IP address range to a specific AWS
    /// 			account using bring your own IP addresses (BYOIP). </p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
    /// 			IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public struct CidrAuthorizationContext: Swift.Equatable {
        /// <p>The plain-text authorization message for the prefix and account.</p>
        public let message: Swift.String?
        /// <p>The signed authorization message for the prefix and account.</p>
        public let signature: Swift.String?

        public init (
            message: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.message = message
            self.signature = signature
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum ClientAffinity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sourceIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientAffinity] {
            return [
                .none,
                .sourceIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sourceIp: return "SOURCE_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientAffinity(rawValue: rawValue) ?? ClientAffinity.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't use both of those options.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAcceleratorOutputError>
}

extension CreateAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAcceleratorInput(enabled: \(Swift.String(describing: enabled)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), ipAddressType: \(Swift.String(describing: ipAddressType)), ipAddresses: \(Swift.String(describing: ipAddresses)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddresses0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddresses0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAcceleratorOutputError>
}

public struct CreateAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAcceleratorOutputError>
}

public struct CreateAcceleratorInput: Swift.Equatable {
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 		       <p>If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Swift.Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the
    /// 			uniqueness—of an accelerator.</p>
    public var idempotencyToken: Swift.String?
    /// <p>The value for the address type must be IPv4.</p>
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// <p>Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose IP addresses
    /// 			from your own pool to use for the accelerator's static IP addresses when you create an accelerator. You can
    /// 			specify one or two addresses, separated by a space. Do not include the /32 suffix.</p>
    /// 		       <p>Only one IP address from each of your IP address ranges can be used for each accelerator. If you specify only
    /// 			one IP address from your IP address range, Global Accelerator assigns a second static IP address for the
    /// 			accelerator from the AWS IP address pool.</p>
    /// 		       <p>Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new
    /// 			accelerator with the new addresses.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
    /// 			IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let ipAddresses: [Swift.String]?
    /// <p>The name of an accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
    /// 			hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: Swift.String?
    /// <p>Create tags for an accelerator.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
    /// 			in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateAcceleratorInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    public let ipAddresses: [Swift.String]?
    public let enabled: Swift.Bool?
    public let idempotencyToken: Swift.String?
    public let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension CreateAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAcceleratorOutputResponse(accelerator: \(Swift.String(describing: accelerator)))"}
}

extension CreateAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateAcceleratorOutputResponse: Swift.Equatable {
    /// <p>The accelerator that is created by specifying a listener and the supported IP address types.</p>
    public let accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateAcceleratorOutputResponseBody: Swift.Equatable {
    public let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension CreateAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct CreateCustomRoutingAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingAcceleratorOutputError>
}

extension CreateCustomRoutingAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomRoutingAcceleratorInput(enabled: \(Swift.String(describing: enabled)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), ipAddressType: \(Swift.String(describing: ipAddressType)), ipAddresses: \(Swift.String(describing: ipAddresses)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateCustomRoutingAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddresses0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddresses0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateCustomRoutingAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingAcceleratorOutputError>
}

public struct CreateCustomRoutingAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingAcceleratorOutputError>
}

public struct CreateCustomRoutingAcceleratorInput: Swift.Equatable {
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 	        <p>If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Swift.Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that
    /// 			is, the uniqueness—of the request.</p>
    public var idempotencyToken: Swift.String?
    /// <p>The value for the address type must be IPv4.</p>
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// <p>Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose IP addresses
    /// 				from your own pool to use for the accelerator's static IP addresses when you create an accelerator. You can
    /// 				specify one or two addresses, separated by a space. Do not include the /32 suffix.</p>
    /// 			      <p>Only one IP address from each of your IP address ranges can be used for each accelerator. If you specify only
    /// 				one IP address from your IP address range, Global Accelerator assigns a second static IP address for the
    /// 				accelerator from the AWS IP address pool.</p>
    /// 			      <p>Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new
    /// 				accelerator with the new addresses.</p>
    /// 			      <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring
    /// 				your own IP addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let ipAddresses: [Swift.String]?
    /// <p>The name of a custom routing accelerator. The name can have a maximum of 64 characters, must contain
    /// 		only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: Swift.String?
    /// <p>Create tags for an accelerator.</p>
    /// 	        <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
    /// 		in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateCustomRoutingAcceleratorInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    public let ipAddresses: [Swift.String]?
    public let enabled: Swift.Bool?
    public let idempotencyToken: Swift.String?
    public let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension CreateCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomRoutingAcceleratorOutputResponse(accelerator: \(Swift.String(describing: accelerator)))"}
}

extension CreateCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateCustomRoutingAcceleratorOutputResponse: Swift.Equatable {
    /// <p>The accelerator that is created.</p>
    public let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateCustomRoutingAcceleratorOutputResponseBody: Swift.Equatable {
    public let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension CreateCustomRoutingAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct CreateCustomRoutingEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingEndpointGroupOutputError>
}

extension CreateCustomRoutingEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomRoutingEndpointGroupInput(destinationConfigurations: \(Swift.String(describing: destinationConfigurations)), endpointGroupRegion: \(Swift.String(describing: endpointGroupRegion)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension CreateCustomRoutingEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for customroutingdestinationconfigurations0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(customroutingdestinationconfigurations0)
            }
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct CreateCustomRoutingEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingEndpointGroupOutputError>
}

public struct CreateCustomRoutingEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingEndpointGroupOutputError>
}

public struct CreateCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// <p>Sets the port range and protocol for all endpoints (virtual private cloud subnets) in a custom routing endpoint group to accept
    /// 		client traffic on.</p>
    public let destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]?
    /// <p>The AWS Region where the endpoint group is located. A listener can have only one endpoint group in a
    /// 		specific Region.</p>
    public let endpointGroupRegion: Swift.String?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the
    /// 		uniqueness—of the request.</p>
    public var idempotencyToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the listener for a custom routing endpoint.</p>
    public let listenerArn: Swift.String?

    public init (
        destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil
    )
    {
        self.destinationConfigurations = destinationConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
    }
}

struct CreateCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
    public let endpointGroupRegion: Swift.String?
    public let destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]?
    public let idempotencyToken: Swift.String?
}

extension CreateCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupAlreadyExistsException" : self = .endpointGroupAlreadyExistsException(try EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomRoutingEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case endpointGroupAlreadyExistsException(EndpointGroupAlreadyExistsException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomRoutingEndpointGroupOutputResponse(endpointGroup: \(Swift.String(describing: endpointGroup)))"}
}

extension CreateCustomRoutingEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomRoutingEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateCustomRoutingEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>The information about the endpoint group created for a custom routing accelerator.</p>
    public let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateCustomRoutingEndpointGroupOutputResponseBody: Swift.Equatable {
    public let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?
}

extension CreateCustomRoutingEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct CreateCustomRoutingListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingListenerOutputError>
}

extension CreateCustomRoutingListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomRoutingListenerInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), portRanges: \(Swift.String(describing: portRanges)))"}
}

extension CreateCustomRoutingListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
    }
}

public struct CreateCustomRoutingListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingListenerOutputError>
}

public struct CreateCustomRoutingListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomRoutingListenerOutputError>
}

public struct CreateCustomRoutingListenerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator for a custom routing listener.</p>
    public let acceleratorArn: Swift.String?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the
    /// 		uniqueness—of the request.</p>
    public var idempotencyToken: Swift.String?
    /// <p>The port range to support for connections from clients to your accelerator.</p>
    /// 	        <p>Separately, you set port ranges for endpoints. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html">About
    /// 		endpoints for custom routing accelerators</a>.</p>
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init (
        acceleratorArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
    }
}

struct CreateCustomRoutingListenerInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    public let idempotencyToken: Swift.String?
}

extension CreateCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomRoutingListenerOutputResponse(listener: \(Swift.String(describing: listener)))"}
}

extension CreateCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateCustomRoutingListenerOutputResponse: Swift.Equatable {
    /// <p>The listener that you've created for a custom routing accelerator.</p>
    public let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init (
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateCustomRoutingListenerOutputResponseBody: Swift.Equatable {
    public let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension CreateCustomRoutingListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct CreateEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointGroupOutputError>
}

extension CreateEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointGroupInput(endpointConfigurations: \(Swift.String(describing: endpointConfigurations)), endpointGroupRegion: \(Swift.String(describing: endpointGroupRegion)), healthCheckIntervalSeconds: \(Swift.String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(Swift.String(describing: healthCheckPath)), healthCheckPort: \(Swift.String(describing: healthCheckPort)), healthCheckProtocol: \(Swift.String(describing: healthCheckProtocol)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), listenerArn: \(Swift.String(describing: listenerArn)), portOverrides: \(Swift.String(describing: portOverrides)), thresholdCount: \(Swift.String(describing: thresholdCount)), trafficDialPercentage: \(Swift.String(describing: trafficDialPercentage)))"}
}

extension CreateEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfigurations0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfigurations0)
            }
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverrides0 in portOverrides {
                try portOverridesContainer.encode(portoverrides0)
            }
        }
        if let thresholdCount = thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

public struct CreateEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointGroupOutputError>
}

public struct CreateEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEndpointGroupOutputError>
}

public struct CreateEndpointGroupInput: Swift.Equatable {
    /// <p>The list of endpoint objects.</p>
    public let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// <p>The AWS Region where the endpoint group is located. A listener can have only one endpoint group in a
    /// 			specific Region.</p>
    public let endpointGroupRegion: Swift.String?
    /// <p>The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.</p>
    public let healthCheckIntervalSeconds: Swift.Int?
    /// <p>If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The
    /// 			default value is slash (/).</p>
    public let healthCheckPath: Swift.String?
    /// <p>The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port
    /// 			is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the
    /// 			first port in the list.</p>
    public let healthCheckPort: Swift.Int?
    /// <p>The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default
    /// 			value is TCP.</p>
    public let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the
    /// 			uniqueness—of the request.</p>
    public var idempotencyToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of this endpoint group.
    /// 			For example, you can create a port override in which the listener
    /// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
    /// 			and 1443, respectively, on the endpoints.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html">
    /// 			Port overrides</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
    /// 			unhealthy endpoint to healthy. The default value is 3.</p>
    public let thresholdCount: Swift.Int?
    /// <p>The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
    /// 			this listener. </p>
    /// 		       <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
    /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// 		       <p>The default value is 100.</p>
    public let trafficDialPercentage: Swift.Float?

    public init (
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct CreateEndpointGroupInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
    public let endpointGroupRegion: Swift.String?
    public let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    public let trafficDialPercentage: Swift.Float?
    public let healthCheckPort: Swift.Int?
    public let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    public let healthCheckPath: Swift.String?
    public let healthCheckIntervalSeconds: Swift.Int?
    public let thresholdCount: Swift.Int?
    public let idempotencyToken: Swift.String?
    public let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
}

extension CreateEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension CreateEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupAlreadyExistsException" : self = .endpointGroupAlreadyExistsException(try EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case endpointGroupAlreadyExistsException(EndpointGroupAlreadyExistsException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointGroupOutputResponse(endpointGroup: \(Swift.String(describing: endpointGroup)))"}
}

extension CreateEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>The information about the endpoint group that was created.</p>
    public let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateEndpointGroupOutputResponseBody: Swift.Equatable {
    public let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension CreateEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct CreateListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateListenerOutputError>
}

extension CreateListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateListenerInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), clientAffinity: \(Swift.String(describing: clientAffinity)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), portRanges: \(Swift.String(describing: portRanges)), protocol: \(Swift.String(describing: `protocol`)))"}
}

extension CreateListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let clientAffinity = clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

public struct CreateListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateListenerOutputError>
}

public struct CreateListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateListenerOutputError>
}

public struct CreateListenerInput: Swift.Equatable {
    /// <p>The protocol for connections from clients to your accelerator.</p>
    public let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    /// <p>The Amazon Resource Name (ARN) of your accelerator.</p>
    public let acceleratorArn: Swift.String?
    /// <p>Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
    /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
    /// 			route each client to the same specific endpoint.</p>
    /// 		       <p>AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
    /// 			affinity is <code>NONE</code>, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port,
    /// 			destination IP address, destination port, and protocol—to select the hash value, and then chooses the best
    /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
    /// 			be always routed to the same endpoint because the hash value changes. </p>
    /// 		       <p>If you want a given client to always be routed to the same endpoint, set client affinity to <code>SOURCE_IP</code>
    /// 			instead. When you use the <code>SOURCE_IP</code> setting, Global Accelerator uses the "two-tuple" (2-tuple) properties—
    /// 			source (client) IP address and destination IP address—to select the hash value.</p>
    /// 		       <p>The default value is <code>NONE</code>.</p>
    public let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the
    /// 			uniqueness—of the request.</p>
    public var idempotencyToken: Swift.String?
    /// <p>The list of port ranges to support for connections from clients to your accelerator.</p>
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init (
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil,
        acceleratorArn: Swift.String? = nil,
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.`protocol` = `protocol`
        self.acceleratorArn = acceleratorArn
        self.clientAffinity = clientAffinity
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
    }
}

struct CreateListenerInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    public let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    public let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    public let idempotencyToken: Swift.String?
}

extension CreateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateListenerOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateListenerOutputResponse(listener: \(Swift.String(describing: listener)))"}
}

extension CreateListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateListenerOutputResponse: Swift.Equatable {
    /// <p>The listener that you've created.</p>
    public let listener: GlobalAcceleratorClientTypes.Listener?

    public init (
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateListenerOutputResponseBody: Swift.Equatable {
    public let listener: GlobalAcceleratorClientTypes.Listener?
}

extension CreateListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingAccelerator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipsets0 in ipSets {
                try ipSetsContainer.encode(ipsets0)
            }
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[GlobalAcceleratorClientTypes.IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [GlobalAcceleratorClientTypes.IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingAccelerator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingAccelerator(acceleratorArn: \(Swift.String(describing: acceleratorArn)), createdTime: \(Swift.String(describing: createdTime)), dnsName: \(Swift.String(describing: dnsName)), enabled: \(Swift.String(describing: enabled)), ipAddressType: \(Swift.String(describing: ipAddressType)), ipSets: \(Swift.String(describing: ipSets)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>Attributes of a custom routing accelerator.</p>
    public struct CustomRoutingAccelerator: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator.</p>
        public let acceleratorArn: Swift.String?
        /// <p>The date and time that the accelerator was created.</p>
        public let createdTime: ClientRuntime.Date?
        /// <p>The Domain Name System (DNS) name that Global Accelerator creates that points to your accelerator's static IP addresses. </p>
        /// 		       <p>The naming convention for the DNS name is the following: A lowercase letter a,
        /// 			followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example:
        /// 			a1234567890abcdef.awsglobalaccelerator.com.</p>
        /// 		       <p>For more information about the default DNS name, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-accelerators.html#about-accelerators.dns-addressing">
        /// 			Support for DNS Addressing in Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
        public let dnsName: Swift.String?
        /// <p>Indicates whether the accelerator is enabled. The value is true or false. The default value is true. </p>
        /// 		       <p>If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.</p>
        public let enabled: Swift.Bool?
        /// <p>The value for the address type must be IPv4.</p>
        public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// <p>The static IP addresses that Global Accelerator associates with the accelerator.</p>
        public let ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// <p>The date and time that the accelerator was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>The name of the accelerator. The name must contain only alphanumeric characters or
        /// 			hyphens (-), and must not begin or end with a hyphen.</p>
        public let name: Swift.String?
        /// <p>Describes the deployment status of the accelerator.</p>
        public let status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus?

        public init (
            acceleratorArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingAcceleratorAttributes(flowLogsEnabled: \(Swift.String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(Swift.String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(Swift.String(describing: flowLogsS3Prefix)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>Attributes of a custom routing accelerator.</p>
    public struct CustomRoutingAcceleratorAttributes: Swift.Equatable {
        /// <p>Indicates whether flow logs are enabled. The default value is false. If the value is true,
        /// 			<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
        /// 			the <i>AWS Global Accelerator Developer Guide</i>.</p>
        public let flowLogsEnabled: Swift.Bool?
        /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
        /// 			<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
        /// 			bucket.</p>
        public let flowLogsS3Bucket: Swift.String?
        /// <p>The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
        /// 			<code>FlowLogsEnabled</code> is <code>true</code>.</p>
        /// 		       <p>If you don’t specify a prefix, the flow logs are stored in the
        /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
        /// 		       <p>DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id</p>
        public let flowLogsS3Prefix: Swift.String?

        public init (
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingAcceleratorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingAcceleratorStatus] {
            return [
                .deployed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingAcceleratorStatus(rawValue: rawValue) ?? CustomRoutingAcceleratorStatus.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocols0 in protocols {
                try protocolsContainer.encode(customroutingprotocols0.rawValue)
            }
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingDestinationConfiguration(fromPort: \(Swift.String(describing: fromPort)), protocols: \(Swift.String(describing: protocols)), toPort: \(Swift.String(describing: toPort)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>For a custom routing accelerator, sets the port range and protocol for all endpoints (virtual
    /// 			private cloud subnets) in an endpoint group to accept client traffic on.</p>
    public struct CustomRoutingDestinationConfiguration: Swift.Equatable {
        /// <p>The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
        public let fromPort: Swift.Int?
        /// <p>The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.</p>
        public let protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?
        /// <p>The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
        public let toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.ModelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingDestinationDescription(fromPort: \(Swift.String(describing: fromPort)), protocols: \(Swift.String(describing: protocols)), toPort: \(Swift.String(describing: toPort)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>For a custom routing accelerator, describes the port range and protocol for all endpoints
    /// 			(virtual private cloud subnets) in an endpoint group to accept client traffic on.</p>
    public struct CustomRoutingDestinationDescription: Swift.Equatable {
        /// <p>The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
        public let fromPort: Swift.Int?
        /// <p>The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.</p>
        public let protocols: [GlobalAcceleratorClientTypes.ModelProtocol]?
        /// <p>The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
        public let toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.ModelProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingDestinationTrafficState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingDestinationTrafficState] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingDestinationTrafficState(rawValue: rawValue) ?? CustomRoutingDestinationTrafficState.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingEndpointConfiguration(endpointId: \(Swift.String(describing: endpointId)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>The list of endpoint objects. For custom routing, this is a list of virtual private cloud (VPC) subnet IDs.</p>
    public struct CustomRoutingEndpointConfiguration: Swift.Equatable {
        /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC)
        /// 			subnet ID. </p>
        public let endpointId: Swift.String?

        public init (
            endpointId: Swift.String? = nil
        )
        {
            self.endpointId = endpointId
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingEndpointDescription(endpointId: \(Swift.String(describing: endpointId)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for an endpoint for a custom routing accelerator. Each endpoint group can include one or more endpoints,
    /// 			which are virtual private cloud (VPC) subnets.</p>
    public struct CustomRoutingEndpointDescription: Swift.Equatable {
        /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC)
        /// 			subnet ID. </p>
        public let endpointId: Swift.String?

        public init (
            endpointId: Swift.String? = nil
        )
        {
            self.endpointId = endpointId
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationDescriptions = "DestinationDescriptions"
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDescriptions = destinationDescriptions {
            var destinationDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationDescriptions)
            for customroutingdestinationdescriptions0 in destinationDescriptions {
                try destinationDescriptionsContainer.encode(customroutingdestinationdescriptions0)
            }
        }
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for customroutingendpointdescriptions0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(customroutingendpointdescriptions0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription?].self, forKey: .destinationDescriptions)
        var destinationDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]? = nil
        if let destinationDescriptionsContainer = destinationDescriptionsContainer {
            destinationDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]()
            for structure0 in destinationDescriptionsContainer {
                if let structure0 = structure0 {
                    destinationDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        destinationDescriptions = destinationDescriptionsDecoded0
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingEndpointGroup(destinationDescriptions: \(Swift.String(describing: destinationDescriptions)), endpointDescriptions: \(Swift.String(describing: endpointDescriptions)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), endpointGroupRegion: \(Swift.String(describing: endpointGroupRegion)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for the endpoint group for a custom routing accelerator. An AWS Region can have only one endpoint group for a specific listener.
    /// 		</p>
    public struct CustomRoutingEndpointGroup: Swift.Equatable {
        /// <p>For a custom routing accelerator, describes the port range and protocol for all endpoints
        /// 			(virtual private cloud subnets) in an endpoint group to accept client traffic on.</p>
        public let destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]?
        /// <p>For a custom routing accelerator, describes the endpoints (virtual private cloud subnets) in an
        /// 			endpoint group to accept client traffic on.</p>
        public let endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
        /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
        public let endpointGroupArn: Swift.String?
        /// <p>The AWS Region where the endpoint group is located.</p>
        public let endpointGroupRegion: Swift.String?

        public init (
            destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]? = nil,
            endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil
        )
        {
            self.destinationDescriptions = destinationDescriptions
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingListener: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingListener: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomRoutingListener(listenerArn: \(Swift.String(describing: listenerArn)), portRanges: \(Swift.String(describing: portRanges)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for a listener for a custom routing accelerator.</p>
    public struct CustomRoutingListener: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        public let listenerArn: Swift.String?
        /// <p>The port range to support for connections from clients to your accelerator.</p>
        /// 		       <p>Separately, you set port ranges for endpoints. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html">About
        /// 				endpoints for custom routing accelerators</a>.</p>
        public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?

        public init (
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
        )
        {
            self.listenerArn = listenerArn
            self.portRanges = portRanges
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingProtocol(rawValue: rawValue) ?? CustomRoutingProtocol.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAcceleratorOutputError>
}

extension DeleteAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAcceleratorInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)))"}
}

extension DeleteAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DeleteAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAcceleratorOutputError>
}

public struct DeleteAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAcceleratorOutputError>
}

public struct DeleteAcceleratorInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of an accelerator.</p>
    public let acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteAcceleratorInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
}

extension DeleteAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotDisabledException" : self = .acceleratorNotDisabledException(try AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociatedListenerFoundException" : self = .associatedListenerFoundException(try AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotDisabledException(AcceleratorNotDisabledException)
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case associatedListenerFoundException(AssociatedListenerFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAcceleratorOutputResponse()"}
}

extension DeleteAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAcceleratorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAcceleratorOutputResponseBody: Swift.Equatable {
}

extension DeleteAcceleratorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteCustomRoutingAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingAcceleratorOutputError>
}

extension DeleteCustomRoutingAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomRoutingAcceleratorInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)))"}
}

extension DeleteCustomRoutingAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DeleteCustomRoutingAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingAcceleratorOutputError>
}

public struct DeleteCustomRoutingAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingAcceleratorOutputError>
}

public struct DeleteCustomRoutingAcceleratorInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator to delete.</p>
    public let acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteCustomRoutingAcceleratorInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
}

extension DeleteCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotDisabledException" : self = .acceleratorNotDisabledException(try AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociatedListenerFoundException" : self = .associatedListenerFoundException(try AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotDisabledException(AcceleratorNotDisabledException)
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case associatedListenerFoundException(AssociatedListenerFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomRoutingAcceleratorOutputResponse()"}
}

extension DeleteCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingAcceleratorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCustomRoutingAcceleratorOutputResponseBody: Swift.Equatable {
}

extension DeleteCustomRoutingAcceleratorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteCustomRoutingEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingEndpointGroupOutputError>
}

extension DeleteCustomRoutingEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomRoutingEndpointGroupInput(endpointGroupArn: \(Swift.String(describing: endpointGroupArn)))"}
}

extension DeleteCustomRoutingEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DeleteCustomRoutingEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingEndpointGroupOutputError>
}

public struct DeleteCustomRoutingEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingEndpointGroupOutputError>
}

public struct DeleteCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to delete.</p>
    public let endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    public let endpointGroupArn: Swift.String?
}

extension DeleteCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomRoutingEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomRoutingEndpointGroupOutputResponse()"}
}

extension DeleteCustomRoutingEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingEndpointGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCustomRoutingEndpointGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteCustomRoutingEndpointGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteCustomRoutingListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingListenerOutputError>
}

extension DeleteCustomRoutingListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomRoutingListenerInput(listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension DeleteCustomRoutingListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DeleteCustomRoutingListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingListenerOutputError>
}

public struct DeleteCustomRoutingListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomRoutingListenerOutputError>
}

public struct DeleteCustomRoutingListenerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to delete.</p>
    public let listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteCustomRoutingListenerInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
}

extension DeleteCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociatedEndpointGroupFoundException" : self = .associatedEndpointGroupFoundException(try AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case associatedEndpointGroupFoundException(AssociatedEndpointGroupFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomRoutingListenerOutputResponse()"}
}

extension DeleteCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingListenerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCustomRoutingListenerOutputResponseBody: Swift.Equatable {
}

extension DeleteCustomRoutingListenerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointGroupOutputError>
}

extension DeleteEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointGroupInput(endpointGroupArn: \(Swift.String(describing: endpointGroupArn)))"}
}

extension DeleteEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DeleteEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointGroupOutputError>
}

public struct DeleteEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointGroupOutputError>
}

public struct DeleteEndpointGroupInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to delete.</p>
    public let endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteEndpointGroupInputBody: Swift.Equatable {
    public let endpointGroupArn: Swift.String?
}

extension DeleteEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointGroupOutputResponse()"}
}

extension DeleteEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEndpointGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteEndpointGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteListenerOutputError>
}

extension DeleteListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteListenerInput(listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension DeleteListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DeleteListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteListenerInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
}

extension DeleteListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociatedEndpointGroupFoundException" : self = .associatedEndpointGroupFoundException(try AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteListenerOutputError: Swift.Error, Swift.Equatable {
    case associatedEndpointGroupFoundException(AssociatedEndpointGroupFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteListenerOutputResponse()"}
}

extension DeleteListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteListenerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteListenerOutputResponseBody: Swift.Equatable {
}

extension DeleteListenerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DenyCustomRoutingTrafficInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DenyCustomRoutingTrafficInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DenyCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DenyCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DenyCustomRoutingTrafficInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DenyCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DenyCustomRoutingTrafficOutputError>
}

extension DenyCustomRoutingTrafficInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DenyCustomRoutingTrafficInput(denyAllTrafficToEndpoint: \(Swift.String(describing: denyAllTrafficToEndpoint)), destinationAddresses: \(Swift.String(describing: destinationAddresses)), destinationPorts: \(Swift.String(describing: destinationPorts)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), endpointId: \(Swift.String(describing: endpointId)))"}
}

extension DenyCustomRoutingTrafficInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let denyAllTrafficToEndpoint = denyAllTrafficToEndpoint {
            try encodeContainer.encode(denyAllTrafficToEndpoint, forKey: .denyAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for destinationaddresses0 in destinationAddresses {
                try destinationAddressesContainer.encode(destinationaddresses0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for destinationports0 in destinationPorts {
                try destinationPortsContainer.encode(destinationports0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

public struct DenyCustomRoutingTrafficInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DenyCustomRoutingTrafficInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DenyCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DenyCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DenyCustomRoutingTrafficInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DenyCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DenyCustomRoutingTrafficOutputError>
}

public struct DenyCustomRoutingTrafficInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DenyCustomRoutingTrafficInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DenyCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DenyCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DenyCustomRoutingTrafficInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DenyCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DenyCustomRoutingTrafficOutputError>
}

public struct DenyCustomRoutingTrafficInput: Swift.Equatable {
    /// <p>Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint <i>cannot</i>
    /// 			receive traffic from a custom routing accelerator. The value is TRUE or FALSE. </p>
    /// 		       <p>When set to TRUE, <i>no</i> destinations in the custom routing VPC subnet can receive traffic. Note
    /// 			that you cannot specify destination IP addresses and ports when the value is set to TRUE.</p>
    /// 		       <p>When set to FALSE (or not specified), you <i>must</i> specify a list of destination IP addresses that cannot receive
    /// 			traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is
    /// 			the same as the ports configured for the endpoint group.</p>
    /// 		       <p>The default value is FALSE.</p>
    public let denyAllTrafficToEndpoint: Swift.Bool?
    /// <p>A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to prevent from receiving
    /// 			traffic. The IP addresses must be a subset of the IP addresses allowed for the VPC subnet associated with the
    /// 			endpoint group.</p>
    public let destinationAddresses: [Swift.String]?
    /// <p>A list of specific Amazon EC2 instance ports (destination ports) in a subnet endpoint that you want to prevent from
    /// 			receiving traffic.</p>
    public let destinationPorts: [Swift.Int]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: Swift.String?
    /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.</p>
    public let endpointId: Swift.String?

    public init (
        denyAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.denyAllTrafficToEndpoint = denyAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct DenyCustomRoutingTrafficInputBody: Swift.Equatable {
    public let endpointGroupArn: Swift.String?
    public let endpointId: Swift.String?
    public let destinationAddresses: [Swift.String]?
    public let destinationPorts: [Swift.Int]?
    public let denyAllTrafficToEndpoint: Swift.Bool?
}

extension DenyCustomRoutingTrafficInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[Swift.String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [Swift.String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Swift.Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Swift.Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let denyAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .denyAllTrafficToEndpoint)
        denyAllTrafficToEndpoint = denyAllTrafficToEndpointDecoded
    }
}

extension DenyCustomRoutingTrafficOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DenyCustomRoutingTrafficOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DenyCustomRoutingTrafficOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DenyCustomRoutingTrafficOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DenyCustomRoutingTrafficOutputResponse()"}
}

extension DenyCustomRoutingTrafficOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DenyCustomRoutingTrafficOutputResponse: Swift.Equatable {

    public init() {}
}

struct DenyCustomRoutingTrafficOutputResponseBody: Swift.Equatable {
}

extension DenyCustomRoutingTrafficOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeprovisionByoipCidrInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeprovisionByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeprovisionByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeprovisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeprovisionByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeprovisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeprovisionByoipCidrOutputError>
}

extension DeprovisionByoipCidrInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeprovisionByoipCidrInput(cidr: \(Swift.String(describing: cidr)))"}
}

extension DeprovisionByoipCidrInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

public struct DeprovisionByoipCidrInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeprovisionByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeprovisionByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeprovisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeprovisionByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeprovisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeprovisionByoipCidrOutputError>
}

public struct DeprovisionByoipCidrInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeprovisionByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeprovisionByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeprovisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeprovisionByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeprovisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeprovisionByoipCidrOutputError>
}

public struct DeprovisionByoipCidrInput: Swift.Equatable {
    /// <p>The address range, in CIDR notation. The prefix must be the same prefix that you specified
    /// 			when you provisioned the address range.</p>
    public let cidr: Swift.String?

    public init (
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct DeprovisionByoipCidrInputBody: Swift.Equatable {
    public let cidr: Swift.String?
}

extension DeprovisionByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension DeprovisionByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprovisionByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeprovisionByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprovisionByoipCidrOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeprovisionByoipCidrOutputResponse(byoipCidr: \(Swift.String(describing: byoipCidr)))"}
}

extension DeprovisionByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeprovisionByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct DeprovisionByoipCidrOutputResponse: Swift.Equatable {
    /// <p>Information about the address range.</p>
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct DeprovisionByoipCidrOutputResponseBody: Swift.Equatable {
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension DeprovisionByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

public struct DescribeAcceleratorAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAcceleratorAttributesOutputError>
}

extension DescribeAcceleratorAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAcceleratorAttributesInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)))"}
}

extension DescribeAcceleratorAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeAcceleratorAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAcceleratorAttributesOutputError>
}

public struct DescribeAcceleratorAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAcceleratorAttributesOutputError>
}

public struct DescribeAcceleratorAttributesInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator with the attributes that you want to describe.</p>
    public let acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorAttributesInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
}

extension DescribeAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAcceleratorAttributesOutputResponse(acceleratorAttributes: \(Swift.String(describing: acceleratorAttributes)))"}
}

extension DescribeAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// <p>The attributes of the accelerator.</p>
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?
}

extension DescribeAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct DescribeAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAcceleratorOutputError>
}

extension DescribeAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAcceleratorInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)))"}
}

extension DescribeAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAcceleratorOutputError>
}

public struct DescribeAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAcceleratorOutputError>
}

public struct DescribeAcceleratorInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to describe.</p>
    public let acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
}

extension DescribeAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAcceleratorOutputResponse(accelerator: \(Swift.String(describing: accelerator)))"}
}

extension DescribeAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeAcceleratorOutputResponse: Swift.Equatable {
    /// <p>The description of the accelerator.</p>
    public let accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeAcceleratorOutputResponseBody: Swift.Equatable {
    public let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension DescribeAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingAcceleratorAttributesOutputError>
}

extension DescribeCustomRoutingAcceleratorAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingAcceleratorAttributesInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)))"}
}

extension DescribeCustomRoutingAcceleratorAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingAcceleratorAttributesOutputError>
}

public struct DescribeCustomRoutingAcceleratorAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingAcceleratorAttributesOutputError>
}

public struct DescribeCustomRoutingAcceleratorAttributesInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator to describe the attributes for.</p>
    public let acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorAttributesInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
}

extension DescribeCustomRoutingAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingAcceleratorAttributesOutputResponse(acceleratorAttributes: \(Swift.String(describing: acceleratorAttributes)))"}
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomRoutingAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// <p>The attributes of the custom routing accelerator.</p>
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct DescribeCustomRoutingAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingAcceleratorOutputError>
}

extension DescribeCustomRoutingAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingAcceleratorInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)))"}
}

extension DescribeCustomRoutingAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeCustomRoutingAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingAcceleratorOutputError>
}

public struct DescribeCustomRoutingAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingAcceleratorOutputError>
}

public struct DescribeCustomRoutingAcceleratorInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to describe.</p>
    public let acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
}

extension DescribeCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingAcceleratorOutputResponse(accelerator: \(Swift.String(describing: accelerator)))"}
}

extension DescribeCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorOutputResponse: Swift.Equatable {
    /// <p>The description of the custom routing accelerator.</p>
    public let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeCustomRoutingAcceleratorOutputResponseBody: Swift.Equatable {
    public let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension DescribeCustomRoutingAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct DescribeCustomRoutingEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingEndpointGroupOutputError>
}

extension DescribeCustomRoutingEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingEndpointGroupInput(endpointGroupArn: \(Swift.String(describing: endpointGroupArn)))"}
}

extension DescribeCustomRoutingEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DescribeCustomRoutingEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingEndpointGroupOutputError>
}

public struct DescribeCustomRoutingEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingEndpointGroupOutputError>
}

public struct DescribeCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to describe.</p>
    public let endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    public let endpointGroupArn: Swift.String?
}

extension DescribeCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingEndpointGroupOutputResponse(endpointGroup: \(Swift.String(describing: endpointGroup)))"}
}

extension DescribeCustomRoutingEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomRoutingEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeCustomRoutingEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>The description of an endpoint group for a custom routing accelerator.</p>
    public let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeCustomRoutingEndpointGroupOutputResponseBody: Swift.Equatable {
    public let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?
}

extension DescribeCustomRoutingEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct DescribeCustomRoutingListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingListenerOutputError>
}

extension DescribeCustomRoutingListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingListenerInput(listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension DescribeCustomRoutingListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DescribeCustomRoutingListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingListenerOutputError>
}

public struct DescribeCustomRoutingListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomRoutingListenerOutputError>
}

public struct DescribeCustomRoutingListenerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to describe.</p>
    public let listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeCustomRoutingListenerInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
}

extension DescribeCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomRoutingListenerOutputResponse(listener: \(Swift.String(describing: listener)))"}
}

extension DescribeCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeCustomRoutingListenerOutputResponse: Swift.Equatable {
    /// <p>The description of a listener for a custom routing accelerator.</p>
    public let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init (
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeCustomRoutingListenerOutputResponseBody: Swift.Equatable {
    public let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension DescribeCustomRoutingListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct DescribeEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointGroupOutputError>
}

extension DescribeEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointGroupInput(endpointGroupArn: \(Swift.String(describing: endpointGroupArn)))"}
}

extension DescribeEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DescribeEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointGroupOutputError>
}

public struct DescribeEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointGroupOutputError>
}

public struct DescribeEndpointGroupInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to describe.</p>
    public let endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeEndpointGroupInputBody: Swift.Equatable {
    public let endpointGroupArn: Swift.String?
}

extension DescribeEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointGroupOutputResponse(endpointGroup: \(Swift.String(describing: endpointGroup)))"}
}

extension DescribeEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>The description of an endpoint group.</p>
    public let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeEndpointGroupOutputResponseBody: Swift.Equatable {
    public let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension DescribeEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct DescribeListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenerOutputError>
}

extension DescribeListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeListenerInput(listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension DescribeListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DescribeListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenerOutputError>
}

public struct DescribeListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenerOutputError>
}

public struct DescribeListenerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to describe.</p>
    public let listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeListenerInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
}

extension DescribeListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeListenerOutputResponse(listener: \(Swift.String(describing: listener)))"}
}

extension DescribeListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeListenerOutputResponse: Swift.Equatable {
    /// <p>The description of a listener.</p>
    public let listener: GlobalAcceleratorClientTypes.Listener?

    public init (
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeListenerOutputResponseBody: Swift.Equatable {
    public let listener: GlobalAcceleratorClientTypes.Listener?
}

extension DescribeListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension GlobalAcceleratorClientTypes.DestinationPortMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case acceleratorSocketAddresses = "AcceleratorSocketAddresses"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case endpointId = "EndpointId"
        case ipAddressType = "IpAddressType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let acceleratorSocketAddresses = acceleratorSocketAddresses {
            var acceleratorSocketAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorSocketAddresses)
            for socketaddresses0 in acceleratorSocketAddresses {
                try acceleratorSocketAddressesContainer.encode(socketaddresses0)
            }
        }
        if let destinationSocketAddress = destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let acceleratorSocketAddressesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.SocketAddress?].self, forKey: .acceleratorSocketAddresses)
        var acceleratorSocketAddressesDecoded0:[GlobalAcceleratorClientTypes.SocketAddress]? = nil
        if let acceleratorSocketAddressesContainer = acceleratorSocketAddressesContainer {
            acceleratorSocketAddressesDecoded0 = [GlobalAcceleratorClientTypes.SocketAddress]()
            for structure0 in acceleratorSocketAddressesContainer {
                if let structure0 = structure0 {
                    acceleratorSocketAddressesDecoded0?.append(structure0)
                }
            }
        }
        acceleratorSocketAddresses = acceleratorSocketAddressesDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension GlobalAcceleratorClientTypes.DestinationPortMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DestinationPortMapping(acceleratorArn: \(Swift.String(describing: acceleratorArn)), acceleratorSocketAddresses: \(Swift.String(describing: acceleratorSocketAddresses)), destinationSocketAddress: \(Swift.String(describing: destinationSocketAddress)), destinationTrafficState: \(Swift.String(describing: destinationTrafficState)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), endpointGroupRegion: \(Swift.String(describing: endpointGroupRegion)), endpointId: \(Swift.String(describing: endpointId)), ipAddressType: \(Swift.String(describing: ipAddressType)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>The port mappings for a specified endpoint IP address (destination).</p>
    public struct DestinationPortMapping: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator
        /// 			that you have port mappings for.</p>
        public let acceleratorArn: Swift.String?
        /// <p>The IP address/port combinations (sockets) that map to a given destination socket
        /// 			address.</p>
        public let acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]?
        /// <p>The endpoint IP address/port combination for traffic received on the accelerator socket address.</p>
        public let destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// <p>Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if
        /// 			traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.</p>
        public let destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
        public let endpointGroupArn: Swift.String?
        /// <p>The AWS Region for the endpoint group.</p>
        public let endpointGroupRegion: Swift.String?
        /// <p>The ID for the virtual private cloud (VPC) subnet.</p>
        public let endpointId: Swift.String?
        /// <p>The IP address type, which must be IPv4.</p>
        public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?

        public init (
            acceleratorArn: Swift.String? = nil,
            acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.acceleratorSocketAddresses = acceleratorSocketAddresses
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.endpointId = endpointId
            self.ipAddressType = ipAddressType
        }
    }

}

extension EndpointAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension EndpointAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EndpointAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint that you specified doesn't exist.</p>
public struct EndpointAlreadyExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.EndpointConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let weight = weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes.EndpointConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointConfiguration(clientIPPreservationEnabled: \(Swift.String(describing: clientIPPreservationEnabled)), endpointId: \(Swift.String(describing: endpointId)), weight: \(Swift.String(describing: weight)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for endpoints. A resource must be valid and active when you add it as an endpoint.</p>
    public struct EndpointConfiguration: Swift.Equatable {
        /// <p>Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint.
        /// 			The value is true or false. The default value is true for new accelerators. </p>
        /// 		       <p>If the value is set to true, the client's IP address is preserved in the <code>X-Forwarded-For</code> request header as
        /// 			traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html">
        /// 			Preserve Client IP Addresses in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
        public let clientIPPreservationEnabled: Swift.Bool?
        /// <p>An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon
        /// 			Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address
        /// 			allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. A resource must be valid and active
        /// 			when you add it as an endpoint.</p>
        /// 		       <p>An Application Load Balancer can be either internal or internet-facing.</p>
        public let endpointId: Swift.String?
        /// <p>The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic
        /// 			based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The
        /// 			result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second
        /// 			and third endpoints, and 6/20 is routed to the last endpoint. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html">Endpoint Weights</a> in the
        /// 				<i>AWS Global Accelerator Developer Guide</i>.</p>
        public let weight: Swift.Int?

        public init (
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.weight = weight
        }
    }

}

extension GlobalAcceleratorClientTypes.EndpointDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case healthReason = "HealthReason"
        case healthState = "HealthState"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let healthReason = healthReason {
            try encodeContainer.encode(healthReason, forKey: .healthReason)
        }
        if let healthState = healthState {
            try encodeContainer.encode(healthState.rawValue, forKey: .healthState)
        }
        if let weight = weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let healthStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthState.self, forKey: .healthState)
        healthState = healthStateDecoded
        let healthReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthReason)
        healthReason = healthReasonDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes.EndpointDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointDescription(clientIPPreservationEnabled: \(Swift.String(describing: clientIPPreservationEnabled)), endpointId: \(Swift.String(describing: endpointId)), healthReason: \(Swift.String(describing: healthReason)), healthState: \(Swift.String(describing: healthState)), weight: \(Swift.String(describing: weight)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for an endpoint. Each endpoint group can include one or more endpoints, such as load
    /// 			balancers.</p>
    public struct EndpointDescription: Swift.Equatable {
        /// <p>Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint.
        /// 			The value is true or false. The default value is true for new accelerators. </p>
        /// 		       <p>If the value is set to true, the client's IP address is preserved in the <code>X-Forwarded-For</code> request header as
        /// 			traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/introduction-how-it-works-client-ip.html">
        /// 			Viewing Client IP Addresses in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
        public let clientIPPreservationEnabled: Swift.Bool?
        /// <p>An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon
        /// 			Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address
        /// 			allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. </p>
        /// 		       <p>An Application Load Balancer can be either internal or internet-facing.</p>
        public let endpointId: Swift.String?
        /// <p>Returns a null result.</p>
        public let healthReason: Swift.String?
        /// <p>The health status of the endpoint.</p>
        public let healthState: GlobalAcceleratorClientTypes.HealthState?
        /// <p>The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic
        /// 			based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The
        /// 			result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second
        /// 			and third endpoints, and 6/20 is routed to the last endpoint. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html">Endpoint Weights</a> in the
        /// 				<i>AWS Global Accelerator Developer Guide</i>. </p>
        public let weight: Swift.Int?

        public init (
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            healthReason: Swift.String? = nil,
            healthState: GlobalAcceleratorClientTypes.HealthState? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.healthReason = healthReason
            self.healthState = healthState
            self.weight = weight
        }
    }

}

extension GlobalAcceleratorClientTypes.EndpointGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for endpointdescriptions0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(endpointdescriptions0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverrides0 in portOverrides {
                try portOverridesContainer.encode(portoverrides0)
            }
        }
        if let thresholdCount = thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.EndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.EndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension GlobalAcceleratorClientTypes.EndpointGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointGroup(endpointDescriptions: \(Swift.String(describing: endpointDescriptions)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), endpointGroupRegion: \(Swift.String(describing: endpointGroupRegion)), healthCheckIntervalSeconds: \(Swift.String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(Swift.String(describing: healthCheckPath)), healthCheckPort: \(Swift.String(describing: healthCheckPort)), healthCheckProtocol: \(Swift.String(describing: healthCheckProtocol)), portOverrides: \(Swift.String(describing: portOverrides)), thresholdCount: \(Swift.String(describing: thresholdCount)), trafficDialPercentage: \(Swift.String(describing: trafficDialPercentage)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for the endpoint group. An AWS Region can have only one endpoint group for a specific listener.
    /// 		</p>
    public struct EndpointGroup: Swift.Equatable {
        /// <p>The list of endpoint objects.</p>
        public let endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
        /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
        public let endpointGroupArn: Swift.String?
        /// <p>The AWS Region where the endpoint group is located.</p>
        public let endpointGroupRegion: Swift.String?
        /// <p>The time—10 seconds or 30 seconds—between health checks for each endpoint. The default value is 30.</p>
        public let healthCheckIntervalSeconds: Swift.Int?
        /// <p>If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the
        /// 			endpoints for health checks. The default is slash (/).</p>
        public let healthCheckPath: Swift.String?
        /// <p>The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. </p>
        /// 		
        /// 		       <p>The default port is the port for the listener that this endpoint group is associated with. If the listener port is a
        /// 			list, Global Accelerator uses the first specified port in the list of ports.</p>
        public let healthCheckPort: Swift.Int?
        /// <p>The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default
        /// 			value is TCP.</p>
        public let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
        /// <p>Allows you to override the destination ports used to route traffic to an endpoint.
        /// 			Using a port override lets you to map a list of external destination ports (that your
        /// 			users send traffic to) to a list of internal destination ports that you want an application
        /// 			endpoint to receive traffic on. </p>
        public let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
        /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
        /// 			unhealthy endpoint to healthy. The default value is 3.</p>
        public let thresholdCount: Swift.Int?
        /// <p>The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
        /// 			this listener. </p>
        /// 		       <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
        /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
        /// 		       <p>The default value is 100.</p>
        public let trafficDialPercentage: Swift.Float?

        public init (
            endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckPath: Swift.String? = nil,
            healthCheckPort: Swift.Int? = nil,
            healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
            portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
            thresholdCount: Swift.Int? = nil,
            trafficDialPercentage: Swift.Float? = nil
        )
        {
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.portOverrides = portOverrides
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }
    }

}

extension EndpointGroupAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointGroupAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension EndpointGroupAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EndpointGroupAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint group that you specified already exists.</p>
public struct EndpointGroupAlreadyExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointGroupAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointGroupAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointGroupNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointGroupNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension EndpointGroupNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EndpointGroupNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint group that you specified doesn't exist.</p>
public struct EndpointGroupNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointGroupNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointGroupNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension EndpointNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EndpointNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint that you specified doesn't exist.</p>
public struct EndpointNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum HealthCheckProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .https,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes {
    public enum HealthState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case initial
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthState] {
            return [
                .healthy,
                .initial,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthState(rawValue: rawValue) ?? HealthState.sdkUnknown(rawValue)
        }
    }
}

extension IncorrectCidrStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncorrectCidrStateException(message: \(Swift.String(describing: message)))"}
}

extension IncorrectCidrStateException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncorrectCidrStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CIDR that you specified is not valid for this action. For example, the state of the CIDR might be
/// 		incorrect for this action.</p>
public struct IncorrectCidrStateException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncorrectCidrStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncorrectCidrStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an internal error for AWS Global Accelerator.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArgumentException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An argument that you specified is invalid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There isn't another item to return.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPortRangeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPortRangeException(message: \(Swift.String(describing: message)))"}
}

extension InvalidPortRangeException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPortRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The port numbers that you specified are not valid numbers or are not unique for this accelerator.</p>
public struct InvalidPortRangeException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPortRangeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPortRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .ipv4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.IpSet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddresses = "IpAddresses"
        case ipFamily = "IpFamily"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddresses0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddresses0)
            }
        }
        if let ipFamily = ipFamily {
            try encodeContainer.encode(ipFamily, forKey: .ipFamily)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipFamily)
        ipFamily = ipFamilyDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
    }
}

extension GlobalAcceleratorClientTypes.IpSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IpSet(ipAddresses: \(Swift.String(describing: ipAddresses)), ipFamily: \(Swift.String(describing: ipFamily)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for the set of IP addresses for an accelerator.</p>
    public struct IpSet: Swift.Equatable {
        /// <p>The array of IP addresses in the IP address set. An IP address set can have a maximum of two IP addresses.</p>
        public let ipAddresses: [Swift.String]?
        /// <p>The types of IP addresses included in this IP set.</p>
        public let ipFamily: Swift.String?

        public init (
            ipAddresses: [Swift.String]? = nil,
            ipFamily: Swift.String? = nil
        )
        {
            self.ipAddresses = ipAddresses
            self.ipFamily = ipFamily
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed an AWS Global Accelerator limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAcceleratorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAcceleratorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAcceleratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAcceleratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAcceleratorsOutputError>
}

extension ListAcceleratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAcceleratorsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAcceleratorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAcceleratorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAcceleratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAcceleratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAcceleratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAcceleratorsOutputError>
}

public struct ListAcceleratorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAcceleratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAcceleratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAcceleratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAcceleratorsOutputError>
}

public struct ListAcceleratorsInput: Swift.Equatable {
    /// <p>The number of Global Accelerator objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListAcceleratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAcceleratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAcceleratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAcceleratorsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAcceleratorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAcceleratorsOutputResponse(accelerators: \(Swift.String(describing: accelerators)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAcceleratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAcceleratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListAcceleratorsOutputResponse: Swift.Equatable {
    /// <p>The list of accelerators for a customer account.</p>
    public let accelerators: [GlobalAcceleratorClientTypes.Accelerator]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        accelerators: [GlobalAcceleratorClientTypes.Accelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsOutputResponseBody: Swift.Equatable {
    public let accelerators: [GlobalAcceleratorClientTypes.Accelerator]?
    public let nextToken: Swift.String?
}

extension ListAcceleratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Accelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[GlobalAcceleratorClientTypes.Accelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [GlobalAcceleratorClientTypes.Accelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListByoipCidrsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListByoipCidrsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListByoipCidrsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListByoipCidrsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListByoipCidrsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListByoipCidrsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListByoipCidrsOutputError>
}

extension ListByoipCidrsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListByoipCidrsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListByoipCidrsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListByoipCidrsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListByoipCidrsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListByoipCidrsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListByoipCidrsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListByoipCidrsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListByoipCidrsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListByoipCidrsOutputError>
}

public struct ListByoipCidrsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListByoipCidrsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListByoipCidrsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListByoipCidrsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListByoipCidrsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListByoipCidrsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListByoipCidrsOutputError>
}

public struct ListByoipCidrsInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining results, make
    /// 			another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListByoipCidrsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListByoipCidrsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListByoipCidrsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListByoipCidrsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListByoipCidrsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListByoipCidrsOutputResponse(byoipCidrs: \(Swift.String(describing: byoipCidrs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListByoipCidrsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListByoipCidrsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidrs = output.byoipCidrs
            self.nextToken = output.nextToken
        } else {
            self.byoipCidrs = nil
            self.nextToken = nil
        }
    }
}

public struct ListByoipCidrsOutputResponse: Swift.Equatable {
    /// <p>Information about your address ranges.</p>
    public let byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byoipCidrs = byoipCidrs
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsOutputResponseBody: Swift.Equatable {
    public let byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]?
    public let nextToken: Swift.String?
}

extension ListByoipCidrsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidrs = "ByoipCidrs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ByoipCidr?].self, forKey: .byoipCidrs)
        var byoipCidrsDecoded0:[GlobalAcceleratorClientTypes.ByoipCidr]? = nil
        if let byoipCidrsContainer = byoipCidrsContainer {
            byoipCidrsDecoded0 = [GlobalAcceleratorClientTypes.ByoipCidr]()
            for structure0 in byoipCidrsContainer {
                if let structure0 = structure0 {
                    byoipCidrsDecoded0?.append(structure0)
                }
            }
        }
        byoipCidrs = byoipCidrsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingAcceleratorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingAcceleratorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingAcceleratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingAcceleratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingAcceleratorsOutputError>
}

extension ListCustomRoutingAcceleratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingAcceleratorsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingAcceleratorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingAcceleratorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingAcceleratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingAcceleratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingAcceleratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingAcceleratorsOutputError>
}

public struct ListCustomRoutingAcceleratorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingAcceleratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingAcceleratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingAcceleratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingAcceleratorsOutputError>
}

public struct ListCustomRoutingAcceleratorsInput: Swift.Equatable {
    /// <p>The number of custom routing Global Accelerator objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingAcceleratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingAcceleratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingAcceleratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingAcceleratorsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingAcceleratorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingAcceleratorsOutputResponse(accelerators: \(Swift.String(describing: accelerators)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingAcceleratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCustomRoutingAcceleratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingAcceleratorsOutputResponse: Swift.Equatable {
    /// <p>The list of custom routing accelerators for a customer account.</p>
    public let accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsOutputResponseBody: Swift.Equatable {
    public let accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingAcceleratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingAccelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingAccelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingEndpointGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingEndpointGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingEndpointGroupsOutputError>
}

extension ListCustomRoutingEndpointGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingEndpointGroupsInput(listenerArn: \(Swift.String(describing: listenerArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingEndpointGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingEndpointGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingEndpointGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingEndpointGroupsOutputError>
}

public struct ListCustomRoutingEndpointGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingEndpointGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingEndpointGroupsOutputError>
}

public struct ListCustomRoutingEndpointGroupsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to list endpoint groups for.</p>
    public let listenerArn: Swift.String?
    /// <p>The number of endpoint group objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingEndpointGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingEndpointGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingEndpointGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingEndpointGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingEndpointGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingEndpointGroupsOutputResponse(endpointGroups: \(Swift.String(describing: endpointGroups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingEndpointGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCustomRoutingEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingEndpointGroupsOutputResponse: Swift.Equatable {
    /// <p>The list of the endpoint groups associated with a listener for a custom routing accelerator.</p>
    public let endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsOutputResponseBody: Swift.Equatable {
    public let endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingEndpointGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingListenersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingListenersOutputError>
}

extension ListCustomRoutingListenersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingListenersInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingListenersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingListenersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingListenersOutputError>
}

public struct ListCustomRoutingListenersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingListenersOutputError>
}

public struct ListCustomRoutingListenersInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to list listeners for.</p>
    public let acceleratorArn: Swift.String?
    /// <p>The number of listener objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingListenersOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingListenersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingListenersOutputResponse(listeners: \(Swift.String(describing: listeners)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCustomRoutingListenersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingListenersOutputResponse: Swift.Equatable {
    /// <p>The list of listeners for a custom routing accelerator.</p>
    public let listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersOutputResponseBody: Swift.Equatable {
    public let listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingListenersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingListener?].self, forKey: .listeners)
        var listenersDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingPortMappingsByDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingPortMappingsByDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingPortMappingsByDestinationOutputError>
}

extension ListCustomRoutingPortMappingsByDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingPortMappingsByDestinationInput(destinationAddress: \(Swift.String(describing: destinationAddress)), endpointId: \(Swift.String(describing: endpointId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingPortMappingsByDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationAddress = destinationAddress {
            try encodeContainer.encode(destinationAddress, forKey: .destinationAddress)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingPortMappingsByDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingPortMappingsByDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingPortMappingsByDestinationOutputError>
}

public struct ListCustomRoutingPortMappingsByDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingPortMappingsByDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingPortMappingsByDestinationOutputError>
}

public struct ListCustomRoutingPortMappingsByDestinationInput: Swift.Equatable {
    /// <p>The endpoint IP address in a virtual private cloud (VPC) subnet for which you want to receive back port
    /// 		mappings.</p>
    public let destinationAddress: Swift.String?
    /// <p>The ID for the virtual private cloud (VPC) subnet.</p>
    public let endpointId: Swift.String?
    /// <p>The number of destination port mappings that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        destinationAddress: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationAddress = destinationAddress
        self.endpointId = endpointId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationInputBody: Swift.Equatable {
    public let endpointId: Swift.String?
    public let destinationAddress: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsByDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAddress)
        destinationAddress = destinationAddressDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointNotFoundException" : self = .endpointNotFoundException(try EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingPortMappingsByDestinationOutputError: Swift.Error, Swift.Equatable {
    case endpointNotFoundException(EndpointNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingPortMappingsByDestinationOutputResponse(destinationPortMappings: \(Swift.String(describing: destinationPortMappings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCustomRoutingPortMappingsByDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationPortMappings = output.destinationPortMappings
            self.nextToken = output.nextToken
        } else {
            self.destinationPortMappings = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsByDestinationOutputResponse: Swift.Equatable {
    /// <p>The port mappings for the endpoint IP address that you specified in the request.</p>
    public let destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationPortMappings = destinationPortMappings
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationOutputResponseBody: Swift.Equatable {
    public let destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPortMappings = "DestinationPortMappings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPortMappingsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.DestinationPortMapping?].self, forKey: .destinationPortMappings)
        var destinationPortMappingsDecoded0:[GlobalAcceleratorClientTypes.DestinationPortMapping]? = nil
        if let destinationPortMappingsContainer = destinationPortMappingsContainer {
            destinationPortMappingsDecoded0 = [GlobalAcceleratorClientTypes.DestinationPortMapping]()
            for structure0 in destinationPortMappingsContainer {
                if let structure0 = structure0 {
                    destinationPortMappingsDecoded0?.append(structure0)
                }
            }
        }
        destinationPortMappings = destinationPortMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingPortMappingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingPortMappingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingPortMappingsOutputError>
}

extension ListCustomRoutingPortMappingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingPortMappingsInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCustomRoutingPortMappingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingPortMappingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingPortMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingPortMappingsOutputError>
}

public struct ListCustomRoutingPortMappingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCustomRoutingPortMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCustomRoutingPortMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCustomRoutingPortMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCustomRoutingPortMappingsOutputError>
}

public struct ListCustomRoutingPortMappingsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to list the custom routing port mappings for.</p>
    public let acceleratorArn: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to list the custom routing port mappings for.</p>
    public let endpointGroupArn: Swift.String?
    /// <p>The number of destination port mappings that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        endpointGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.endpointGroupArn = endpointGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let endpointGroupArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingPortMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingPortMappingsOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingPortMappingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomRoutingPortMappingsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), portMappings: \(Swift.String(describing: portMappings)))"}
}

extension ListCustomRoutingPortMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCustomRoutingPortMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portMappings = output.portMappings
        } else {
            self.nextToken = nil
            self.portMappings = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsOutputResponse: Swift.Equatable {
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?
    /// <p>The port mappings for a custom routing accelerator.</p>
    public let portMappings: [GlobalAcceleratorClientTypes.PortMapping]?

    public init (
        nextToken: Swift.String? = nil,
        portMappings: [GlobalAcceleratorClientTypes.PortMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.portMappings = portMappings
    }
}

struct ListCustomRoutingPortMappingsOutputResponseBody: Swift.Equatable {
    public let portMappings: [GlobalAcceleratorClientTypes.PortMapping]?
    public let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case portMappings = "PortMappings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[GlobalAcceleratorClientTypes.PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [GlobalAcceleratorClientTypes.PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEndpointGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEndpointGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEndpointGroupsOutputError>
}

extension ListEndpointGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEndpointGroupsInput(listenerArn: \(Swift.String(describing: listenerArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEndpointGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEndpointGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEndpointGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEndpointGroupsOutputError>
}

public struct ListEndpointGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEndpointGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEndpointGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEndpointGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEndpointGroupsOutputError>
}

public struct ListEndpointGroupsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?
    /// <p>The number of endpoint group objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListEndpointGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEndpointGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEndpointGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEndpointGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEndpointGroupsOutputResponse(endpointGroups: \(Swift.String(describing: endpointGroups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEndpointGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointGroupsOutputResponse: Swift.Equatable {
    /// <p>The list of the endpoint groups associated with a listener.</p>
    public let endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsOutputResponseBody: Swift.Equatable {
    public let endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]?
    public let nextToken: Swift.String?
}

extension ListEndpointGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[GlobalAcceleratorClientTypes.EndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [GlobalAcceleratorClientTypes.EndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListListenersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListListenersOutputError>
}

extension ListListenersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListListenersInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListListenersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListListenersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListListenersOutputError>
}

public struct ListListenersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListListenersOutputError>
}

public struct ListListenersInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator for which you want to list listener objects.</p>
    public let acceleratorArn: Swift.String?
    /// <p>The number of listener objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListListenersInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListListenersOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListListenersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListListenersOutputResponse(listeners: \(Swift.String(describing: listeners)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListListenersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListListenersOutputResponse: Swift.Equatable {
    /// <p>The list of listeners for an accelerator.</p>
    public let listeners: [GlobalAcceleratorClientTypes.Listener]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: Swift.String?

    public init (
        listeners: [GlobalAcceleratorClientTypes.Listener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListListenersOutputResponseBody: Swift.Equatable {
    public let listeners: [GlobalAcceleratorClientTypes.Listener]?
    public let nextToken: Swift.String?
}

extension ListListenersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Listener?].self, forKey: .listeners)
        var listenersDecoded0:[GlobalAcceleratorClientTypes.Listener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [GlobalAcceleratorClientTypes.Listener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to list tags for. An ARN uniquely identifies an accelerator.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>Root level tag for the Tags parameters.</p>
    public let tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GlobalAcceleratorClientTypes.Listener: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension GlobalAcceleratorClientTypes.Listener: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Listener(clientAffinity: \(Swift.String(describing: clientAffinity)), listenerArn: \(Swift.String(describing: listenerArn)), portRanges: \(Swift.String(describing: portRanges)), protocol: \(Swift.String(describing: `protocol`)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for a listener.</p>
    public struct Listener: Swift.Equatable {
        /// <p>The protocol for the connections from clients to the accelerator.</p>
        public let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
        /// <p>Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
        /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
        /// 			route each client to the same specific endpoint.</p>
        /// 		       <p>AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
        /// 			affinity is <code>NONE</code>, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port,
        /// 			destination IP address, destination port, and protocol—to select the hash value, and then chooses the best
        /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
        /// 			be always routed to the same endpoint because the hash value changes. </p>
        /// 		       <p>If you want a given client to always be routed to the same endpoint, set client affinity to <code>SOURCE_IP</code>
        /// 			instead. When you use the <code>SOURCE_IP</code> setting, Global Accelerator uses the "two-tuple" (2-tuple) properties—
        /// 			source (client) IP address and destination IP address—to select the hash value.</p>
        /// 		       <p>The default value is <code>NONE</code>.</p>
        public let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        public let listenerArn: Swift.String?
        /// <p>The list of port ranges for the connections from clients to the accelerator.</p>
        public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?

        public init (
            `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil,
            clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
        )
        {
            self.`protocol` = `protocol`
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
        }
    }

}

extension ListenerNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListenerNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ListenerNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListenerNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The listener that you specified doesn't exist.</p>
public struct ListenerNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ListenerNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ListenerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.PortMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorPort = "AcceleratorPort"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
        case protocols = "Protocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorPort = acceleratorPort {
            try encodeContainer.encode(acceleratorPort, forKey: .acceleratorPort)
        }
        if let destinationSocketAddress = destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocols0 in protocols {
                try protocolsContainer.encode(customroutingprotocols0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceleratorPort)
        acceleratorPort = acceleratorPortDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension GlobalAcceleratorClientTypes.PortMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortMapping(acceleratorPort: \(Swift.String(describing: acceleratorPort)), destinationSocketAddress: \(Swift.String(describing: destinationSocketAddress)), destinationTrafficState: \(Swift.String(describing: destinationTrafficState)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), endpointId: \(Swift.String(describing: endpointId)), protocols: \(Swift.String(describing: protocols)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>Returns the ports and associated IP addresses and ports of Amazon EC2 instances in your virtual
    /// 			private cloud (VPC) subnets. Custom routing is a port mapping protocol in AWS Global Accelerator that
    /// 			statically associates port ranges with VPC subnets, which allows Global Accelerator to route to
    /// 			specific instances and ports within one or more subnets. </p>
    public struct PortMapping: Swift.Equatable {
        /// <p>The accelerator port.</p>
        public let acceleratorPort: Swift.Int?
        /// <p>The EC2 instance IP address and port number in the virtual private cloud (VPC) subnet.</p>
        public let destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// <p>Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if
        /// 			traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.</p>
        public let destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
        public let endpointGroupArn: Swift.String?
        /// <p>The IP address of the VPC subnet (the subnet ID).</p>
        public let endpointId: Swift.String?
        /// <p>The protocols supported by the endpoint group.</p>
        public let protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?

        public init (
            acceleratorPort: Swift.Int? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        )
        {
            self.acceleratorPort = acceleratorPort
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointId = endpointId
            self.protocols = protocols
        }
    }

}

extension GlobalAcceleratorClientTypes.PortOverride: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointPort = "EndpointPort"
        case listenerPort = "ListenerPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointPort = endpointPort {
            try encodeContainer.encode(endpointPort, forKey: .endpointPort)
        }
        if let listenerPort = listenerPort {
            try encodeContainer.encode(listenerPort, forKey: .listenerPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .listenerPort)
        listenerPort = listenerPortDecoded
        let endpointPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endpointPort)
        endpointPort = endpointPortDecoded
    }
}

extension GlobalAcceleratorClientTypes.PortOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortOverride(endpointPort: \(Swift.String(describing: endpointPort)), listenerPort: \(Swift.String(describing: listenerPort)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of an endpoint group.
    /// 			For example, you can create a port override in which the listener
    /// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
    /// 			and 1443, respectively, on the endpoints.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html">
    /// 			Port overrides</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public struct PortOverride: Swift.Equatable {
        /// <p>The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint,
        /// 			such as the Application Load Balancer or Amazon EC2 instance.</p>
        public let endpointPort: Swift.Int?
        /// <p>The listener port that you want to map to a specific endpoint port. This is the port that user traffic
        /// 		arrives to the Global Accelerator on.</p>
        public let listenerPort: Swift.Int?

        public init (
            endpointPort: Swift.Int? = nil,
            listenerPort: Swift.Int? = nil
        )
        {
            self.endpointPort = endpointPort
            self.listenerPort = listenerPort
        }
    }

}

extension GlobalAcceleratorClientTypes.PortRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension GlobalAcceleratorClientTypes.PortRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortRange(fromPort: \(Swift.String(describing: fromPort)), toPort: \(Swift.String(describing: toPort)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type for a range of ports for a listener.</p>
    public struct PortRange: Swift.Equatable {
        /// <p>The first port in the range of ports, inclusive.</p>
        public let fromPort: Swift.Int?
        /// <p>The last port in the range of ports, inclusive.</p>
        public let toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

public struct ProvisionByoipCidrInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ProvisionByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ProvisionByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ProvisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ProvisionByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ProvisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ProvisionByoipCidrOutputError>
}

extension ProvisionByoipCidrInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionByoipCidrInput(cidr: \(Swift.String(describing: cidr)), cidrAuthorizationContext: \(Swift.String(describing: cidrAuthorizationContext)))"}
}

extension ProvisionByoipCidrInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let cidrAuthorizationContext = cidrAuthorizationContext {
            try encodeContainer.encode(cidrAuthorizationContext, forKey: .cidrAuthorizationContext)
        }
    }
}

public struct ProvisionByoipCidrInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ProvisionByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ProvisionByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ProvisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ProvisionByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ProvisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ProvisionByoipCidrOutputError>
}

public struct ProvisionByoipCidrInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ProvisionByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ProvisionByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ProvisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ProvisionByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ProvisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ProvisionByoipCidrOutputError>
}

public struct ProvisionByoipCidrInput: Swift.Equatable {
    /// <p>The public IPv4 address range, in CIDR notation. The most specific IP prefix that you can
    /// 			specify is /24. The address range cannot overlap with another address range that you've brought
    /// 			to this or another Region.</p>
    public let cidr: Swift.String?
    /// <p>A signed document that proves that you are authorized to bring the specified IP address range to
    /// 			Amazon using BYOIP.
    /// 		</p>
    public let cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext?

    public init (
        cidr: Swift.String? = nil,
        cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext? = nil
    )
    {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
    }
}

struct ProvisionByoipCidrInputBody: Swift.Equatable {
    public let cidr: Swift.String?
    public let cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext?
}

extension ProvisionByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let cidrAuthorizationContextDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CidrAuthorizationContext.self, forKey: .cidrAuthorizationContext)
        cidrAuthorizationContext = cidrAuthorizationContextDecoded
    }
}

extension ProvisionByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvisionByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionByoipCidrOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionByoipCidrOutputResponse(byoipCidr: \(Swift.String(describing: byoipCidr)))"}
}

extension ProvisionByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvisionByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct ProvisionByoipCidrOutputResponse: Swift.Equatable {
    /// <p>Information about the address range.</p>
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct ProvisionByoipCidrOutputResponseBody: Swift.Equatable {
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension ProvisionByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

public struct RemoveCustomRoutingEndpointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveCustomRoutingEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveCustomRoutingEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveCustomRoutingEndpointsOutputError>
}

extension RemoveCustomRoutingEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveCustomRoutingEndpointsInput(endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), endpointIds: \(Swift.String(describing: endpointIds)))"}
}

extension RemoveCustomRoutingEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointIds = endpointIds {
            var endpointIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointIds)
            for endpointids0 in endpointIds {
                try endpointIdsContainer.encode(endpointids0)
            }
        }
    }
}

public struct RemoveCustomRoutingEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveCustomRoutingEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveCustomRoutingEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveCustomRoutingEndpointsOutputError>
}

public struct RemoveCustomRoutingEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveCustomRoutingEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveCustomRoutingEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveCustomRoutingEndpointsOutputError>
}

public struct RemoveCustomRoutingEndpointsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to remove endpoints from.</p>
    public let endpointGroupArn: Swift.String?
    /// <p>The IDs for the endpoints. For custom routing accelerators, endpoint IDs are the virtual private cloud (VPC)
    /// 		subnet IDs. </p>
    public let endpointIds: [Swift.String]?

    public init (
        endpointGroupArn: Swift.String? = nil,
        endpointIds: [Swift.String]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIds = endpointIds
    }
}

struct RemoveCustomRoutingEndpointsInputBody: Swift.Equatable {
    public let endpointIds: [Swift.String]?
    public let endpointGroupArn: Swift.String?
}

extension RemoveCustomRoutingEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpointIds)
        var endpointIdsDecoded0:[Swift.String]? = nil
        if let endpointIdsContainer = endpointIdsContainer {
            endpointIdsDecoded0 = [Swift.String]()
            for string0 in endpointIdsContainer {
                if let string0 = string0 {
                    endpointIdsDecoded0?.append(string0)
                }
            }
        }
        endpointIds = endpointIdsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension RemoveCustomRoutingEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveCustomRoutingEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundException" : self = .endpointNotFoundException(try EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveCustomRoutingEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case endpointNotFoundException(EndpointNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveCustomRoutingEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveCustomRoutingEndpointsOutputResponse()"}
}

extension RemoveCustomRoutingEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveCustomRoutingEndpointsOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveCustomRoutingEndpointsOutputResponseBody: Swift.Equatable {
}

extension RemoveCustomRoutingEndpointsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlobalAcceleratorClientTypes.SocketAddress: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension GlobalAcceleratorClientTypes.SocketAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SocketAddress(ipAddress: \(Swift.String(describing: ipAddress)), port: \(Swift.String(describing: port)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>An IP address/port combination.</p>
    public struct SocketAddress: Swift.Equatable {
        /// <p>The IP address for the socket address.</p>
        public let ipAddress: Swift.String?
        /// <p>The port for the socket address.</p>
        public let port: Swift.Int?

        public init (
            ipAddress: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.port = port
        }
    }

}

extension GlobalAcceleratorClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GlobalAcceleratorClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension GlobalAcceleratorClientTypes {
    /// <p>A complex type that contains a <code>Tag</code> key and <code>Tag</code> value.</p>
    public struct Tag: Swift.Equatable {
        /// <p>A string that contains a <code>Tag</code> key.</p>
        public let key: Swift.String?
        /// <p>A string that contains a <code>Tag</code> value.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Global Accelerator resource to add tags to. An ARN uniquely identifies a resource.</p>
    public let resourceArn: Swift.String?
    /// <p>The tags to add to a resource. A tag consists of a key and a value that you define.</p>
    public let tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Global Accelerator resource to remove tags from. An ARN uniquely identifies a resource.</p>
    public let resourceArn: Swift.String?
    /// <p>The tag key pairs that you want to remove from the specified resources.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAcceleratorAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAcceleratorAttributesOutputError>
}

extension UpdateAcceleratorAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAcceleratorAttributesInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), flowLogsEnabled: \(Swift.String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(Swift.String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(Swift.String(describing: flowLogsS3Prefix)))"}
}

extension UpdateAcceleratorAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

public struct UpdateAcceleratorAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAcceleratorAttributesOutputError>
}

public struct UpdateAcceleratorAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAcceleratorAttributesOutputError>
}

public struct UpdateAcceleratorAttributesInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator that you want to update.</p>
    public let acceleratorArn: Swift.String?
    /// <p>Update whether flow logs are enabled. The default value is false. If the value is true,
    /// 				<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
    /// 			the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let flowLogsEnabled: Swift.Bool?
    /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
    /// 				<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
    /// 			bucket.</p>
    public let flowLogsS3Bucket: Swift.String?
    /// <p>Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
    /// 				<code>FlowLogsEnabled</code> is <code>true</code>. </p>
    /// 		       <p>If you don’t specify a prefix, the flow logs are stored in the
    /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
    /// 			      <p>s3-bucket_name//AWSLogs/aws_account_id</p>
    public let flowLogsS3Prefix: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateAcceleratorAttributesInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let flowLogsEnabled: Swift.Bool?
    public let flowLogsS3Bucket: Swift.String?
    public let flowLogsS3Prefix: Swift.String?
}

extension UpdateAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAcceleratorAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAcceleratorAttributesOutputResponse(acceleratorAttributes: \(Swift.String(describing: acceleratorAttributes)))"}
}

extension UpdateAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// <p>Updated attributes for the accelerator.</p>
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?
}

extension UpdateAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct UpdateAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAcceleratorOutputError>
}

extension UpdateAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAcceleratorInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), enabled: \(Swift.String(describing: enabled)), ipAddressType: \(Swift.String(describing: ipAddressType)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAcceleratorOutputError>
}

public struct UpdateAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAcceleratorOutputError>
}

public struct UpdateAcceleratorInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to update.</p>
    public let acceleratorArn: Swift.String?
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 		       <p>If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Swift.Bool?
    /// <p>The IP address type, which must be IPv4.</p>
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// <p>The name of the accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
    /// 			hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateAcceleratorInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let name: Swift.String?
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    public let enabled: Swift.Bool?
}

extension UpdateAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAcceleratorOutputResponse(accelerator: \(Swift.String(describing: accelerator)))"}
}

extension UpdateAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateAcceleratorOutputResponse: Swift.Equatable {
    /// <p>Information about the updated accelerator.</p>
    public let accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateAcceleratorOutputResponseBody: Swift.Equatable {
    public let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension UpdateAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingAcceleratorAttributesOutputError>
}

extension UpdateCustomRoutingAcceleratorAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomRoutingAcceleratorAttributesInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), flowLogsEnabled: \(Swift.String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(Swift.String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(Swift.String(describing: flowLogsS3Prefix)))"}
}

extension UpdateCustomRoutingAcceleratorAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingAcceleratorAttributesOutputError>
}

public struct UpdateCustomRoutingAcceleratorAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingAcceleratorAttributesOutputError>
}

public struct UpdateCustomRoutingAcceleratorAttributesInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator to update attributes for.</p>
    public let acceleratorArn: Swift.String?
    /// <p>Update whether flow logs are enabled. The default value is false. If the value is true,
    /// 		<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
    /// 	        <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
    /// 		the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let flowLogsEnabled: Swift.Bool?
    /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
    /// 		<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
    /// 		bucket.</p>
    public let flowLogsS3Bucket: Swift.String?
    /// <p>Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
    /// 		<code>FlowLogsEnabled</code> is <code>true</code>. </p>
    /// 	        <p>If you don’t specify a prefix, the flow logs are stored in the
    /// 		root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
    /// 	        <p>DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id</p>
    public let flowLogsS3Prefix: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateCustomRoutingAcceleratorAttributesInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let flowLogsEnabled: Swift.Bool?
    public let flowLogsS3Bucket: Swift.String?
    public let flowLogsS3Prefix: Swift.String?
}

extension UpdateCustomRoutingAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomRoutingAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomRoutingAcceleratorAttributesOutputResponse(acceleratorAttributes: \(Swift.String(describing: acceleratorAttributes)))"}
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCustomRoutingAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// <p>Updated custom routing accelerator.</p>
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    public let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct UpdateCustomRoutingAcceleratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingAcceleratorOutputError>
}

extension UpdateCustomRoutingAcceleratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomRoutingAcceleratorInput(acceleratorArn: \(Swift.String(describing: acceleratorArn)), enabled: \(Swift.String(describing: enabled)), ipAddressType: \(Swift.String(describing: ipAddressType)), name: \(Swift.String(describing: name)))"}
}

extension UpdateCustomRoutingAcceleratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateCustomRoutingAcceleratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingAcceleratorOutputError>
}

public struct UpdateCustomRoutingAcceleratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingAcceleratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingAcceleratorOutputError>
}

public struct UpdateCustomRoutingAcceleratorInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to update.</p>
    public let acceleratorArn: Swift.String?
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 	        <p>If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Swift.Bool?
    /// <p>The value for the address type must be IPv4.</p>
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// <p>The name of the accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
    /// 		hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateCustomRoutingAcceleratorInputBody: Swift.Equatable {
    public let acceleratorArn: Swift.String?
    public let name: Swift.String?
    public let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    public let enabled: Swift.Bool?
}

extension UpdateCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingAcceleratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomRoutingAcceleratorOutputResponse(accelerator: \(Swift.String(describing: accelerator)))"}
}

extension UpdateCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorOutputResponse: Swift.Equatable {
    /// <p>Information about the updated custom routing accelerator.</p>
    public let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateCustomRoutingAcceleratorOutputResponseBody: Swift.Equatable {
    public let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension UpdateCustomRoutingAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct UpdateCustomRoutingListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingListenerOutputError>
}

extension UpdateCustomRoutingListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomRoutingListenerInput(listenerArn: \(Swift.String(describing: listenerArn)), portRanges: \(Swift.String(describing: portRanges)))"}
}

extension UpdateCustomRoutingListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
    }
}

public struct UpdateCustomRoutingListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingListenerOutputError>
}

public struct UpdateCustomRoutingListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCustomRoutingListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCustomRoutingListenerOutputError>
}

public struct UpdateCustomRoutingListenerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to update.</p>
    public let listenerArn: Swift.String?
    /// <p>The updated port range to support for connections from clients to your accelerator. If you remove ports that are
    /// 	currently being used by a subnet endpoint, the call fails.</p>
    /// 	        <p>Separately, you set port ranges for endpoints. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html">About
    /// 		endpoints for custom routing accelerators</a>.</p>
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init (
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

struct UpdateCustomRoutingListenerInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
}

extension UpdateCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension UpdateCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomRoutingListenerOutputResponse(listener: \(Swift.String(describing: listener)))"}
}

extension UpdateCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateCustomRoutingListenerOutputResponse: Swift.Equatable {
    /// <p>Information for the updated listener for a custom routing accelerator.</p>
    public let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init (
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateCustomRoutingListenerOutputResponseBody: Swift.Equatable {
    public let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension UpdateCustomRoutingListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct UpdateEndpointGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEndpointGroupOutputError>
}

extension UpdateEndpointGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEndpointGroupInput(endpointConfigurations: \(Swift.String(describing: endpointConfigurations)), endpointGroupArn: \(Swift.String(describing: endpointGroupArn)), healthCheckIntervalSeconds: \(Swift.String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(Swift.String(describing: healthCheckPath)), healthCheckPort: \(Swift.String(describing: healthCheckPort)), healthCheckProtocol: \(Swift.String(describing: healthCheckProtocol)), portOverrides: \(Swift.String(describing: portOverrides)), thresholdCount: \(Swift.String(describing: thresholdCount)), trafficDialPercentage: \(Swift.String(describing: trafficDialPercentage)))"}
}

extension UpdateEndpointGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfigurations0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfigurations0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverrides0 in portOverrides {
                try portOverridesContainer.encode(portoverrides0)
            }
        }
        if let thresholdCount = thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

public struct UpdateEndpointGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEndpointGroupOutputError>
}

public struct UpdateEndpointGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEndpointGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEndpointGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEndpointGroupOutputError>
}

public struct UpdateEndpointGroupInput: Swift.Equatable {
    /// <p>The list of endpoint objects. A resource must be valid and active when you add it as an endpoint.</p>
    public let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: Swift.String?
    /// <p>The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.</p>
    public let healthCheckIntervalSeconds: Swift.Int?
    /// <p>If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The
    /// 			default value is slash (/).</p>
    public let healthCheckPath: Swift.String?
    /// <p>The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port
    /// 			is the listener port that this endpoint group is associated with. If the listener port is a list of ports, Global Accelerator uses
    /// 			the first port in the list.</p>
    public let healthCheckPort: Swift.Int?
    /// <p>The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default
    /// 			value is TCP.</p>
    public let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of this endpoint group.
    /// 			For example, you can create a port override in which the listener
    /// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
    /// 			and 1443, respectively, on the endpoints.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html">
    /// 			Port overrides</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
    /// 			unhealthy endpoint to healthy. The default value is 3.</p>
    public let thresholdCount: Swift.Int?
    /// <p>The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
    /// 			this listener. </p>
    /// 		       <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
    /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// 		       <p>The default value is 100.</p>
    public let trafficDialPercentage: Swift.Float?

    public init (
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct UpdateEndpointGroupInputBody: Swift.Equatable {
    public let endpointGroupArn: Swift.String?
    public let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    public let trafficDialPercentage: Swift.Float?
    public let healthCheckPort: Swift.Int?
    public let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    public let healthCheckPath: Swift.String?
    public let healthCheckIntervalSeconds: Swift.Int?
    public let thresholdCount: Swift.Int?
    public let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
}

extension UpdateEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension UpdateEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEndpointGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEndpointGroupOutputResponse(endpointGroup: \(Swift.String(describing: endpointGroup)))"}
}

extension UpdateEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct UpdateEndpointGroupOutputResponse: Swift.Equatable {
    /// <p>The information about the endpoint group that was updated.</p>
    public let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct UpdateEndpointGroupOutputResponseBody: Swift.Equatable {
    public let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension UpdateEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct UpdateListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateListenerOutputError>
}

extension UpdateListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateListenerInput(clientAffinity: \(Swift.String(describing: clientAffinity)), listenerArn: \(Swift.String(describing: listenerArn)), portRanges: \(Swift.String(describing: portRanges)), protocol: \(Swift.String(describing: `protocol`)))"}
}

extension UpdateListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

public struct UpdateListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateListenerOutputError>
}

public struct UpdateListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateListenerOutputError>
}

public struct UpdateListenerInput: Swift.Equatable {
    /// <p>The updated protocol for the connections from clients to the accelerator.</p>
    public let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    /// <p>Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
    /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
    /// 			route each client to the same specific endpoint.</p>
    /// 		       <p>AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
    /// 			affinity is <code>NONE</code>, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port,
    /// 			destination IP address, destination port, and protocol—to select the hash value, and then chooses the best
    /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
    /// 			be always routed to the same endpoint because the hash value changes. </p>
    /// 		       <p>If you want a given client to always be routed to the same endpoint, set client affinity to <code>SOURCE_IP</code>
    /// 			instead. When you use the <code>SOURCE_IP</code> setting, Global Accelerator uses the "two-tuple" (2-tuple) properties—
    /// 			source (client) IP address and destination IP address—to select the hash value.</p>
    /// 		       <p>The default value is <code>NONE</code>.</p>
    public let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// <p>The Amazon Resource Name (ARN) of the listener to update.</p>
    public let listenerArn: Swift.String?
    /// <p>The updated list of port ranges for the connections from clients to the accelerator.</p>
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init (
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil,
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.`protocol` = `protocol`
        self.clientAffinity = clientAffinity
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

struct UpdateListenerInputBody: Swift.Equatable {
    public let listenerArn: Swift.String?
    public let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    public let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    public let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
}

extension UpdateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension UpdateListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateListenerOutputResponse(listener: \(Swift.String(describing: listener)))"}
}

extension UpdateListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateListenerOutputResponse: Swift.Equatable {
    /// <p>Information for the updated listener.</p>
    public let listener: GlobalAcceleratorClientTypes.Listener?

    public init (
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateListenerOutputResponseBody: Swift.Equatable {
    public let listener: GlobalAcceleratorClientTypes.Listener?
}

extension UpdateListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct WithdrawByoipCidrInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "WithdrawByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<WithdrawByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<WithdrawByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<WithdrawByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<WithdrawByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<WithdrawByoipCidrOutputError>
}

extension WithdrawByoipCidrInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WithdrawByoipCidrInput(cidr: \(Swift.String(describing: cidr)))"}
}

extension WithdrawByoipCidrInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

public struct WithdrawByoipCidrInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "WithdrawByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<WithdrawByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<WithdrawByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<WithdrawByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<WithdrawByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<WithdrawByoipCidrOutputError>
}

public struct WithdrawByoipCidrInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "WithdrawByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<WithdrawByoipCidrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<WithdrawByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<WithdrawByoipCidrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<WithdrawByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<WithdrawByoipCidrOutputError>
}

public struct WithdrawByoipCidrInput: Swift.Equatable {
    /// <p>The address range, in CIDR notation.</p>
    public let cidr: Swift.String?

    public init (
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct WithdrawByoipCidrInputBody: Swift.Equatable {
    public let cidr: Swift.String?
}

extension WithdrawByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension WithdrawByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension WithdrawByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum WithdrawByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension WithdrawByoipCidrOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WithdrawByoipCidrOutputResponse(byoipCidr: \(Swift.String(describing: byoipCidr)))"}
}

extension WithdrawByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: WithdrawByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct WithdrawByoipCidrOutputResponse: Swift.Equatable {
    /// <p>Information about the address pool.</p>
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct WithdrawByoipCidrOutputResponseBody: Swift.Equatable {
    public let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension WithdrawByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}
