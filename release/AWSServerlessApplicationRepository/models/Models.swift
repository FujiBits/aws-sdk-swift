// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case semanticVersion = "semanticVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationDependencySummary(applicationId: \(Swift.String(describing: applicationId)), semanticVersion: \(Swift.String(describing: semanticVersion)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// A nested application summary.
    public struct ApplicationDependencySummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the nested application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The semantic version of the nested application.
        /// This member is required.
        public var semanticVersion: Swift.String?

        public init (
            applicationId: Swift.String? = nil,
            semanticVersion: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "actions"
        case principalOrgIDs = "principalOrgIDs"
        case principals = "principals"
        case statementId = "statementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for __listof__string0 in actions {
                try actionsContainer.encode(__listof__string0)
            }
        }
        if let principalOrgIDs = principalOrgIDs {
            var principalOrgIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principalOrgIDs)
            for __listof__string0 in principalOrgIDs {
                try principalOrgIDsContainer.encode(__listof__string0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for __listof__string0 in principals {
                try principalsContainer.encode(__listof__string0)
            }
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let principalOrgIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principalOrgIDs)
        var principalOrgIDsDecoded0:[Swift.String]? = nil
        if let principalOrgIDsContainer = principalOrgIDsContainer {
            principalOrgIDsDecoded0 = [Swift.String]()
            for string0 in principalOrgIDsContainer {
                if let string0 = string0 {
                    principalOrgIDsDecoded0?.append(string0)
                }
            }
        }
        principalOrgIDs = principalOrgIDsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationPolicyStatement(actions: \(Swift.String(describing: actions)), principalOrgIDs: \(Swift.String(describing: principalOrgIDs)), principals: \(Swift.String(describing: principals)), statementId: \(Swift.String(describing: statementId)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Policy statement applied to the application.
    public struct ApplicationPolicyStatement: Swift.Equatable {
        /// For the list of actions supported for this operation, see <a href="https://docs.aws.amazon.com/serverlessrepo/latest/devguide/access-control-resource-based.html#application-permissions">Application
        ///  Permissions.
        /// This member is required.
        public var actions: [Swift.String]?
        /// An array of PrinciplalOrgIDs, which corresponds to AWS IAM <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#principal-org-id">aws:PrincipalOrgID global condition key.
        public var principalOrgIDs: [Swift.String]?
        /// An array of AWS account IDs, or * to make the application public.
        /// This member is required.
        public var principals: [Swift.String]?
        /// A unique ID for the statement.
        public var statementId: Swift.String?

        public init (
            actions: [Swift.String]? = nil,
            principalOrgIDs: [Swift.String]? = nil,
            principals: [Swift.String]? = nil,
            statementId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.principalOrgIDs = principalOrgIDs
            self.principals = principals
            self.statementId = statementId
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.ApplicationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case name = "name"
        case spdxLicenseId = "spdxLicenseId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __listof__string0 in labels {
                try labelsContainer.encode(__listof__string0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let spdxLicenseId = spdxLicenseId {
            try encodeContainer.encode(spdxLicenseId, forKey: .spdxLicenseId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.ApplicationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationSummary(applicationId: \(Swift.String(describing: applicationId)), author: \(Swift.String(describing: author)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), homePageUrl: \(Swift.String(describing: homePageUrl)), labels: \(Swift.String(describing: labels)), name: \(Swift.String(describing: name)), spdxLicenseId: \(Swift.String(describing: spdxLicenseId)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Summary of details about the application.
    public struct ApplicationSummary: Swift.Equatable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        /// This member is required.
        public var author: Swift.String?
        /// The date and time this resource was created.
        public var creationTime: Swift.String?
        /// The description of the application.Minimum length=1. Maximum length=256
        /// This member is required.
        public var description: Swift.String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public var homePageUrl: Swift.String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public var labels: [Swift.String]?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        /// This member is required.
        public var name: Swift.String?
        /// A valid identifier from <a href="https://spdx.org/licenses/">https://spdx.org/licenses/.
        public var spdxLicenseId: Swift.String?

        public init (
            applicationId: Swift.String? = nil,
            author: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            description: Swift.String? = nil,
            homePageUrl: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            name: Swift.String? = nil,
            spdxLicenseId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.name = name
            self.spdxLicenseId = spdxLicenseId
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the parameters in the request is invalid.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 400
    public var errorCode: Swift.String?
    /// One of the parameters in the request is invalid.
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Values that must be specified in order to deploy some applications.
    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case capabilityAutoExpand
        case capabilityIam
        case capabilityNamedIam
        case capabilityResourcePolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .capabilityAutoExpand,
                .capabilityIam,
                .capabilityNamedIam,
                .capabilityResourcePolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .capabilityAutoExpand: return "CAPABILITY_AUTO_EXPAND"
            case .capabilityIam: return "CAPABILITY_IAM"
            case .capabilityNamedIam: return "CAPABILITY_NAMED_IAM"
            case .capabilityResourcePolicy: return "CAPABILITY_RESOURCE_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 409
    public var errorCode: Swift.String?
    /// The resource already exists.
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationInput(author: \(Swift.String(describing: author)), description: \(Swift.String(describing: description)), homePageUrl: \(Swift.String(describing: homePageUrl)), labels: \(Swift.String(describing: labels)), licenseBody: \(Swift.String(describing: licenseBody)), licenseUrl: \(Swift.String(describing: licenseUrl)), name: \(Swift.String(describing: name)), readmeBody: \(Swift.String(describing: readmeBody)), readmeUrl: \(Swift.String(describing: readmeUrl)), semanticVersion: \(Swift.String(describing: semanticVersion)), sourceCodeArchiveUrl: \(Swift.String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(Swift.String(describing: sourceCodeUrl)), spdxLicenseId: \(Swift.String(describing: spdxLicenseId)), templateBody: \(Swift.String(describing: templateBody)), templateUrl: \(Swift.String(describing: templateUrl)))"}
}

extension CreateApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case licenseBody = "licenseBody"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __listof__string0 in labels {
                try labelsContainer.encode(__listof__string0)
            }
        }
        if let licenseBody = licenseBody {
            try encodeContainer.encode(licenseBody, forKey: .licenseBody)
        }
        if let licenseUrl = licenseUrl {
            try encodeContainer.encode(licenseUrl, forKey: .licenseUrl)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let readmeBody = readmeBody {
            try encodeContainer.encode(readmeBody, forKey: .readmeBody)
        }
        if let readmeUrl = readmeUrl {
            try encodeContainer.encode(readmeUrl, forKey: .readmeUrl)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeArchiveUrl = sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let spdxLicenseId = spdxLicenseId {
            try encodeContainer.encode(spdxLicenseId, forKey: .spdxLicenseId)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateUrl = templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/applications"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    /// This member is required.
    public var author: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    /// This member is required.
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A local text file that contains the license of the app that matches the spdxLicenseID value of your application.
    ///  The file has the format file://&lt;path>/&lt;filename>.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
    public var licenseBody: Swift.String?
    /// A link to the S3 object that contains the license of the app that matches the spdxLicenseID value of your application.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
    public var licenseUrl: Swift.String?
    /// The name of the application that you want to publish.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    /// This member is required.
    public var name: Swift.String?
    /// A local text readme file in Markdown language that contains a more detailed description of the application and how it works.
    ///  The file has the format file://&lt;path>/&lt;filename>.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
    public var readmeBody: Swift.String?
    /// A link to the S3 object in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
    public var readmeUrl: Swift.String?
    /// The semantic version of the application:
    ///  <a href="https://semver.org/">https://semver.org/
    ///
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// A valid identifier from <a href="https://spdx.org/licenses/">https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The local raw packaged AWS SAM template file of your application.
    ///  The file has the format file://&lt;path>/&lt;filename>.You can specify only one of templateBody and templateUrl; otherwise an error results.
    public var templateBody: Swift.String?
    /// A link to the S3 object containing the packaged AWS SAM template of your application.You can specify only one of templateBody and templateUrl; otherwise an error results.
    public var templateUrl: Swift.String?

    public init (
        author: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        licenseBody: Swift.String? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeBody: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.licenseBody = licenseBody
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.spdxLicenseId = spdxLicenseId
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    public let author: Swift.String?
    public let description: Swift.String?
    public let homePageUrl: Swift.String?
    public let labels: [Swift.String]?
    public let licenseBody: Swift.String?
    public let licenseUrl: Swift.String?
    public let name: Swift.String?
    public let readmeBody: Swift.String?
    public let readmeUrl: Swift.String?
    public let semanticVersion: Swift.String?
    public let sourceCodeArchiveUrl: Swift.String?
    public let sourceCodeUrl: Swift.String?
    public let spdxLicenseId: Swift.String?
    public let templateBody: Swift.String?
    public let templateUrl: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case licenseBody = "licenseBody"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseBody)
        licenseBody = licenseBodyDecoded
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeBody)
        readmeBody = readmeBodyDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationOutputResponse(applicationId: \(Swift.String(describing: applicationId)), author: \(Swift.String(describing: author)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), homePageUrl: \(Swift.String(describing: homePageUrl)), isVerifiedAuthor: \(Swift.String(describing: isVerifiedAuthor)), labels: \(Swift.String(describing: labels)), licenseUrl: \(Swift.String(describing: licenseUrl)), name: \(Swift.String(describing: name)), readmeUrl: \(Swift.String(describing: readmeUrl)), spdxLicenseId: \(Swift.String(describing: spdxLicenseId)), verifiedAuthorUrl: \(Swift.String(describing: verifiedAuthorUrl)), version: \(Swift.String(describing: version)))"}
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = nil
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init (
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let author: Swift.String?
    public let creationTime: Swift.String?
    public let description: Swift.String?
    public let homePageUrl: Swift.String?
    public let isVerifiedAuthor: Swift.Bool?
    public let labels: [Swift.String]?
    public let licenseUrl: Swift.String?
    public let name: Swift.String?
    public let readmeUrl: Swift.String?
    public let spdxLicenseId: Swift.String?
    public let verifiedAuthorUrl: Swift.String?
    public let version: ServerlessApplicationRepositoryClientTypes.Version?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Version.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateApplicationVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationVersionOutputError>
}

extension CreateApplicationVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationVersionInput(applicationId: \(Swift.String(describing: applicationId)), semanticVersion: \(Swift.String(describing: semanticVersion)), sourceCodeArchiveUrl: \(Swift.String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(Swift.String(describing: sourceCodeUrl)), templateBody: \(Swift.String(describing: templateBody)), templateUrl: \(Swift.String(describing: templateUrl)))"}
}

extension CreateApplicationVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceCodeArchiveUrl = sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateUrl = templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }
}

public struct CreateApplicationVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationVersionOutputError>
}

public struct CreateApplicationVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationVersionOutputError>
}

public struct CreateApplicationVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateApplicationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApplicationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationVersionOutputError>
}

public struct CreateApplicationVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateApplicationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let semanticVersion = input.semanticVersion else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("semanticVersion is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/versions/\(semanticVersion.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApplicationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationVersionOutputError>
}

public struct CreateApplicationVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the new version.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// The raw packaged AWS SAM template of your application.
    public var templateBody: Swift.String?
    /// A link to the packaged AWS SAM template of your application.
    public var templateUrl: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationVersionInputBody: Swift.Equatable {
    public let sourceCodeArchiveUrl: Swift.String?
    public let sourceCodeUrl: Swift.String?
    public let templateBody: Swift.String?
    public let templateUrl: Swift.String?
}

extension CreateApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension CreateApplicationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationVersionOutputResponse(applicationId: \(Swift.String(describing: applicationId)), creationTime: \(Swift.String(describing: creationTime)), parameterDefinitions: \(Swift.String(describing: parameterDefinitions)), requiredCapabilities: \(Swift.String(describing: requiredCapabilities)), resourcesSupported: \(Swift.String(describing: resourcesSupported)), semanticVersion: \(Swift.String(describing: semanticVersion)), sourceCodeArchiveUrl: \(Swift.String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(Swift.String(describing: sourceCodeUrl)), templateUrl: \(Swift.String(describing: templateUrl)))"}
}

extension CreateApplicationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.parameterDefinitions = output.parameterDefinitions
            self.requiredCapabilities = output.requiredCapabilities
            self.resourcesSupported = output.resourcesSupported
            self.semanticVersion = output.semanticVersion
            self.sourceCodeArchiveUrl = output.sourceCodeArchiveUrl
            self.sourceCodeUrl = output.sourceCodeUrl
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.parameterDefinitions = nil
            self.requiredCapabilities = nil
            self.resourcesSupported = nil
            self.semanticVersion = nil
            self.sourceCodeArchiveUrl = nil
            self.sourceCodeUrl = nil
            self.templateUrl = nil
        }
    }
}

public struct CreateApplicationVersionOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// An array of parameter types supported by the application.
    public var parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
    /// A list of values that you must specify before you can deploy certain applications.
    ///  Some applications might include resources that can affect permissions in your AWS
    ///  account, for example, by creating new AWS Identity and Access Management (IAM) users.
    ///  For those applications, you must explicitly acknowledge their capabilities by
    ///  specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM,
    ///  CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or
    ///  CAPABILITY_NAMED_IAM:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">AWS::IAM::Group,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html">AWS::IAM::InstanceProfile,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM::Policy, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">AWS::IAM::Role.
    ///  If the application contains IAM resources, you can specify either CAPABILITY_IAM
    ///  or CAPABILITY_NAMED_IAM. If the application contains IAM resources
    ///  with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html">AWS::Lambda::Permission,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM:Policy,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html">AWS::ApplicationAutoScaling::ScalingPolicy,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html">AWS::S3::BucketPolicy,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html">AWS::SQS::QueuePolicy, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html">AWS::SNS::TopicPolicy.Applications that contain one or more nested applications require you to specify
    ///  CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review
    ///  all permissions associated with the application before deploying. If you don't specify
    ///  this parameter for an application that requires capabilities, the call will fail.
    public var requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
    /// Whether all of the AWS resources contained in this application are supported in the region
    ///  in which it is being retrieved.
    public var resourcesSupported: Swift.Bool?
    /// The semantic version of the application:
    ///  <a href="https://semver.org/">https://semver.org/
    ///
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// A link to the packaged AWS SAM template of your application.
    public var templateUrl: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil,
        requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]? = nil,
        resourcesSupported: Swift.Bool? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.parameterDefinitions = parameterDefinitions
        self.requiredCapabilities = requiredCapabilities
        self.resourcesSupported = resourcesSupported
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationVersionOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let creationTime: Swift.String?
    public let parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
    public let requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
    public let resourcesSupported: Swift.Bool?
    public let semanticVersion: Swift.String?
    public let sourceCodeArchiveUrl: Swift.String?
    public let sourceCodeUrl: Swift.String?
    public let templateUrl: Swift.String?
}

extension CreateApplicationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case parameterDefinitions = "parameterDefinitions"
        case requiredCapabilities = "requiredCapabilities"
        case resourcesSupported = "resourcesSupported"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let parameterDefinitionsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ParameterDefinition?].self, forKey: .parameterDefinitions)
        var parameterDefinitionsDecoded0:[ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil
        if let parameterDefinitionsContainer = parameterDefinitionsContainer {
            parameterDefinitionsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]()
            for structure0 in parameterDefinitionsContainer {
                if let structure0 = structure0 {
                    parameterDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        parameterDefinitions = parameterDefinitionsDecoded0
        let requiredCapabilitiesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.Capability?].self, forKey: .requiredCapabilities)
        var requiredCapabilitiesDecoded0:[ServerlessApplicationRepositoryClientTypes.Capability]? = nil
        if let requiredCapabilitiesContainer = requiredCapabilitiesContainer {
            requiredCapabilitiesDecoded0 = [ServerlessApplicationRepositoryClientTypes.Capability]()
            for string0 in requiredCapabilitiesContainer {
                if let string0 = string0 {
                    requiredCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        requiredCapabilities = requiredCapabilitiesDecoded0
        let resourcesSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .resourcesSupported)
        resourcesSupported = resourcesSupportedDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

public struct CreateCloudFormationChangeSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFormationChangeSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFormationChangeSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationChangeSetOutputError>
}

extension CreateCloudFormationChangeSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFormationChangeSetInput(applicationId: \(Swift.String(describing: applicationId)), capabilities: \(Swift.String(describing: capabilities)), changeSetName: \(Swift.String(describing: changeSetName)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), notificationArns: \(Swift.String(describing: notificationArns)), parameterOverrides: \(Swift.String(describing: parameterOverrides)), resourceTypes: \(Swift.String(describing: resourceTypes)), rollbackConfiguration: \(Swift.String(describing: rollbackConfiguration)), semanticVersion: \(Swift.String(describing: semanticVersion)), stackName: \(Swift.String(describing: stackName)), tags: \(Swift.String(describing: tags)), templateId: \(Swift.String(describing: templateId)))"}
}

extension CreateCloudFormationChangeSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "capabilities"
        case changeSetName = "changeSetName"
        case clientToken = "clientToken"
        case description = "description"
        case notificationArns = "notificationArns"
        case parameterOverrides = "parameterOverrides"
        case resourceTypes = "resourceTypes"
        case rollbackConfiguration = "rollbackConfiguration"
        case semanticVersion = "semanticVersion"
        case stackName = "stackName"
        case tags = "tags"
        case templateId = "templateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for __listof__string0 in capabilities {
                try capabilitiesContainer.encode(__listof__string0)
            }
        }
        if let changeSetName = changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for __listof__string0 in notificationArns {
                try notificationArnsContainer.encode(__listof__string0)
            }
        }
        if let parameterOverrides = parameterOverrides {
            var parameterOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterOverrides)
            for __listofparametervalue0 in parameterOverrides {
                try parameterOverridesContainer.encode(__listofparametervalue0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for __listof__string0 in resourceTypes {
                try resourceTypesContainer.encode(__listof__string0)
            }
        }
        if let rollbackConfiguration = rollbackConfiguration {
            try encodeContainer.encode(rollbackConfiguration, forKey: .rollbackConfiguration)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for __listoftag0 in tags {
                try tagsContainer.encode(__listoftag0)
            }
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

public struct CreateCloudFormationChangeSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFormationChangeSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFormationChangeSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationChangeSetOutputError>
}

public struct CreateCloudFormationChangeSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFormationChangeSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFormationChangeSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationChangeSetOutputError>
}

public struct CreateCloudFormationChangeSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationChangeSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCloudFormationChangeSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCloudFormationChangeSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationChangeSetOutputError>
}

public struct CreateCloudFormationChangeSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationChangeSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCloudFormationChangeSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/changesets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCloudFormationChangeSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationChangeSetOutputError>
}

public struct CreateCloudFormationChangeSetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A list of values that you must specify before you can deploy certain applications.
    ///  Some applications might include resources that can affect permissions in your AWS
    ///  account, for example, by creating new AWS Identity and Access Management (IAM) users.
    ///  For those applications, you must explicitly acknowledge their capabilities by
    ///  specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM,
    ///  CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or
    ///  CAPABILITY_NAMED_IAM:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">AWS::IAM::Group,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html">AWS::IAM::InstanceProfile,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM::Policy, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">AWS::IAM::Role.
    ///  If the application contains IAM resources, you can specify either CAPABILITY_IAM
    ///  or CAPABILITY_NAMED_IAM. If the application contains IAM resources
    ///  with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html">AWS::Lambda::Permission,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM:Policy,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html">AWS::ApplicationAutoScaling::ScalingPolicy,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html">AWS::S3::BucketPolicy,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html">AWS::SQS::QueuePolicy, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html">AWS::SNS:TopicPolicy.Applications that contain one or more nested applications require you to specify
    ///  CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review
    ///  all permissions associated with the application before deploying. If you don't specify
    ///  this parameter for an application that requires capabilities, the call will fail.
    public var capabilities: [Swift.String]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    public var changeSetName: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    public var clientToken: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    public var description: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    public var notificationArns: [Swift.String]?
    /// A list of parameter values for the parameters of the application.
    public var parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    public var resourceTypes: [Swift.String]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    public var rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration?
    /// The semantic version of the application:
    ///  <a href="https://semver.org/">https://semver.org/
    ///
    public var semanticVersion: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    /// This member is required.
    public var stackName: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet
    ///   API.
    public var tags: [ServerlessApplicationRepositoryClientTypes.Tag]?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        capabilities: [Swift.String]? = nil,
        changeSetName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]? = nil,
        resourceTypes: [Swift.String]? = nil,
        rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration? = nil,
        semanticVersion: Swift.String? = nil,
        stackName: Swift.String? = nil,
        tags: [ServerlessApplicationRepositoryClientTypes.Tag]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.capabilities = capabilities
        self.changeSetName = changeSetName
        self.clientToken = clientToken
        self.description = description
        self.notificationArns = notificationArns
        self.parameterOverrides = parameterOverrides
        self.resourceTypes = resourceTypes
        self.rollbackConfiguration = rollbackConfiguration
        self.semanticVersion = semanticVersion
        self.stackName = stackName
        self.tags = tags
        self.templateId = templateId
    }
}

struct CreateCloudFormationChangeSetInputBody: Swift.Equatable {
    public let capabilities: [Swift.String]?
    public let changeSetName: Swift.String?
    public let clientToken: Swift.String?
    public let description: Swift.String?
    public let notificationArns: [Swift.String]?
    public let parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]?
    public let resourceTypes: [Swift.String]?
    public let rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration?
    public let semanticVersion: Swift.String?
    public let stackName: Swift.String?
    public let tags: [ServerlessApplicationRepositoryClientTypes.Tag]?
    public let templateId: Swift.String?
}

extension CreateCloudFormationChangeSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "capabilities"
        case changeSetName = "changeSetName"
        case clientToken = "clientToken"
        case description = "description"
        case notificationArns = "notificationArns"
        case parameterOverrides = "parameterOverrides"
        case resourceTypes = "resourceTypes"
        case rollbackConfiguration = "rollbackConfiguration"
        case semanticVersion = "semanticVersion"
        case stackName = "stackName"
        case tags = "tags"
        case templateId = "templateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let parameterOverridesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ParameterValue?].self, forKey: .parameterOverrides)
        var parameterOverridesDecoded0:[ServerlessApplicationRepositoryClientTypes.ParameterValue]? = nil
        if let parameterOverridesContainer = parameterOverridesContainer {
            parameterOverridesDecoded0 = [ServerlessApplicationRepositoryClientTypes.ParameterValue]()
            for structure0 in parameterOverridesContainer {
                if let structure0 = structure0 {
                    parameterOverridesDecoded0?.append(structure0)
                }
            }
        }
        parameterOverrides = parameterOverridesDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let rollbackConfigurationDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.RollbackConfiguration.self, forKey: .rollbackConfiguration)
        rollbackConfiguration = rollbackConfigurationDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServerlessApplicationRepositoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServerlessApplicationRepositoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension CreateCloudFormationChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCloudFormationChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFormationChangeSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFormationChangeSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFormationChangeSetOutputResponse(applicationId: \(Swift.String(describing: applicationId)), changeSetId: \(Swift.String(describing: changeSetId)), semanticVersion: \(Swift.String(describing: semanticVersion)), stackId: \(Swift.String(describing: stackId)))"}
}

extension CreateCloudFormationChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCloudFormationChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.changeSetId = output.changeSetId
            self.semanticVersion = output.semanticVersion
            self.stackId = output.stackId
        } else {
            self.applicationId = nil
            self.changeSetId = nil
            self.semanticVersion = nil
            self.stackId = nil
        }
    }
}

public struct CreateCloudFormationChangeSetOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the change set.Length constraints: Minimum length of 1.Pattern: ARN:[-a-zA-Z0-9:/]*
    public var changeSetId: Swift.String?
    /// The semantic version of the application:
    ///  <a href="https://semver.org/">https://semver.org/
    ///
    public var semanticVersion: Swift.String?
    /// The unique ID of the stack.
    public var stackId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        changeSetId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.changeSetId = changeSetId
        self.semanticVersion = semanticVersion
        self.stackId = stackId
    }
}

struct CreateCloudFormationChangeSetOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let changeSetId: Swift.String?
    public let semanticVersion: Swift.String?
    public let stackId: Swift.String?
}

extension CreateCloudFormationChangeSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case changeSetId = "changeSetId"
        case semanticVersion = "semanticVersion"
        case stackId = "stackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct CreateCloudFormationTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFormationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationTemplateOutputError>
}

extension CreateCloudFormationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFormationTemplateInput(applicationId: \(Swift.String(describing: applicationId)), semanticVersion: \(Swift.String(describing: semanticVersion)))"}
}

extension CreateCloudFormationTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semanticVersion = "semanticVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
    }
}

public struct CreateCloudFormationTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFormationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationTemplateOutputError>
}

public struct CreateCloudFormationTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFormationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationTemplateOutputError>
}

public struct CreateCloudFormationTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCloudFormationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCloudFormationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationTemplateOutputError>
}

public struct CreateCloudFormationTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFormationTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCloudFormationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/templates"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCloudFormationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFormationTemplateOutputError>
}

public struct CreateCloudFormationTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the application:
    ///  <a href="https://semver.org/">https://semver.org/
    ///
    public var semanticVersion: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

struct CreateCloudFormationTemplateInputBody: Swift.Equatable {
    public let semanticVersion: Swift.String?
}

extension CreateCloudFormationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semanticVersion = "semanticVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
    }
}

extension CreateCloudFormationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCloudFormationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFormationTemplateOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFormationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFormationTemplateOutputResponse(applicationId: \(Swift.String(describing: applicationId)), creationTime: \(Swift.String(describing: creationTime)), expirationTime: \(Swift.String(describing: expirationTime)), semanticVersion: \(Swift.String(describing: semanticVersion)), status: \(Swift.String(describing: status)), templateId: \(Swift.String(describing: templateId)), templateUrl: \(Swift.String(describing: templateUrl)))"}
}

extension CreateCloudFormationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCloudFormationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.semanticVersion = output.semanticVersion
            self.status = output.status
            self.templateId = output.templateId
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.semanticVersion = nil
            self.status = nil
            self.templateId = nil
            self.templateUrl = nil
        }
    }
}

public struct CreateCloudFormationTemplateOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The date and time this template expires. Templates
    ///  expire 1 hour after creation.
    public var expirationTime: Swift.String?
    /// The semantic version of the application:
    ///  <a href="https://semver.org/">https://semver.org/
    ///
    public var semanticVersion: Swift.String?
    /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
    ///
    public var status: ServerlessApplicationRepositoryClientTypes.Status?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?
    /// A link to the template that can be used to deploy the application using
    ///  AWS CloudFormation.
    public var templateUrl: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        expirationTime: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        status: ServerlessApplicationRepositoryClientTypes.Status? = nil,
        templateId: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

struct CreateCloudFormationTemplateOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let creationTime: Swift.String?
    public let expirationTime: Swift.String?
    public let semanticVersion: Swift.String?
    public let status: ServerlessApplicationRepositoryClientTypes.Status?
    public let templateId: Swift.String?
    public let templateUrl: Swift.String?
}

extension CreateCloudFormationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case expirationTime = "expirationTime"
        case semanticVersion = "semanticVersion"
        case status = "status"
        case templateId = "templateId"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension DeleteApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApplicationInput(applicationId: \(Swift.String(describing: applicationId)))"}
}

extension DeleteApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Swift.Equatable {
}

extension DeleteApplicationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not authenticated.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 403
    public var errorCode: Swift.String?
    /// The client is not authenticated.
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationInput(applicationId: \(Swift.String(describing: applicationId)), semanticVersion: \(Swift.String(describing: semanticVersion)))"}
}

extension GetApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let semanticVersion = input.operationInput.semanticVersion {
            let semanticVersionQueryItem = ClientRuntime.URLQueryItem(name: "semanticVersion".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
            input.builder.withQueryItem(semanticVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the application to get.
    public var semanticVersion: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationOutputResponse(applicationId: \(Swift.String(describing: applicationId)), author: \(Swift.String(describing: author)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), homePageUrl: \(Swift.String(describing: homePageUrl)), isVerifiedAuthor: \(Swift.String(describing: isVerifiedAuthor)), labels: \(Swift.String(describing: labels)), licenseUrl: \(Swift.String(describing: licenseUrl)), name: \(Swift.String(describing: name)), readmeUrl: \(Swift.String(describing: readmeUrl)), spdxLicenseId: \(Swift.String(describing: spdxLicenseId)), verifiedAuthorUrl: \(Swift.String(describing: verifiedAuthorUrl)), version: \(Swift.String(describing: version)))"}
}

extension GetApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = nil
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct GetApplicationOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init (
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct GetApplicationOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let author: Swift.String?
    public let creationTime: Swift.String?
    public let description: Swift.String?
    public let homePageUrl: Swift.String?
    public let isVerifiedAuthor: Swift.Bool?
    public let labels: [Swift.String]?
    public let licenseUrl: Swift.String?
    public let name: Swift.String?
    public let readmeUrl: Swift.String?
    public let spdxLicenseId: Swift.String?
    public let verifiedAuthorUrl: Swift.String?
    public let version: ServerlessApplicationRepositoryClientTypes.Version?
}

extension GetApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Version.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetApplicationPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationPolicyInput(applicationId: \(Swift.String(describing: applicationId)))"}
}

extension GetApplicationPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetApplicationPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationPolicyOutputError>
}

public struct GetApplicationPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationPolicyOutputError>
}

public struct GetApplicationPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetApplicationPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetApplicationPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationPolicyOutputError>
}

public struct GetApplicationPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetApplicationPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetApplicationPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationPolicyOutputError>
}

public struct GetApplicationPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationPolicyInputBody: Swift.Equatable {
}

extension GetApplicationPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationPolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationPolicyOutputResponse(statements: \(Swift.String(describing: statements)))"}
}

extension GetApplicationPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statements = output.statements
        } else {
            self.statements = nil
        }
    }
}

public struct GetApplicationPolicyOutputResponse: Swift.Equatable {
    /// An array of policy statements applied to the application.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init (
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

struct GetApplicationPolicyOutputResponseBody: Swift.Equatable {
    public let statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?
}

extension GetApplicationPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension GetCloudFormationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFormationTemplateInput(applicationId: \(Swift.String(describing: applicationId)), templateId: \(Swift.String(describing: templateId)))"}
}

extension GetCloudFormationTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCloudFormationTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFormationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFormationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFormationTemplateOutputError>
}

public struct GetCloudFormationTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFormationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFormationTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFormationTemplateOutputError>
}

public struct GetCloudFormationTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFormationTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCloudFormationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCloudFormationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFormationTemplateOutputError>
}

public struct GetCloudFormationTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFormationTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCloudFormationTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let templateId = input.templateId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("templateId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCloudFormationTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFormationTemplateOutputError>
}

public struct GetCloudFormationTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.templateId = templateId
    }
}

struct GetCloudFormationTemplateInputBody: Swift.Equatable {
}

extension GetCloudFormationTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFormationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCloudFormationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFormationTemplateOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFormationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFormationTemplateOutputResponse(applicationId: \(Swift.String(describing: applicationId)), creationTime: \(Swift.String(describing: creationTime)), expirationTime: \(Swift.String(describing: expirationTime)), semanticVersion: \(Swift.String(describing: semanticVersion)), status: \(Swift.String(describing: status)), templateId: \(Swift.String(describing: templateId)), templateUrl: \(Swift.String(describing: templateUrl)))"}
}

extension GetCloudFormationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCloudFormationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.semanticVersion = output.semanticVersion
            self.status = output.status
            self.templateId = output.templateId
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.semanticVersion = nil
            self.status = nil
            self.templateId = nil
            self.templateUrl = nil
        }
    }
}

public struct GetCloudFormationTemplateOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The date and time this template expires. Templates
    ///  expire 1 hour after creation.
    public var expirationTime: Swift.String?
    /// The semantic version of the application:
    ///  <a href="https://semver.org/">https://semver.org/
    ///
    public var semanticVersion: Swift.String?
    /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
    ///
    public var status: ServerlessApplicationRepositoryClientTypes.Status?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?
    /// A link to the template that can be used to deploy the application using
    ///  AWS CloudFormation.
    public var templateUrl: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        expirationTime: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        status: ServerlessApplicationRepositoryClientTypes.Status? = nil,
        templateId: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

struct GetCloudFormationTemplateOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let creationTime: Swift.String?
    public let expirationTime: Swift.String?
    public let semanticVersion: Swift.String?
    public let status: ServerlessApplicationRepositoryClientTypes.Status?
    public let templateId: Swift.String?
    public let templateUrl: Swift.String?
}

extension GetCloudFormationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case expirationTime = "expirationTime"
        case semanticVersion = "semanticVersion"
        case status = "status"
        case templateId = "templateId"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension InternalServerErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerErrorException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The AWS Serverless Application Repository service encountered an internal error.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// 500
    public var errorCode: Swift.String?
    /// The AWS Serverless Application Repository service encountered an internal error.
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationDependenciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationDependenciesInput(applicationId: \(Swift.String(describing: applicationId)), maxItems: \(Swift.String(describing: maxItems)), nextToken: \(Swift.String(describing: nextToken)), semanticVersion: \(Swift.String(describing: semanticVersion)))"}
}

extension ListApplicationDependenciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListApplicationDependenciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationDependenciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationDependenciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationDependenciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationDependenciesOutputError>
}

public struct ListApplicationDependenciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationDependenciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationDependenciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let semanticVersion = input.operationInput.semanticVersion {
            let semanticVersionQueryItem = ClientRuntime.URLQueryItem(name: "semanticVersion".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
            input.builder.withQueryItem(semanticVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationDependenciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationDependenciesOutputError>
}

public struct ListApplicationDependenciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationDependenciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListApplicationDependenciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationDependenciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationDependenciesOutputError>
}

public struct ListApplicationDependenciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationDependenciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListApplicationDependenciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/dependencies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationDependenciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationDependenciesOutputError>
}

public struct ListApplicationDependenciesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?
    /// The semantic version of the application to get.
    public var semanticVersion: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
        self.semanticVersion = semanticVersion
    }
}

struct ListApplicationDependenciesInputBody: Swift.Equatable {
}

extension ListApplicationDependenciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationDependenciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationDependenciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationDependenciesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationDependenciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationDependenciesOutputResponse(dependencies: \(Swift.String(describing: dependencies)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationDependenciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationDependenciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dependencies = output.dependencies
            self.nextToken = output.nextToken
        } else {
            self.dependencies = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationDependenciesOutputResponse: Swift.Equatable {
    /// An array of application summaries nested in the application.
    public var dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.nextToken = nextToken
    }
}

struct ListApplicationDependenciesOutputResponseBody: Swift.Equatable {
    public let dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]?
    public let nextToken: Swift.String?
}

extension ListApplicationDependenciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies = "dependencies"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dependenciesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary?].self, forKey: .dependencies)
        var dependenciesDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationVersionsInput(applicationId: \(Swift.String(describing: applicationId)), maxItems: \(Swift.String(describing: maxItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListApplicationVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListApplicationVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListApplicationVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsInputBody: Swift.Equatable {
}

extension ListApplicationVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationVersionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), versions: \(Swift.String(describing: versions)))"}
}

extension ListApplicationVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListApplicationVersionsOutputResponse: Swift.Equatable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// An array of version summaries for the application.
    public var versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListApplicationVersionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]?
}

extension ListApplicationVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case versions = "versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.VersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[ServerlessApplicationRepositoryClientTypes.VersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [ServerlessApplicationRepositoryClientTypes.VersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListApplicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationsInput(maxItems: \(Swift.String(describing: maxItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListApplicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/applications"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?

    public init (
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationsOutputResponse(applications: \(Swift.String(describing: applications)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// An array of application summaries.
    public var applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    public let applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]?
    public let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "applications"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource (for example, an access policy statement) specified in the request doesn't exist.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 404
    public var errorCode: Swift.String?
    /// The resource (for example, an access policy statement) specified in the request doesn't exist.
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.ParameterDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "allowedPattern"
        case allowedValues = "allowedValues"
        case constraintDescription = "constraintDescription"
        case defaultValue = "defaultValue"
        case description = "description"
        case maxLength = "maxLength"
        case maxValue = "maxValue"
        case minLength = "minLength"
        case minValue = "minValue"
        case name = "name"
        case noEcho = "noEcho"
        case referencedByResources = "referencedByResources"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for __listof__string0 in allowedValues {
                try allowedValuesContainer.encode(__listof__string0)
            }
        }
        if let constraintDescription = constraintDescription {
            try encodeContainer.encode(constraintDescription, forKey: .constraintDescription)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxLength = maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minLength = minLength {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let noEcho = noEcho {
            try encodeContainer.encode(noEcho, forKey: .noEcho)
        }
        if let referencedByResources = referencedByResources {
            var referencedByResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referencedByResources)
            for __listof__string0 in referencedByResources {
                try referencedByResourcesContainer.encode(__listof__string0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let constraintDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintDescription)
        constraintDescription = constraintDescriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLength)
        minLength = minLengthDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let noEchoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noEcho)
        noEcho = noEchoDecoded
        let referencedByResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referencedByResources)
        var referencedByResourcesDecoded0:[Swift.String]? = nil
        if let referencedByResourcesContainer = referencedByResourcesContainer {
            referencedByResourcesDecoded0 = [Swift.String]()
            for string0 in referencedByResourcesContainer {
                if let string0 = string0 {
                    referencedByResourcesDecoded0?.append(string0)
                }
            }
        }
        referencedByResources = referencedByResourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.ParameterDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterDefinition(allowedPattern: \(Swift.String(describing: allowedPattern)), allowedValues: \(Swift.String(describing: allowedValues)), constraintDescription: \(Swift.String(describing: constraintDescription)), defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), maxLength: \(Swift.String(describing: maxLength)), maxValue: \(Swift.String(describing: maxValue)), minLength: \(Swift.String(describing: minLength)), minValue: \(Swift.String(describing: minValue)), name: \(Swift.String(describing: name)), noEcho: \(Swift.String(describing: noEcho)), referencedByResources: \(Swift.String(describing: referencedByResources)), type: \(Swift.String(describing: type)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Parameters supported by the application.
    public struct ParameterDefinition: Swift.Equatable {
        /// A regular expression that represents the patterns to allow for String types.
        public var allowedPattern: Swift.String?
        /// An array containing the list of values allowed for the parameter.
        public var allowedValues: [Swift.String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description,
        ///  a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user
        ///  specifies an invalid value:
        ///  Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+
        ///  By adding a constraint description, such as "must contain only uppercase and lowercase letters and numbers," you can display
        ///  the following customized error message:
        ///  Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
        ///
        public var constraintDescription: Swift.String?
        /// A value of the appropriate type for the template to use if no value is specified when a stack is created.
        ///  If you define constraints for the parameter, you must specify a value that adheres to those constraints.
        public var defaultValue: Swift.String?
        /// A string of up to 4,000 characters that describes the parameter.
        public var description: Swift.String?
        /// An integer value that determines the largest number of characters that you want to allow for String types.
        public var maxLength: Swift.Int?
        /// A numeric value that determines the largest numeric value that you want to allow for Number types.
        public var maxValue: Swift.Int?
        /// An integer value that determines the smallest number of characters that you want to allow for String types.
        public var minLength: Swift.Int?
        /// A numeric value that determines the smallest numeric value that you want to allow for Number types.
        public var minValue: Swift.Int?
        /// The name of the parameter.
        /// This member is required.
        public var name: Swift.String?
        /// Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the
        ///  value to true, the parameter value is masked with asterisks (*****).
        public var noEcho: Swift.Bool?
        /// A list of AWS SAM resources that use this parameter.
        /// This member is required.
        public var referencedByResources: [Swift.String]?
        /// The type of the parameter.Valid values: String | Number | List&lt;Number> | CommaDelimitedList
        ///
        ///  String: A literal string.For example, users can specify "MyUserName".
        ///  Number: An integer or float. AWS CloudFormation validates the parameter value as a number. However, when you use the
        ///  parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.For example, users might specify "8888".
        ///  List&lt;Number>: An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers. However, when
        ///  you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.For example, users might specify "80,20", and then Ref results in ["80","20"].
        ///  CommaDelimitedList: An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas.
        ///  Also, each member string is space-trimmed.For example, users might specify "test,dev,prod", and then Ref results in ["test","dev","prod"].
        public var type: Swift.String?

        public init (
            allowedPattern: Swift.String? = nil,
            allowedValues: [Swift.String]? = nil,
            constraintDescription: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            maxLength: Swift.Int? = nil,
            maxValue: Swift.Int? = nil,
            minLength: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            noEcho: Swift.Bool? = nil,
            referencedByResources: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.defaultValue = defaultValue
            self.description = description
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
            self.name = name
            self.noEcho = noEcho
            self.referencedByResources = referencedByResources
            self.type = type
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.ParameterValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.ParameterValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterValue(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Parameter value of the application.
    public struct ParameterValue: Swift.Equatable {
        /// The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation
        ///  uses the default value that is specified in your template.
        /// This member is required.
        public var name: Swift.String?
        /// The input value associated with the parameter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

public struct PutApplicationPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApplicationPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutApplicationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutApplicationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApplicationPolicyOutputError>
}

extension PutApplicationPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutApplicationPolicyInput(applicationId: \(Swift.String(describing: applicationId)), statements: \(Swift.String(describing: statements)))"}
}

extension PutApplicationPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statements = statements {
            var statementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statements)
            for __listofapplicationpolicystatement0 in statements {
                try statementsContainer.encode(__listofapplicationpolicystatement0)
            }
        }
    }
}

public struct PutApplicationPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApplicationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutApplicationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutApplicationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApplicationPolicyOutputError>
}

public struct PutApplicationPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApplicationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutApplicationPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutApplicationPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApplicationPolicyOutputError>
}

public struct PutApplicationPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApplicationPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutApplicationPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutApplicationPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApplicationPolicyOutputError>
}

public struct PutApplicationPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApplicationPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutApplicationPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutApplicationPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApplicationPolicyOutputError>
}

public struct PutApplicationPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// An array of policy statements applied to the application.
    /// This member is required.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init (
        applicationId: Swift.String? = nil,
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.applicationId = applicationId
        self.statements = statements
    }
}

struct PutApplicationPolicyInputBody: Swift.Equatable {
    public let statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?
}

extension PutApplicationPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension PutApplicationPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutApplicationPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutApplicationPolicyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutApplicationPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutApplicationPolicyOutputResponse(statements: \(Swift.String(describing: statements)))"}
}

extension PutApplicationPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutApplicationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statements = output.statements
        } else {
            self.statements = nil
        }
    }
}

public struct PutApplicationPolicyOutputResponse: Swift.Equatable {
    /// An array of policy statements applied to the application.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init (
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

struct PutApplicationPolicyOutputResponseBody: Swift.Equatable {
    public let statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?
}

extension PutApplicationPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension ServerlessApplicationRepositoryClientTypes.RollbackConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringTimeInMinutes = "monitoringTimeInMinutes"
        case rollbackTriggers = "rollbackTriggers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitoringTimeInMinutes = monitoringTimeInMinutes {
            try encodeContainer.encode(monitoringTimeInMinutes, forKey: .monitoringTimeInMinutes)
        }
        if let rollbackTriggers = rollbackTriggers {
            var rollbackTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rollbackTriggers)
            for __listofrollbacktrigger0 in rollbackTriggers {
                try rollbackTriggersContainer.encode(__listofrollbacktrigger0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringTimeInMinutes)
        monitoringTimeInMinutes = monitoringTimeInMinutesDecoded
        let rollbackTriggersContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.RollbackTrigger?].self, forKey: .rollbackTriggers)
        var rollbackTriggersDecoded0:[ServerlessApplicationRepositoryClientTypes.RollbackTrigger]? = nil
        if let rollbackTriggersContainer = rollbackTriggersContainer {
            rollbackTriggersDecoded0 = [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]()
            for structure0 in rollbackTriggersContainer {
                if let structure0 = structure0 {
                    rollbackTriggersDecoded0?.append(structure0)
                }
            }
        }
        rollbackTriggers = rollbackTriggersDecoded0
    }
}

extension ServerlessApplicationRepositoryClientTypes.RollbackConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RollbackConfiguration(monitoringTimeInMinutes: \(Swift.String(describing: monitoringTimeInMinutes)), rollbackTriggers: \(Swift.String(describing: rollbackTriggers)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// This property corresponds to the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration">RollbackConfiguration
    ///   Data Type.
    public struct RollbackConfiguration: Swift.Equatable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration">RollbackConfiguration
        ///   Data Type.
        public var monitoringTimeInMinutes: Swift.Int?
        /// This property corresponds to the content of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration">RollbackConfiguration
        ///   Data Type.
        public var rollbackTriggers: [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]?

        public init (
            monitoringTimeInMinutes: Swift.Int? = nil,
            rollbackTriggers: [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]? = nil
        )
        {
            self.monitoringTimeInMinutes = monitoringTimeInMinutes
            self.rollbackTriggers = rollbackTriggers
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.RollbackTrigger: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.RollbackTrigger: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RollbackTrigger(arn: \(Swift.String(describing: arn)), type: \(Swift.String(describing: type)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// This property corresponds to the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger">RollbackTrigger
    ///   Data Type.
    public struct RollbackTrigger: Swift.Equatable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger">RollbackTrigger
        ///   Data Type.
        /// This member is required.
        public var arn: Swift.String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger">RollbackTrigger
        ///   Data Type.
        /// This member is required.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case expired
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .expired,
                .preparing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .preparing: return "PREPARING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// This property corresponds to the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag">Tag
    ///   Data Type.
    public struct Tag: Swift.Equatable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag">Tag
        ///   Data Type.
        /// This member is required.
        public var key: Swift.String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag">
        ///  Tag
        ///
        ///  Data Type.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is sending more than the allowed number of requests per unit of time.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 429
    public var errorCode: Swift.String?
    /// The client is sending more than the allowed number of requests per unit of time.
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let errorCode: Swift.String?
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnshareApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnshareApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnshareApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnshareApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnshareApplicationOutputError>
}

extension UnshareApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnshareApplicationInput(applicationId: \(Swift.String(describing: applicationId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension UnshareApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "organizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct UnshareApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnshareApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnshareApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnshareApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnshareApplicationOutputError>
}

public struct UnshareApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnshareApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnshareApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnshareApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnshareApplicationOutputError>
}

public struct UnshareApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnshareApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UnshareApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnshareApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnshareApplicationOutputError>
}

public struct UnshareApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnshareApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UnshareApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/unshare"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnshareApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnshareApplicationOutputError>
}

public struct UnshareApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The AWS Organization ID to unshare the application from.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.organizationId = organizationId
    }
}

struct UnshareApplicationInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
}

extension UnshareApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "organizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension UnshareApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnshareApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnshareApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnshareApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnshareApplicationOutputResponse()"}
}

extension UnshareApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnshareApplicationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnshareApplicationOutputResponseBody: Swift.Equatable {
}

extension UnshareApplicationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationInput(applicationId: \(Swift.String(describing: applicationId)), author: \(Swift.String(describing: author)), description: \(Swift.String(describing: description)), homePageUrl: \(Swift.String(describing: homePageUrl)), labels: \(Swift.String(describing: labels)), readmeBody: \(Swift.String(describing: readmeBody)), readmeUrl: \(Swift.String(describing: readmeUrl)))"}
}

extension UpdateApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __listof__string0 in labels {
                try labelsContainer.encode(__listof__string0)
            }
        }
        if let readmeBody = readmeBody {
            try encodeContainer.encode(readmeBody, forKey: .readmeBody)
        }
        if let readmeUrl = readmeUrl {
            try encodeContainer.encode(readmeUrl, forKey: .readmeUrl)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A text readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeBody: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        readmeBody: Swift.String? = nil,
        readmeUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    public let author: Swift.String?
    public let description: Swift.String?
    public let homePageUrl: Swift.String?
    public let labels: [Swift.String]?
    public let readmeBody: Swift.String?
    public let readmeUrl: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let readmeBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeBody)
        readmeBody = readmeBodyDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationOutputResponse(applicationId: \(Swift.String(describing: applicationId)), author: \(Swift.String(describing: author)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), homePageUrl: \(Swift.String(describing: homePageUrl)), isVerifiedAuthor: \(Swift.String(describing: isVerifiedAuthor)), labels: \(Swift.String(describing: labels)), licenseUrl: \(Swift.String(describing: licenseUrl)), name: \(Swift.String(describing: name)), readmeUrl: \(Swift.String(describing: readmeUrl)), spdxLicenseId: \(Swift.String(describing: spdxLicenseId)), verifiedAuthorUrl: \(Swift.String(describing: verifiedAuthorUrl)), version: \(Swift.String(describing: version)))"}
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = nil
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init (
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let author: Swift.String?
    public let creationTime: Swift.String?
    public let description: Swift.String?
    public let homePageUrl: Swift.String?
    public let isVerifiedAuthor: Swift.Bool?
    public let labels: [Swift.String]?
    public let licenseUrl: Swift.String?
    public let name: Swift.String?
    public let readmeUrl: Swift.String?
    public let spdxLicenseId: Swift.String?
    public let verifiedAuthorUrl: Swift.String?
    public let version: ServerlessApplicationRepositoryClientTypes.Version?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Version.self, forKey: .version)
        version = versionDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.Version: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case parameterDefinitions = "parameterDefinitions"
        case requiredCapabilities = "requiredCapabilities"
        case resourcesSupported = "resourcesSupported"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let parameterDefinitions = parameterDefinitions {
            var parameterDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterDefinitions)
            for __listofparameterdefinition0 in parameterDefinitions {
                try parameterDefinitionsContainer.encode(__listofparameterdefinition0)
            }
        }
        if let requiredCapabilities = requiredCapabilities {
            var requiredCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredCapabilities)
            for __listofcapability0 in requiredCapabilities {
                try requiredCapabilitiesContainer.encode(__listofcapability0.rawValue)
            }
        }
        if let resourcesSupported = resourcesSupported {
            try encodeContainer.encode(resourcesSupported, forKey: .resourcesSupported)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeArchiveUrl = sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let templateUrl = templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let parameterDefinitionsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ParameterDefinition?].self, forKey: .parameterDefinitions)
        var parameterDefinitionsDecoded0:[ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil
        if let parameterDefinitionsContainer = parameterDefinitionsContainer {
            parameterDefinitionsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]()
            for structure0 in parameterDefinitionsContainer {
                if let structure0 = structure0 {
                    parameterDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        parameterDefinitions = parameterDefinitionsDecoded0
        let requiredCapabilitiesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.Capability?].self, forKey: .requiredCapabilities)
        var requiredCapabilitiesDecoded0:[ServerlessApplicationRepositoryClientTypes.Capability]? = nil
        if let requiredCapabilitiesContainer = requiredCapabilitiesContainer {
            requiredCapabilitiesDecoded0 = [ServerlessApplicationRepositoryClientTypes.Capability]()
            for string0 in requiredCapabilitiesContainer {
                if let string0 = string0 {
                    requiredCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        requiredCapabilities = requiredCapabilitiesDecoded0
        let resourcesSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .resourcesSupported)
        resourcesSupported = resourcesSupportedDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.Version: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Version(applicationId: \(Swift.String(describing: applicationId)), creationTime: \(Swift.String(describing: creationTime)), parameterDefinitions: \(Swift.String(describing: parameterDefinitions)), requiredCapabilities: \(Swift.String(describing: requiredCapabilities)), resourcesSupported: \(Swift.String(describing: resourcesSupported)), semanticVersion: \(Swift.String(describing: semanticVersion)), sourceCodeArchiveUrl: \(Swift.String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(Swift.String(describing: sourceCodeUrl)), templateUrl: \(Swift.String(describing: templateUrl)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Application version details.
    public struct Version: Swift.Equatable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The date and time this resource was created.
        /// This member is required.
        public var creationTime: Swift.String?
        /// An array of parameter types supported by the application.
        /// This member is required.
        public var parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
        /// A list of values that you must specify before you can deploy certain applications.
        ///  Some applications might include resources that can affect permissions in your AWS
        ///  account, for example, by creating new AWS Identity and Access Management (IAM) users.
        ///  For those applications, you must explicitly acknowledge their capabilities by
        ///  specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM,
        ///  CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or
        ///  CAPABILITY_NAMED_IAM:
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">AWS::IAM::Group,
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html">AWS::IAM::InstanceProfile,
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM::Policy, and
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">AWS::IAM::Role.
        ///  If the application contains IAM resources, you can specify either CAPABILITY_IAM
        ///  or CAPABILITY_NAMED_IAM. If the application contains IAM resources
        ///  with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY:
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html">AWS::Lambda::Permission,
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM:Policy,
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html">AWS::ApplicationAutoScaling::ScalingPolicy,
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html">AWS::S3::BucketPolicy,
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html">AWS::SQS::QueuePolicy, and
        ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html">AWS::SNS::TopicPolicy.Applications that contain one or more nested applications require you to specify
        ///  CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review
        ///  all permissions associated with the application before deploying. If you don't specify
        ///  this parameter for an application that requires capabilities, the call will fail.
        /// This member is required.
        public var requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
        /// Whether all of the AWS resources contained in this application are supported in the region
        ///  in which it is being retrieved.
        /// This member is required.
        public var resourcesSupported: Swift.Bool?
        /// The semantic version of the application:
        ///  <a href="https://semver.org/">https://semver.org/
        ///
        /// This member is required.
        public var semanticVersion: Swift.String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public var sourceCodeArchiveUrl: Swift.String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public var sourceCodeUrl: Swift.String?
        /// A link to the packaged AWS SAM template of your application.
        /// This member is required.
        public var templateUrl: Swift.String?

        public init (
            applicationId: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil,
            requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]? = nil,
            resourcesSupported: Swift.Bool? = nil,
            semanticVersion: Swift.String? = nil,
            sourceCodeArchiveUrl: Swift.String? = nil,
            sourceCodeUrl: Swift.String? = nil,
            templateUrl: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.VersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case semanticVersion = "semanticVersion"
        case sourceCodeUrl = "sourceCodeUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.VersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VersionSummary(applicationId: \(Swift.String(describing: applicationId)), creationTime: \(Swift.String(describing: creationTime)), semanticVersion: \(Swift.String(describing: semanticVersion)), sourceCodeUrl: \(Swift.String(describing: sourceCodeUrl)))"}
}

extension ServerlessApplicationRepositoryClientTypes {
    /// An application version summary.
    public struct VersionSummary: Swift.Equatable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The date and time this resource was created.
        /// This member is required.
        public var creationTime: Swift.String?
        /// The semantic version of the application:
        ///  <a href="https://semver.org/">https://semver.org/
        ///
        /// This member is required.
        public var semanticVersion: Swift.String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public var sourceCodeUrl: Swift.String?

        public init (
            applicationId: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            semanticVersion: Swift.String? = nil,
            sourceCodeUrl: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.semanticVersion = semanticVersion
            self.sourceCodeUrl = sourceCodeUrl
        }
    }

}
